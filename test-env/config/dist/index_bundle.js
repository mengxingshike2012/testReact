/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "1ed20ee8e8bbcf0c304b"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(89)(__webpack_require__.s = 89);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invariant;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat() {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error = void 0;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warningWithoutStack = function warningWithoutStack() {};

if (true) {
  warningWithoutStack = function warningWithoutStack(condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (args.length > 8) {
      // Check before the condition to catch violations early.
      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
    }
    if (condition) {
      return;
    }
    if (typeof console !== 'undefined') {
      var argsWithFormat = args.map(function (item) {
        return '' + item;
      });
      argsWithFormat.unshift('Warning: ' + format);

      // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610
      Function.prototype.apply.call(console.error, console, argsWithFormat);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  };
}

exports.default = warningWithoutStack;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var warning = _warningWithoutStack2.default;

if (true) {
  warning = function warning(condition, format) {
    if (condition) {
      return;
    }
    var ReactDebugCurrentFrame = _ReactSharedInternals2.default.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();
    // eslint-disable-next-line react-internal/warning-and-invariant-args

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    _warningWithoutStack2.default.apply(undefined, [false, format + '%s'].concat(args, [stack]));
  };
}

exports.default = warning;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addUserTimingListener = addUserTimingListener;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

var enableUserTimingAPI = exports.enableUserTimingAPI = true;

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = exports.debugRenderPhaseSideEffects = false;

// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:
var debugRenderPhaseSideEffectsForStrictMode = exports.debugRenderPhaseSideEffectsForStrictMode = true;

// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.
var replayFailedUnitOfWorkWithInvokeGuardedCallback = exports.replayFailedUnitOfWorkWithInvokeGuardedCallback = true;

// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
var warnAboutDeprecatedLifecycles = exports.warnAboutDeprecatedLifecycles = false;

// Gather advanced timing metrics for Profiler subtrees.
var enableProfilerTimer = exports.enableProfilerTimer = true;

// Trace which interactions trigger each commit.
var enableSchedulerTracing = exports.enableSchedulerTracing = true;

// Only used in www builds.
var enableSuspenseServerRenderer = exports.enableSuspenseServerRenderer = false; // TODO: __DEV__? Here it might just be false.

// Only used in www builds.
var enableSchedulerDebugging = exports.enableSchedulerDebugging = false;

// Only used in www builds.
function addUserTimingListener() {
  throw new Error('Not implemented.');
}

// React Fire: prevent the value and checked attributes from syncing
// with their related DOM properties
var disableInputAttributeSyncing = exports.disableInputAttributeSyncing = false;

// These APIs will no longer be "unstable" in the upcoming 16.7 release,
// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.
var enableStableConcurrentModeAPIs = exports.enableStableConcurrentModeAPIs = false;

var warnAboutShorthandPropertyCollision = exports.warnAboutShorthandPropertyCollision = false;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var FunctionComponent = exports.FunctionComponent = 0; /**
                                                        * Copyright (c) Facebook, Inc. and its affiliates.
                                                        *
                                                        * This source code is licensed under the MIT license found in the
                                                        * LICENSE file in the root directory of this source tree.
                                                        *
                                                        * 
                                                        */

var ClassComponent = exports.ClassComponent = 1;
var IndeterminateComponent = exports.IndeterminateComponent = 2; // Before we know whether it is function or class
var HostRoot = exports.HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = exports.HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = exports.HostComponent = 5;
var HostText = exports.HostText = 6;
var Fragment = exports.Fragment = 7;
var Mode = exports.Mode = 8;
var ContextConsumer = exports.ContextConsumer = 9;
var ContextProvider = exports.ContextProvider = 10;
var ForwardRef = exports.ForwardRef = 11;
var Profiler = exports.Profiler = 12;
var SuspenseComponent = exports.SuspenseComponent = 13;
var MemoComponent = exports.MemoComponent = 14;
var SimpleMemoComponent = exports.SimpleMemoComponent = 15;
var LazyComponent = exports.LazyComponent = 16;
var IncompleteClassComponent = exports.IncompleteClassComponent = 17;
var DehydratedSuspenseComponent = exports.DehydratedSuspenseComponent = 18;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactSymbols = __webpack_require__(6);

var _ReactLazyComponent = __webpack_require__(44);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }
  if (true) {
    if (typeof type.tag === 'number') {
      (0, _warningWithoutStack2.default)(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }
  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }
  if (typeof type === 'string') {
    return type;
  }
  switch (type) {
    case _ReactSymbols.REACT_CONCURRENT_MODE_TYPE:
      return 'ConcurrentMode';
    case _ReactSymbols.REACT_FRAGMENT_TYPE:
      return 'Fragment';
    case _ReactSymbols.REACT_PORTAL_TYPE:
      return 'Portal';
    case _ReactSymbols.REACT_PROFILER_TYPE:
      return 'Profiler';
    case _ReactSymbols.REACT_STRICT_MODE_TYPE:
      return 'StrictMode';
    case _ReactSymbols.REACT_SUSPENSE_TYPE:
      return 'Suspense';
  }
  if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {
    switch (type.$$typeof) {
      case _ReactSymbols.REACT_CONTEXT_TYPE:
        return 'Context.Consumer';
      case _ReactSymbols.REACT_PROVIDER_TYPE:
        return 'Context.Provider';
      case _ReactSymbols.REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');
      case _ReactSymbols.REACT_MEMO_TYPE:
        return getComponentName(type.type);
      case _ReactSymbols.REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = (0, _ReactLazyComponent.refineResolvedLazyComponent)(thenable);
          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }
        }
    }
  }
  return null;
}

exports.default = getComponentName;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getIteratorFn = getIteratorFn;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = exports.REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = exports.REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = exports.REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = exports.REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = exports.REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = exports.REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = exports.REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = exports.REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = exports.REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = exports.REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = exports.REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_MEMO_TYPE = exports.REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = exports.REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || (typeof maybeIterable === 'undefined' ? 'undefined' : _typeof(maybeIterable)) !== 'object') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phase = exports.current = undefined;
exports.getStackByFiberInDevAndProd = getStackByFiberInDevAndProd;
exports.getCurrentFiberOwnerNameInDevOrNull = getCurrentFiberOwnerNameInDevOrNull;
exports.getCurrentFiberStackInDev = getCurrentFiberStackInDev;
exports.resetCurrentFiber = resetCurrentFiber;
exports.setCurrentFiber = setCurrentFiber;
exports.setCurrentPhase = setCurrentPhase;

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _ReactWorkTags = __webpack_require__(4);

var _describeComponentFrame = __webpack_require__(65);

var _describeComponentFrame2 = _interopRequireDefault(_describeComponentFrame);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ReactDebugCurrentFrame = _ReactSharedInternals2.default.ReactDebugCurrentFrame; /**
                                                                                     * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                     *
                                                                                     * This source code is licensed under the MIT license found in the
                                                                                     * LICENSE file in the root directory of this source tree.
                                                                                     *
                                                                                     * 
                                                                                     */

function describeFiber(fiber) {
  switch (fiber.tag) {
    case _ReactWorkTags.HostRoot:
    case _ReactWorkTags.HostPortal:
    case _ReactWorkTags.HostText:
    case _ReactWorkTags.Fragment:
    case _ReactWorkTags.ContextProvider:
    case _ReactWorkTags.ContextConsumer:
      return '';
    default:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = (0, _getComponentName2.default)(fiber.type);
      var ownerName = null;
      if (owner) {
        ownerName = (0, _getComponentName2.default)(owner.type);
      }
      return (0, _describeComponentFrame2.default)(name, source, ownerName);
  }
}

function getStackByFiberInDevAndProd(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    node = node.return;
  } while (node);
  return info;
}

var current = exports.current = null;
var phase = exports.phase = null;

function getCurrentFiberOwnerNameInDevOrNull() {
  if (true) {
    if (current === null) {
      return null;
    }
    var owner = current._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return (0, _getComponentName2.default)(owner.type);
    }
  }
  return null;
}

function getCurrentFiberStackInDev() {
  if (true) {
    if (current === null) {
      return '';
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackByFiberInDevAndProd(current);
  }
  return '';
}

function resetCurrentFiber() {
  if (true) {
    ReactDebugCurrentFrame.getCurrentStack = null;
    exports.current = current = null;
    exports.phase = phase = null;
  }
}

function setCurrentFiber(fiber) {
  if (true) {
    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
    exports.current = current = fiber;
    exports.phase = phase = null;
  }
}

function setCurrentPhase(lifeCyclePhase) {
  if (true) {
    exports.phase = phase = lifeCyclePhase;
  }
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


// Don't change these two values. They're used by React Dev Tools.
var NoEffect = /*              */exports.NoEffect = 0; /**
                                                        * Copyright (c) Facebook, Inc. and its affiliates.
                                                        *
                                                        * This source code is licensed under the MIT license found in the
                                                        * LICENSE file in the root directory of this source tree.
                                                        *
                                                        * 
                                                        */

var PerformedWork = /*         */exports.PerformedWork = 1;

// You can change the rest (and add more).
var Placement = /*             */exports.Placement = 2;
var Update = /*                */exports.Update = 4;
var PlacementAndUpdate = /*    */exports.PlacementAndUpdate = 6;
var Deletion = /*              */exports.Deletion = 8;
var ContentReset = /*          */exports.ContentReset = 16;
var Callback = /*              */exports.Callback = 32;
var DidCapture = /*            */exports.DidCapture = 64;
var Ref = /*                   */exports.Ref = 128;
var Snapshot = /*              */exports.Snapshot = 256;
var Passive = /*               */exports.Passive = 512;

// Passive & Update & Callback & Ref & Snapshot
var LifecycleEffectMask = /*   */exports.LifecycleEffectMask = 932;

// Union of all host effects
var HostEffectMask = /*        */exports.HostEffectMask = 1023;

var Incomplete = /*            */exports.Incomplete = 1024;
var ShouldCapture = /*         */exports.ShouldCapture = 2048;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HIGH_PRIORITY_BATCH_SIZE = exports.HIGH_PRIORITY_EXPIRATION = exports.LOW_PRIORITY_BATCH_SIZE = exports.LOW_PRIORITY_EXPIRATION = exports.Sync = exports.Never = exports.NoWork = undefined;
exports.msToExpirationTime = msToExpirationTime;
exports.expirationTimeToMs = expirationTimeToMs;
exports.computeAsyncExpiration = computeAsyncExpiration;
exports.computeInteractiveExpiration = computeInteractiveExpiration;

var _maxSigned31BitInt = __webpack_require__(55);

var _maxSigned31BitInt2 = _interopRequireDefault(_maxSigned31BitInt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NoWork = exports.NoWork = 0; /**
                                  * Copyright (c) Facebook, Inc. and its affiliates.
                                  *
                                  * This source code is licensed under the MIT license found in the
                                  * LICENSE file in the root directory of this source tree.
                                  *
                                  * 
                                  */

var Never = exports.Never = 1;
var Sync = exports.Sync = _maxSigned31BitInt2.default;

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = _maxSigned31BitInt2.default - 1;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);
}

function expirationTimeToMs(expirationTime) {
  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var LOW_PRIORITY_EXPIRATION = exports.LOW_PRIORITY_EXPIRATION = 5000;
var LOW_PRIORITY_BATCH_SIZE = exports.LOW_PRIORITY_BATCH_SIZE = 250;

function computeAsyncExpiration(currentTime) {
  return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
}

// We intentionally set a higher expiration time for interactive updates in
// dev than in production.
//
// If the main thread is being blocked so long that you hit the expiration,
// it's a problem that could be solved with better scheduling.
//
// People will be more likely to notice this and fix it with the long
// expiration time in development.
//
// In production we opt for better UX at the risk of masking scheduling
// problems, by expiring fast.
var HIGH_PRIORITY_EXPIRATION = exports.HIGH_PRIORITY_EXPIRATION =  true ? 500 : 150;
var HIGH_PRIORITY_BATCH_SIZE = exports.HIGH_PRIORITY_BATCH_SIZE = 100;

function computeInteractiveExpiration(currentTime) {
  return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(22);

var _react2 = _interopRequireDefault(_react);

var _ReactSharedInternals = __webpack_require__(61);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactSharedInternals = _react2.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

// Prevent newer renderers from RTE when used with older react package versions.
// Current owner and dispatcher used to share the same ref,
// but PR #14548 split them out to better support the react-debug-tools package.
// if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {
//   ReactSharedInternals.ReactCurrentDispatcher = {
//     current: null,
//   };
// }

exports.default = _ReactSharedInternals2.default;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ReactFiberHostConfig = __webpack_require__(168);

Object.keys(_ReactFiberHostConfig).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _ReactFiberHostConfig[key];
    }
  });
});

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* eslint valid-typeof: 0 */

var EVENT_POOL_SIZE = 10;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: function currentTarget() {
    return null;
  },
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function timeStamp(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

function functionThatReturnsTrue() {
  return true;
}

function functionThatReturnsFalse() {
  return false;
}

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if (true) {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
    delete this.isDefaultPrevented;
    delete this.isPropagationStopped;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if (true) {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = functionThatReturnsTrue;
  } else {
    this.isDefaultPrevented = functionThatReturnsFalse;
  }
  this.isPropagationStopped = functionThatReturnsFalse;
  return this;
}

Object.assign(SyntheticEvent.prototype, {
  preventDefault: function preventDefault() {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = functionThatReturnsTrue;
  },

  stopPropagation: function stopPropagation() {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = functionThatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function persist() {
    this.isPersistent = functionThatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: functionThatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function destructor() {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (true) {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    this.dispatchConfig = null;
    this._targetInst = null;
    this.nativeEvent = null;
    this.isDefaultPrevented = functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    this._dispatchListeners = null;
    this._dispatchInstances = null;
    if (true) {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));
      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 */
SyntheticEvent.extend = function (Interface) {
  var Super = this;

  var E = function E() {};
  E.prototype = Super.prototype;
  var prototype = new E();

  function Class() {
    return Super.apply(this, arguments);
  }
  Object.assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = Object.assign({}, Super.Interface, Interface);
  Class.extend = Super.extend;
  addEventPoolingTo(Class);

  return Class;
};

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    (0, _warningWithoutStack2.default)(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  (0, _invariant2.default)(event instanceof EventConstructor, 'Trying to release an event instance into a pool of a different type.');
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

exports.default = SyntheticEvent;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var NoContext = exports.NoContext = 0; /**
                                        * Copyright (c) Facebook, Inc. and its affiliates.
                                        *
                                        * This source code is licensed under the MIT license found in the
                                        * LICENSE file in the root directory of this source tree.
                                        *
                                        * 
                                        */
var ConcurrentMode = exports.ConcurrentMode = 1;
var StrictMode = exports.StrictMode = 2;
var ProfileMode = exports.ProfileMode = 4;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mediaEventTypes = exports.TOP_WHEEL = exports.TOP_WAITING = exports.TOP_VOLUME_CHANGE = exports.TOP_TRANSITION_END = exports.TOP_TOUCH_START = exports.TOP_TOUCH_MOVE = exports.TOP_TOUCH_END = exports.TOP_TOUCH_CANCEL = exports.TOP_TOGGLE = exports.TOP_TIME_UPDATE = exports.TOP_TEXT_INPUT = exports.TOP_SUSPEND = exports.TOP_SUBMIT = exports.TOP_STALLED = exports.TOP_SELECTION_CHANGE = exports.TOP_SEEKING = exports.TOP_SEEKED = exports.TOP_SCROLL = exports.TOP_RESET = exports.TOP_RATE_CHANGE = exports.TOP_PROGRESS = exports.TOP_POINTER_UP = exports.TOP_POINTER_OVER = exports.TOP_POINTER_OUT = exports.TOP_POINTER_MOVE = exports.TOP_POINTER_LEAVE = exports.TOP_POINTER_ENTER = exports.TOP_POINTER_DOWN = exports.TOP_POINTER_CANCEL = exports.TOP_PLAYING = exports.TOP_PLAY = exports.TOP_PAUSE = exports.TOP_PASTE = exports.TOP_MOUSE_UP = exports.TOP_MOUSE_OVER = exports.TOP_MOUSE_OUT = exports.TOP_MOUSE_MOVE = exports.TOP_MOUSE_DOWN = exports.TOP_LOST_POINTER_CAPTURE = exports.TOP_LOADED_METADATA = exports.TOP_LOADED_DATA = exports.TOP_LOAD_START = exports.TOP_LOAD = exports.TOP_KEY_UP = exports.TOP_KEY_PRESS = exports.TOP_KEY_DOWN = exports.TOP_INVALID = exports.TOP_INPUT = exports.TOP_GOT_POINTER_CAPTURE = exports.TOP_FOCUS = exports.TOP_ERROR = exports.TOP_ENDED = exports.TOP_ENCRYPTED = exports.TOP_EMPTIED = exports.TOP_DURATION_CHANGE = exports.TOP_DROP = exports.TOP_DRAG_START = exports.TOP_DRAG_OVER = exports.TOP_DRAG_LEAVE = exports.TOP_DRAG_EXIT = exports.TOP_DRAG_ENTER = exports.TOP_DRAG_END = exports.TOP_DRAG = exports.TOP_AUX_CLICK = exports.TOP_DOUBLE_CLICK = exports.TOP_CUT = exports.TOP_COPY = exports.TOP_CONTEXT_MENU = exports.TOP_COMPOSITION_UPDATE = exports.TOP_COMPOSITION_START = exports.TOP_COMPOSITION_END = exports.TOP_CLOSE = exports.TOP_CLICK = exports.TOP_CHANGE = exports.TOP_CANCEL = exports.TOP_CAN_PLAY_THROUGH = exports.TOP_CAN_PLAY = exports.TOP_BLUR = exports.TOP_ANIMATION_START = exports.TOP_ANIMATION_ITERATION = exports.TOP_ANIMATION_END = exports.TOP_ABORT = undefined;
exports.getRawEventName = getRawEventName;

var _TopLevelEventTypes = __webpack_require__(115);

var _getVendorPrefixedEventName = __webpack_require__(116);

var _getVendorPrefixedEventName2 = _interopRequireDefault(_getVendorPrefixedEventName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * To identify top level events in ReactDOM, we use constants defined by this
 * module. This is the only module that uses the unsafe* methods to express
 * that the constants actually correspond to the browser event names. This lets
 * us save some bundle size by avoiding a top level type -> event name map.
 * The rest of ReactDOM code should import top level types from this file.
 */
var TOP_ABORT = exports.TOP_ABORT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('abort'); /**
                                                                                                          * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                          *
                                                                                                          * This source code is licensed under the MIT license found in the
                                                                                                          * LICENSE file in the root directory of this source tree.
                                                                                                          *
                                                                                                          * 
                                                                                                          */

var TOP_ANIMATION_END = exports.TOP_ANIMATION_END = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)((0, _getVendorPrefixedEventName2.default)('animationend'));
var TOP_ANIMATION_ITERATION = exports.TOP_ANIMATION_ITERATION = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)((0, _getVendorPrefixedEventName2.default)('animationiteration'));
var TOP_ANIMATION_START = exports.TOP_ANIMATION_START = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)((0, _getVendorPrefixedEventName2.default)('animationstart'));
var TOP_BLUR = exports.TOP_BLUR = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('blur');
var TOP_CAN_PLAY = exports.TOP_CAN_PLAY = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('canplay');
var TOP_CAN_PLAY_THROUGH = exports.TOP_CAN_PLAY_THROUGH = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('canplaythrough');
var TOP_CANCEL = exports.TOP_CANCEL = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('cancel');
var TOP_CHANGE = exports.TOP_CHANGE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('change');
var TOP_CLICK = exports.TOP_CLICK = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('click');
var TOP_CLOSE = exports.TOP_CLOSE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('close');
var TOP_COMPOSITION_END = exports.TOP_COMPOSITION_END = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('compositionend');
var TOP_COMPOSITION_START = exports.TOP_COMPOSITION_START = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('compositionstart');
var TOP_COMPOSITION_UPDATE = exports.TOP_COMPOSITION_UPDATE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('compositionupdate');
var TOP_CONTEXT_MENU = exports.TOP_CONTEXT_MENU = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('contextmenu');
var TOP_COPY = exports.TOP_COPY = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('copy');
var TOP_CUT = exports.TOP_CUT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('cut');
var TOP_DOUBLE_CLICK = exports.TOP_DOUBLE_CLICK = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('dblclick');
var TOP_AUX_CLICK = exports.TOP_AUX_CLICK = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('auxclick');
var TOP_DRAG = exports.TOP_DRAG = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('drag');
var TOP_DRAG_END = exports.TOP_DRAG_END = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('dragend');
var TOP_DRAG_ENTER = exports.TOP_DRAG_ENTER = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('dragenter');
var TOP_DRAG_EXIT = exports.TOP_DRAG_EXIT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('dragexit');
var TOP_DRAG_LEAVE = exports.TOP_DRAG_LEAVE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('dragleave');
var TOP_DRAG_OVER = exports.TOP_DRAG_OVER = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('dragover');
var TOP_DRAG_START = exports.TOP_DRAG_START = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('dragstart');
var TOP_DROP = exports.TOP_DROP = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('drop');
var TOP_DURATION_CHANGE = exports.TOP_DURATION_CHANGE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('durationchange');
var TOP_EMPTIED = exports.TOP_EMPTIED = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('emptied');
var TOP_ENCRYPTED = exports.TOP_ENCRYPTED = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('encrypted');
var TOP_ENDED = exports.TOP_ENDED = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('ended');
var TOP_ERROR = exports.TOP_ERROR = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('error');
var TOP_FOCUS = exports.TOP_FOCUS = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('focus');
var TOP_GOT_POINTER_CAPTURE = exports.TOP_GOT_POINTER_CAPTURE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('gotpointercapture');
var TOP_INPUT = exports.TOP_INPUT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('input');
var TOP_INVALID = exports.TOP_INVALID = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('invalid');
var TOP_KEY_DOWN = exports.TOP_KEY_DOWN = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('keydown');
var TOP_KEY_PRESS = exports.TOP_KEY_PRESS = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('keypress');
var TOP_KEY_UP = exports.TOP_KEY_UP = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('keyup');
var TOP_LOAD = exports.TOP_LOAD = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('load');
var TOP_LOAD_START = exports.TOP_LOAD_START = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('loadstart');
var TOP_LOADED_DATA = exports.TOP_LOADED_DATA = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('loadeddata');
var TOP_LOADED_METADATA = exports.TOP_LOADED_METADATA = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('loadedmetadata');
var TOP_LOST_POINTER_CAPTURE = exports.TOP_LOST_POINTER_CAPTURE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('lostpointercapture');
var TOP_MOUSE_DOWN = exports.TOP_MOUSE_DOWN = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('mousedown');
var TOP_MOUSE_MOVE = exports.TOP_MOUSE_MOVE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('mousemove');
var TOP_MOUSE_OUT = exports.TOP_MOUSE_OUT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('mouseout');
var TOP_MOUSE_OVER = exports.TOP_MOUSE_OVER = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('mouseover');
var TOP_MOUSE_UP = exports.TOP_MOUSE_UP = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('mouseup');
var TOP_PASTE = exports.TOP_PASTE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('paste');
var TOP_PAUSE = exports.TOP_PAUSE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pause');
var TOP_PLAY = exports.TOP_PLAY = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('play');
var TOP_PLAYING = exports.TOP_PLAYING = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('playing');
var TOP_POINTER_CANCEL = exports.TOP_POINTER_CANCEL = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointercancel');
var TOP_POINTER_DOWN = exports.TOP_POINTER_DOWN = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointerdown');
var TOP_POINTER_ENTER = exports.TOP_POINTER_ENTER = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointerenter');
var TOP_POINTER_LEAVE = exports.TOP_POINTER_LEAVE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointerleave');
var TOP_POINTER_MOVE = exports.TOP_POINTER_MOVE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointermove');
var TOP_POINTER_OUT = exports.TOP_POINTER_OUT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointerout');
var TOP_POINTER_OVER = exports.TOP_POINTER_OVER = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointerover');
var TOP_POINTER_UP = exports.TOP_POINTER_UP = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('pointerup');
var TOP_PROGRESS = exports.TOP_PROGRESS = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('progress');
var TOP_RATE_CHANGE = exports.TOP_RATE_CHANGE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('ratechange');
var TOP_RESET = exports.TOP_RESET = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('reset');
var TOP_SCROLL = exports.TOP_SCROLL = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('scroll');
var TOP_SEEKED = exports.TOP_SEEKED = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('seeked');
var TOP_SEEKING = exports.TOP_SEEKING = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('seeking');
var TOP_SELECTION_CHANGE = exports.TOP_SELECTION_CHANGE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('selectionchange');
var TOP_STALLED = exports.TOP_STALLED = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('stalled');
var TOP_SUBMIT = exports.TOP_SUBMIT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('submit');
var TOP_SUSPEND = exports.TOP_SUSPEND = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('suspend');
var TOP_TEXT_INPUT = exports.TOP_TEXT_INPUT = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('textInput');
var TOP_TIME_UPDATE = exports.TOP_TIME_UPDATE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('timeupdate');
var TOP_TOGGLE = exports.TOP_TOGGLE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('toggle');
var TOP_TOUCH_CANCEL = exports.TOP_TOUCH_CANCEL = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('touchcancel');
var TOP_TOUCH_END = exports.TOP_TOUCH_END = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('touchend');
var TOP_TOUCH_MOVE = exports.TOP_TOUCH_MOVE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('touchmove');
var TOP_TOUCH_START = exports.TOP_TOUCH_START = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('touchstart');
var TOP_TRANSITION_END = exports.TOP_TRANSITION_END = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)((0, _getVendorPrefixedEventName2.default)('transitionend'));
var TOP_VOLUME_CHANGE = exports.TOP_VOLUME_CHANGE = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('volumechange');
var TOP_WAITING = exports.TOP_WAITING = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('waiting');
var TOP_WHEEL = exports.TOP_WHEEL = (0, _TopLevelEventTypes.unsafeCastStringToDOMTopLevelType)('wheel');

// List of events that need to be individually attached to media elements.
// Note that events in this list will *not* be listened to at the top level
// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.
var mediaEventTypes = exports.mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];

function getRawEventName(topLevelType) {
  return (0, _TopLevelEventTypes.unsafeCastDOMTopLevelTypeToString)(topLevelType);
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = exports.ELEMENT_NODE = 1;
var TEXT_NODE = exports.TEXT_NODE = 3;
var COMMENT_NODE = exports.COMMENT_NODE = 8;
var DOCUMENT_NODE = exports.DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = exports.DOCUMENT_FRAGMENT_NODE = 11;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.precacheFiberNode = precacheFiberNode;
exports.getClosestInstanceFromNode = getClosestInstanceFromNode;
exports.getInstanceFromNode = getInstanceFromNode;
exports.getNodeFromInstance = getNodeFromInstance;
exports.getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNode;
exports.updateFiberProps = updateFiberProps;

var _ReactWorkTags = __webpack_require__(4);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  while (!node[internalInstanceKey]) {
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var inst = node[internalInstanceKey];
  if (inst.tag === _ReactWorkTags.HostComponent || inst.tag === _ReactWorkTags.HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }

  return null;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === _ReactWorkTags.HostComponent || inst.tag === _ReactWorkTags.HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  if (inst.tag === _ReactWorkTags.HostComponent || inst.tag === _ReactWorkTags.HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  (0, _invariant2.default)(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps(node, props) {
  node[internalEventHandlersKey] = props;
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetCurrentlyProcessingQueue = exports.CaptureUpdate = exports.ForceUpdate = exports.ReplaceState = exports.UpdateState = undefined;
exports.createUpdateQueue = createUpdateQueue;
exports.createUpdate = createUpdate;
exports.enqueueUpdate = enqueueUpdate;
exports.enqueueCapturedUpdate = enqueueCapturedUpdate;
exports.processUpdateQueue = processUpdateQueue;
exports.resetHasForceUpdateBeforeProcessing = resetHasForceUpdateBeforeProcessing;
exports.checkHasForceUpdateAfterProcessing = checkHasForceUpdateAfterProcessing;
exports.commitUpdateQueue = commitUpdateQueue;

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactFiberNewContext = __webpack_require__(19);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactWorkTags = __webpack_require__(4);

var _ReactFeatureFlags = __webpack_require__(3);

var _ReactTypeOfMode = __webpack_require__(13);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

// UpdateQueue is a linked list of prioritized updates.
//
// Like fibers, update queues come in pairs: a current queue, which represents
// the visible state of the screen, and a work-in-progress queue, which can be
// mutated and processed asynchronously before it is committed  a form of
// double buffering. If a work-in-progress render is discarded before finishing,
// we create a new work-in-progress by cloning the current queue.
//
// Both queues share a persistent, singly-linked list structure. To schedule an
// update, we append it to the end of both queues. Each queue maintains a
// pointer to first update in the persistent list that hasn't been processed.
// The work-in-progress pointer always has a position equal to or greater than
// the current queue, since we always work on that one. The current queue's
// pointer is only updated during the commit phase, when we swap in the
// work-in-progress.
//
// For example:
//
//   Current pointer:           A - B - C - D - E - F
//   Work-in-progress pointer:              D - E - F
//                                          ^
//                                          The work-in-progress queue has
//                                          processed more updates than current.
//
// The reason we append to both queues is because otherwise we might drop
// updates without ever processing them. For example, if we only add updates to
// the work-in-progress queue, some updates could be lost whenever a work-in
// -progress render restarts by cloning from current. Similarly, if we only add
// updates to the current queue, the updates will be lost whenever an already
// in-progress queue commits and swaps with the current queue. However, by
// adding to both queues, we guarantee that the update will be part of the next
// work-in-progress. (And because the work-in-progress queue becomes the
// current queue once it commits, there's no danger of applying the same
// update twice.)
//
// Prioritization
// --------------
//
// Updates are not sorted by priority, but by insertion; new updates are always
// appended to the end of the list.
//
// The priority is still important, though. When processing the update queue
// during the render phase, only the updates with sufficient priority are
// included in the result. If we skip an update because it has insufficient
// priority, it remains in the queue to be processed later, during a lower
// priority render. Crucially, all updates subsequent to a skipped update also
// remain in the queue *regardless of their priority*. That means high priority
// updates are sometimes processed twice, at two separate priorities. We also
// keep track of a base state, that represents the state before the first
// update in the queue is applied.
//
// For example:
//
//   Given a base state of '', and the following queue of updates
//
//     A1 - B2 - C1 - D2
//
//   where the number indicates the priority, and the update is applied to the
//   previous state by appending a letter, React will process these updates as
//   two separate renders, one per distinct priority level:
//
//   First render, at priority 1:
//     Base state: ''
//     Updates: [A1, C1]
//     Result state: 'AC'
//
//   Second render, at priority 2:
//     Base state: 'A'            <-  The base state does not include C1,
//                                    because B2 was skipped.
//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
//     Result state: 'ABCD'
//
// Because we process updates in insertion order, and rebase high priority
// updates when preceding updates are skipped, the final result is deterministic
// regardless of priority. Intermediate state may vary according to system
// resources, but the final state is always the same.

var UpdateState = exports.UpdateState = 0;
var ReplaceState = exports.ReplaceState = 1;
var ForceUpdate = exports.ForceUpdate = 2;
var CaptureUpdate = exports.CaptureUpdate = 3;

// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
var hasForceUpdate = false;

var didWarnUpdateInsideUpdate = void 0;
var currentlyProcessingQueue = void 0;
var resetCurrentlyProcessingQueue = exports.resetCurrentlyProcessingQueue = void 0;
if (true) {
  didWarnUpdateInsideUpdate = false;
  currentlyProcessingQueue = null;
  exports.resetCurrentlyProcessingQueue = resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {
    currentlyProcessingQueue = null;
  };
}

function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    firstUpdate: null,
    lastUpdate: null,
    firstCapturedUpdate: null,
    lastCapturedUpdate: null,
    firstEffect: null,
    lastEffect: null,
    firstCapturedEffect: null,
    lastCapturedEffect: null
  };
  return queue;
}

function cloneUpdateQueue(currentQueue) {
  var queue = {
    baseState: currentQueue.baseState,
    firstUpdate: currentQueue.firstUpdate,
    lastUpdate: currentQueue.lastUpdate,

    // TODO: With resuming, if we bail out and resuse the child tree, we should
    // keep these effects.
    firstCapturedUpdate: null,
    lastCapturedUpdate: null,

    firstEffect: null,
    lastEffect: null,

    firstCapturedEffect: null,
    lastCapturedEffect: null
  };
  return queue;
}

function createUpdate(expirationTime) {
  return {
    expirationTime: expirationTime,

    tag: UpdateState,
    payload: null,
    callback: null,

    next: null,
    nextEffect: null
  };
}

function appendUpdateToQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.lastUpdate === null) {
    // Queue is empty
    queue.firstUpdate = queue.lastUpdate = update;
  } else {
    queue.lastUpdate.next = update;
    queue.lastUpdate = update;
  }
}

function enqueueUpdate(fiber, update) {
  // Update queues are created lazily.
  var alternate = fiber.alternate;
  var queue1 = void 0;
  var queue2 = void 0;
  if (alternate === null) {
    // There's only one fiber.
    queue1 = fiber.updateQueue;
    queue2 = null;
    if (queue1 === null) {
      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
    }
  } else {
    // There are two owners.
    queue1 = fiber.updateQueue;
    queue2 = alternate.updateQueue;
    if (queue1 === null) {
      if (queue2 === null) {
        // Neither fiber has an update queue. Create new ones.
        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
        queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
      } else {
        // Only one fiber has an update queue. Clone to create a new one.
        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
      }
    } else {
      if (queue2 === null) {
        // Only one fiber has an update queue. Clone to create a new one.
        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
      } else {
        // Both owners have an update queue.
      }
    }
  }
  if (queue2 === null || queue1 === queue2) {
    // There's only a single queue.
    appendUpdateToQueue(queue1, update);
  } else {
    // There are two queues. We need to append the update to both queues,
    // while accounting for the persistent structure of the list  we don't
    // want the same update to be added multiple times.
    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
      // One of the queues is not empty. We must add the update to both queues.
      appendUpdateToQueue(queue1, update);
      appendUpdateToQueue(queue2, update);
    } else {
      // Both queues are non-empty. The last update is the same in both lists,
      // because of structural sharing. So, only append to one of the lists.
      appendUpdateToQueue(queue1, update);
      // But we still need to update the `lastUpdate` pointer of queue2.
      queue2.lastUpdate = update;
    }
  }

  if (true) {
    if (fiber.tag === _ReactWorkTags.ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
      (0, _warningWithoutStack2.default)(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }
}

function enqueueCapturedUpdate(workInProgress, update) {
  // Captured updates go into a separate list, and only on the work-in-
  // progress queue.
  var workInProgressQueue = workInProgress.updateQueue;
  if (workInProgressQueue === null) {
    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
  } else {
    // TODO: I put this here rather than createWorkInProgress so that we don't
    // clone the queue unnecessarily. There's probably a better way to
    // structure this.
    workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
  }

  // Append the update to the end of the list.
  if (workInProgressQueue.lastCapturedUpdate === null) {
    // This is the first render phase update
    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
  } else {
    workInProgressQueue.lastCapturedUpdate.next = update;
    workInProgressQueue.lastCapturedUpdate = update;
  }
}

function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
  var current = workInProgress.alternate;
  if (current !== null) {
    // If the work-in-progress queue is equal to the current queue,
    // we need to clone it first.
    if (queue === current.updateQueue) {
      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
    }
  }
  return queue;
}

function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState:
      {
        var _payload = update.payload;
        if (typeof _payload === 'function') {
          // Updater function
          if (true) {
            (0, _ReactFiberNewContext.enterDisallowedContextReadInDEV)();
            if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
              _payload.call(instance, prevState, nextProps);
            }
          }
          var nextState = _payload.call(instance, prevState, nextProps);
          if (true) {
            (0, _ReactFiberNewContext.exitDisallowedContextReadInDEV)();
          }
          return nextState;
        }
        // State object
        return _payload;
      }
    case CaptureUpdate:
      {
        workInProgress.effectTag = workInProgress.effectTag & ~_ReactSideEffectTags.ShouldCapture | _ReactSideEffectTags.DidCapture;
      }
    // Intentional fallthrough
    case UpdateState:
      {
        var _payload2 = update.payload;
        var partialState = void 0;
        if (typeof _payload2 === 'function') {
          // Updater function
          if (true) {
            (0, _ReactFiberNewContext.enterDisallowedContextReadInDEV)();
            if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
              _payload2.call(instance, prevState, nextProps);
            }
          }
          partialState = _payload2.call(instance, prevState, nextProps);
          if (true) {
            (0, _ReactFiberNewContext.exitDisallowedContextReadInDEV)();
          }
        } else {
          // Partial state object
          partialState = _payload2;
        }
        if (partialState === null || partialState === undefined) {
          // Null and undefined are treated as no-ops.
          return prevState;
        }
        // Merge the partial state and the previous state.
        return Object.assign({}, prevState, partialState);
      }
    case ForceUpdate:
      {
        hasForceUpdate = true;
        return prevState;
      }
  }
  return prevState;
}

function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
  hasForceUpdate = false;

  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);

  if (true) {
    currentlyProcessingQueue = queue;
  }

  // These values may change as we process the queue.
  var newBaseState = queue.baseState;
  var newFirstUpdate = null;
  var newExpirationTime = _ReactFiberExpirationTime.NoWork;

  // Iterate through the list of updates to compute the result.
  var update = queue.firstUpdate;
  var resultState = newBaseState;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime < renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      if (newFirstUpdate === null) {
        // This is the first skipped update. It will be the first update in
        // the new list.
        newFirstUpdate = update;
        // Since this is the first update that was skipped, the current result
        // is the new base state.
        newBaseState = resultState;
      }
      // Since this update will remain in the list, update the remaining
      // expiration time.
      if (newExpirationTime < updateExpirationTime) {
        newExpirationTime = updateExpirationTime;
      }
    } else {
      // This update does have sufficient priority. Process it and compute
      // a new result.
      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
      var _callback = update.callback;
      if (_callback !== null) {
        workInProgress.effectTag |= _ReactSideEffectTags.Callback;
        // Set this to null, in case it was mutated during an aborted render.
        update.nextEffect = null;
        if (queue.lastEffect === null) {
          queue.firstEffect = queue.lastEffect = update;
        } else {
          queue.lastEffect.nextEffect = update;
          queue.lastEffect = update;
        }
      }
    }
    // Continue to the next update.
    update = update.next;
  }

  // Separately, iterate though the list of captured updates.
  var newFirstCapturedUpdate = null;
  update = queue.firstCapturedUpdate;
  while (update !== null) {
    var _updateExpirationTime = update.expirationTime;
    if (_updateExpirationTime < renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      if (newFirstCapturedUpdate === null) {
        // This is the first skipped captured update. It will be the first
        // update in the new list.
        newFirstCapturedUpdate = update;
        // If this is the first update that was skipped, the current result is
        // the new base state.
        if (newFirstUpdate === null) {
          newBaseState = resultState;
        }
      }
      // Since this update will remain in the list, update the remaining
      // expiration time.
      if (newExpirationTime < _updateExpirationTime) {
        newExpirationTime = _updateExpirationTime;
      }
    } else {
      // This update does have sufficient priority. Process it and compute
      // a new result.
      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
      var _callback2 = update.callback;
      if (_callback2 !== null) {
        workInProgress.effectTag |= _ReactSideEffectTags.Callback;
        // Set this to null, in case it was mutated during an aborted render.
        update.nextEffect = null;
        if (queue.lastCapturedEffect === null) {
          queue.firstCapturedEffect = queue.lastCapturedEffect = update;
        } else {
          queue.lastCapturedEffect.nextEffect = update;
          queue.lastCapturedEffect = update;
        }
      }
    }
    update = update.next;
  }

  if (newFirstUpdate === null) {
    queue.lastUpdate = null;
  }
  if (newFirstCapturedUpdate === null) {
    queue.lastCapturedUpdate = null;
  } else {
    workInProgress.effectTag |= _ReactSideEffectTags.Callback;
  }
  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
    // We processed every update, without skipping. That means the new base
    // state is the same as the result state.
    newBaseState = resultState;
  }

  queue.baseState = newBaseState;
  queue.firstUpdate = newFirstUpdate;
  queue.firstCapturedUpdate = newFirstCapturedUpdate;

  // Set the remaining expiration time to be whatever is remaining in the queue.
  // This should be fine because the only two other things that contribute to
  // expiration time are props and context. We're already in the middle of the
  // begin phase by the time we start processing the queue, so we've already
  // dealt with the props. Context in components that specify
  // shouldComponentUpdate is tricky; but we'll have to account for
  // that regardless.
  workInProgress.expirationTime = newExpirationTime;
  workInProgress.memoizedState = resultState;

  if (true) {
    currentlyProcessingQueue = null;
  }
}

function callCallback(callback, context) {
  (0, _invariant2.default)(typeof callback === 'function', 'Invalid argument passed as callback. Expected a function. Instead ' + 'received: %s', callback);
  callback.call(context);
}

function resetHasForceUpdateBeforeProcessing() {
  hasForceUpdate = false;
}

function checkHasForceUpdateAfterProcessing() {
  return hasForceUpdate;
}

function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
  // If the finished render included captured updates, and there are still
  // lower priority updates left over, we need to keep the captured updates
  // in the queue so that they are rebased and not dropped once we process the
  // queue again at the lower priority.
  if (finishedQueue.firstCapturedUpdate !== null) {
    // Join the captured update list to the end of the normal list.
    if (finishedQueue.lastUpdate !== null) {
      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
    }
    // Clear the list of captured updates.
    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
  }

  // Commit the effects
  commitUpdateEffects(finishedQueue.firstEffect, instance);
  finishedQueue.firstEffect = finishedQueue.lastEffect = null;

  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
}

function commitUpdateEffects(effect, instance) {
  while (effect !== null) {
    var _callback3 = effect.callback;
    if (_callback3 !== null) {
      effect.callback = null;
      callCallback(_callback3, instance);
    }
    effect = effect.nextEffect;
  }
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetContextDependences = resetContextDependences;
exports.enterDisallowedContextReadInDEV = enterDisallowedContextReadInDEV;
exports.exitDisallowedContextReadInDEV = exitDisallowedContextReadInDEV;
exports.pushProvider = pushProvider;
exports.popProvider = popProvider;
exports.calculateChangedBits = calculateChangedBits;
exports.propagateContextChange = propagateContextChange;
exports.prepareToReadContext = prepareToReadContext;
exports.readContext = readContext;

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiberStack = __webpack_require__(38);

var _maxSigned31BitInt = __webpack_require__(55);

var _maxSigned31BitInt2 = _interopRequireDefault(_maxSigned31BitInt);

var _ReactWorkTags = __webpack_require__(4);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _objectIs = __webpack_require__(53);

var _objectIs2 = _interopRequireDefault(_objectIs);

var _ReactUpdateQueue = __webpack_require__(18);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactFiberBeginWork = __webpack_require__(40);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var valueCursor = (0, _ReactFiberStack.createCursor)(null);

var rendererSigil = void 0;
if (true) {
  // Use this to detect multiple renderers using the same context
  rendererSigil = {};
}

var currentlyRenderingFiber = null;
var lastContextDependency = null;
var lastContextWithAllBitsObserved = null;

var isDisallowedContextReadInDEV = false;

function resetContextDependences() {
  // This is called right before React yields execution, to ensure `readContext`
  // cannot be called outside the render phase.
  currentlyRenderingFiber = null;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;
  if (true) {
    isDisallowedContextReadInDEV = false;
  }
}

function enterDisallowedContextReadInDEV() {
  if (true) {
    isDisallowedContextReadInDEV = true;
  }
}

function exitDisallowedContextReadInDEV() {
  if (true) {
    isDisallowedContextReadInDEV = false;
  }
}

function pushProvider(providerFiber, nextValue) {
  var context = providerFiber.type._context;

  if (_ReactFiberHostConfig.isPrimaryRenderer) {
    (0, _ReactFiberStack.push)(valueCursor, context._currentValue, providerFiber);

    context._currentValue = nextValue;
    if (true) {
      (0, _warningWithoutStack2.default)(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
      context._currentRenderer = rendererSigil;
    }
  } else {
    (0, _ReactFiberStack.push)(valueCursor, context._currentValue2, providerFiber);

    context._currentValue2 = nextValue;
    if (true) {
      (0, _warningWithoutStack2.default)(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
      context._currentRenderer2 = rendererSigil;
    }
  }
}

function popProvider(providerFiber) {
  var currentValue = valueCursor.current;

  (0, _ReactFiberStack.pop)(valueCursor, providerFiber);

  var context = providerFiber.type._context;
  if (_ReactFiberHostConfig.isPrimaryRenderer) {
    context._currentValue = currentValue;
  } else {
    context._currentValue2 = currentValue;
  }
}

function calculateChangedBits(context, newValue, oldValue) {
  if ((0, _objectIs2.default)(oldValue, newValue)) {
    // No change
    return 0;
  } else {
    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : _maxSigned31BitInt2.default;

    if (true) {
      (0, _warning2.default)((changedBits & _maxSigned31BitInt2.default) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
    }
    return changedBits | 0;
  }
}

function scheduleWorkOnParentPath(parent, renderExpirationTime) {
  // Update the child expiration time of all the ancestors, including
  // the alternates.
  var node = parent;
  while (node !== null) {
    var alternate = node.alternate;
    if (node.childExpirationTime < renderExpirationTime) {
      node.childExpirationTime = renderExpirationTime;
      if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
        alternate.childExpirationTime = renderExpirationTime;
      }
    } else if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
      alternate.childExpirationTime = renderExpirationTime;
    } else {
      // Neither alternate was updated, which means the rest of the
      // ancestor path already has sufficient priority.
      break;
    }
    node = node.return;
  }
}

function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
  var fiber = workInProgress.child;
  if (fiber !== null) {
    // Set the return pointer of the child to the work-in-progress fiber.
    fiber.return = workInProgress;
  }
  while (fiber !== null) {
    var nextFiber = void 0;

    // Visit this fiber.
    var list = fiber.contextDependencies;
    if (list !== null) {
      nextFiber = fiber.child;

      var dependency = list.first;
      while (dependency !== null) {
        // Check if the context matches.
        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
          // Match! Schedule an update on this fiber.

          if (fiber.tag === _ReactWorkTags.ClassComponent) {
            // Schedule a force update on the work-in-progress.
            var update = (0, _ReactUpdateQueue.createUpdate)(renderExpirationTime);
            update.tag = _ReactUpdateQueue.ForceUpdate;
            // TODO: Because we don't have a work-in-progress, this will add the
            // update to the current fiber, too, which means it will persist even if
            // this render is thrown away. Since it's a race condition, not sure it's
            // worth fixing.
            (0, _ReactUpdateQueue.enqueueUpdate)(fiber, update);
          }

          if (fiber.expirationTime < renderExpirationTime) {
            fiber.expirationTime = renderExpirationTime;
          }
          var alternate = fiber.alternate;
          if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
            alternate.expirationTime = renderExpirationTime;
          }

          scheduleWorkOnParentPath(fiber.return, renderExpirationTime);

          // Mark the expiration time on the list, too.
          if (list.expirationTime < renderExpirationTime) {
            list.expirationTime = renderExpirationTime;
          }

          // Since we already found a match, we can stop traversing the
          // dependency list.
          break;
        }
        dependency = dependency.next;
      }
    } else if (fiber.tag === _ReactWorkTags.ContextProvider) {
      // Don't scan deeper if this is a matching provider
      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
    } else if (_ReactFeatureFlags.enableSuspenseServerRenderer && fiber.tag === _ReactWorkTags.DehydratedSuspenseComponent) {
      // If a dehydrated suspense component is in this subtree, we don't know
      // if it will have any context consumers in it. The best we can do is
      // mark it as having updates on its children.
      if (fiber.expirationTime < renderExpirationTime) {
        fiber.expirationTime = renderExpirationTime;
      }
      var _alternate = fiber.alternate;
      if (_alternate !== null && _alternate.expirationTime < renderExpirationTime) {
        _alternate.expirationTime = renderExpirationTime;
      }
      // This is intentionally passing this fiber as the parent
      // because we want to schedule this fiber as having work
      // on its children. We'll use the childExpirationTime on
      // this fiber to indicate that a context has changed.
      scheduleWorkOnParentPath(fiber, renderExpirationTime);
      nextFiber = fiber.sibling;
    } else {
      // Traverse down.
      nextFiber = fiber.child;
    }

    if (nextFiber !== null) {
      // Set the return pointer of the child to the work-in-progress fiber.
      nextFiber.return = fiber;
    } else {
      // No child. Traverse to next sibling.
      nextFiber = fiber;
      while (nextFiber !== null) {
        if (nextFiber === workInProgress) {
          // We're back to the root of this subtree. Exit.
          nextFiber = null;
          break;
        }
        var sibling = nextFiber.sibling;
        if (sibling !== null) {
          // Set the return pointer of the sibling to the work-in-progress fiber.
          sibling.return = nextFiber.return;
          nextFiber = sibling;
          break;
        }
        // No more siblings. Traverse up.
        nextFiber = nextFiber.return;
      }
    }
    fiber = nextFiber;
  }
}

function prepareToReadContext(workInProgress, renderExpirationTime) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;

  var currentDependencies = workInProgress.contextDependencies;
  if (currentDependencies !== null && currentDependencies.expirationTime >= renderExpirationTime) {
    // Context list has a pending update. Mark that this fiber performed work.
    (0, _ReactFiberBeginWork.markWorkInProgressReceivedUpdate)();
  }

  // Reset the work-in-progress list
  workInProgress.contextDependencies = null;
}

function readContext(context, observedBits) {
  if (true) {
    // This warning would fire if you read context inside a Hook like useMemo.
    // Unlike the class check below, it's not enforced in production for perf.
    (0, _warning2.default)(!isDisallowedContextReadInDEV, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
  }

  if (lastContextWithAllBitsObserved === context) {
    // Nothing to do. We already observe everything in this context.
  } else if (observedBits === false || observedBits === 0) {
    // Do not observe any updates.
  } else {
    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.
    if (typeof observedBits !== 'number' || observedBits === _maxSigned31BitInt2.default) {
      // Observe all updates.
      lastContextWithAllBitsObserved = context;
      resolvedObservedBits = _maxSigned31BitInt2.default;
    } else {
      resolvedObservedBits = observedBits;
    }

    var contextItem = {
      context: context,
      observedBits: resolvedObservedBits,
      next: null
    };

    if (lastContextDependency === null) {
      (0, _invariant2.default)(currentlyRenderingFiber !== null, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');

      // This is the first dependency for this component. Create a new list.
      lastContextDependency = contextItem;
      currentlyRenderingFiber.contextDependencies = {
        first: contextItem,
        expirationTime: _ReactFiberExpirationTime.NoWork
      };
    } else {
      // Append a new context item.
      lastContextDependency = lastContextDependency.next = contextItem;
    }
  }
  return _ReactFiberHostConfig.isPrimaryRenderer ? context._currentValue : context._currentValue2;
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accumulateTwoPhaseDispatches = accumulateTwoPhaseDispatches;
exports.accumulateTwoPhaseDispatchesSkipTarget = accumulateTwoPhaseDispatchesSkipTarget;
exports.accumulateEnterLeaveDispatches = accumulateEnterLeaveDispatches;
exports.accumulateDirectDispatches = accumulateDirectDispatches;

var _ReactTreeTraversal = __webpack_require__(114);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _EventPluginHub = __webpack_require__(24);

var _accumulateInto = __webpack_require__(67);

var _accumulateInto2 = _interopRequireDefault(_accumulateInto);

var _forEachAccumulated = __webpack_require__(68);

var _forEachAccumulated2 = _interopRequireDefault(_forEachAccumulated);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return (0, _EventPluginHub.getListener)(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function accumulateDirectionalDispatches(inst, phase, event) {
  if (true) {
    (0, _warningWithoutStack2.default)(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = (0, _accumulateInto2.default)(event._dispatchListeners, listener);
    event._dispatchInstances = (0, _accumulateInto2.default)(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    (0, _ReactTreeTraversal.traverseTwoPhase)(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? (0, _ReactTreeTraversal.getParentInstance)(targetInst) : null;
    (0, _ReactTreeTraversal.traverseTwoPhase)(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = (0, _EventPluginHub.getListener)(inst, registrationName);
    if (listener) {
      event._dispatchListeners = (0, _accumulateInto2.default)(event._dispatchListeners, listener);
      event._dispatchInstances = (0, _accumulateInto2.default)(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  (0, _forEachAccumulated2.default)(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  (0, _forEachAccumulated2.default)(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  (0, _ReactTreeTraversal.traverseEnterLeave)(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  (0, _forEachAccumulated2.default)(events, accumulateDirectDispatchesSingle);
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findCurrentUnmaskedContext = exports.invalidateContextProvider = exports.pushContextProvider = exports.isContextProvider = exports.processChildContext = exports.pushTopLevelContextObject = exports.popTopLevelContextObject = exports.popContext = exports.hasContextChanged = exports.getMaskedContext = exports.cacheContext = exports.getUnmaskedContext = exports.emptyContextObject = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * 
                                                                                                                                                                                                                                                                   */

var _reflection = __webpack_require__(36);

var _ReactWorkTags = __webpack_require__(4);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _checkPropTypes = __webpack_require__(33);

var _checkPropTypes2 = _interopRequireDefault(_checkPropTypes);

var _ReactCurrentFiber = __webpack_require__(7);

var _ReactDebugFiberPerf = __webpack_require__(29);

var _ReactFiberStack = __webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warnedAboutMissingGetChildContext = void 0;

if (true) {
  warnedAboutMissingGetChildContext = {};
}

var emptyContextObject = exports.emptyContextObject = {};
if (true) {
  Object.freeze(emptyContextObject);
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = (0, _ReactFiberStack.createCursor)(emptyContextObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = (0, _ReactFiberStack.createCursor)(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyContextObject;

function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
  if (didPushOwnContextIfProvider && isContextProvider(Component)) {
    // If the fiber is a context provider itself, when we read its context
    // we may have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyContextObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  if (true) {
    var name = (0, _getComponentName2.default)(type) || 'Unknown';
    (0, _checkPropTypes2.default)(contextTypes, context, 'context', name, _ReactCurrentFiber.getCurrentFiberStackInDev);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextProvider(type) {
  var childContextTypes = type.childContextTypes;
  return childContextTypes !== null && childContextTypes !== undefined;
}

function popContext(fiber) {
  (0, _ReactFiberStack.pop)(didPerformWorkStackCursor, fiber);
  (0, _ReactFiberStack.pop)(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  (0, _ReactFiberStack.pop)(didPerformWorkStackCursor, fiber);
  (0, _ReactFiberStack.pop)(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  (0, _invariant2.default)(contextStackCursor.current === emptyContextObject, 'Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');

  (0, _ReactFiberStack.push)(contextStackCursor, context, fiber);
  (0, _ReactFiberStack.push)(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, type, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    if (true) {
      var componentName = (0, _getComponentName2.default)(type) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        (0, _warningWithoutStack2.default)(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  if (true) {
    (0, _ReactCurrentFiber.setCurrentPhase)('getChildContext');
  }
  (0, _ReactDebugFiberPerf.startPhaseTimer)(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  (0, _ReactDebugFiberPerf.stopPhaseTimer)();
  if (true) {
    (0, _ReactCurrentFiber.setCurrentPhase)(null);
  }
  for (var contextKey in childContext) {
    (0, _invariant2.default)(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', (0, _getComponentName2.default)(type) || 'Unknown', contextKey);
  }
  if (true) {
    var name = (0, _getComponentName2.default)(type) || 'Unknown';
    (0, _checkPropTypes2.default)(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    _ReactCurrentFiber.getCurrentFiberStackInDev);
  }

  return _extends({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  (0, _ReactFiberStack.push)(contextStackCursor, memoizedMergedChildContext, workInProgress);
  (0, _ReactFiberStack.push)(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, type, didChange) {
  var instance = workInProgress.stateNode;
  (0, _invariant2.default)(instance, 'Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, type, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    (0, _ReactFiberStack.pop)(didPerformWorkStackCursor, workInProgress);
    (0, _ReactFiberStack.pop)(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    (0, _ReactFiberStack.push)(contextStackCursor, mergedContext, workInProgress);
    (0, _ReactFiberStack.push)(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    (0, _ReactFiberStack.pop)(didPerformWorkStackCursor, workInProgress);
    (0, _ReactFiberStack.push)(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  (0, _invariant2.default)((0, _reflection.isFiberMounted)(fiber) && fiber.tag === _ReactWorkTags.ClassComponent, 'Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');

  var node = fiber;
  do {
    switch (node.tag) {
      case _ReactWorkTags.HostRoot:
        return node.stateNode.context;
      case _ReactWorkTags.ClassComponent:
        {
          var Component = node.type;
          if (isContextProvider(Component)) {
            return node.stateNode.__reactInternalMemoizedMergedChildContext;
          }
          break;
        }
    }
    node = node.return;
  } while (node !== null);
  (0, _invariant2.default)(false, 'Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');
}

exports.getUnmaskedContext = getUnmaskedContext;
exports.cacheContext = cacheContext;
exports.getMaskedContext = getMaskedContext;
exports.hasContextChanged = hasContextChanged;
exports.popContext = popContext;
exports.popTopLevelContextObject = popTopLevelContextObject;
exports.pushTopLevelContextObject = pushTopLevelContextObject;
exports.processChildContext = processChildContext;
exports.isContextProvider = isContextProvider;
exports.pushContextProvider = pushContextProvider;
exports.invalidateContextProvider = invalidateContextProvider;
exports.findCurrentUnmaskedContext = findCurrentUnmaskedContext;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// const React = require('./src/React');

var _React = __webpack_require__(90);

var _React2 = _interopRequireDefault(_React);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
module.exports = _React2.default.default || _React2.default;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tracing = __webpack_require__(63);

Object.keys(_Tracing).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tracing[key];
    }
  });
});

var _TracingSubscriptions = __webpack_require__(99);

Object.keys(_TracingSubscriptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _TracingSubscriptions[key];
    }
  });
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.injection = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.getListener = getListener;
exports.runEventsInBatch = runEventsInBatch;
exports.runExtractedEventsInBatch = runExtractedEventsInBatch;

var _ReactErrorUtils = __webpack_require__(34);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _EventPluginRegistry = __webpack_require__(25);

var _EventPluginUtils = __webpack_require__(46);

var _accumulateInto = __webpack_require__(67);

var _accumulateInto2 = _interopRequireDefault(_accumulateInto);

var _forEachAccumulated = __webpack_require__(68);

var _forEachAccumulated2 = _interopRequireDefault(_forEachAccumulated);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */
var executeDispatchesAndRelease = function executeDispatchesAndRelease(event) {
  if (event) {
    (0, _EventPluginUtils.executeDispatchesInOrder)(event);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
  return executeDispatchesAndRelease(e);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection = exports.injection = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: _EventPluginRegistry.injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: _EventPluginRegistry.injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener = void 0;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = (0, _EventPluginUtils.getFiberCurrentPropsFromNode)(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  (0, _invariant2.default)(!listener || typeof listener === 'function', 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener));
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = null;
  for (var i = 0; i < _EventPluginRegistry.plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = _EventPluginRegistry.plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = (0, _accumulateInto2.default)(events, extractedEvents);
      }
    }
  }
  return events;
}

function runEventsInBatch(events) {
  if (events !== null) {
    eventQueue = (0, _accumulateInto2.default)(eventQueue, events);
  }

  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  (0, _forEachAccumulated2.default)(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  (0, _invariant2.default)(!eventQueue, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.');
  // This would be a good time to rethrow if any of the event handlers threw.
  (0, _ReactErrorUtils.rethrowCaughtError)();
}

function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventsInBatch(events);
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.possibleRegistrationNames = exports.registrationNameDependencies = exports.registrationNameModules = exports.eventNameDispatchConfigs = exports.plugins = undefined;
exports.injectEventPluginOrder = injectEventPluginOrder;
exports.injectEventPluginsByName = injectEventPluginsByName;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    (0, _invariant2.default)(pluginIndex > -1, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName);
    if (plugins[pluginIndex]) {
      continue;
    }
    (0, _invariant2.default)(pluginModule.extractEvents, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName);
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      (0, _invariant2.default)(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName);
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  (0, _invariant2.default)(!eventNameDispatchConfigs.hasOwnProperty(eventName), 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName);
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  (0, _invariant2.default)(!registrationNameModules[registrationName], 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if (true) {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = exports.plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = exports.eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = exports.registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = exports.registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in __DEV__.
 * @type {Object}
 */
var possibleRegistrationNames = exports.possibleRegistrationNames =  true ? {} : null;
// Trust the developer to only use possibleRegistrationNames in __DEV__

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  (0, _invariant2.default)(!eventPluginOrder, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.');
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      (0, _invariant2.default)(!namesToPlugins[pluginName], 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName);
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VALID_ATTRIBUTE_NAME_REGEX = exports.ROOT_ATTRIBUTE_NAME = exports.ID_ATTRIBUTE_NAME = exports.ATTRIBUTE_NAME_CHAR = exports.ATTRIBUTE_NAME_START_CHAR = exports.POSITIVE_NUMERIC = exports.NUMERIC = exports.OVERLOADED_BOOLEAN = exports.BOOLEAN = exports.BOOLEANISH_STRING = exports.STRING = exports.RESERVED = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.isAttributeNameSafe = isAttributeNameSafe;
exports.shouldIgnoreAttribute = shouldIgnoreAttribute;
exports.shouldRemoveAttributeWithWarning = shouldRemoveAttributeWithWarning;
exports.shouldRemoveAttribute = shouldRemoveAttribute;
exports.getPropertyInfo = getPropertyInfo;

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = exports.RESERVED = 0;

// A simple string attribute.
// Attributes that aren't in the whitelist are presumed to have this type.
var STRING = exports.STRING = 1;

// A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING = exports.BOOLEANISH_STRING = 2;

// A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN = exports.BOOLEAN = 3;

// An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN = exports.OVERLOADED_BOOLEAN = 4;

// An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC = exports.NUMERIC = 5;

// An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC = exports.POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = exports.ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = exports.ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';

var ID_ATTRIBUTE_NAME = exports.ID_ATTRIBUTE_NAME = 'data-reactid';
var ROOT_ATTRIBUTE_NAME = exports.ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = exports.VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  if (true) {
    (0, _warning2.default)(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }
  if (isCustomComponentTag) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }
  return false;
}

function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }
  switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    case 'function':
    // $FlowIssue symbol is perfectly valid here
    case 'symbol':
      // eslint-disable-line
      return true;
    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }
        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }
    default:
      return false;
  }
}

function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }
  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }
  if (isCustomComponentTag) {
    return false;
  }
  if (propertyInfo !== null) {
    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;
      case OVERLOADED_BOOLEAN:
        return value === false;
      case NUMERIC:
        return isNaN(value);
      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }
  return false;
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
}

// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties = {};

// These props are reserved by React. They shouldn't be written to the DOM.
['children', 'dangerouslySetInnerHTML',
// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      name = _ref2[0],
      attributeName = _ref2[1];

  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null);
} // attributeNamespace
);

// These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null);
} // attributeNamespace
);

// These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML boolean attributes.
['allowFullScreen', 'async',
// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',
// Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null);
} // attributeNamespace
);

// These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
['checked',
// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
['capture', 'download'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML attributes that must be positive numbers.
['cols', 'rows', 'size', 'span'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML attributes that must be numbers.
['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null);
} // attributeNamespace
);

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function capitalize(token) {
  return token[1].toUpperCase();
};

// This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML whitelist.
// Some of these attributes can be hard to find. This list was created by
// scrapping the MDN documentation.
['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null);
} // attributeNamespace
);

// String SVG attributes with the xlink namespace.
['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink');
});

// String SVG attributes with the xml namespace.
['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace');
});

// These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.
['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null);
} // attributeNamespace
);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticUIEvent = __webpack_require__(28);

var _SyntheticUIEvent2 = _interopRequireDefault(_SyntheticUIEvent);

var _getEventModifierState = __webpack_require__(51);

var _getEventModifierState2 = _interopRequireDefault(_getEventModifierState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var previousScreenX = 0;
var previousScreenY = 0;
// Use flags to signal movementX/Y has already been set
var isMovementXSet = false;
var isMovementYSet = false;

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticMouseEvent = _SyntheticUIEvent2.default.extend({
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: _getEventModifierState2.default,
  button: null,
  buttons: null,
  relatedTarget: function relatedTarget(event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  movementX: function movementX(event) {
    if ('movementX' in event) {
      return event.movementX;
    }

    var screenX = previousScreenX;
    previousScreenX = event.screenX;

    if (!isMovementXSet) {
      isMovementXSet = true;
      return 0;
    }

    return event.type === 'mousemove' ? event.screenX - screenX : 0;
  },
  movementY: function movementY(event) {
    if ('movementY' in event) {
      return event.movementY;
    }

    var screenY = previousScreenY;
    previousScreenY = event.screenY;

    if (!isMovementYSet) {
      isMovementYSet = true;
      return 0;
    }

    return event.type === 'mousemove' ? event.screenY - screenY : 0;
  }
});

exports.default = SyntheticMouseEvent;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SyntheticUIEvent = _SyntheticEvent2.default.extend({
  view: null,
  detail: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticUIEvent;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.recordEffect = recordEffect;
exports.recordScheduleUpdate = recordScheduleUpdate;
exports.startRequestCallbackTimer = startRequestCallbackTimer;
exports.stopRequestCallbackTimer = stopRequestCallbackTimer;
exports.startWorkTimer = startWorkTimer;
exports.cancelWorkTimer = cancelWorkTimer;
exports.stopWorkTimer = stopWorkTimer;
exports.stopFailedWorkTimer = stopFailedWorkTimer;
exports.startPhaseTimer = startPhaseTimer;
exports.stopPhaseTimer = stopPhaseTimer;
exports.startWorkLoopTimer = startWorkLoopTimer;
exports.stopWorkLoopTimer = stopWorkLoopTimer;
exports.startCommitTimer = startCommitTimer;
exports.stopCommitTimer = stopCommitTimer;
exports.startCommitSnapshotEffectsTimer = startCommitSnapshotEffectsTimer;
exports.stopCommitSnapshotEffectsTimer = stopCommitSnapshotEffectsTimer;
exports.startCommitHostEffectsTimer = startCommitHostEffectsTimer;
exports.stopCommitHostEffectsTimer = stopCommitHostEffectsTimer;
exports.startCommitLifeCyclesTimer = startCommitLifeCyclesTimer;
exports.stopCommitLifeCyclesTimer = stopCommitLifeCyclesTimer;

var _ReactFeatureFlags = __webpack_require__(3);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _ReactWorkTags = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function formatMarkName(markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function formatLabel(label, warning) {
  var prefix = warning ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning ? ' Warning: ' + warning : '';
  return '' + prefix + label + suffix;
};

var beginMark = function beginMark(markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function clearMark(markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function endMark(label, markName, warning) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function getFiberMarkName(label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function beginFiberMark(fiber, phase) {
  var componentName = (0, _getComponentName2.default)(fiber.type) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function clearFiberMark(fiber, phase) {
  var componentName = (0, _getComponentName2.default)(fiber.type) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function endFiberMark(fiber, phase, warning) {
  var componentName = (0, _getComponentName2.default)(fiber.type) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning);
};

var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case _ReactWorkTags.HostRoot:
    case _ReactWorkTags.HostComponent:
    case _ReactWorkTags.HostText:
    case _ReactWorkTags.HostPortal:
    case _ReactWorkTags.Fragment:
    case _ReactWorkTags.ContextProvider:
    case _ReactWorkTags.ContextConsumer:
    case _ReactWorkTags.Mode:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function pauseTimers() {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber.return;
  }
};

var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
  if (fiber.return !== null) {
    resumeTimersRecursively(fiber.return);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function resumeTimers() {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire, expirationTime) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning);
    }
  }
}

function startWorkTimer(fiber) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber.return;
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber.return;
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning = fiber.tag === _ReactWorkTags.SuspenseComponent || fiber.tag === _ReactWorkTags.DehydratedSuspenseComponent ? 'Rendering was suspended' : 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning);
  }
}

function startPhaseTimer(fiber, phase) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === _ReactWorkTags.HostRoot) {
        warning = 'A top-level update interrupted the previous render';
      } else {
        var componentName = (0, _getComponentName2.default)(interruptedBy.type) || 'Unknown';
        warning = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark(label, '(React Tree Reconciliation)', warning);
  }
}

function startCommitTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning);
  }
}

function startCommitSnapshotEffectsTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Snapshot Effects)');
  }
}

function stopCommitSnapshotEffectsTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);
  }
}

function startCommitHostEffectsTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (_ReactFeatureFlags.enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.isSimpleFunctionComponent = isSimpleFunctionComponent;
exports.resolveLazyComponentTag = resolveLazyComponentTag;
exports.createWorkInProgress = createWorkInProgress;
exports.createHostRootFiber = createHostRootFiber;
exports.createFiberFromTypeAndProps = createFiberFromTypeAndProps;
exports.createFiberFromElement = createFiberFromElement;
exports.createFiberFromFragment = createFiberFromFragment;
exports.createFiberFromSuspense = createFiberFromSuspense;
exports.createFiberFromText = createFiberFromText;
exports.createFiberFromHostInstanceForDeletion = createFiberFromHostInstanceForDeletion;
exports.createFiberFromPortal = createFiberFromPortal;
exports.assignFiberPropertiesInDEV = assignFiberPropertiesInDEV;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactFeatureFlags = __webpack_require__(3);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactWorkTags = __webpack_require__(4);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _ReactFiberDevToolsHook = __webpack_require__(39);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactTypeOfMode = __webpack_require__(13);

var _ReactSymbols = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasBadMapPolyfill = void 0;

if (true) {
  hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    var testMap = new Map([[nonExtensibleObject, null]]);
    var testSet = new Set([nonExtensibleObject]);
    // This is necessary for Rollup to not consider these unused.
    // https://github.com/rollup/rollup/issues/1771
    // TODO: we can remove these if Rollup fixes the bug.
    testMap.set(0, 0);
    testSet.add(0);
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


var debugCounter = void 0;

if (true) {
  debugCounter = 1;
}

function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.contextDependencies = null;

  this.mode = mode;

  // Effects
  this.effectTag = _ReactSideEffectTags.NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = _ReactFiberExpirationTime.NoWork;
  this.childExpirationTime = _ReactFiberExpirationTime.NoWork;

  this.alternate = null;

  if (_ReactFeatureFlags.enableProfilerTimer) {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN;

    // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).
    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  if (true) {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function createFiber(tag, pendingProps, key, mode) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function isSimpleFunctionComponent(type) {
  return typeof type === 'function' && !shouldConstruct(type) && type.defaultProps === undefined;
}

function resolveLazyComponentTag(Component) {
  if (typeof Component === 'function') {
    return shouldConstruct(Component) ? _ReactWorkTags.ClassComponent : _ReactWorkTags.FunctionComponent;
  } else if (Component !== undefined && Component !== null) {
    var $$typeof = Component.$$typeof;
    if ($$typeof === _ReactSymbols.REACT_FORWARD_REF_TYPE) {
      return _ReactWorkTags.ForwardRef;
    }
    if ($$typeof === _ReactSymbols.REACT_MEMO_TYPE) {
      return _ReactWorkTags.MemoComponent;
    }
  }
  return _ReactWorkTags.IndeterminateComponent;
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    if (true) {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;

    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = _ReactSideEffectTags.NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    if (_ReactFeatureFlags.enableProfilerTimer) {
      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
      // This prevents time from endlessly accumulating in new commits.
      // This has the downside of resetting values for different priority renders,
      // But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.childExpirationTime = current.childExpirationTime;
  workInProgress.expirationTime = current.expirationTime;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.contextDependencies = current.contextDependencies;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  if (_ReactFeatureFlags.enableProfilerTimer) {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  return workInProgress;
}

function createHostRootFiber(isConcurrent) {
  var mode = isConcurrent ? _ReactTypeOfMode.ConcurrentMode | _ReactTypeOfMode.StrictMode : _ReactTypeOfMode.NoContext;

  if (_ReactFeatureFlags.enableProfilerTimer && _ReactFiberDevToolsHook.isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any point
    // Without some nodes in the tree having empty base times.
    mode |= _ReactTypeOfMode.ProfileMode;
  }

  return createFiber(_ReactWorkTags.HostRoot, null, null, mode);
}

function createFiberFromTypeAndProps(type, // React$ElementType
key, pendingProps, owner, mode, expirationTime) {
  var fiber = void 0;

  var fiberTag = _ReactWorkTags.IndeterminateComponent;
  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
  var resolvedType = type;
  if (typeof type === 'function') {
    if (shouldConstruct(type)) {
      fiberTag = _ReactWorkTags.ClassComponent;
    }
  } else if (typeof type === 'string') {
    fiberTag = _ReactWorkTags.HostComponent;
  } else {
    getTag: switch (type) {
      case _ReactSymbols.REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);
      case _ReactSymbols.REACT_CONCURRENT_MODE_TYPE:
        return createFiberFromMode(pendingProps, mode | _ReactTypeOfMode.ConcurrentMode | _ReactTypeOfMode.StrictMode, expirationTime, key);
      case _ReactSymbols.REACT_STRICT_MODE_TYPE:
        return createFiberFromMode(pendingProps, mode | _ReactTypeOfMode.StrictMode, expirationTime, key);
      case _ReactSymbols.REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
      case _ReactSymbols.REACT_SUSPENSE_TYPE:
        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
      default:
        {
          if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null) {
            switch (type.$$typeof) {
              case _ReactSymbols.REACT_PROVIDER_TYPE:
                fiberTag = _ReactWorkTags.ContextProvider;
                break getTag;
              case _ReactSymbols.REACT_CONTEXT_TYPE:
                // This is a consumer
                fiberTag = _ReactWorkTags.ContextConsumer;
                break getTag;
              case _ReactSymbols.REACT_FORWARD_REF_TYPE:
                fiberTag = _ReactWorkTags.ForwardRef;
                break getTag;
              case _ReactSymbols.REACT_MEMO_TYPE:
                fiberTag = _ReactWorkTags.MemoComponent;
                break getTag;
              case _ReactSymbols.REACT_LAZY_TYPE:
                fiberTag = _ReactWorkTags.LazyComponent;
                resolvedType = null;
                break getTag;
            }
          }
          var info = '';
          if (true) {
            if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
            }
            var ownerName = owner ? (0, _getComponentName2.default)(owner.type) : null;
            if (ownerName) {
              info += '\n\nCheck the render method of `' + ownerName + '`.';
            }
          }
          (0, _invariant2.default)(false, 'Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + 'but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);
        }
    }
  }

  fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromElement(element, mode, expirationTime) {
  var owner = null;
  if (true) {
    owner = element._owner;
  }
  var type = element.type;
  var key = element.key;
  var pendingProps = element.props;
  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
  if (true) {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }
  return fiber;
}

function createFiberFromFragment(elements, mode, expirationTime, key) {
  var fiber = createFiber(_ReactWorkTags.Fragment, elements, key, mode);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
  if (true) {
    if (typeof pendingProps.id !== 'string' || typeof pendingProps.onRender !== 'function') {
      (0, _warningWithoutStack2.default)(false, 'Profiler must specify an "id" string and "onRender" function as props');
    }
  }

  var fiber = createFiber(_ReactWorkTags.Profiler, pendingProps, key, mode | _ReactTypeOfMode.ProfileMode);
  // TODO: The Profiler fiber shouldn't have a type. It has a tag.
  fiber.elementType = _ReactSymbols.REACT_PROFILER_TYPE;
  fiber.type = _ReactSymbols.REACT_PROFILER_TYPE;
  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromMode(pendingProps, mode, expirationTime, key) {
  var fiber = createFiber(_ReactWorkTags.Mode, pendingProps, key, mode);

  // TODO: The Mode fiber shouldn't have a type. It has a tag.
  var type = (mode & _ReactTypeOfMode.ConcurrentMode) === _ReactTypeOfMode.NoContext ? _ReactSymbols.REACT_STRICT_MODE_TYPE : _ReactSymbols.REACT_CONCURRENT_MODE_TYPE;
  fiber.elementType = type;
  fiber.type = type;

  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
  var fiber = createFiber(_ReactWorkTags.SuspenseComponent, pendingProps, key, mode);

  // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
  var type = _ReactSymbols.REACT_SUSPENSE_TYPE;
  fiber.elementType = type;
  fiber.type = type;

  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, mode, expirationTime) {
  var fiber = createFiber(_ReactWorkTags.HostText, content, null, mode);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(_ReactWorkTags.HostComponent, null, null, _ReactTypeOfMode.NoContext);
  // TODO: These should not need a type.
  fiber.elementType = 'DELETED';
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromPortal(portal, mode, expirationTime) {
  var pendingProps = portal.children !== null ? portal.children : [];
  var fiber = createFiber(_ReactWorkTags.HostPortal, pendingProps, portal.key, mode);
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

// Used for stashing WIP properties to replay failed work in DEV.
function assignFiberPropertiesInDEV(target, source) {
  if (target === null) {
    // This Fiber's initial properties will always be overwritten.
    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
    target = createFiber(_ReactWorkTags.IndeterminateComponent, null, null, _ReactTypeOfMode.NoContext);
  }

  // This is intentionally written as a list of all properties.
  // We tried to use Object.assign() instead but this is called in
  // the hottest path, and Object.assign() was too slow:
  // https://github.com/facebook/react/issues/12502
  // This code is DEV-only so size is not a concern.

  target.tag = source.tag;
  target.key = source.key;
  target.elementType = source.elementType;
  target.type = source.type;
  target.stateNode = source.stateNode;
  target.return = source.return;
  target.child = source.child;
  target.sibling = source.sibling;
  target.index = source.index;
  target.ref = source.ref;
  target.pendingProps = source.pendingProps;
  target.memoizedProps = source.memoizedProps;
  target.updateQueue = source.updateQueue;
  target.memoizedState = source.memoizedState;
  target.contextDependencies = source.contextDependencies;
  target.mode = source.mode;
  target.effectTag = source.effectTag;
  target.nextEffect = source.nextEffect;
  target.firstEffect = source.firstEffect;
  target.lastEffect = source.lastEffect;
  target.expirationTime = source.expirationTime;
  target.childExpirationTime = source.childExpirationTime;
  target.alternate = source.alternate;
  if (_ReactFeatureFlags.enableProfilerTimer) {
    target.actualDuration = source.actualDuration;
    target.actualStartTime = source.actualStartTime;
    target.selfBaseDuration = source.selfBaseDuration;
    target.treeBaseDuration = source.treeBaseDuration;
  }
  target._debugID = source._debugID;
  target._debugSource = source._debugSource;
  target._debugOwner = source._debugOwner;
  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
  return target;
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flushPassiveEffects = exports.computeUniqueAsyncExpiration = exports.flushInteractiveUpdates = exports.interactiveUpdates = exports.syncUpdates = exports.deferredUpdates = exports.flushControlled = exports.flushSync = exports.unbatchedUpdates = exports.batchedUpdates = exports.flushRoot = exports.requestWork = exports.scheduleWork = exports.isAlreadyFailedLegacyErrorBoundary = exports.markLegacyErrorBoundaryAsFailed = exports.retryTimedOutBoundary = exports.pingSuspendedRoot = exports.renderDidError = exports.renderDidSuspend = exports.onUncaughtError = exports.captureCommitPhaseError = exports.computeExpirationForFiber = exports.requestCurrentTime = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.warnIfNotCurrentlyBatchingInDev = warnIfNotCurrentlyBatchingInDev;

var _tracing = __webpack_require__(23);

var _scheduler = __webpack_require__(62);

var _ReactErrorUtils = __webpack_require__(34);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _ReactStrictModeWarnings = __webpack_require__(56);

var _ReactStrictModeWarnings2 = _interopRequireDefault(_ReactStrictModeWarnings);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactWorkTags = __webpack_require__(4);

var _ReactFeatureFlags = __webpack_require__(3);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactFiberInstrumentation = __webpack_require__(79);

var _ReactFiberInstrumentation2 = _interopRequireDefault(_ReactFiberInstrumentation);

var _ReactCurrentFiber = __webpack_require__(7);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiberPendingPriority = __webpack_require__(80);

var _ReactDebugFiberPerf = __webpack_require__(29);

var _ReactFiber = __webpack_require__(30);

var _ReactFiberDevToolsHook = __webpack_require__(39);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactTypeOfMode = __webpack_require__(13);

var _ReactUpdateQueue = __webpack_require__(18);

var _ReactCapturedValue = __webpack_require__(85);

var _ReactFiberContext = __webpack_require__(21);

var _ReactFiberNewContext = __webpack_require__(19);

var _ReactFiberHooks = __webpack_require__(82);

var _ReactFiberHostContext = __webpack_require__(41);

var _ReactProfilerTimer = __webpack_require__(58);

var _ReactFiberStack = __webpack_require__(38);

var _ReactFiberBeginWork = __webpack_require__(40);

var _ReactFiberCompleteWork = __webpack_require__(142);

var _ReactFiberUnwindWork = __webpack_require__(143);

var _ReactFiberCommitWork = __webpack_require__(86);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ReactCurrentDispatcher = _ReactSharedInternals2.default.ReactCurrentDispatcher,
    ReactCurrentOwner = _ReactSharedInternals2.default.ReactCurrentOwner;


var didWarnAboutStateTransition = void 0;
var didWarnSetStateChildContext = void 0;
var warnAboutUpdateOnUnmounted = void 0;
var warnAboutInvalidUpdates = void 0;

if (_ReactFeatureFlags.enableSchedulerTracing) {
  // Provide explicit error message when production+profiling bundle of e.g. react-dom
  // is used with production (non-profiling) bundle of scheduler/tracing
  (0, _invariant2.default)(_tracing.__interactionsRef != null && _tracing.__interactionsRef.current != null, 'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) ' + 'without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. ' + 'Your bundler might have a setting for aliasing both modules. ' + 'Learn more at http://fb.me/react-profiling');
}

if (true) {
  didWarnAboutStateTransition = false;
  didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber, isClass) {
    // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.
    var componentName = (0, _getComponentName2.default)(fiber.type) || 'ReactComponent';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    (0, _warningWithoutStack2.default)(false, "Can't perform a React state update on an unmounted component. This " + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.%s', isClass ? 'the componentWillUnmount method' : 'a useEffect cleanup function', (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(fiber));
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
    switch (_ReactCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        (0, _warningWithoutStack2.default)(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        (0, _warningWithoutStack2.default)(false, 'Cannot update during an existing state transition (such as within ' + '`render`). Render methods should be a pure function of props and state.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

// Used to ensure computeUniqueAsyncExpiration is monotonically decreasing.
var lastUniqueAsyncExpiration = _ReactFiberExpirationTime.Sync - 1;

var isWorking = false;

// The next work in progress fiber that we're currently working on.
var nextUnitOfWork = null;
var nextRoot = null;
// The time at which we're currently rendering work.
var nextRenderExpirationTime = _ReactFiberExpirationTime.NoWork;
var nextLatestAbsoluteTimeoutMs = -1;
var nextRenderDidError = false;

// The next fiber with an effect that we're currently committing.
var nextEffect = null;

var isCommitting = false;
var rootWithPendingPassiveEffects = null;
var passiveEffectCallbackHandle = null;
var passiveEffectCallback = null;

var legacyErrorBoundariesThatAlreadyFailed = null;

// Used for performance tracking.
var interruptedBy = null;

var stashedWorkInProgressProperties = void 0;
var replayUnitOfWork = void 0;
var mayReplayFailedUnitOfWork = void 0;
var isReplayingFailedUnitOfWork = void 0;
var originalReplayError = void 0;
var rethrowOriginalError = void 0;
if (true && _ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback) {
  stashedWorkInProgressProperties = null;
  mayReplayFailedUnitOfWork = true;
  isReplayingFailedUnitOfWork = false;
  originalReplayError = null;
  replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {
    if (thrownValue !== null && (typeof thrownValue === 'undefined' ? 'undefined' : _typeof(thrownValue)) === 'object' && typeof thrownValue.then === 'function') {
      // Don't replay promises. Treat everything else like an error.
      // TODO: Need to figure out a different strategy if/when we add
      // support for catching other types.
      return;
    }

    // Restore the original state of the work-in-progress
    if (stashedWorkInProgressProperties === null) {
      // This should never happen. Don't throw because this code is DEV-only.
      (0, _warningWithoutStack2.default)(false, 'Could not replay rendering after an error. This is likely a bug in React. ' + 'Please file an issue.');
      return;
    }
    (0, _ReactFiber.assignFiberPropertiesInDEV)(failedUnitOfWork, stashedWorkInProgressProperties);

    switch (failedUnitOfWork.tag) {
      case _ReactWorkTags.HostRoot:
        (0, _ReactFiberHostContext.popHostContainer)(failedUnitOfWork);
        (0, _ReactFiberContext.popTopLevelContextObject)(failedUnitOfWork);
        break;
      case _ReactWorkTags.HostComponent:
        (0, _ReactFiberHostContext.popHostContext)(failedUnitOfWork);
        break;
      case _ReactWorkTags.ClassComponent:
        {
          var Component = failedUnitOfWork.type;
          if ((0, _ReactFiberContext.isContextProvider)(Component)) {
            (0, _ReactFiberContext.popContext)(failedUnitOfWork);
          }
          break;
        }
      case _ReactWorkTags.HostPortal:
        (0, _ReactFiberHostContext.popHostContainer)(failedUnitOfWork);
        break;
      case _ReactWorkTags.ContextProvider:
        (0, _ReactFiberNewContext.popProvider)(failedUnitOfWork);
        break;
    }
    // Replay the begin phase.
    isReplayingFailedUnitOfWork = true;
    originalReplayError = thrownValue;
    (0, _ReactErrorUtils.invokeGuardedCallback)(null, workLoop, null, isYieldy);
    isReplayingFailedUnitOfWork = false;
    originalReplayError = null;
    if ((0, _ReactErrorUtils.hasCaughtError)()) {
      var replayError = (0, _ReactErrorUtils.clearCaughtError)();
      if (replayError != null && thrownValue != null) {
        try {
          // Reading the expando property is intentionally
          // inside `try` because it might be a getter or Proxy.
          if (replayError._suppressLogging) {
            // Also suppress logging for the original error.
            thrownValue._suppressLogging = true;
          }
        } catch (inner) {
          // Ignore.
        }
      }
    } else {
      // If the begin phase did not fail the second time, set this pointer
      // back to the original value.
      nextUnitOfWork = failedUnitOfWork;
    }
  };
  rethrowOriginalError = function rethrowOriginalError() {
    throw originalReplayError;
  };
}

function resetStack() {
  if (nextUnitOfWork !== null) {
    var interruptedWork = nextUnitOfWork.return;
    while (interruptedWork !== null) {
      (0, _ReactFiberUnwindWork.unwindInterruptedWork)(interruptedWork);
      interruptedWork = interruptedWork.return;
    }
  }

  if (true) {
    _ReactStrictModeWarnings2.default.discardPendingWarnings();
    (0, _ReactFiberStack.checkThatStackIsEmpty)();
  }

  nextRoot = null;
  nextRenderExpirationTime = _ReactFiberExpirationTime.NoWork;
  nextLatestAbsoluteTimeoutMs = -1;
  nextRenderDidError = false;
  nextUnitOfWork = null;
}

function commitAllHostEffects() {
  while (nextEffect !== null) {
    if (true) {
      (0, _ReactCurrentFiber.setCurrentFiber)(nextEffect);
    }
    (0, _ReactDebugFiberPerf.recordEffect)();

    var effectTag = nextEffect.effectTag;

    if (effectTag & _ReactSideEffectTags.ContentReset) {
      (0, _ReactFiberCommitWork.commitResetTextContent)(nextEffect);
    }

    if (effectTag & _ReactSideEffectTags.Ref) {
      var current = nextEffect.alternate;
      if (current !== null) {
        (0, _ReactFiberCommitWork.commitDetachRef)(current);
      }
    }

    // The following switch statement is only concerned about placement,
    // updates, and deletions. To avoid needing to add a case for every
    // possible bitmap value, we remove the secondary effects from the
    // effect tag and switch on that value.
    var primaryEffectTag = effectTag & (_ReactSideEffectTags.Placement | _ReactSideEffectTags.Update | _ReactSideEffectTags.Deletion);
    switch (primaryEffectTag) {
      case _ReactSideEffectTags.Placement:
        {
          (0, _ReactFiberCommitWork.commitPlacement)(nextEffect);
          // Clear the "placement" from effect tag so that we know that this is inserted, before
          // any life-cycles like componentDidMount gets called.
          // TODO: findDOMNode doesn't rely on this any more but isMounted
          // does and isMounted is deprecated anyway so we should be able
          // to kill this.
          nextEffect.effectTag &= ~_ReactSideEffectTags.Placement;
          break;
        }
      case _ReactSideEffectTags.PlacementAndUpdate:
        {
          // Placement
          (0, _ReactFiberCommitWork.commitPlacement)(nextEffect);
          // Clear the "placement" from effect tag so that we know that this is inserted, before
          // any life-cycles like componentDidMount gets called.
          nextEffect.effectTag &= ~_ReactSideEffectTags.Placement;

          // Update
          var _current = nextEffect.alternate;
          (0, _ReactFiberCommitWork.commitWork)(_current, nextEffect);
          break;
        }
      case _ReactSideEffectTags.Update:
        {
          var _current2 = nextEffect.alternate;
          (0, _ReactFiberCommitWork.commitWork)(_current2, nextEffect);
          break;
        }
      case _ReactSideEffectTags.Deletion:
        {
          (0, _ReactFiberCommitWork.commitDeletion)(nextEffect);
          break;
        }
    }
    nextEffect = nextEffect.nextEffect;
  }

  if (true) {
    (0, _ReactCurrentFiber.resetCurrentFiber)();
  }
}

function commitBeforeMutationLifecycles() {
  while (nextEffect !== null) {
    if (true) {
      (0, _ReactCurrentFiber.setCurrentFiber)(nextEffect);
    }

    var effectTag = nextEffect.effectTag;
    if (effectTag & _ReactSideEffectTags.Snapshot) {
      (0, _ReactDebugFiberPerf.recordEffect)();
      var current = nextEffect.alternate;
      (0, _ReactFiberCommitWork.commitBeforeMutationLifeCycles)(current, nextEffect);
    }

    nextEffect = nextEffect.nextEffect;
  }

  if (true) {
    (0, _ReactCurrentFiber.resetCurrentFiber)();
  }
}

function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
  if (true) {
    _ReactStrictModeWarnings2.default.flushPendingUnsafeLifecycleWarnings();
    _ReactStrictModeWarnings2.default.flushLegacyContextWarning();

    if (_ReactFeatureFlags.warnAboutDeprecatedLifecycles) {
      _ReactStrictModeWarnings2.default.flushPendingDeprecationWarnings();
    }
  }
  while (nextEffect !== null) {
    if (true) {
      (0, _ReactCurrentFiber.setCurrentFiber)(nextEffect);
    }
    var effectTag = nextEffect.effectTag;

    if (effectTag & (_ReactSideEffectTags.Update | _ReactSideEffectTags.Callback)) {
      (0, _ReactDebugFiberPerf.recordEffect)();
      var current = nextEffect.alternate;
      (0, _ReactFiberCommitWork.commitLifeCycles)(finishedRoot, current, nextEffect, committedExpirationTime);
    }

    if (effectTag & _ReactSideEffectTags.Ref) {
      (0, _ReactDebugFiberPerf.recordEffect)();
      (0, _ReactFiberCommitWork.commitAttachRef)(nextEffect);
    }

    if (effectTag & _ReactSideEffectTags.Passive) {
      rootWithPendingPassiveEffects = finishedRoot;
    }

    nextEffect = nextEffect.nextEffect;
  }
  if (true) {
    (0, _ReactCurrentFiber.resetCurrentFiber)();
  }
}

function commitPassiveEffects(root, firstEffect) {
  rootWithPendingPassiveEffects = null;
  passiveEffectCallbackHandle = null;
  passiveEffectCallback = null;

  // Set this to true to prevent re-entrancy
  var previousIsRendering = isRendering;
  isRendering = true;

  var effect = firstEffect;
  do {
    if (true) {
      (0, _ReactCurrentFiber.setCurrentFiber)(effect);
    }

    if (effect.effectTag & _ReactSideEffectTags.Passive) {
      var didError = false;
      var error = void 0;
      if (true) {
        (0, _ReactErrorUtils.invokeGuardedCallback)(null, _ReactFiberCommitWork.commitPassiveHookEffects, null, effect);
        if ((0, _ReactErrorUtils.hasCaughtError)()) {
          didError = true;
          error = (0, _ReactErrorUtils.clearCaughtError)();
        }
      } else {
        try {
          (0, _ReactFiberCommitWork.commitPassiveHookEffects)(effect);
        } catch (e) {
          didError = true;
          error = e;
        }
      }
      if (didError) {
        captureCommitPhaseError(effect, error);
      }
    }
    effect = effect.nextEffect;
  } while (effect !== null);
  if (true) {
    (0, _ReactCurrentFiber.resetCurrentFiber)();
  }

  isRendering = previousIsRendering;

  // Check if work was scheduled by one of the effects
  var rootExpirationTime = root.expirationTime;
  if (rootExpirationTime !== _ReactFiberExpirationTime.NoWork) {
    requestWork(root, rootExpirationTime);
  }
  // Flush any sync work that was scheduled by effects
  if (!isBatchingUpdates && !isRendering) {
    performSyncWork();
  }
}

function isAlreadyFailedLegacyErrorBoundary(instance) {
  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
}

function markLegacyErrorBoundaryAsFailed(instance) {
  if (legacyErrorBoundariesThatAlreadyFailed === null) {
    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
  } else {
    legacyErrorBoundariesThatAlreadyFailed.add(instance);
  }
}

function flushPassiveEffects() {
  if (passiveEffectCallbackHandle !== null) {
    (0, _ReactFiberHostConfig.cancelPassiveEffects)(passiveEffectCallbackHandle);
  }
  if (passiveEffectCallback !== null) {
    // We call the scheduled callback instead of commitPassiveEffects directly
    // to ensure tracing works correctly.
    passiveEffectCallback();
  }
}

function commitRoot(root, finishedWork) {
  isWorking = true;
  isCommitting = true;
  (0, _ReactDebugFiberPerf.startCommitTimer)();

  (0, _invariant2.default)(root.current !== finishedWork, 'Cannot commit the same tree as before. This is probably a bug ' + 'related to the return field. This error is likely caused by a bug ' + 'in React. Please file an issue.');
  var committedExpirationTime = root.pendingCommitExpirationTime;
  (0, _invariant2.default)(committedExpirationTime !== _ReactFiberExpirationTime.NoWork, 'Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');
  root.pendingCommitExpirationTime = _ReactFiberExpirationTime.NoWork;

  // Update the pending priority levels to account for the work that we are
  // about to commit. This needs to happen before calling the lifecycles, since
  // they may schedule additional updates.
  var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
  var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
  var earliestRemainingTimeBeforeCommit = childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
  (0, _ReactFiberPendingPriority.markCommittedPriorityLevels)(root, earliestRemainingTimeBeforeCommit);

  var prevInteractions = null;
  if (_ReactFeatureFlags.enableSchedulerTracing) {
    // Restore any pending interactions at this point,
    // So that cascading work triggered during the render phase will be accounted for.
    prevInteractions = _tracing.__interactionsRef.current;
    _tracing.__interactionsRef.current = root.memoizedInteractions;
  }

  // Reset this to null before calling lifecycles
  ReactCurrentOwner.current = null;

  var firstEffect = void 0;
  if (finishedWork.effectTag > _ReactSideEffectTags.PerformedWork) {
    // A fiber's effect list consists only of its children, not itself. So if
    // the root has an effect, we need to add it to the end of the list. The
    // resulting list is the set that would belong to the root's parent, if
    // it had one; that is, all the effects in the tree including the root.
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  (0, _ReactFiberHostConfig.prepareForCommit)(root.containerInfo);

  // Invoke instances of getSnapshotBeforeUpdate before mutation.
  nextEffect = firstEffect;
  (0, _ReactDebugFiberPerf.startCommitSnapshotEffectsTimer)();
  while (nextEffect !== null) {
    var didError = false;
    var error = void 0;
    if (true) {
      (0, _ReactErrorUtils.invokeGuardedCallback)(null, commitBeforeMutationLifecycles, null);
      if ((0, _ReactErrorUtils.hasCaughtError)()) {
        didError = true;
        error = (0, _ReactErrorUtils.clearCaughtError)();
      }
    } else {
      try {
        commitBeforeMutationLifecycles();
      } catch (e) {
        didError = true;
        error = e;
      }
    }
    if (didError) {
      (0, _invariant2.default)(nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.');
      captureCommitPhaseError(nextEffect, error);
      // Clean-up
      if (nextEffect !== null) {
        nextEffect = nextEffect.nextEffect;
      }
    }
  }
  (0, _ReactDebugFiberPerf.stopCommitSnapshotEffectsTimer)();

  if (_ReactFeatureFlags.enableProfilerTimer) {
    // Mark the current commit time to be shared by all Profilers in this batch.
    // This enables them to be grouped later.
    (0, _ReactProfilerTimer.recordCommitTime)();
  }

  // Commit all the side-effects within a tree. We'll do this in two passes.
  // The first pass performs all the host insertions, updates, deletions and
  // ref unmounts.
  nextEffect = firstEffect;
  (0, _ReactDebugFiberPerf.startCommitHostEffectsTimer)();
  while (nextEffect !== null) {
    var _didError = false;
    var _error = void 0;
    if (true) {
      (0, _ReactErrorUtils.invokeGuardedCallback)(null, commitAllHostEffects, null);
      if ((0, _ReactErrorUtils.hasCaughtError)()) {
        _didError = true;
        _error = (0, _ReactErrorUtils.clearCaughtError)();
      }
    } else {
      try {
        commitAllHostEffects();
      } catch (e) {
        _didError = true;
        _error = e;
      }
    }
    if (_didError) {
      (0, _invariant2.default)(nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.');
      captureCommitPhaseError(nextEffect, _error);
      // Clean-up
      if (nextEffect !== null) {
        nextEffect = nextEffect.nextEffect;
      }
    }
  }
  (0, _ReactDebugFiberPerf.stopCommitHostEffectsTimer)();

  (0, _ReactFiberHostConfig.resetAfterCommit)(root.containerInfo);

  // The work-in-progress tree is now the current tree. This must come after
  // the first pass of the commit phase, so that the previous tree is still
  // current during componentWillUnmount, but before the second pass, so that
  // the finished work is current during componentDidMount/Update.
  root.current = finishedWork;

  // In the second pass we'll perform all life-cycles and ref callbacks.
  // Life-cycles happen as a separate pass so that all placements, updates,
  // and deletions in the entire tree have already been invoked.
  // This pass also triggers any renderer-specific initial effects.
  nextEffect = firstEffect;
  (0, _ReactDebugFiberPerf.startCommitLifeCyclesTimer)();
  while (nextEffect !== null) {
    var _didError2 = false;
    var _error2 = void 0;
    if (true) {
      (0, _ReactErrorUtils.invokeGuardedCallback)(null, commitAllLifeCycles, null, root, committedExpirationTime);
      if ((0, _ReactErrorUtils.hasCaughtError)()) {
        _didError2 = true;
        _error2 = (0, _ReactErrorUtils.clearCaughtError)();
      }
    } else {
      try {
        commitAllLifeCycles(root, committedExpirationTime);
      } catch (e) {
        _didError2 = true;
        _error2 = e;
      }
    }
    if (_didError2) {
      (0, _invariant2.default)(nextEffect !== null, 'Should have next effect. This error is likely caused by a bug ' + 'in React. Please file an issue.');
      captureCommitPhaseError(nextEffect, _error2);
      if (nextEffect !== null) {
        nextEffect = nextEffect.nextEffect;
      }
    }
  }

  if (firstEffect !== null && rootWithPendingPassiveEffects !== null) {
    // This commit included a passive effect. These do not need to fire until
    // after the next paint. Schedule an callback to fire them in an async
    // event. To ensure serial execution, the callback will be flushed early if
    // we enter rootWithPendingPassiveEffects commit phase before then.
    var callback = commitPassiveEffects.bind(null, root, firstEffect);
    if (_ReactFeatureFlags.enableSchedulerTracing) {
      // TODO: Avoid this extra callback by mutating the tracing ref directly,
      // like we do at the beginning of commitRoot. I've opted not to do that
      // here because that code is still in flux.
      callback = (0, _tracing.unstable_wrap)(callback);
    }
    passiveEffectCallbackHandle = (0, _scheduler.unstable_runWithPriority)(_scheduler.unstable_NormalPriority, function () {
      return (0, _ReactFiberHostConfig.schedulePassiveEffects)(callback);
    });
    passiveEffectCallback = callback;
  }

  isCommitting = false;
  isWorking = false;
  (0, _ReactDebugFiberPerf.stopCommitLifeCyclesTimer)();
  (0, _ReactDebugFiberPerf.stopCommitTimer)();
  (0, _ReactFiberDevToolsHook.onCommitRoot)(finishedWork.stateNode);
  if (true && _ReactFiberInstrumentation2.default.debugTool) {
    _ReactFiberInstrumentation2.default.debugTool.onCommitWork(finishedWork);
  }

  var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
  var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
  var earliestRemainingTimeAfterCommit = childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;
  if (earliestRemainingTimeAfterCommit === _ReactFiberExpirationTime.NoWork) {
    // If there's no remaining work, we can clear the set of already failed
    // error boundaries.
    legacyErrorBoundariesThatAlreadyFailed = null;
  }
  onCommit(root, earliestRemainingTimeAfterCommit);

  if (_ReactFeatureFlags.enableSchedulerTracing) {
    _tracing.__interactionsRef.current = prevInteractions;

    var subscriber = void 0;

    try {
      subscriber = _tracing.__subscriberRef.current;
      if (subscriber !== null && root.memoizedInteractions.size > 0) {
        var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
        subscriber.onWorkStopped(root.memoizedInteractions, threadID);
      }
    } catch (error) {
      // It's not safe for commitRoot() to throw.
      // Store the error for now and we'll re-throw in finishRendering().
      if (!hasUnhandledError) {
        hasUnhandledError = true;
        unhandledError = error;
      }
    } finally {
      // Clear completed interactions from the pending Map.
      // Unless the render was suspended or cascading work was scheduled,
      // In which case leave pending interactions until the subsequent render.
      var pendingInteractionMap = root.pendingInteractionMap;
      pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
        // Only decrement the pending interaction count if we're done.
        // If there's still work at the current priority,
        // That indicates that we are waiting for suspense data.
        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
          pendingInteractionMap.delete(scheduledExpirationTime);

          scheduledInteractions.forEach(function (interaction) {
            interaction.__count--;

            if (subscriber !== null && interaction.__count === 0) {
              try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              } catch (error) {
                // It's not safe for commitRoot() to throw.
                // Store the error for now and we'll re-throw in finishRendering().
                if (!hasUnhandledError) {
                  hasUnhandledError = true;
                  unhandledError = error;
                }
              }
            }
          });
        }
      });
    }
  }
}

function resetChildExpirationTime(workInProgress, renderTime) {
  if (renderTime !== _ReactFiberExpirationTime.Never && workInProgress.childExpirationTime === _ReactFiberExpirationTime.Never) {
    // The children of this component are hidden. Don't bubble their
    // expiration times.
    return;
  }

  var newChildExpirationTime = _ReactFiberExpirationTime.NoWork;

  // Bubble up the earliest expiration time.
  if (_ReactFeatureFlags.enableProfilerTimer && workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
    // We're in profiling mode.
    // Let's use this same traversal to update the render durations.
    var actualDuration = workInProgress.actualDuration;
    var treeBaseDuration = workInProgress.selfBaseDuration;

    // When a fiber is cloned, its actualDuration is reset to 0.
    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).
    // When work is done, it should bubble to the parent's actualDuration.
    // If the fiber has not been cloned though, (meaning no work was done),
    // Then this value will reflect the amount of time spent working on a previous render.
    // In that case it should not bubble.
    // We determine whether it was cloned by comparing the child pointer.
    var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;

    var child = workInProgress.child;
    while (child !== null) {
      var childUpdateExpirationTime = child.expirationTime;
      var childChildExpirationTime = child.childExpirationTime;
      if (childUpdateExpirationTime > newChildExpirationTime) {
        newChildExpirationTime = childUpdateExpirationTime;
      }
      if (childChildExpirationTime > newChildExpirationTime) {
        newChildExpirationTime = childChildExpirationTime;
      }
      if (shouldBubbleActualDurations) {
        actualDuration += child.actualDuration;
      }
      treeBaseDuration += child.treeBaseDuration;
      child = child.sibling;
    }
    workInProgress.actualDuration = actualDuration;
    workInProgress.treeBaseDuration = treeBaseDuration;
  } else {
    var _child = workInProgress.child;
    while (_child !== null) {
      var _childUpdateExpirationTime = _child.expirationTime;
      var _childChildExpirationTime = _child.childExpirationTime;
      if (_childUpdateExpirationTime > newChildExpirationTime) {
        newChildExpirationTime = _childUpdateExpirationTime;
      }
      if (_childChildExpirationTime > newChildExpirationTime) {
        newChildExpirationTime = _childChildExpirationTime;
      }
      _child = _child.sibling;
    }
  }

  workInProgress.childExpirationTime = newChildExpirationTime;
}

function completeUnitOfWork(workInProgress) {
  // Attempt to complete the current unit of work, then move to the
  // next sibling. If there are no more siblings, return to the
  // parent fiber.
  while (true) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;
    if (true) {
      (0, _ReactCurrentFiber.setCurrentFiber)(workInProgress);
    }

    var returnFiber = workInProgress.return;
    var siblingFiber = workInProgress.sibling;

    if ((workInProgress.effectTag & _ReactSideEffectTags.Incomplete) === _ReactSideEffectTags.NoEffect) {
      if (true && _ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        // Don't replay if it fails during completion phase.
        mayReplayFailedUnitOfWork = false;
      }
      // This fiber completed.
      // Remember we're completing this unit so we can find a boundary if it fails.
      nextUnitOfWork = workInProgress;
      if (_ReactFeatureFlags.enableProfilerTimer) {
        if (workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
          (0, _ReactProfilerTimer.startProfilerTimer)(workInProgress);
        }
        nextUnitOfWork = (0, _ReactFiberCompleteWork.completeWork)(current, workInProgress, nextRenderExpirationTime);
        if (workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
          // Update render duration assuming we didn't error.
          (0, _ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta)(workInProgress, false);
        }
      } else {
        nextUnitOfWork = (0, _ReactFiberCompleteWork.completeWork)(current, workInProgress, nextRenderExpirationTime);
      }
      if (true && _ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        // We're out of completion phase so replaying is fine now.
        mayReplayFailedUnitOfWork = true;
      }
      (0, _ReactDebugFiberPerf.stopWorkTimer)(workInProgress);
      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
      if (true) {
        (0, _ReactCurrentFiber.resetCurrentFiber)();
      }

      if (nextUnitOfWork !== null) {
        // Completing this fiber spawned new work. Work on that next.
        return nextUnitOfWork;
      }

      if (returnFiber !== null &&
      // Do not append effects to parents if a sibling failed to complete
      (returnFiber.effectTag & _ReactSideEffectTags.Incomplete) === _ReactSideEffectTags.NoEffect) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > _ReactSideEffectTags.PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      if (true && _ReactFiberInstrumentation2.default.debugTool) {
        _ReactFiberInstrumentation2.default.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        return null;
      }
    } else {
      if (_ReactFeatureFlags.enableProfilerTimer && workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
        // Record the render duration for the fiber that errored.
        (0, _ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta)(workInProgress, false);

        // Include the time spent working on failed children before continuing.
        var actualDuration = workInProgress.actualDuration;
        var child = workInProgress.child;
        while (child !== null) {
          actualDuration += child.actualDuration;
          child = child.sibling;
        }
        workInProgress.actualDuration = actualDuration;
      }

      // This fiber did not complete because something threw. Pop values off
      // the stack without entering the complete phase. If this is a boundary,
      // capture values if possible.
      var next = (0, _ReactFiberUnwindWork.unwindWork)(workInProgress, nextRenderExpirationTime);
      // Because this fiber did not complete, don't reset its expiration time.
      if (workInProgress.effectTag & _ReactSideEffectTags.DidCapture) {
        // Restarting an error boundary
        (0, _ReactDebugFiberPerf.stopFailedWorkTimer)(workInProgress);
      } else {
        (0, _ReactDebugFiberPerf.stopWorkTimer)(workInProgress);
      }

      if (true) {
        (0, _ReactCurrentFiber.resetCurrentFiber)();
      }

      if (next !== null) {
        (0, _ReactDebugFiberPerf.stopWorkTimer)(workInProgress);
        if (true && _ReactFiberInstrumentation2.default.debugTool) {
          _ReactFiberInstrumentation2.default.debugTool.onCompleteWork(workInProgress);
        }

        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        // Since we're restarting, remove anything that is not a host effect
        // from the effect tag.
        next.effectTag &= _ReactSideEffectTags.HostEffectMask;
        return next;
      }

      if (returnFiber !== null) {
        // Mark the parent fiber as incomplete and clear its effect list.
        returnFiber.firstEffect = returnFiber.lastEffect = null;
        returnFiber.effectTag |= _ReactSideEffectTags.Incomplete;
      }

      if (true && _ReactFiberInstrumentation2.default.debugTool) {
        _ReactFiberInstrumentation2.default.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        return null;
      }
    }
  }

  // Without this explicit null return Flow complains of invalid return type
  // TODO Remove the above while(true) loop
  // eslint-disable-next-line no-unreachable
  return null;
}

function performUnitOfWork(workInProgress) {
  // The current, flushed, state of this fiber is the alternate.
  // Ideally nothing should rely on this, but relying on it here
  // means that we don't need an additional field on the work in
  // progress.
  var current = workInProgress.alternate;

  // See if beginning this work spawns more work.
  (0, _ReactDebugFiberPerf.startWorkTimer)(workInProgress);
  if (true) {
    (0, _ReactCurrentFiber.setCurrentFiber)(workInProgress);
  }

  if (true && _ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback) {
    stashedWorkInProgressProperties = (0, _ReactFiber.assignFiberPropertiesInDEV)(stashedWorkInProgressProperties, workInProgress);
  }

  var next = void 0;
  if (_ReactFeatureFlags.enableProfilerTimer) {
    if (workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
      (0, _ReactProfilerTimer.startProfilerTimer)(workInProgress);
    }

    next = (0, _ReactFiberBeginWork.beginWork)(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;

    if (workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
      // Record the render duration assuming we didn't bailout (or error).
      (0, _ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta)(workInProgress, true);
    }
  } else {
    next = (0, _ReactFiberBeginWork.beginWork)(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
  }

  if (true) {
    (0, _ReactCurrentFiber.resetCurrentFiber)();
    if (isReplayingFailedUnitOfWork) {
      // Currently replaying a failed unit of work. This should be unreachable,
      // because the render phase is meant to be idempotent, and it should
      // have thrown again. Since it didn't, rethrow the original error, so
      // React's internal stack is not misaligned.
      rethrowOriginalError();
    }
  }
  if (true && _ReactFiberInstrumentation2.default.debugTool) {
    _ReactFiberInstrumentation2.default.debugTool.onBeginWork(workInProgress);
  }

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    next = completeUnitOfWork(workInProgress);
  }

  ReactCurrentOwner.current = null;

  return next;
}

function workLoop(isYieldy) {
  if (!isYieldy) {
    // Flush work without yielding
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    // Flush asynchronous work until there's a higher priority event
    while (nextUnitOfWork !== null && !shouldYieldToRenderer()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}

function renderRoot(root, isYieldy) {
  (0, _invariant2.default)(!isWorking, 'renderRoot was called recursively. This error is likely caused ' + 'by a bug in React. Please file an issue.');

  flushPassiveEffects();

  isWorking = true;
  var previousDispatcher = ReactCurrentDispatcher.current;
  ReactCurrentDispatcher.current = _ReactFiberHooks.ContextOnlyDispatcher;

  var expirationTime = root.nextExpirationTimeToWorkOn;

  // Check if we're starting from a fresh stack, or if we're resuming from
  // previously yielded work.
  if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
    // Reset the stack and start working from the root.
    resetStack();
    nextRoot = root;
    nextRenderExpirationTime = expirationTime;
    nextUnitOfWork = (0, _ReactFiber.createWorkInProgress)(nextRoot.current, null, nextRenderExpirationTime);
    root.pendingCommitExpirationTime = _ReactFiberExpirationTime.NoWork;

    if (_ReactFeatureFlags.enableSchedulerTracing) {
      // Determine which interactions this batch of work currently includes,
      // So that we can accurately attribute time spent working on it,
      var interactions = new Set();
      root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
        if (scheduledExpirationTime >= expirationTime) {
          scheduledInteractions.forEach(function (interaction) {
            return interactions.add(interaction);
          });
        }
      });

      // Store the current set of interactions on the FiberRoot for a few reasons:
      // We can re-use it in hot functions like renderRoot() without having to recalculate it.
      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.
      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.
      root.memoizedInteractions = interactions;

      if (interactions.size > 0) {
        var subscriber = _tracing.__subscriberRef.current;
        if (subscriber !== null) {
          var threadID = computeThreadID(expirationTime, root.interactionThreadID);
          try {
            subscriber.onWorkStarted(interactions, threadID);
          } catch (error) {
            // Work thrown by an interaction tracing subscriber should be rethrown,
            // But only once it's safe (to avoid leaving the scheduler in an invalid state).
            // Store the error for now and we'll re-throw in finishRendering().
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          }
        }
      }
    }
  }

  var prevInteractions = null;
  if (_ReactFeatureFlags.enableSchedulerTracing) {
    // We're about to start new traced work.
    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.
    prevInteractions = _tracing.__interactionsRef.current;
    _tracing.__interactionsRef.current = root.memoizedInteractions;
  }

  var didFatal = false;

  (0, _ReactDebugFiberPerf.startWorkLoopTimer)(nextUnitOfWork);

  do {
    try {
      workLoop(isYieldy);
    } catch (thrownValue) {
      (0, _ReactFiberNewContext.resetContextDependences)();
      (0, _ReactFiberHooks.resetHooks)();

      // Reset in case completion throws.
      // This is only used in DEV and when replaying is on.
      var mayReplay = void 0;
      if (true && _ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        mayReplay = mayReplayFailedUnitOfWork;
        mayReplayFailedUnitOfWork = true;
      }

      if (nextUnitOfWork === null) {
        // This is a fatal error.
        didFatal = true;
        onUncaughtError(thrownValue);
      } else {
        if (_ReactFeatureFlags.enableProfilerTimer && nextUnitOfWork.mode & _ReactTypeOfMode.ProfileMode) {
          // Record the time spent rendering before an error was thrown.
          // This avoids inaccurate Profiler durations in the case of a suspended render.
          (0, _ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta)(nextUnitOfWork, true);
        }

        if (true) {
          // Reset global debug state
          // We assume this is defined in DEV
          (0, _ReactUpdateQueue.resetCurrentlyProcessingQueue)();
        }

        if (true && _ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback) {
          if (mayReplay) {
            var failedUnitOfWork = nextUnitOfWork;
            replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
          }
        }

        // TODO: we already know this isn't true in some cases.
        // At least this shows a nicer error message until we figure out the cause.
        // https://github.com/facebook/react/issues/12449#issuecomment-386727431
        (0, _invariant2.default)(nextUnitOfWork !== null, 'Failed to replay rendering after an error. This ' + 'is likely caused by a bug in React. Please file an issue ' + 'with a reproducing case to help us find it.');

        var sourceFiber = nextUnitOfWork;
        var returnFiber = sourceFiber.return;
        if (returnFiber === null) {
          // This is the root. The root could capture its own errors. However,
          // we don't know if it errors before or after we pushed the host
          // context. This information is needed to avoid a stack mismatch.
          // Because we're not sure, treat this as a fatal error. We could track
          // which phase it fails in, but doesn't seem worth it. At least
          // for now.
          didFatal = true;
          onUncaughtError(thrownValue);
        } else {
          (0, _ReactFiberUnwindWork.throwException)(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
          nextUnitOfWork = completeUnitOfWork(sourceFiber);
          continue;
        }
      }
    }
    break;
  } while (true);

  if (_ReactFeatureFlags.enableSchedulerTracing) {
    // Traced work is done for now; restore the previous interactions.
    _tracing.__interactionsRef.current = prevInteractions;
  }

  // We're done performing work. Time to clean up.
  isWorking = false;
  ReactCurrentDispatcher.current = previousDispatcher;
  (0, _ReactFiberNewContext.resetContextDependences)();
  (0, _ReactFiberHooks.resetHooks)();

  // Yield back to main thread.
  if (didFatal) {
    var _didCompleteRoot = false;
    (0, _ReactDebugFiberPerf.stopWorkLoopTimer)(interruptedBy, _didCompleteRoot);
    interruptedBy = null;
    // There was a fatal error.
    if (true) {
      (0, _ReactFiberStack.resetStackAfterFatalErrorInDev)();
    }
    // `nextRoot` points to the in-progress root. A non-null value indicates
    // that we're in the middle of an async render. Set it to null to indicate
    // there's no more work to be done in the current batch.
    nextRoot = null;
    onFatal(root);
    return;
  }

  if (nextUnitOfWork !== null) {
    // There's still remaining async work in this tree, but we ran out of time
    // in the current frame. Yield back to the renderer. Unless we're
    // interrupted by a higher priority update, we'll continue later from where
    // we left off.
    var _didCompleteRoot2 = false;
    (0, _ReactDebugFiberPerf.stopWorkLoopTimer)(interruptedBy, _didCompleteRoot2);
    interruptedBy = null;
    onYield(root);
    return;
  }

  // We completed the whole tree.
  var didCompleteRoot = true;
  (0, _ReactDebugFiberPerf.stopWorkLoopTimer)(interruptedBy, didCompleteRoot);
  var rootWorkInProgress = root.current.alternate;
  (0, _invariant2.default)(rootWorkInProgress !== null, 'Finished root should have a work-in-progress. This error is likely ' + 'caused by a bug in React. Please file an issue.');

  // `nextRoot` points to the in-progress root. A non-null value indicates
  // that we're in the middle of an async render. Set it to null to indicate
  // there's no more work to be done in the current batch.
  nextRoot = null;
  interruptedBy = null;

  if (nextRenderDidError) {
    // There was an error
    if ((0, _ReactFiberPendingPriority.hasLowerPriorityWork)(root, expirationTime)) {
      // There's lower priority work. If so, it may have the effect of fixing
      // the exception that was just thrown. Exit without committing. This is
      // similar to a suspend, but without a timeout because we're not waiting
      // for a promise to resolve. React will restart at the lower
      // priority level.
      (0, _ReactFiberPendingPriority.markSuspendedPriorityLevel)(root, expirationTime);
      var suspendedExpirationTime = expirationTime;
      var rootExpirationTime = root.expirationTime;
      onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1 // Indicates no timeout
      );
      return;
    } else if (
    // There's no lower priority work, but we're rendering asynchronously.
    // Synchronously attempt to render the same level one more time. This is
    // similar to a suspend, but without a timeout because we're not waiting
    // for a promise to resolve.
    !root.didError && isYieldy) {
      root.didError = true;
      var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;
      var _rootExpirationTime = root.expirationTime = _ReactFiberExpirationTime.Sync;
      onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1 // Indicates no timeout
      );
      return;
    }
  }

  if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
    // The tree was suspended.
    var _suspendedExpirationTime2 = expirationTime;
    (0, _ReactFiberPendingPriority.markSuspendedPriorityLevel)(root, _suspendedExpirationTime2);

    // Find the earliest uncommitted expiration time in the tree, including
    // work that is suspended. The timeout threshold cannot be longer than
    // the overall expiration.
    var earliestExpirationTime = (0, _ReactFiberPendingPriority.findEarliestOutstandingPriorityLevel)(root, expirationTime);
    var earliestExpirationTimeMs = (0, _ReactFiberExpirationTime.expirationTimeToMs)(earliestExpirationTime);
    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
    }

    // Subtract the current time from the absolute timeout to get the number
    // of milliseconds until the timeout. In other words, convert an absolute
    // timestamp to a relative time. This is the value that is passed
    // to `setTimeout`.
    var currentTimeMs = (0, _ReactFiberExpirationTime.expirationTimeToMs)(requestCurrentTime());
    var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;

    // TODO: Account for the Just Noticeable Difference

    var _rootExpirationTime2 = root.expirationTime;
    onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
    return;
  }

  // Ready to commit.
  onComplete(root, rootWorkInProgress, expirationTime);
}

function captureCommitPhaseError(sourceFiber, value) {
  var expirationTime = _ReactFiberExpirationTime.Sync;
  var fiber = sourceFiber.return;
  while (fiber !== null) {
    switch (fiber.tag) {
      case _ReactWorkTags.ClassComponent:
        var ctor = fiber.type;
        var instance = fiber.stateNode;
        if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
          var errorInfo = (0, _ReactCapturedValue.createCapturedValue)(value, sourceFiber);
          var update = (0, _ReactFiberUnwindWork.createClassErrorUpdate)(fiber, errorInfo, expirationTime);
          (0, _ReactUpdateQueue.enqueueUpdate)(fiber, update);
          scheduleWork(fiber, expirationTime);
          return;
        }
        break;
      case _ReactWorkTags.HostRoot:
        {
          var _errorInfo = (0, _ReactCapturedValue.createCapturedValue)(value, sourceFiber);
          var _update = (0, _ReactFiberUnwindWork.createRootErrorUpdate)(fiber, _errorInfo, expirationTime);
          (0, _ReactUpdateQueue.enqueueUpdate)(fiber, _update);
          scheduleWork(fiber, expirationTime);
          return;
        }
    }
    fiber = fiber.return;
  }

  if (sourceFiber.tag === _ReactWorkTags.HostRoot) {
    // Error was thrown at the root. There is no parent, so the root
    // itself should capture it.
    var rootFiber = sourceFiber;
    var _errorInfo2 = (0, _ReactCapturedValue.createCapturedValue)(value, rootFiber);
    var _update2 = (0, _ReactFiberUnwindWork.createRootErrorUpdate)(rootFiber, _errorInfo2, expirationTime);
    (0, _ReactUpdateQueue.enqueueUpdate)(rootFiber, _update2);
    scheduleWork(rootFiber, expirationTime);
  }
}

function computeThreadID(expirationTime, interactionThreadID) {
  // Interaction threads are unique per root and expiration time.
  return expirationTime * 1000 + interactionThreadID;
}

// Creates a unique async expiration time.
function computeUniqueAsyncExpiration() {
  var currentTime = requestCurrentTime();
  var result = (0, _ReactFiberExpirationTime.computeAsyncExpiration)(currentTime);
  if (result >= lastUniqueAsyncExpiration) {
    // Since we assume the current time monotonically increases, we only hit
    // this branch when computeUniqueAsyncExpiration is fired multiple times
    // within a 200ms window (or whatever the async bucket size is).
    result = lastUniqueAsyncExpiration - 1;
  }
  lastUniqueAsyncExpiration = result;
  return lastUniqueAsyncExpiration;
}

function computeExpirationForFiber(currentTime, fiber) {
  var priorityLevel = (0, _scheduler.unstable_getCurrentPriorityLevel)();

  var expirationTime = void 0;
  if ((fiber.mode & _ReactTypeOfMode.ConcurrentMode) === _ReactTypeOfMode.NoContext) {
    // Outside of concurrent mode, updates are always synchronous.
    expirationTime = _ReactFiberExpirationTime.Sync;
  } else if (isWorking && !isCommitting) {
    // During render phase, updates expire during as the current render.
    expirationTime = nextRenderExpirationTime;
  } else {
    switch (priorityLevel) {
      case _scheduler.unstable_ImmediatePriority:
        expirationTime = _ReactFiberExpirationTime.Sync;
        break;
      case _scheduler.unstable_UserBlockingPriority:
        expirationTime = (0, _ReactFiberExpirationTime.computeInteractiveExpiration)(currentTime);
        break;
      case _scheduler.unstable_NormalPriority:
        // This is a normal, concurrent update
        expirationTime = (0, _ReactFiberExpirationTime.computeAsyncExpiration)(currentTime);
        break;
      case _scheduler.unstable_LowPriority:
      case _scheduler.unstable_IdlePriority:
        expirationTime = _ReactFiberExpirationTime.Never;
        break;
      default:
        (0, _invariant2.default)(false, 'Unknown priority level. This error is likely caused by a bug in ' + 'React. Please file an issue.');
    }

    // If we're in the middle of rendering a tree, do not update at the same
    // expiration time that is already rendering.
    if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
      expirationTime -= 1;
    }
  }

  // Keep track of the lowest pending interactive expiration time. This
  // allows us to synchronously flush all interactive updates
  // when needed.
  // TODO: Move this to renderer?
  if (priorityLevel === _scheduler.unstable_UserBlockingPriority && (lowestPriorityPendingInteractiveExpirationTime === _ReactFiberExpirationTime.NoWork || expirationTime < lowestPriorityPendingInteractiveExpirationTime)) {
    lowestPriorityPendingInteractiveExpirationTime = expirationTime;
  }

  return expirationTime;
}

function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
  // Schedule the timeout.
  if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
  }
}

function renderDidError() {
  nextRenderDidError = true;
}

function pingSuspendedRoot(root, thenable, pingTime) {
  // A promise that previously suspended React from committing has resolved.
  // If React is still suspended, try again at the previous level (pingTime).

  var pingCache = root.pingCache;
  if (pingCache !== null) {
    // The thenable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    pingCache.delete(thenable);
  }

  if (nextRoot !== null && nextRenderExpirationTime === pingTime) {
    // Received a ping at the same priority level at which we're currently
    // rendering. Restart from the root.
    nextRoot = null;
  } else {
    // Confirm that the root is still suspended at this level. Otherwise exit.
    if ((0, _ReactFiberPendingPriority.isPriorityLevelSuspended)(root, pingTime)) {
      // Ping at the original level
      (0, _ReactFiberPendingPriority.markPingedPriorityLevel)(root, pingTime);
      var rootExpirationTime = root.expirationTime;
      if (rootExpirationTime !== _ReactFiberExpirationTime.NoWork) {
        requestWork(root, rootExpirationTime);
      }
    }
  }
}

function retryTimedOutBoundary(boundaryFiber, thenable) {
  // The boundary fiber (a Suspense component) previously timed out and was
  // rendered in its fallback state. One of the promises that suspended it has
  // resolved, which means at least part of the tree was likely unblocked. Try
  var retryCache = void 0;
  if (_ReactFeatureFlags.enableSuspenseServerRenderer) {
    switch (boundaryFiber.tag) {
      case _ReactWorkTags.SuspenseComponent:
        retryCache = boundaryFiber.stateNode;
        break;
      case _ReactWorkTags.DehydratedSuspenseComponent:
        retryCache = boundaryFiber.memoizedState;
        break;
      default:
        (0, _invariant2.default)(false, 'Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');
    }
  } else {
    retryCache = boundaryFiber.stateNode;
  }
  if (retryCache !== null) {
    // The thenable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    retryCache.delete(thenable);
  }

  var currentTime = requestCurrentTime();
  var retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
  var root = scheduleWorkToRoot(boundaryFiber, retryTime);
  if (root !== null) {
    (0, _ReactFiberPendingPriority.markPendingPriorityLevel)(root, retryTime);
    var rootExpirationTime = root.expirationTime;
    if (rootExpirationTime !== _ReactFiberExpirationTime.NoWork) {
      requestWork(root, rootExpirationTime);
    }
  }
}

function scheduleWorkToRoot(fiber, expirationTime) {
  (0, _ReactDebugFiberPerf.recordScheduleUpdate)();

  if (true) {
    if (fiber.tag === _ReactWorkTags.ClassComponent) {
      var instance = fiber.stateNode;
      warnAboutInvalidUpdates(instance);
    }
  }

  // Update the source fiber's expiration time
  if (fiber.expirationTime < expirationTime) {
    fiber.expirationTime = expirationTime;
  }
  var alternate = fiber.alternate;
  if (alternate !== null && alternate.expirationTime < expirationTime) {
    alternate.expirationTime = expirationTime;
  }
  // Walk the parent path to the root and update the child expiration time.
  var node = fiber.return;
  var root = null;
  if (node === null && fiber.tag === _ReactWorkTags.HostRoot) {
    root = fiber.stateNode;
  } else {
    while (node !== null) {
      alternate = node.alternate;
      if (node.childExpirationTime < expirationTime) {
        node.childExpirationTime = expirationTime;
        if (alternate !== null && alternate.childExpirationTime < expirationTime) {
          alternate.childExpirationTime = expirationTime;
        }
      } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {
        alternate.childExpirationTime = expirationTime;
      }
      if (node.return === null && node.tag === _ReactWorkTags.HostRoot) {
        root = node.stateNode;
        break;
      }
      node = node.return;
    }
  }

  if (_ReactFeatureFlags.enableSchedulerTracing) {
    if (root !== null) {
      var interactions = _tracing.__interactionsRef.current;
      if (interactions.size > 0) {
        var pendingInteractionMap = root.pendingInteractionMap;
        var pendingInteractions = pendingInteractionMap.get(expirationTime);
        if (pendingInteractions != null) {
          interactions.forEach(function (interaction) {
            if (!pendingInteractions.has(interaction)) {
              // Update the pending async work count for previously unscheduled interaction.
              interaction.__count++;
            }

            pendingInteractions.add(interaction);
          });
        } else {
          pendingInteractionMap.set(expirationTime, new Set(interactions));

          // Update the pending async work count for the current interactions.
          interactions.forEach(function (interaction) {
            interaction.__count++;
          });
        }

        var subscriber = _tracing.__subscriberRef.current;
        if (subscriber !== null) {
          var threadID = computeThreadID(expirationTime, root.interactionThreadID);
          subscriber.onWorkScheduled(interactions, threadID);
        }
      }
    }
  }
  return root;
}

function warnIfNotCurrentlyBatchingInDev(fiber) {
  if (true) {
    if (isRendering === false && isBatchingUpdates === false) {
      (0, _warningWithoutStack2.default)(false, 'An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see in the browser." + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', (0, _getComponentName2.default)(fiber.type), (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(fiber));
    }
  }
}

function scheduleWork(fiber, expirationTime) {
  var root = scheduleWorkToRoot(fiber, expirationTime);
  if (root === null) {
    if (true) {
      switch (fiber.tag) {
        case _ReactWorkTags.ClassComponent:
          warnAboutUpdateOnUnmounted(fiber, true);
          break;
        case _ReactWorkTags.FunctionComponent:
        case _ReactWorkTags.ForwardRef:
        case _ReactWorkTags.MemoComponent:
        case _ReactWorkTags.SimpleMemoComponent:
          warnAboutUpdateOnUnmounted(fiber, false);
          break;
      }
    }
    return;
  }

  if (!isWorking && nextRenderExpirationTime !== _ReactFiberExpirationTime.NoWork && expirationTime > nextRenderExpirationTime) {
    // This is an interruption. (Used for performance tracking.)
    interruptedBy = fiber;
    resetStack();
  }
  (0, _ReactFiberPendingPriority.markPendingPriorityLevel)(root, expirationTime);
  if (
  // If we're in the render phase, we don't need to schedule this root
  // for an update, because we'll do it before we exit...
  !isWorking || isCommitting ||
  // ...unless this is a different root than the one we're rendering.
  nextRoot !== root) {
    var rootExpirationTime = root.expirationTime;
    requestWork(root, rootExpirationTime);
  }
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    // Reset this back to zero so subsequent updates don't throw.
    nestedUpdateCount = 0;
    (0, _invariant2.default)(false, 'Maximum update depth exceeded. This can happen when a ' + 'component repeatedly calls setState inside ' + 'componentWillUpdate or componentDidUpdate. React limits ' + 'the number of nested updates to prevent infinite loops.');
  }
}

function syncUpdates(fn, a, b, c, d) {
  return (0, _scheduler.unstable_runWithPriority)(_scheduler.unstable_ImmediatePriority, function () {
    return fn(a, b, c, d);
  });
}

// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.

// Linked-list of roots
var firstScheduledRoot = null;
var lastScheduledRoot = null;

var callbackExpirationTime = _ReactFiberExpirationTime.NoWork;
var callbackID = void 0;
var isRendering = false;
var nextFlushedRoot = null;
var nextFlushedExpirationTime = _ReactFiberExpirationTime.NoWork;
var lowestPriorityPendingInteractiveExpirationTime = _ReactFiberExpirationTime.NoWork;
var hasUnhandledError = false;
var unhandledError = null;

var isBatchingUpdates = false;
var isUnbatchingUpdates = false;

var completedBatches = null;

var originalStartTimeMs = (0, _ReactFiberHostConfig.now)();
var currentRendererTime = (0, _ReactFiberExpirationTime.msToExpirationTime)(originalStartTimeMs);
var currentSchedulerTime = currentRendererTime;

// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT = 50;
var nestedUpdateCount = 0;
var lastCommittedRootDuringThisBatch = null;

function recomputeCurrentRendererTime() {
  var currentTimeMs = (0, _ReactFiberHostConfig.now)() - originalStartTimeMs;
  currentRendererTime = (0, _ReactFiberExpirationTime.msToExpirationTime)(currentTimeMs);
}

function scheduleCallbackWithExpirationTime(root, expirationTime) {
  if (callbackExpirationTime !== _ReactFiberExpirationTime.NoWork) {
    // A callback is already scheduled. Check its expiration time (timeout).
    if (expirationTime < callbackExpirationTime) {
      // Existing callback has sufficient timeout. Exit.
      return;
    } else {
      if (callbackID !== null) {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        (0, _ReactFiberHostConfig.cancelDeferredCallback)(callbackID);
      }
    }
    // The request callback timer is already running. Don't start a new one.
  } else {
    (0, _ReactDebugFiberPerf.startRequestCallbackTimer)();
  }

  callbackExpirationTime = expirationTime;
  var currentMs = (0, _ReactFiberHostConfig.now)() - originalStartTimeMs;
  var expirationTimeMs = (0, _ReactFiberExpirationTime.expirationTimeToMs)(expirationTime);
  var timeout = expirationTimeMs - currentMs;
  callbackID = (0, _ReactFiberHostConfig.scheduleDeferredCallback)(performAsyncWork, { timeout: timeout });
}

// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and
// onYield is called upon exiting. We use these in lieu of returning a tuple.
// I've also chosen not to inline them into renderRoot because these will
// eventually be lifted into the renderer.
function onFatal(root) {
  root.finishedWork = null;
}

function onComplete(root, finishedWork, expirationTime) {
  root.pendingCommitExpirationTime = expirationTime;
  root.finishedWork = finishedWork;
}

function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
  root.expirationTime = rootExpirationTime;
  if (msUntilTimeout === 0 && !shouldYieldToRenderer()) {
    // Don't wait an additional tick. Commit the tree immediately.
    root.pendingCommitExpirationTime = suspendedExpirationTime;
    root.finishedWork = finishedWork;
  } else if (msUntilTimeout > 0) {
    // Wait `msUntilTimeout` milliseconds before committing.
    root.timeoutHandle = (0, _ReactFiberHostConfig.scheduleTimeout)(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
  }
}

function onYield(root) {
  root.finishedWork = null;
}

function onTimeout(root, finishedWork, suspendedExpirationTime) {
  // The root timed out. Commit it.
  root.pendingCommitExpirationTime = suspendedExpirationTime;
  root.finishedWork = finishedWork;
  // Read the current time before entering the commit phase. We can be
  // certain this won't cause tearing related to batching of event updates
  // because we're at the top of a timer event.
  recomputeCurrentRendererTime();
  currentSchedulerTime = currentRendererTime;
  flushRoot(root, suspendedExpirationTime);
}

function onCommit(root, expirationTime) {
  root.expirationTime = expirationTime;
  root.finishedWork = null;
}

function requestCurrentTime() {
  // requestCurrentTime is called by the scheduler to compute an expiration
  // time.
  //
  // Expiration times are computed by adding to the current time (the start
  // time). However, if two updates are scheduled within the same event, we
  // should treat their start times as simultaneous, even if the actual clock
  // time has advanced between the first and second call.

  // In other words, because expiration times determine how updates are batched,
  // we want all updates of like priority that occur within the same event to
  // receive the same expiration time. Otherwise we get tearing.
  //
  // We keep track of two separate times: the current "renderer" time and the
  // current "scheduler" time. The renderer time can be updated whenever; it
  // only exists to minimize the calls performance.now.
  //
  // But the scheduler time can only be updated if there's no pending work, or
  // if we know for certain that we're not in the middle of an event.

  if (isRendering) {
    // We're already rendering. Return the most recently read time.
    return currentSchedulerTime;
  }
  // Check if there's pending work.
  findHighestPriorityRoot();
  if (nextFlushedExpirationTime === _ReactFiberExpirationTime.NoWork || nextFlushedExpirationTime === _ReactFiberExpirationTime.Never) {
    // If there's no pending work, or if the pending work is offscreen, we can
    // read the current time without risk of tearing.
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
    return currentSchedulerTime;
  }
  // There's already pending work. We might be in the middle of a browser
  // event. If we were to read the current time, it could cause multiple updates
  // within the same event to receive different expiration times, leading to
  // tearing. Return the last read time. During the next idle callback, the
  // time will be updated.
  return currentSchedulerTime;
}

// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root, expirationTime) {
  addRootToSchedule(root, expirationTime);
  if (isRendering) {
    // Prevent reentrancy. Remaining work will be scheduled at the end of
    // the currently rendering batch.
    return;
  }

  if (isBatchingUpdates) {
    // Flush work at the end of the batch.
    if (isUnbatchingUpdates) {
      // ...unless we're inside unbatchedUpdates, in which case we should
      // flush it now.
      nextFlushedRoot = root;
      nextFlushedExpirationTime = _ReactFiberExpirationTime.Sync;
      performWorkOnRoot(root, _ReactFiberExpirationTime.Sync, false);
    }
    return;
  }

  // TODO: Get rid of Sync and use current time?
  if (expirationTime === _ReactFiberExpirationTime.Sync) {
    performSyncWork();
  } else {
    scheduleCallbackWithExpirationTime(root, expirationTime);
  }
}

function addRootToSchedule(root, expirationTime) {
  // Add the root to the schedule.
  // Check if this root is already part of the schedule.
  if (root.nextScheduledRoot === null) {
    // This root is not already scheduled. Add it.
    root.expirationTime = expirationTime;
    if (lastScheduledRoot === null) {
      firstScheduledRoot = lastScheduledRoot = root;
      root.nextScheduledRoot = root;
    } else {
      lastScheduledRoot.nextScheduledRoot = root;
      lastScheduledRoot = root;
      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
    }
  } else {
    // This root is already scheduled, but its priority may have increased.
    var remainingExpirationTime = root.expirationTime;
    if (expirationTime > remainingExpirationTime) {
      // Update the priority.
      root.expirationTime = expirationTime;
    }
  }
}

function findHighestPriorityRoot() {
  var highestPriorityWork = _ReactFiberExpirationTime.NoWork;
  var highestPriorityRoot = null;
  if (lastScheduledRoot !== null) {
    var previousScheduledRoot = lastScheduledRoot;
    var root = firstScheduledRoot;
    while (root !== null) {
      var remainingExpirationTime = root.expirationTime;
      if (remainingExpirationTime === _ReactFiberExpirationTime.NoWork) {
        // This root no longer has work. Remove it from the scheduler.

        // TODO: This check is redudant, but Flow is confused by the branch
        // below where we set lastScheduledRoot to null, even though we break
        // from the loop right after.
        (0, _invariant2.default)(previousScheduledRoot !== null && lastScheduledRoot !== null, 'Should have a previous and last root. This error is likely ' + 'caused by a bug in React. Please file an issue.');
        if (root === root.nextScheduledRoot) {
          // This is the only root in the list.
          root.nextScheduledRoot = null;
          firstScheduledRoot = lastScheduledRoot = null;
          break;
        } else if (root === firstScheduledRoot) {
          // This is the first root in the list.
          var next = root.nextScheduledRoot;
          firstScheduledRoot = next;
          lastScheduledRoot.nextScheduledRoot = next;
          root.nextScheduledRoot = null;
        } else if (root === lastScheduledRoot) {
          // This is the last root in the list.
          lastScheduledRoot = previousScheduledRoot;
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          root.nextScheduledRoot = null;
          break;
        } else {
          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
          root.nextScheduledRoot = null;
        }
        root = previousScheduledRoot.nextScheduledRoot;
      } else {
        if (remainingExpirationTime > highestPriorityWork) {
          // Update the priority, if it's higher
          highestPriorityWork = remainingExpirationTime;
          highestPriorityRoot = root;
        }
        if (root === lastScheduledRoot) {
          break;
        }
        if (highestPriorityWork === _ReactFiberExpirationTime.Sync) {
          // Sync is highest priority by definition so
          // we can stop searching.
          break;
        }
        previousScheduledRoot = root;
        root = root.nextScheduledRoot;
      }
    }
  }

  nextFlushedRoot = highestPriorityRoot;
  nextFlushedExpirationTime = highestPriorityWork;
}

// TODO: This wrapper exists because many of the older tests (the ones that use
// flushDeferredPri) rely on the number of times `shouldYield` is called. We
// should get rid of it.
var didYield = false;
function shouldYieldToRenderer() {
  if (didYield) {
    return true;
  }
  if ((0, _ReactFiberHostConfig.shouldYield)()) {
    didYield = true;
    return true;
  }
  return false;
}

function performAsyncWork() {
  try {
    if (!shouldYieldToRenderer()) {
      // The callback timed out. That means at least one update has expired.
      // Iterate through the root schedule. If they contain expired work, set
      // the next render expiration time to the current time. This has the effect
      // of flushing all expired work in a single batch, instead of flushing each
      // level one at a time.
      if (firstScheduledRoot !== null) {
        recomputeCurrentRendererTime();
        var root = firstScheduledRoot;
        do {
          (0, _ReactFiberPendingPriority.didExpireAtExpirationTime)(root, currentRendererTime);
          // The root schedule is circular, so this is never null.
          root = root.nextScheduledRoot;
        } while (root !== firstScheduledRoot);
      }
    }
    performWork(_ReactFiberExpirationTime.NoWork, true);
  } finally {
    didYield = false;
  }
}

function performSyncWork() {
  performWork(_ReactFiberExpirationTime.Sync, false);
}

function performWork(minExpirationTime, isYieldy) {
  // Keep working on roots until there's no more work, or until there's a higher
  // priority event.
  findHighestPriorityRoot();

  if (isYieldy) {
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;

    if (_ReactFeatureFlags.enableUserTimingAPI) {
      var didExpire = nextFlushedExpirationTime > currentRendererTime;
      var timeout = (0, _ReactFiberExpirationTime.expirationTimeToMs)(nextFlushedExpirationTime);
      (0, _ReactDebugFiberPerf.stopRequestCallbackTimer)(didExpire, timeout);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== _ReactFiberExpirationTime.NoWork && minExpirationTime <= nextFlushedExpirationTime && !(didYield && currentRendererTime > nextFlushedExpirationTime)) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime);
      findHighestPriorityRoot();
      recomputeCurrentRendererTime();
      currentSchedulerTime = currentRendererTime;
    }
  } else {
    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== _ReactFiberExpirationTime.NoWork && minExpirationTime <= nextFlushedExpirationTime) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
      findHighestPriorityRoot();
    }
  }

  // We're done flushing work. Either we ran out of time in this callback,
  // or there's no more work left with sufficient priority.

  // If we're inside a callback, set this to false since we just completed it.
  if (isYieldy) {
    callbackExpirationTime = _ReactFiberExpirationTime.NoWork;
    callbackID = null;
  }
  // If there's work left over, schedule a new callback.
  if (nextFlushedExpirationTime !== _ReactFiberExpirationTime.NoWork) {
    scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
  }

  // Clean-up.
  finishRendering();
}

function flushRoot(root, expirationTime) {
  (0, _invariant2.default)(!isRendering, 'work.commit(): Cannot commit while already rendering. This likely ' + 'means you attempted to commit from inside a lifecycle method.');
  // Perform work on root as if the given expiration time is the current time.
  // This has the effect of synchronously flushing all work up to and
  // including the given time.
  nextFlushedRoot = root;
  nextFlushedExpirationTime = expirationTime;
  performWorkOnRoot(root, expirationTime, false);
  // Flush any sync work that was scheduled by lifecycles
  performSyncWork();
}

function finishRendering() {
  nestedUpdateCount = 0;
  lastCommittedRootDuringThisBatch = null;

  if (completedBatches !== null) {
    var batches = completedBatches;
    completedBatches = null;
    for (var i = 0; i < batches.length; i++) {
      var batch = batches[i];
      try {
        batch._onComplete();
      } catch (error) {
        if (!hasUnhandledError) {
          hasUnhandledError = true;
          unhandledError = error;
        }
      }
    }
  }

  if (hasUnhandledError) {
    var error = unhandledError;
    unhandledError = null;
    hasUnhandledError = false;
    throw error;
  }
}

function performWorkOnRoot(root, expirationTime, isYieldy) {
  (0, _invariant2.default)(!isRendering, 'performWorkOnRoot was called recursively. This error is likely caused ' + 'by a bug in React. Please file an issue.');

  isRendering = true;

  // Check if this is async work or sync/expired work.
  if (!isYieldy) {
    // Flush work without yielding.
    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer
    // may want to perform some work without yielding, but also without
    // requiring the root to complete (by triggering placeholders).

    var finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      // This root is already complete. We can commit it.
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      // If this root previously suspended, clear its existing timeout, since
      // we're about to try rendering again.
      var timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== _ReactFiberHostConfig.noTimeout) {
        root.timeoutHandle = _ReactFiberHostConfig.noTimeout;
        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
        (0, _ReactFiberHostConfig.cancelTimeout)(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // We've completed the root. Commit it.
        completeRoot(root, finishedWork, expirationTime);
      }
    }
  } else {
    // Flush async work.
    var _finishedWork = root.finishedWork;
    if (_finishedWork !== null) {
      // This root is already complete. We can commit it.
      completeRoot(root, _finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      // If this root previously suspended, clear its existing timeout, since
      // we're about to try rendering again.
      var _timeoutHandle = root.timeoutHandle;
      if (_timeoutHandle !== _ReactFiberHostConfig.noTimeout) {
        root.timeoutHandle = _ReactFiberHostConfig.noTimeout;
        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
        (0, _ReactFiberHostConfig.cancelTimeout)(_timeoutHandle);
      }
      renderRoot(root, isYieldy);
      _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // We've completed the root. Check the if we should yield one more time
        // before committing.
        if (!shouldYieldToRenderer()) {
          // Still time left. Commit the root.
          completeRoot(root, _finishedWork, expirationTime);
        } else {
          // There's no time left. Mark this root as complete. We'll come
          // back and commit it later.
          root.finishedWork = _finishedWork;
        }
      }
    }
  }

  isRendering = false;
}

function completeRoot(root, finishedWork, expirationTime) {
  // Check if there's a batch that matches this expiration time.
  var firstBatch = root.firstBatch;
  if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
    if (completedBatches === null) {
      completedBatches = [firstBatch];
    } else {
      completedBatches.push(firstBatch);
    }
    if (firstBatch._defer) {
      // This root is blocked from committing by a batch. Unschedule it until
      // we receive another update.
      root.finishedWork = finishedWork;
      root.expirationTime = _ReactFiberExpirationTime.NoWork;
      return;
    }
  }

  // Commit the root.
  root.finishedWork = null;

  // Check if this is a nested update (a sync update scheduled during the
  // commit phase).
  if (root === lastCommittedRootDuringThisBatch) {
    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    nestedUpdateCount++;
  } else {
    // Reset whenever we switch roots.
    lastCommittedRootDuringThisBatch = root;
    nestedUpdateCount = 0;
  }
  (0, _scheduler.unstable_runWithPriority)(_scheduler.unstable_ImmediatePriority, function () {
    commitRoot(root, finishedWork);
  });
}

function onUncaughtError(error) {
  (0, _invariant2.default)(nextFlushedRoot !== null, 'Should be working on a root. This error is likely caused by a bug in ' + 'React. Please file an issue.');
  // Unschedule this root so we don't work on it again until there's
  // another update.
  nextFlushedRoot.expirationTime = _ReactFiberExpirationTime.NoWork;
  if (!hasUnhandledError) {
    hasUnhandledError = true;
    unhandledError = error;
  }
}

// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn, a) {
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    return fn(a);
  } finally {
    isBatchingUpdates = previousIsBatchingUpdates;
    if (!isBatchingUpdates && !isRendering) {
      performSyncWork();
    }
  }
}

// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn, a) {
  if (isBatchingUpdates && !isUnbatchingUpdates) {
    isUnbatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isUnbatchingUpdates = false;
    }
  }
  return fn(a);
}

// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn, a) {
  (0, _invariant2.default)(!isRendering, 'flushSync was called from inside a lifecycle method. It cannot be ' + 'called when React is already rendering.');
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    return syncUpdates(fn, a);
  } finally {
    isBatchingUpdates = previousIsBatchingUpdates;
    performSyncWork();
  }
}

function interactiveUpdates(fn, a, b) {
  // If there are any pending interactive updates, synchronously flush them.
  // This needs to happen before we read any handlers, because the effect of
  // the previous event may influence which handlers are called during
  // this event.
  if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== _ReactFiberExpirationTime.NoWork) {
    // Synchronously flush pending interactive updates.
    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
    lowestPriorityPendingInteractiveExpirationTime = _ReactFiberExpirationTime.NoWork;
  }
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    return (0, _scheduler.unstable_runWithPriority)(_scheduler.unstable_UserBlockingPriority, function () {
      return fn(a, b);
    });
  } finally {
    isBatchingUpdates = previousIsBatchingUpdates;
    if (!isBatchingUpdates && !isRendering) {
      performSyncWork();
    }
  }
}

function flushInteractiveUpdates() {
  if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== _ReactFiberExpirationTime.NoWork) {
    // Synchronously flush pending interactive updates.
    performWork(lowestPriorityPendingInteractiveExpirationTime, false);
    lowestPriorityPendingInteractiveExpirationTime = _ReactFiberExpirationTime.NoWork;
  }
}

function flushControlled(fn) {
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    syncUpdates(fn);
  } finally {
    isBatchingUpdates = previousIsBatchingUpdates;
    if (!isBatchingUpdates && !isRendering) {
      performSyncWork();
    }
  }
}

exports.requestCurrentTime = requestCurrentTime;
exports.computeExpirationForFiber = computeExpirationForFiber;
exports.captureCommitPhaseError = captureCommitPhaseError;
exports.onUncaughtError = onUncaughtError;
exports.renderDidSuspend = renderDidSuspend;
exports.renderDidError = renderDidError;
exports.pingSuspendedRoot = pingSuspendedRoot;
exports.retryTimedOutBoundary = retryTimedOutBoundary;
exports.markLegacyErrorBoundaryAsFailed = markLegacyErrorBoundaryAsFailed;
exports.isAlreadyFailedLegacyErrorBoundary = isAlreadyFailedLegacyErrorBoundary;
exports.scheduleWork = scheduleWork;
exports.requestWork = requestWork;
exports.flushRoot = flushRoot;
exports.batchedUpdates = batchedUpdates;
exports.unbatchedUpdates = unbatchedUpdates;
exports.flushSync = flushSync;
exports.flushControlled = flushControlled;
exports.deferredUpdates = _scheduler.unstable_next;
exports.syncUpdates = syncUpdates;
exports.interactiveUpdates = interactiveUpdates;
exports.flushInteractiveUpdates = flushInteractiveUpdates;
exports.computeUniqueAsyncExpiration = computeUniqueAsyncExpiration;
exports.flushPassiveEffects = flushPassiveEffects;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function lowPriorityWarning() {};

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function lowPriorityWarning(condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

exports.default = lowPriorityWarning;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = __webpack_require__(107);
  var loggedTypeFailures = {};

  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.');
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + (typeof error === 'undefined' ? 'undefined' : _typeof(error)) + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(106)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invokeGuardedCallback = invokeGuardedCallback;
exports.invokeGuardedCallbackAndCatchFirstError = invokeGuardedCallbackAndCatchFirstError;
exports.rethrowCaughtError = rethrowCaughtError;
exports.hasCaughtError = hasCaughtError;
exports.clearCaughtError = clearCaughtError;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _invokeGuardedCallbackImpl = __webpack_require__(112);

var _invokeGuardedCallbackImpl2 = _interopRequireDefault(_invokeGuardedCallbackImpl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Used by Fiber to simulate a try-catch.
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var hasError = false;
var caughtError = null;

// Used by event system to capture/rethrow the first error.
var hasRethrowError = false;
var rethrowError = null;

var reporter = {
  onError: function onError(error) {
    hasError = true;
    caughtError = error;
  }
};

/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */
function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
  hasError = false;
  caughtError = null;
  _invokeGuardedCallbackImpl2.default.apply(reporter, arguments);
}

/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */
function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
  invokeGuardedCallback.apply(this, arguments);
  if (hasError) {
    var error = clearCaughtError();
    if (!hasRethrowError) {
      hasRethrowError = true;
      rethrowError = error;
    }
  }
}

/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */
function rethrowCaughtError() {
  if (hasRethrowError) {
    var error = rethrowError;
    hasRethrowError = false;
    rethrowError = null;
    throw error;
  }
}

function hasCaughtError() {
  return hasError;
}

function clearCaughtError() {
  if (hasError) {
    var error = caughtError;
    hasError = false;
    caughtError = null;
    return error;
  } else {
    (0, _invariant2.default)(false, 'clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');
  }
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.toString = toString;
exports.getToStringValue = getToStringValue;


// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value) {
  return '' + value;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

function getToStringValue(value) {
  switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    case 'boolean':
    case 'number':
    case 'object':
    case 'string':
    case 'undefined':
      return value;
    default:
      // function, symbol are assigned as empty strings
      return '';
  }
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ReactFiberTreeReflection = __webpack_require__(124);

Object.keys(_ReactFiberTreeReflection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _ReactFiberTreeReflection[key];
    }
  });
});

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = remove;
exports.get = get;
exports.has = has;
exports.set = set;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */
function remove(key) {
  key._reactInternalFiber = undefined;
}

function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetStackAfterFatalErrorInDev = exports.checkThatStackIsEmpty = exports.push = exports.pop = exports.isEmpty = exports.createCursor = undefined;

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var valueStack = [];

var fiberStack = void 0;

if (true) {
  fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}

function isEmpty() {
  return index === -1;
}

function pop(cursor, fiber) {
  if (index < 0) {
    if (true) {
      (0, _warningWithoutStack2.default)(false, 'Unexpected pop.');
    }
    return;
  }

  if (true) {
    if (fiber !== fiberStack[index]) {
      (0, _warningWithoutStack2.default)(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  if (true) {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  if (true) {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function checkThatStackIsEmpty() {
  if (true) {
    if (index !== -1) {
      (0, _warningWithoutStack2.default)(false, 'Expected an empty stack. Something was not reset properly.');
    }
  }
}

function resetStackAfterFatalErrorInDev() {
  if (true) {
    index = -1;
    valueStack.length = 0;
    fiberStack.length = 0;
  }
}

exports.createCursor = createCursor;
exports.isEmpty = isEmpty;
exports.pop = pop;
exports.push = push;
exports.checkThatStackIsEmpty = checkThatStackIsEmpty;
exports.resetStackAfterFatalErrorInDev = resetStackAfterFatalErrorInDev;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDevToolsPresent = undefined;
exports.injectInternals = injectInternals;
exports.onCommitRoot = onCommitRoot;
exports.onCommitUnmount = onCommitUnmount;

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var onCommitFiberRoot = null; /**
                               * Copyright (c) Facebook, Inc. and its affiliates.
                               *
                               * This source code is licensed under the MIT license found in the
                               * LICENSE file in the root directory of this source tree.
                               *
                               * 
                               */

var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        (0, _warningWithoutStack2.default)(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

var isDevToolsPresent = exports.isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    if (true) {
      (0, _warningWithoutStack2.default)(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    if (true) {
      (0, _warningWithoutStack2.default)(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginWork = exports.didWarnAboutReassigningProps = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.reconcileChildren = reconcileChildren;
exports.markWorkInProgressReceivedUpdate = markWorkInProgressReceivedUpdate;

var _checkPropTypes = __webpack_require__(33);

var _checkPropTypes2 = _interopRequireDefault(_checkPropTypes);

var _ReactWorkTags = __webpack_require__(4);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _ReactFeatureFlags = __webpack_require__(3);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _shallowEqual = __webpack_require__(52);

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _ReactStrictModeWarnings = __webpack_require__(56);

var _ReactStrictModeWarnings2 = _interopRequireDefault(_ReactStrictModeWarnings);

var _ReactLazyComponent = __webpack_require__(44);

var _ReactSymbols = __webpack_require__(6);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactCurrentFiber = __webpack_require__(7);

var _ReactDebugFiberPerf = __webpack_require__(29);

var _ReactChildFiber = __webpack_require__(141);

var _ReactUpdateQueue = __webpack_require__(18);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactTypeOfMode = __webpack_require__(13);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiberHostContext = __webpack_require__(41);

var _ReactFiberNewContext = __webpack_require__(19);

var _ReactFiberHooks = __webpack_require__(82);

var _ReactProfilerTimer = __webpack_require__(58);

var _ReactFiberContext = __webpack_require__(21);

var _ReactFiberHydrationContext = __webpack_require__(84);

var _ReactFiberClassComponent = __webpack_require__(81);

var _ReactFiberLazyComponent = __webpack_require__(57);

var _ReactFiber = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ReactCurrentOwner = _ReactSharedInternals2.default.ReactCurrentOwner;

var didReceiveUpdate = false;

var didWarnAboutBadClass = void 0;
var didWarnAboutContextTypeOnFunctionComponent = void 0;
var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
var didWarnAboutFunctionRefs = void 0;
var didWarnAboutReassigningProps = exports.didWarnAboutReassigningProps = void 0;

if (true) {
  didWarnAboutBadClass = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  didWarnAboutFunctionRefs = {};
  exports.didWarnAboutReassigningProps = didWarnAboutReassigningProps = false;
}

function reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime) {
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = (0, _ReactChildFiber.mountChildFibers)(workInProgress, null, nextChildren, renderExpirationTime);
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.

    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = (0, _ReactChildFiber.reconcileChildFibers)(workInProgress, current.child, nextChildren, renderExpirationTime);
  }
}

function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime) {
  // This function is fork of reconcileChildren. It's used in cases where we
  // want to reconcile without matching against the existing set. This has the
  // effect of all current children being unmounted; even if the type and key
  // are the same, the old child is unmounted and a new child is created.
  //
  // To do this, we're going to go through the reconcile algorithm twice. In
  // the first pass, we schedule a deletion for all the current children by
  // passing null.
  workInProgress.child = (0, _ReactChildFiber.reconcileChildFibers)(workInProgress, current.child, null, renderExpirationTime);
  // In the second pass, we mount the new children. The trick here is that we
  // pass null in place of where we usually pass the current child set. This has
  // the effect of remounting all children regardless of whether their their
  // identity matches.
  workInProgress.child = (0, _ReactChildFiber.reconcileChildFibers)(workInProgress, null, nextChildren, renderExpirationTime);
}

function updateForwardRef(current, workInProgress, Component, nextProps, renderExpirationTime) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens after the first render suspends.
  // We'll need to figure out if this is fine or can cause issues.

  if (true) {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;
      if (innerPropTypes) {
        (0, _checkPropTypes2.default)(innerPropTypes, nextProps, // Resolved props
        'prop', (0, _getComponentName2.default)(Component), _ReactCurrentFiber.getCurrentFiberStackInDev);
      }
    }
  }

  var render = Component.render;
  var ref = workInProgress.ref;

  // The rest is a fork of updateFunctionComponent
  var nextChildren = void 0;
  (0, _ReactFiberNewContext.prepareToReadContext)(workInProgress, renderExpirationTime);
  if (true) {
    ReactCurrentOwner.current = workInProgress;
    (0, _ReactCurrentFiber.setCurrentPhase)('render');
    nextChildren = (0, _ReactFiberHooks.renderWithHooks)(current, workInProgress, render, nextProps, ref, renderExpirationTime);
    if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
      // Only double-render components with Hooks
      if (workInProgress.memoizedState !== null) {
        nextChildren = (0, _ReactFiberHooks.renderWithHooks)(current, workInProgress, render, nextProps, ref, renderExpirationTime);
      }
    }
    (0, _ReactCurrentFiber.setCurrentPhase)(null);
  } else {
    nextChildren = (0, _ReactFiberHooks.renderWithHooks)(current, workInProgress, render, nextProps, ref, renderExpirationTime);
  }

  if (current !== null && !didReceiveUpdate) {
    (0, _ReactFiberHooks.bailoutHooks)(current, workInProgress, renderExpirationTime);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
  }

  // React DevTools reads this flag.
  workInProgress.effectTag |= _ReactSideEffectTags.PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  return workInProgress.child;
}

function updateMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
  if (current === null) {
    var type = Component.type;
    if ((0, _ReactFiber.isSimpleFunctionComponent)(type) && Component.compare === null &&
    // SimpleMemoComponent codepath doesn't resolve outer props either.
    Component.defaultProps === undefined) {
      // If this is a plain function component without default props,
      // and with only the default shallow comparison, we upgrade it
      // to a SimpleMemoComponent to allow fast path updates.
      workInProgress.tag = _ReactWorkTags.SimpleMemoComponent;
      workInProgress.type = type;
      if (true) {
        validateFunctionComponentInDev(workInProgress, type);
      }
      return updateSimpleMemoComponent(current, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
    }
    if (true) {
      var innerPropTypes = type.propTypes;
      if (innerPropTypes) {
        // Inner memo component props aren't currently validated in createElement.
        // We could move it there, but we'd still need this for lazy code path.
        (0, _checkPropTypes2.default)(innerPropTypes, nextProps, // Resolved props
        'prop', (0, _getComponentName2.default)(type), _ReactCurrentFiber.getCurrentFiberStackInDev);
      }
    }
    var child = (0, _ReactFiber.createFiberFromTypeAndProps)(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
    child.ref = workInProgress.ref;
    child.return = workInProgress;
    workInProgress.child = child;
    return child;
  }
  if (true) {
    var _type = Component.type;
    var _innerPropTypes = _type.propTypes;
    if (_innerPropTypes) {
      // Inner memo component props aren't currently validated in createElement.
      // We could move it there, but we'd still need this for lazy code path.
      (0, _checkPropTypes2.default)(_innerPropTypes, nextProps, // Resolved props
      'prop', (0, _getComponentName2.default)(_type), _ReactCurrentFiber.getCurrentFiberStackInDev);
    }
  }
  var currentChild = current.child; // This is always exactly one child
  if (updateExpirationTime < renderExpirationTime) {
    // This will be the props with resolved defaultProps,
    // unlike current.memoizedProps which will be the unresolved ones.
    var prevProps = currentChild.memoizedProps;
    // Default to shallow comparison
    var compare = Component.compare;
    compare = compare !== null ? compare : _shallowEqual2.default;
    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
    }
  }
  // React DevTools reads this flag.
  workInProgress.effectTag |= _ReactSideEffectTags.PerformedWork;
  var newChild = (0, _ReactFiber.createWorkInProgress)(currentChild, nextProps, renderExpirationTime);
  newChild.ref = workInProgress.ref;
  newChild.return = workInProgress;
  workInProgress.child = newChild;
  return newChild;
}

function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens when the inner render suspends.
  // We'll need to figure out if this is fine or can cause issues.

  if (true) {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var outerMemoType = workInProgress.elementType;
      if (outerMemoType.$$typeof === _ReactSymbols.REACT_LAZY_TYPE) {
        // We warn when you define propTypes on lazy()
        // so let's just skip over it to find memo() outer wrapper.
        // Inner props for memo are validated later.
        outerMemoType = (0, _ReactLazyComponent.refineResolvedLazyComponent)(outerMemoType);
      }
      var outerPropTypes = outerMemoType && outerMemoType.propTypes;
      if (outerPropTypes) {
        (0, _checkPropTypes2.default)(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
        'prop', (0, _getComponentName2.default)(outerMemoType), _ReactCurrentFiber.getCurrentFiberStackInDev);
      }
      // Inner propTypes will be validated in the function component path.
    }
  }
  if (current !== null) {
    var prevProps = current.memoizedProps;
    if ((0, _shallowEqual2.default)(prevProps, nextProps) && current.ref === workInProgress.ref) {
      didReceiveUpdate = false;
      if (updateExpirationTime < renderExpirationTime) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
      }
    }
  }
  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime);
}

function updateFragment(current, workInProgress, renderExpirationTime) {
  var nextChildren = workInProgress.pendingProps;
  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  return workInProgress.child;
}

function updateMode(current, workInProgress, renderExpirationTime) {
  var nextChildren = workInProgress.pendingProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  return workInProgress.child;
}

function updateProfiler(current, workInProgress, renderExpirationTime) {
  if (_ReactFeatureFlags.enableProfilerTimer) {
    workInProgress.effectTag |= _ReactSideEffectTags.Update;
  }
  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  return workInProgress.child;
}

function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (current === null && ref !== null || current !== null && current.ref !== ref) {
    // Schedule a Ref effect
    workInProgress.effectTag |= _ReactSideEffectTags.Ref;
  }
}

function updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {
  if (true) {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;
      if (innerPropTypes) {
        (0, _checkPropTypes2.default)(innerPropTypes, nextProps, // Resolved props
        'prop', (0, _getComponentName2.default)(Component), _ReactCurrentFiber.getCurrentFiberStackInDev);
      }
    }
  }

  var unmaskedContext = (0, _ReactFiberContext.getUnmaskedContext)(workInProgress, Component, true);
  var context = (0, _ReactFiberContext.getMaskedContext)(workInProgress, unmaskedContext);

  var nextChildren = void 0;
  (0, _ReactFiberNewContext.prepareToReadContext)(workInProgress, renderExpirationTime);
  if (true) {
    ReactCurrentOwner.current = workInProgress;
    (0, _ReactCurrentFiber.setCurrentPhase)('render');
    nextChildren = (0, _ReactFiberHooks.renderWithHooks)(current, workInProgress, Component, nextProps, context, renderExpirationTime);
    if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
      // Only double-render components with Hooks
      if (workInProgress.memoizedState !== null) {
        nextChildren = (0, _ReactFiberHooks.renderWithHooks)(current, workInProgress, Component, nextProps, context, renderExpirationTime);
      }
    }
    (0, _ReactCurrentFiber.setCurrentPhase)(null);
  } else {
    nextChildren = (0, _ReactFiberHooks.renderWithHooks)(current, workInProgress, Component, nextProps, context, renderExpirationTime);
  }

  if (current !== null && !didReceiveUpdate) {
    (0, _ReactFiberHooks.bailoutHooks)(current, workInProgress, renderExpirationTime);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
  }

  // React DevTools reads this flag.
  workInProgress.effectTag |= _ReactSideEffectTags.PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  return workInProgress.child;
}

function updateClassComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {
  if (true) {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;
      if (innerPropTypes) {
        (0, _checkPropTypes2.default)(innerPropTypes, nextProps, // Resolved props
        'prop', (0, _getComponentName2.default)(Component), _ReactCurrentFiber.getCurrentFiberStackInDev);
      }
    }
  }

  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.
  var hasContext = void 0;
  if ((0, _ReactFiberContext.isContextProvider)(Component)) {
    hasContext = true;
    (0, _ReactFiberContext.pushContextProvider)(workInProgress);
  } else {
    hasContext = false;
  }
  (0, _ReactFiberNewContext.prepareToReadContext)(workInProgress, renderExpirationTime);

  var instance = workInProgress.stateNode;
  var shouldUpdate = void 0;
  if (instance === null) {
    if (current !== null) {
      // An class component without an instance only mounts if it suspended
      // inside a non- concurrent tree, in an inconsistent state. We want to
      // tree it like a new mount, even though an empty version of it already
      // committed. Disconnect the alternate pointers.
      current.alternate = null;
      workInProgress.alternate = null;
      // Since this is conceptually a new fiber, schedule a Placement effect
      workInProgress.effectTag |= _ReactSideEffectTags.Placement;
    }
    // In the initial pass we might need to construct the instance.
    (0, _ReactFiberClassComponent.constructClassInstance)(workInProgress, Component, nextProps, renderExpirationTime);
    (0, _ReactFiberClassComponent.mountClassInstance)(workInProgress, Component, nextProps, renderExpirationTime);
    shouldUpdate = true;
  } else if (current === null) {
    // In a resume, we'll already have an instance we can reuse.
    shouldUpdate = (0, _ReactFiberClassComponent.resumeMountClassInstance)(workInProgress, Component, nextProps, renderExpirationTime);
  } else {
    shouldUpdate = (0, _ReactFiberClassComponent.updateClassInstance)(current, workInProgress, Component, nextProps, renderExpirationTime);
  }
  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
  if (true) {
    var inst = workInProgress.stateNode;
    if (inst.props !== nextProps) {
      (0, _warning2.default)(didWarnAboutReassigningProps, 'It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', (0, _getComponentName2.default)(workInProgress.type) || 'a component');
      exports.didWarnAboutReassigningProps = didWarnAboutReassigningProps = true;
    }
  }
  return nextUnitOfWork;
}

function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
  // Refs should update even if shouldComponentUpdate returns false
  markRef(current, workInProgress);

  var didCaptureError = (workInProgress.effectTag & _ReactSideEffectTags.DidCapture) !== _ReactSideEffectTags.NoEffect;

  if (!shouldUpdate && !didCaptureError) {
    // Context providers should defer to sCU for rendering
    if (hasContext) {
      (0, _ReactFiberContext.invalidateContextProvider)(workInProgress, Component, false);
    }

    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
  }

  var instance = workInProgress.stateNode;

  // Rerender
  ReactCurrentOwner.current = workInProgress;
  var nextChildren = void 0;
  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
    // If we captured an error, but getDerivedStateFrom catch is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    if (_ReactFeatureFlags.enableProfilerTimer) {
      (0, _ReactProfilerTimer.stopProfilerTimerIfRunning)(workInProgress);
    }
  } else {
    if (true) {
      (0, _ReactCurrentFiber.setCurrentPhase)('render');
      nextChildren = instance.render();
      if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
        instance.render();
      }
      (0, _ReactCurrentFiber.setCurrentPhase)(null);
    } else {
      nextChildren = instance.render();
    }
  }

  // React DevTools reads this flag.
  workInProgress.effectTag |= _ReactSideEffectTags.PerformedWork;
  if (current !== null && didCaptureError) {
    // If we're recovering from an error, reconcile without reusing any of
    // the existing children. Conceptually, the normal children and the children
    // that are shown on error are two different sets, so we shouldn't reuse
    // normal children even if their identities match.
    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  }

  // Memoize state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.
  workInProgress.memoizedState = instance.state;

  // The context might have changed so we need to recalculate it.
  if (hasContext) {
    (0, _ReactFiberContext.invalidateContextProvider)(workInProgress, Component, true);
  }

  return workInProgress.child;
}

function pushHostRootContext(workInProgress) {
  var root = workInProgress.stateNode;
  if (root.pendingContext) {
    (0, _ReactFiberContext.pushTopLevelContextObject)(workInProgress, root.pendingContext, root.pendingContext !== root.context);
  } else if (root.context) {
    // Should always be set
    (0, _ReactFiberContext.pushTopLevelContextObject)(workInProgress, root.context, false);
  }
  (0, _ReactFiberHostContext.pushHostContainer)(workInProgress, root.containerInfo);
}

function updateHostRoot(current, workInProgress, renderExpirationTime) {
  pushHostRootContext(workInProgress);
  var updateQueue = workInProgress.updateQueue;
  (0, _invariant2.default)(updateQueue !== null, 'If the root does not have an updateQueue, we should have already ' + 'bailed out. This error is likely caused by a bug in React. Please ' + 'file an issue.');
  var nextProps = workInProgress.pendingProps;
  var prevState = workInProgress.memoizedState;
  var prevChildren = prevState !== null ? prevState.element : null;
  (0, _ReactUpdateQueue.processUpdateQueue)(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
  var nextState = workInProgress.memoizedState;
  // Caution: React DevTools currently depends on this property
  // being called "element".
  var nextChildren = nextState.element;
  if (nextChildren === prevChildren) {
    // If the state is the same as before, that's a bailout because we had
    // no work that expires at this time.
    (0, _ReactFiberHydrationContext.resetHydrationState)();
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
  }
  var root = workInProgress.stateNode;
  if ((current === null || current.child === null) && root.hydrate && (0, _ReactFiberHydrationContext.enterHydrationState)(workInProgress)) {
    // If we don't have any current children this might be the first pass.
    // We always try to hydrate. If this isn't a hydration pass there won't
    // be any children to hydrate which is effectively the same thing as
    // not hydrating.

    // This is a bit of a hack. We track the host root as a placement to
    // know that we're currently in a mounting state. That way isMounted
    // works as expected. We must reset this before committing.
    // TODO: Delete this when we delete isMounted and findDOMNode.
    workInProgress.effectTag |= _ReactSideEffectTags.Placement;

    // Ensure that children mount into this root without tracking
    // side-effects. This ensures that we don't store Placement effects on
    // nodes that will be hydrated.
    workInProgress.child = (0, _ReactChildFiber.mountChildFibers)(workInProgress, null, nextChildren, renderExpirationTime);
  } else {
    // Otherwise reset hydration state in case we aborted and resumed another
    // root.
    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
    (0, _ReactFiberHydrationContext.resetHydrationState)();
  }
  return workInProgress.child;
}

function updateHostComponent(current, workInProgress, renderExpirationTime) {
  (0, _ReactFiberHostContext.pushHostContext)(workInProgress);

  if (current === null) {
    (0, _ReactFiberHydrationContext.tryToClaimNextHydratableInstance)(workInProgress);
  }

  var type = workInProgress.type;
  var nextProps = workInProgress.pendingProps;
  var prevProps = current !== null ? current.memoizedProps : null;

  var nextChildren = nextProps.children;
  var isDirectTextChild = (0, _ReactFiberHostConfig.shouldSetTextContent)(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also have access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && (0, _ReactFiberHostConfig.shouldSetTextContent)(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.effectTag |= _ReactSideEffectTags.ContentReset;
  }

  markRef(current, workInProgress);

  // Check the host config to see if the children are offscreen/hidden.
  if (renderExpirationTime !== _ReactFiberExpirationTime.Never && workInProgress.mode & _ReactTypeOfMode.ConcurrentMode && (0, _ReactFiberHostConfig.shouldDeprioritizeSubtree)(type, nextProps)) {
    // Schedule this fiber to re-render at offscreen priority. Then bailout.
    workInProgress.expirationTime = workInProgress.childExpirationTime = _ReactFiberExpirationTime.Never;
    return null;
  }

  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  return workInProgress.child;
}

function updateHostText(current, workInProgress) {
  if (current === null) {
    (0, _ReactFiberHydrationContext.tryToClaimNextHydratableInstance)(workInProgress);
  }
  // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.
  return null;
}

function mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {
  if (_current !== null) {
    // An lazy component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null;
    // Since this is conceptually a new fiber, schedule a Placement effect
    workInProgress.effectTag |= _ReactSideEffectTags.Placement;
  }

  var props = workInProgress.pendingProps;
  // We can't start a User Timing measurement with correct label yet.
  // Cancel and resume right after we know the tag.
  (0, _ReactDebugFiberPerf.cancelWorkTimer)(workInProgress);
  var Component = (0, _ReactFiberLazyComponent.readLazyComponentType)(elementType);
  // Store the unwrapped component in the type.
  workInProgress.type = Component;
  var resolvedTag = workInProgress.tag = (0, _ReactFiber.resolveLazyComponentTag)(Component);
  (0, _ReactDebugFiberPerf.startWorkTimer)(workInProgress);
  var resolvedProps = (0, _ReactFiberLazyComponent.resolveDefaultProps)(Component, props);
  var child = void 0;
  switch (resolvedTag) {
    case _ReactWorkTags.FunctionComponent:
      {
        if (true) {
          validateFunctionComponentInDev(workInProgress, Component);
        }
        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
        break;
      }
    case _ReactWorkTags.ClassComponent:
      {
        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
        break;
      }
    case _ReactWorkTags.ForwardRef:
      {
        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);
        break;
      }
    case _ReactWorkTags.MemoComponent:
      {
        if (true) {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = Component.propTypes;
            if (outerPropTypes) {
              (0, _checkPropTypes2.default)(outerPropTypes, resolvedProps, // Resolved for outer only
              'prop', (0, _getComponentName2.default)(Component), _ReactCurrentFiber.getCurrentFiberStackInDev);
            }
          }
        }
        child = updateMemoComponent(null, workInProgress, Component, (0, _ReactFiberLazyComponent.resolveDefaultProps)(Component.type, resolvedProps), // The inner type can have defaults too
        updateExpirationTime, renderExpirationTime);
        break;
      }
    default:
      {
        var hint = '';
        if (true) {
          if (Component !== null && (typeof Component === 'undefined' ? 'undefined' : _typeof(Component)) === 'object' && Component.$$typeof === _ReactSymbols.REACT_LAZY_TYPE) {
            hint = ' Did you wrap a component in React.lazy() more than once?';
          }
        }
        // This message intentionally doesn't mention ForwardRef or MemoComponent
        // because the fact that it's a separate type of work is an
        // implementation detail.
        (0, _invariant2.default)(false, 'Element type is invalid. Received a promise that resolves to: %s. ' + 'Lazy element type must resolve to a class or function.%s', Component, hint);
      }
  }
  return child;
}

function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {
  if (_current !== null) {
    // An incomplete component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null;
    // Since this is conceptually a new fiber, schedule a Placement effect
    workInProgress.effectTag |= _ReactSideEffectTags.Placement;
  }

  // Promote the fiber to a class and try rendering again.
  workInProgress.tag = _ReactWorkTags.ClassComponent;

  // The rest of this function is a fork of `updateClassComponent`

  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.
  var hasContext = void 0;
  if ((0, _ReactFiberContext.isContextProvider)(Component)) {
    hasContext = true;
    (0, _ReactFiberContext.pushContextProvider)(workInProgress);
  } else {
    hasContext = false;
  }
  (0, _ReactFiberNewContext.prepareToReadContext)(workInProgress, renderExpirationTime);

  (0, _ReactFiberClassComponent.constructClassInstance)(workInProgress, Component, nextProps, renderExpirationTime);
  (0, _ReactFiberClassComponent.mountClassInstance)(workInProgress, Component, nextProps, renderExpirationTime);

  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
}

function mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {
  if (_current !== null) {
    // An indeterminate component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null;
    // Since this is conceptually a new fiber, schedule a Placement effect
    workInProgress.effectTag |= _ReactSideEffectTags.Placement;
  }

  var props = workInProgress.pendingProps;
  var unmaskedContext = (0, _ReactFiberContext.getUnmaskedContext)(workInProgress, Component, false);
  var context = (0, _ReactFiberContext.getMaskedContext)(workInProgress, unmaskedContext);

  (0, _ReactFiberNewContext.prepareToReadContext)(workInProgress, renderExpirationTime);

  var value = void 0;

  if (true) {
    if (Component.prototype && typeof Component.prototype.render === 'function') {
      var componentName = (0, _getComponentName2.default)(Component) || 'Unknown';

      if (!didWarnAboutBadClass[componentName]) {
        (0, _warningWithoutStack2.default)(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
        didWarnAboutBadClass[componentName] = true;
      }
    }

    if (workInProgress.mode & _ReactTypeOfMode.StrictMode) {
      _ReactStrictModeWarnings2.default.recordLegacyContextWarning(workInProgress, null);
    }

    ReactCurrentOwner.current = workInProgress;
    value = (0, _ReactFiberHooks.renderWithHooks)(null, workInProgress, Component, props, context, renderExpirationTime);
  } else {
    value = (0, _ReactFiberHooks.renderWithHooks)(null, workInProgress, Component, props, context, renderExpirationTime);
  }
  // React DevTools reads this flag.
  workInProgress.effectTag |= _ReactSideEffectTags.PerformedWork;

  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
    // Proceed under the assumption that this is a class instance
    workInProgress.tag = _ReactWorkTags.ClassComponent;

    // Throw out any hooks that were used.
    (0, _ReactFiberHooks.resetHooks)();

    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = false;
    if ((0, _ReactFiberContext.isContextProvider)(Component)) {
      hasContext = true;
      (0, _ReactFiberContext.pushContextProvider)(workInProgress);
    } else {
      hasContext = false;
    }

    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;

    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    if (typeof getDerivedStateFromProps === 'function') {
      (0, _ReactFiberClassComponent.applyDerivedStateFromProps)(workInProgress, Component, getDerivedStateFromProps, props);
    }

    (0, _ReactFiberClassComponent.adoptClassInstance)(workInProgress, value);
    (0, _ReactFiberClassComponent.mountClassInstance)(workInProgress, Component, props, renderExpirationTime);
    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
  } else {
    // Proceed under the assumption that this is a function component
    workInProgress.tag = _ReactWorkTags.FunctionComponent;
    if (true) {
      if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
        // Only double-render components with Hooks
        if (workInProgress.memoizedState !== null) {
          value = (0, _ReactFiberHooks.renderWithHooks)(null, workInProgress, Component, props, context, renderExpirationTime);
        }
      }
    }
    reconcileChildren(null, workInProgress, value, renderExpirationTime);
    if (true) {
      validateFunctionComponentInDev(workInProgress, Component);
    }
    return workInProgress.child;
  }
}

function validateFunctionComponentInDev(workInProgress, Component) {
  if (Component) {
    (0, _warningWithoutStack2.default)(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
  }
  if (workInProgress.ref !== null) {
    var info = '';
    var ownerName = (0, _ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull)();
    if (ownerName) {
      info += '\n\nCheck the render method of `' + ownerName + '`.';
    }

    var warningKey = ownerName || workInProgress._debugID || '';
    var debugSource = workInProgress._debugSource;
    if (debugSource) {
      warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
    }
    if (!didWarnAboutFunctionRefs[warningKey]) {
      didWarnAboutFunctionRefs[warningKey] = true;
      (0, _warning2.default)(false, 'Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
    }
  }

  if (typeof Component.getDerivedStateFromProps === 'function') {
    var componentName = (0, _getComponentName2.default)(Component) || 'Unknown';

    if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {
      (0, _warningWithoutStack2.default)(false, '%s: Function components do not support getDerivedStateFromProps.', componentName);
      didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;
    }
  }

  if (_typeof(Component.contextType) === 'object' && Component.contextType !== null) {
    var _componentName = (0, _getComponentName2.default)(Component) || 'Unknown';

    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName]) {
      (0, _warningWithoutStack2.default)(false, '%s: Function components do not support contextType.', _componentName);
      didWarnAboutContextTypeOnFunctionComponent[_componentName] = true;
    }
  }
}

function updateSuspenseComponent(current, workInProgress, renderExpirationTime) {
  var mode = workInProgress.mode;
  var nextProps = workInProgress.pendingProps;

  // We should attempt to render the primary children unless this boundary
  // already suspended during this render (`alreadyCaptured` is true).
  var nextState = workInProgress.memoizedState;

  var nextDidTimeout = void 0;
  if ((workInProgress.effectTag & _ReactSideEffectTags.DidCapture) === _ReactSideEffectTags.NoEffect) {
    // This is the first attempt.
    nextState = null;
    nextDidTimeout = false;
  } else {
    // Something in this boundary's subtree already suspended. Switch to
    // rendering the fallback children.
    nextState = {
      timedOutAt: nextState !== null ? nextState.timedOutAt : _ReactFiberExpirationTime.NoWork
    };
    nextDidTimeout = true;
    workInProgress.effectTag &= ~_ReactSideEffectTags.DidCapture;
  }

  // This next part is a bit confusing. If the children timeout, we switch to
  // showing the fallback children in place of the "primary" children.
  // However, we don't want to delete the primary children because then their
  // state will be lost (both the React state and the host state, e.g.
  // uncontrolled form inputs). Instead we keep them mounted and hide them.
  // Both the fallback children AND the primary children are rendered at the
  // same time. Once the primary children are un-suspended, we can delete
  // the fallback children  don't need to preserve their state.
  //
  // The two sets of children are siblings in the host environment, but
  // semantically, for purposes of reconciliation, they are two separate sets.
  // So we store them using two fragment fibers.
  //
  // However, we want to avoid allocating extra fibers for every placeholder.
  // They're only necessary when the children time out, because that's the
  // only time when both sets are mounted.
  //
  // So, the extra fragment fibers are only used if the children time out.
  // Otherwise, we render the primary children directly. This requires some
  // custom reconciliation logic to preserve the state of the primary
  // children. It's essentially a very basic form of re-parenting.

  // `child` points to the child fiber. In the normal case, this is the first
  // fiber of the primary children set. In the timed-out case, it's a
  // a fragment fiber containing the primary children.
  var child = void 0;
  // `next` points to the next fiber React should render. In the normal case,
  // it's the same as `child`: the first fiber of the primary children set.
  // In the timed-out case, it's a fragment fiber containing the *fallback*
  // children -- we skip over the primary children entirely.
  var next = void 0;
  if (current === null) {
    if (_ReactFeatureFlags.enableSuspenseServerRenderer) {
      // If we're currently hydrating, try to hydrate this boundary.
      // But only if this has a fallback.
      if (nextProps.fallback !== undefined) {
        (0, _ReactFiberHydrationContext.tryToClaimNextHydratableInstance)(workInProgress);
        // This could've changed the tag if this was a dehydrated suspense component.
        if (workInProgress.tag === _ReactWorkTags.DehydratedSuspenseComponent) {
          return updateDehydratedSuspenseComponent(null, workInProgress, renderExpirationTime);
        }
      }
    }

    // This is the initial mount. This branch is pretty simple because there's
    // no previous state that needs to be preserved.
    if (nextDidTimeout) {
      // Mount separate fragments for primary and fallback children.
      var nextFallbackChildren = nextProps.fallback;
      var primaryChildFragment = (0, _ReactFiber.createFiberFromFragment)(null, mode, _ReactFiberExpirationTime.NoWork, null);

      if ((workInProgress.mode & _ReactTypeOfMode.ConcurrentMode) === _ReactTypeOfMode.NoContext) {
        // Outside of concurrent mode, we commit the effects from the
        var progressedState = workInProgress.memoizedState;
        var progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;
        primaryChildFragment.child = progressedPrimaryChild;
      }

      var fallbackChildFragment = (0, _ReactFiber.createFiberFromFragment)(nextFallbackChildren, mode, renderExpirationTime, null);
      primaryChildFragment.sibling = fallbackChildFragment;
      child = primaryChildFragment;
      // Skip the primary children, and continue working on the
      // fallback children.
      next = fallbackChildFragment;
      child.return = next.return = workInProgress;
    } else {
      // Mount the primary children without an intermediate fragment fiber.
      var nextPrimaryChildren = nextProps.children;
      child = next = (0, _ReactChildFiber.mountChildFibers)(workInProgress, null, nextPrimaryChildren, renderExpirationTime);
    }
  } else {
    // This is an update. This branch is more complicated because we need to
    // ensure the state of the primary children is preserved.
    var prevState = current.memoizedState;
    var prevDidTimeout = prevState !== null;
    if (prevDidTimeout) {
      // The current tree already timed out. That means each child set is
      var currentPrimaryChildFragment = current.child;
      var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
      if (nextDidTimeout) {
        // Still timed out. Reuse the current primary children by cloning
        // its fragment. We're going to skip over these entirely.
        var _nextFallbackChildren = nextProps.fallback;
        var _primaryChildFragment = (0, _ReactFiber.createWorkInProgress)(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps, _ReactFiberExpirationTime.NoWork);

        if ((workInProgress.mode & _ReactTypeOfMode.ConcurrentMode) === _ReactTypeOfMode.NoContext) {
          // Outside of concurrent mode, we commit the effects from the
          var _progressedState = workInProgress.memoizedState;
          var _progressedPrimaryChild = _progressedState !== null ? workInProgress.child.child : workInProgress.child;
          if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
            _primaryChildFragment.child = _progressedPrimaryChild;
          }
        }

        // Because primaryChildFragment is a new fiber that we're inserting as the
        // parent of a new tree, we need to set its treeBaseDuration.
        if (_ReactFeatureFlags.enableProfilerTimer && workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
          // treeBaseDuration is the sum of all the child tree base durations.
          var treeBaseDuration = 0;
          var hiddenChild = _primaryChildFragment.child;
          while (hiddenChild !== null) {
            treeBaseDuration += hiddenChild.treeBaseDuration;
            hiddenChild = hiddenChild.sibling;
          }
          _primaryChildFragment.treeBaseDuration = treeBaseDuration;
        }

        // Clone the fallback child fragment, too. These we'll continue
        // working on.
        var _fallbackChildFragment = _primaryChildFragment.sibling = (0, _ReactFiber.createWorkInProgress)(currentFallbackChildFragment, _nextFallbackChildren, currentFallbackChildFragment.expirationTime);
        child = _primaryChildFragment;
        _primaryChildFragment.childExpirationTime = _ReactFiberExpirationTime.NoWork;
        // Skip the primary children, and continue working on the
        // fallback children.
        next = _fallbackChildFragment;
        child.return = next.return = workInProgress;
      } else {
        // No longer suspended. Switch back to showing the primary children,
        // and remove the intermediate fragment fiber.
        var _nextPrimaryChildren = nextProps.children;
        var currentPrimaryChild = currentPrimaryChildFragment.child;
        var primaryChild = (0, _ReactChildFiber.reconcileChildFibers)(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime);

        // If this render doesn't suspend, we need to delete the fallback
        // children. Wait until the complete phase, after we've confirmed the
        // fallback is no longer needed.
        // TODO: Would it be better to store the fallback fragment on
        // the stateNode?

        // Continue rendering the children, like we normally do.
        child = next = primaryChild;
      }
    } else {
      // The current tree has not already timed out. That means the primary
      // children are not wrapped in a fragment fiber.
      var _currentPrimaryChild = current.child;
      if (nextDidTimeout) {
        // Timed out. Wrap the children in a fragment fiber to keep them
        // separate from the fallback children.
        var _nextFallbackChildren2 = nextProps.fallback;
        var _primaryChildFragment2 = (0, _ReactFiber.createFiberFromFragment)(
        // It shouldn't matter what the pending props are because we aren't
        // going to render this fragment.
        null, mode, _ReactFiberExpirationTime.NoWork, null);
        _primaryChildFragment2.child = _currentPrimaryChild;

        // Even though we're creating a new fiber, there are no new children,
        // because we're reusing an already mounted tree. So we don't need to
        // schedule a placement.
        // primaryChildFragment.effectTag |= Placement;

        if ((workInProgress.mode & _ReactTypeOfMode.ConcurrentMode) === _ReactTypeOfMode.NoContext) {
          // Outside of concurrent mode, we commit the effects from the
          var _progressedState2 = workInProgress.memoizedState;
          var _progressedPrimaryChild2 = _progressedState2 !== null ? workInProgress.child.child : workInProgress.child;
          _primaryChildFragment2.child = _progressedPrimaryChild2;
        }

        // Because primaryChildFragment is a new fiber that we're inserting as the
        // parent of a new tree, we need to set its treeBaseDuration.
        if (_ReactFeatureFlags.enableProfilerTimer && workInProgress.mode & _ReactTypeOfMode.ProfileMode) {
          // treeBaseDuration is the sum of all the child tree base durations.
          var _treeBaseDuration = 0;
          var _hiddenChild = _primaryChildFragment2.child;
          while (_hiddenChild !== null) {
            _treeBaseDuration += _hiddenChild.treeBaseDuration;
            _hiddenChild = _hiddenChild.sibling;
          }
          _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
        }

        // Create a fragment from the fallback children, too.
        var _fallbackChildFragment2 = _primaryChildFragment2.sibling = (0, _ReactFiber.createFiberFromFragment)(_nextFallbackChildren2, mode, renderExpirationTime, null);
        _fallbackChildFragment2.effectTag |= _ReactSideEffectTags.Placement;
        child = _primaryChildFragment2;
        _primaryChildFragment2.childExpirationTime = _ReactFiberExpirationTime.NoWork;
        // Skip the primary children, and continue working on the
        // fallback children.
        next = _fallbackChildFragment2;
        child.return = next.return = workInProgress;
      } else {
        // Still haven't timed out.  Continue rendering the children, like we
        // normally do.
        var _nextPrimaryChildren2 = nextProps.children;
        next = child = (0, _ReactChildFiber.reconcileChildFibers)(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);
      }
    }
    workInProgress.stateNode = current.stateNode;
  }

  workInProgress.memoizedState = nextState;
  workInProgress.child = child;
  return next;
}

function updateDehydratedSuspenseComponent(current, workInProgress, renderExpirationTime) {
  if (current === null) {
    // During the first pass, we'll bail out and not drill into the children.
    // Instead, we'll leave the content in place and try to hydrate it later.
    workInProgress.expirationTime = _ReactFiberExpirationTime.Never;
    return null;
  }
  // We use childExpirationTime to indicate that a child might depend on context, so if
  // any context has changed, we need to treat is as if the input might have changed.
  var hasContextChanged = current.childExpirationTime >= renderExpirationTime;
  if (didReceiveUpdate || hasContextChanged) {
    // This boundary has changed since the first render. This means that we are now unable to
    // hydrate it. We might still be able to hydrate it using an earlier expiration time but
    // during this render we can't. Instead, we're going to delete the whole subtree and
    // instead inject a new real Suspense boundary to take its place, which may render content
    // or fallback. The real Suspense boundary will suspend for a while so we have some time
    // to ensure it can produce real content, but all state and pending events will be lost.

    // Detach from the current dehydrated boundary.
    current.alternate = null;
    workInProgress.alternate = null;

    // Insert a deletion in the effect list.
    var returnFiber = workInProgress.return;
    (0, _invariant2.default)(returnFiber !== null, 'Suspense boundaries are never on the root. ' + 'This is probably a bug in React.');
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = current;
      returnFiber.lastEffect = current;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = current;
    }
    current.nextEffect = null;
    current.effectTag = _ReactSideEffectTags.Deletion;

    // Upgrade this work in progress to a real Suspense component.
    workInProgress.tag = _ReactWorkTags.SuspenseComponent;
    workInProgress.stateNode = null;
    workInProgress.memoizedState = null;
    // This is now an insertion.
    workInProgress.effectTag |= _ReactSideEffectTags.Placement;
    // Retry as a real Suspense component.
    return updateSuspenseComponent(null, workInProgress, renderExpirationTime);
  }
  if ((workInProgress.effectTag & _ReactSideEffectTags.DidCapture) === _ReactSideEffectTags.NoEffect) {
    // This is the first attempt.
    (0, _ReactFiberHydrationContext.reenterHydrationStateFromDehydratedSuspenseInstance)(workInProgress);
    var nextProps = workInProgress.pendingProps;
    var nextChildren = nextProps.children;
    workInProgress.child = (0, _ReactChildFiber.mountChildFibers)(workInProgress, null, nextChildren, renderExpirationTime);
    return workInProgress.child;
  } else {
    // Something suspended. Leave the existing children in place.
    // TODO: In non-concurrent mode, should we commit the nodes we have hydrated so far?
    workInProgress.child = null;
    return null;
  }
}

function updatePortalComponent(current, workInProgress, renderExpirationTime) {
  (0, _ReactFiberHostContext.pushHostContainer)(workInProgress, workInProgress.stateNode.containerInfo);
  var nextChildren = workInProgress.pendingProps;
  if (current === null) {
    // Portals are special because we don't append the children during mount
    // but at commit. Therefore we need to track insertions which the normal
    // flow doesn't do during mount. This doesn't happen at the root because
    // the root always starts with a "current" with a null child.
    // TODO: Consider unifying this with how the root works.
    workInProgress.child = (0, _ReactChildFiber.reconcileChildFibers)(workInProgress, null, nextChildren, renderExpirationTime);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
  }
  return workInProgress.child;
}

function updateContextProvider(current, workInProgress, renderExpirationTime) {
  var providerType = workInProgress.type;
  var context = providerType._context;

  var newProps = workInProgress.pendingProps;
  var oldProps = workInProgress.memoizedProps;

  var newValue = newProps.value;

  if (true) {
    var providerPropTypes = workInProgress.type.propTypes;

    if (providerPropTypes) {
      (0, _checkPropTypes2.default)(providerPropTypes, newProps, 'prop', 'Context.Provider', _ReactCurrentFiber.getCurrentFiberStackInDev);
    }
  }

  (0, _ReactFiberNewContext.pushProvider)(workInProgress, newValue);

  if (oldProps !== null) {
    var oldValue = oldProps.value;
    var changedBits = (0, _ReactFiberNewContext.calculateChangedBits)(context, newValue, oldValue);
    if (changedBits === 0) {
      // No change. Bailout early if children are the same.
      if (oldProps.children === newProps.children && !(0, _ReactFiberContext.hasContextChanged)()) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
      }
    } else {
      // The context value changed. Search for matching consumers and schedule
      // them to update.
      (0, _ReactFiberNewContext.propagateContextChange)(workInProgress, context, changedBits, renderExpirationTime);
    }
  }

  var newChildren = newProps.children;
  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
  return workInProgress.child;
}

var hasWarnedAboutUsingContextAsConsumer = false;

function updateContextConsumer(current, workInProgress, renderExpirationTime) {
  var context = workInProgress.type;
  // The logic below for Context differs depending on PROD or DEV mode. In
  // DEV mode, we create a separate object for Context.Consumer that acts
  // like a proxy to Context. This proxy object adds unnecessary code in PROD
  // so we use the old behaviour (Context.Consumer references Context) to
  // reduce size and overhead. The separate object references context via
  // a property called "_context", which also gives us the ability to check
  // in DEV mode if this property exists or not and warn if it does not.
  if (true) {
    if (context._context === undefined) {
      // This may be because it's a Context (rather than a Consumer).
      // Or it may be because it's older React where they're the same thing.
      // We only want to warn if we're sure it's a new React.
      if (context !== context.Consumer) {
        if (!hasWarnedAboutUsingContextAsConsumer) {
          hasWarnedAboutUsingContextAsConsumer = true;
          (0, _warning2.default)(false, 'Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
        }
      }
    } else {
      context = context._context;
    }
  }
  var newProps = workInProgress.pendingProps;
  var render = newProps.children;

  if (true) {
    (0, _warningWithoutStack2.default)(typeof render === 'function', 'A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');
  }

  (0, _ReactFiberNewContext.prepareToReadContext)(workInProgress, renderExpirationTime);
  var newValue = (0, _ReactFiberNewContext.readContext)(context, newProps.unstable_observedBits);
  var newChildren = void 0;
  if (true) {
    ReactCurrentOwner.current = workInProgress;
    (0, _ReactCurrentFiber.setCurrentPhase)('render');
    newChildren = render(newValue);
    (0, _ReactCurrentFiber.setCurrentPhase)(null);
  } else {
    newChildren = render(newValue);
  }

  // React DevTools reads this flag.
  workInProgress.effectTag |= _ReactSideEffectTags.PerformedWork;
  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
  return workInProgress.child;
}

function markWorkInProgressReceivedUpdate() {
  didReceiveUpdate = true;
}

function bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime) {
  (0, _ReactDebugFiberPerf.cancelWorkTimer)(workInProgress);

  if (current !== null) {
    // Reuse previous context list
    workInProgress.contextDependencies = current.contextDependencies;
  }

  if (_ReactFeatureFlags.enableProfilerTimer) {
    // Don't update "base" render times for bailouts.
    (0, _ReactProfilerTimer.stopProfilerTimerIfRunning)(workInProgress);
  }

  // Check if the children have any pending work.
  var childExpirationTime = workInProgress.childExpirationTime;
  if (childExpirationTime < renderExpirationTime) {
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.
    return null;
  } else {
    // This fiber doesn't have work, but its subtree does. Clone the child
    // fibers and continue.
    (0, _ReactChildFiber.cloneChildFibers)(current, workInProgress);
    return workInProgress.child;
  }
}

function beginWork(current, workInProgress, renderExpirationTime) {
  var updateExpirationTime = workInProgress.expirationTime;

  if (current !== null) {
    var oldProps = current.memoizedProps;
    var newProps = workInProgress.pendingProps;

    if (oldProps !== newProps || (0, _ReactFiberContext.hasContextChanged)()) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else if (updateExpirationTime < renderExpirationTime) {
      didReceiveUpdate = false;
      // This fiber does not have any pending work. Bailout without entering
      // the begin phase. There's still some bookkeeping we that needs to be done
      // in this optimized path, mostly pushing stuff onto the stack.
      switch (workInProgress.tag) {
        case _ReactWorkTags.HostRoot:
          pushHostRootContext(workInProgress);
          (0, _ReactFiberHydrationContext.resetHydrationState)();
          break;
        case _ReactWorkTags.HostComponent:
          (0, _ReactFiberHostContext.pushHostContext)(workInProgress);
          break;
        case _ReactWorkTags.ClassComponent:
          {
            var Component = workInProgress.type;
            if ((0, _ReactFiberContext.isContextProvider)(Component)) {
              (0, _ReactFiberContext.pushContextProvider)(workInProgress);
            }
            break;
          }
        case _ReactWorkTags.HostPortal:
          (0, _ReactFiberHostContext.pushHostContainer)(workInProgress, workInProgress.stateNode.containerInfo);
          break;
        case _ReactWorkTags.ContextProvider:
          {
            var newValue = workInProgress.memoizedProps.value;
            (0, _ReactFiberNewContext.pushProvider)(workInProgress, newValue);
            break;
          }
        case _ReactWorkTags.Profiler:
          if (_ReactFeatureFlags.enableProfilerTimer) {
            workInProgress.effectTag |= _ReactSideEffectTags.Update;
          }
          break;
        case _ReactWorkTags.SuspenseComponent:
          {
            var state = workInProgress.memoizedState;
            var didTimeout = state !== null;
            if (didTimeout) {
              // If this boundary is currently timed out, we need to decide
              // whether to retry the primary children, or to skip over it and
              // go straight to the fallback. Check the priority of the primary
              var primaryChildFragment = workInProgress.child;
              var primaryChildExpirationTime = primaryChildFragment.childExpirationTime;
              if (primaryChildExpirationTime !== _ReactFiberExpirationTime.NoWork && primaryChildExpirationTime >= renderExpirationTime) {
                // The primary children have pending work. Use the normal path
                // to attempt to render the primary children again.
                return updateSuspenseComponent(current, workInProgress, renderExpirationTime);
              } else {
                // The primary children do not have pending work with sufficient
                // priority. Bailout.
                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
                if (child !== null) {
                  // The fallback children have pending work. Skip over the
                  // primary children and work on the fallback.
                  return child.sibling;
                } else {
                  return null;
                }
              }
            }
            break;
          }
        case _ReactWorkTags.DehydratedSuspenseComponent:
          {
            if (_ReactFeatureFlags.enableSuspenseServerRenderer) {
              // We know that this component will suspend again because if it has
              // been unsuspended it has committed as a regular Suspense component.
              // If it needs to be retried, it should have work scheduled on it.
              workInProgress.effectTag |= _ReactSideEffectTags.DidCapture;
              break;
            }
          }
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
    }
  } else {
    didReceiveUpdate = false;
  }

  // Before entering the begin phase, clear the expiration time.
  workInProgress.expirationTime = _ReactFiberExpirationTime.NoWork;

  switch (workInProgress.tag) {
    case _ReactWorkTags.IndeterminateComponent:
      {
        var elementType = workInProgress.elementType;
        return mountIndeterminateComponent(current, workInProgress, elementType, renderExpirationTime);
      }
    case _ReactWorkTags.LazyComponent:
      {
        var _elementType = workInProgress.elementType;
        return mountLazyComponent(current, workInProgress, _elementType, updateExpirationTime, renderExpirationTime);
      }
    case _ReactWorkTags.FunctionComponent:
      {
        var _Component = workInProgress.type;
        var unresolvedProps = workInProgress.pendingProps;
        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : (0, _ReactFiberLazyComponent.resolveDefaultProps)(_Component, unresolvedProps);
        return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderExpirationTime);
      }
    case _ReactWorkTags.ClassComponent:
      {
        var _Component2 = workInProgress.type;
        var _unresolvedProps = workInProgress.pendingProps;
        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : (0, _ReactFiberLazyComponent.resolveDefaultProps)(_Component2, _unresolvedProps);
        return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderExpirationTime);
      }
    case _ReactWorkTags.HostRoot:
      return updateHostRoot(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.HostComponent:
      return updateHostComponent(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.HostText:
      return updateHostText(current, workInProgress);
    case _ReactWorkTags.SuspenseComponent:
      return updateSuspenseComponent(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.HostPortal:
      return updatePortalComponent(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.ForwardRef:
      {
        var type = workInProgress.type;
        var _unresolvedProps2 = workInProgress.pendingProps;
        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : (0, _ReactFiberLazyComponent.resolveDefaultProps)(type, _unresolvedProps2);
        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderExpirationTime);
      }
    case _ReactWorkTags.Fragment:
      return updateFragment(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.Mode:
      return updateMode(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.Profiler:
      return updateProfiler(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.ContextProvider:
      return updateContextProvider(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.ContextConsumer:
      return updateContextConsumer(current, workInProgress, renderExpirationTime);
    case _ReactWorkTags.MemoComponent:
      {
        var _type2 = workInProgress.type;
        var _unresolvedProps3 = workInProgress.pendingProps;
        // Resolve outer props first, then resolve inner props.
        var _resolvedProps3 = (0, _ReactFiberLazyComponent.resolveDefaultProps)(_type2, _unresolvedProps3);
        if (true) {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = _type2.propTypes;
            if (outerPropTypes) {
              (0, _checkPropTypes2.default)(outerPropTypes, _resolvedProps3, // Resolved for outer only
              'prop', (0, _getComponentName2.default)(_type2), _ReactCurrentFiber.getCurrentFiberStackInDev);
            }
          }
        }
        _resolvedProps3 = (0, _ReactFiberLazyComponent.resolveDefaultProps)(_type2.type, _resolvedProps3);
        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateExpirationTime, renderExpirationTime);
      }
    case _ReactWorkTags.SimpleMemoComponent:
      {
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
      }
    case _ReactWorkTags.IncompleteClassComponent:
      {
        var _Component3 = workInProgress.type;
        var _unresolvedProps4 = workInProgress.pendingProps;
        var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : (0, _ReactFiberLazyComponent.resolveDefaultProps)(_Component3, _unresolvedProps4);
        return mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);
      }
    case _ReactWorkTags.DehydratedSuspenseComponent:
      {
        if (_ReactFeatureFlags.enableSuspenseServerRenderer) {
          return updateDehydratedSuspenseComponent(current, workInProgress, renderExpirationTime);
        }
        break;
      }
  }
  (0, _invariant2.default)(false, 'Unknown unit of work tag. This error is likely caused by a bug in ' + 'React. Please file an issue.');
}

exports.beginWork = beginWork;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pushHostContext = exports.pushHostContainer = exports.popHostContext = exports.popHostContainer = exports.getRootHostContainer = exports.getHostContext = undefined;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiberStack = __webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var NO_CONTEXT = {};

var contextStackCursor = (0, _ReactFiberStack.createCursor)(NO_CONTEXT);
var contextFiberStackCursor = (0, _ReactFiberStack.createCursor)(NO_CONTEXT);
var rootInstanceStackCursor = (0, _ReactFiberStack.createCursor)(NO_CONTEXT);

function requiredContext(c) {
  (0, _invariant2.default)(c !== NO_CONTEXT, 'Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');
  return c;
}

function getRootHostContainer() {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  return rootInstance;
}

function pushHostContainer(fiber, nextRootInstance) {
  // Push current root instance onto the stack;
  // This allows us to reset root when portals are popped.
  (0, _ReactFiberStack.push)(rootInstanceStackCursor, nextRootInstance, fiber);
  // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.
  (0, _ReactFiberStack.push)(contextFiberStackCursor, fiber, fiber);

  // Finally, we need to push the host context to the stack.
  // However, we can't just call getRootHostContext() and push it because
  // we'd have a different number of entries on the stack depending on
  // whether getRootHostContext() throws somewhere in renderer code or not.
  // So we push an empty value first. This lets us safely unwind on errors.
  (0, _ReactFiberStack.push)(contextStackCursor, NO_CONTEXT, fiber);
  var nextRootContext = (0, _ReactFiberHostConfig.getRootHostContext)(nextRootInstance);
  // Now that we know this function doesn't throw, replace it.
  (0, _ReactFiberStack.pop)(contextStackCursor, fiber);
  (0, _ReactFiberStack.push)(contextStackCursor, nextRootContext, fiber);
}

function popHostContainer(fiber) {
  (0, _ReactFiberStack.pop)(contextStackCursor, fiber);
  (0, _ReactFiberStack.pop)(contextFiberStackCursor, fiber);
  (0, _ReactFiberStack.pop)(rootInstanceStackCursor, fiber);
}

function getHostContext() {
  var context = requiredContext(contextStackCursor.current);
  return context;
}

function pushHostContext(fiber) {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  var context = requiredContext(contextStackCursor.current);
  var nextContext = (0, _ReactFiberHostConfig.getChildHostContext)(context, fiber.type, rootInstance);

  // Don't push this Fiber's context unless it's unique.
  if (context === nextContext) {
    return;
  }

  // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.
  (0, _ReactFiberStack.push)(contextFiberStackCursor, fiber, fiber);
  (0, _ReactFiberStack.push)(contextStackCursor, nextContext, fiber);
}

function popHostContext(fiber) {
  // Do not pop unless this Fiber provided the current context.
  // pushHostContext() only pushes Fibers that provide unique contexts.
  if (contextFiberStackCursor.current !== fiber) {
    return;
  }

  (0, _ReactFiberStack.pop)(contextStackCursor, fiber);
  (0, _ReactFiberStack.pop)(contextFiberStackCursor, fiber);
}

exports.getHostContext = getHostContext;
exports.getRootHostContainer = getRootHostContainer;
exports.popHostContainer = popHostContainer;
exports.popHostContext = popHostContext;
exports.pushHostContainer = pushHostContainer;
exports.pushHostContext = pushHostContext;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
}; /**
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    *
    * 
    */

exports.default = ReactCurrentOwner;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setCurrentlyValidatingElement = setCurrentlyValidatingElement;

var _describeComponentFrame = __webpack_require__(65);

var _describeComponentFrame2 = _interopRequireDefault(_describeComponentFrame);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ReactDebugCurrentFrame = {}; /**
                                  * Copyright (c) Facebook, Inc. and its affiliates.
                                  *
                                  * This source code is licensed under the MIT license found in the
                                  * LICENSE file in the root directory of this source tree.
                                  *
                                  * 
                                  */

var currentlyValidatingElement = null;

function setCurrentlyValidatingElement(element) {
  if (true) {
    currentlyValidatingElement = element;
  }
}

if (true) {
  // Stack implementation injected by the current renderer.
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = '';

    // Add an extra top frame while an element is being validated
    if (currentlyValidatingElement) {
      var name = (0, _getComponentName2.default)(currentlyValidatingElement.type);
      var owner = currentlyValidatingElement._owner;
      stack += (0, _describeComponentFrame2.default)(name, currentlyValidatingElement._source, owner && (0, _getComponentName2.default)(owner.type));
    }

    // Delegate to the injected renderer-specific implementation
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

exports.default = ReactDebugCurrentFrame;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refineResolvedLazyComponent = refineResolvedLazyComponent;
var Pending = exports.Pending = 0; /**
                                    * Copyright (c) Facebook, Inc. and its affiliates.
                                    *
                                    * This source code is licensed under the MIT license found in the
                                    * LICENSE file in the root directory of this source tree.
                                    *
                                    * 
                                    */

var Resolved = exports.Resolved = 1;
var Rejected = exports.Rejected = 2;

function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

exports.createElement = createElement;
exports.createFactory = createFactory;
exports.cloneAndReplaceKey = cloneAndReplaceKey;
exports.cloneElement = cloneElement;
exports.isValidElement = isValidElement;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactSymbols = __webpack_require__(6);

var _ReactCurrentOwner = __webpack_require__(42);

var _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown = void 0,
    specialPropRefWarningShown = void 0;

function hasValidRef(config) {
  if (true) {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (true) {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function warnAboutAccessingKey() {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      (0, _warningWithoutStack2.default)(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function warnAboutAccessingRef() {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      (0, _warningWithoutStack2.default)(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: _ReactSymbols.REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (true) {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName = void 0;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (true) {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (true) {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }
      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }
  return ReactElement(type, key, ref, self, source, _ReactCurrentOwner2.default.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */
function createFactory(type) {
  var factory = createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook: remove it
  factory.type = type;
  return factory;
}

function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  (0, _invariant2.default)(!(element === null || element === undefined), 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element);

  var propName = void 0;

  // Original props are copied
  var props = Object.assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = _ReactCurrentOwner2.default.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps = void 0;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */
function isValidElement(object) {
  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === _ReactSymbols.REACT_ELEMENT_TYPE;
}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNodeFromInstance = exports.getInstanceFromNode = exports.getFiberCurrentPropsFromNode = undefined;
exports.setComponentTree = setComponentTree;
exports.executeDispatchesInOrder = executeDispatchesInOrder;
exports.executeDispatchesInOrderStopAtTrue = executeDispatchesInOrderStopAtTrue;
exports.executeDirectDispatch = executeDirectDispatch;
exports.hasDispatches = hasDispatches;

var _ReactErrorUtils = __webpack_require__(34);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getFiberCurrentPropsFromNode = exports.getFiberCurrentPropsFromNode = null; /**
                                                                                 * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                 *
                                                                                 * This source code is licensed under the MIT license found in the
                                                                                 * LICENSE file in the root directory of this source tree.
                                                                                 */

var getInstanceFromNode = exports.getInstanceFromNode = null;
var getNodeFromInstance = exports.getNodeFromInstance = null;

function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
  exports.getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
  exports.getInstanceFromNode = getInstanceFromNode = getInstanceFromNodeImpl;
  exports.getNodeFromInstance = getNodeFromInstance = getNodeFromInstanceImpl;
  if (true) {
    (0, _warningWithoutStack2.default)(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
  }
}

var validateEventDispatches = void 0;
if (true) {
  validateEventDispatches = function validateEventDispatches(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    (0, _warningWithoutStack2.default)(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  (0, _ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError)(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (true) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (true) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (true) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  (0, _invariant2.default)(!Array.isArray(dispatchListener), 'executeDirectDispatch(...): Invalid `event`.');
  event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setRestoreImplementation = setRestoreImplementation;
exports.enqueueStateRestore = enqueueStateRestore;
exports.needsStateRestore = needsStateRestore;
exports.restoreStateIfNeeded = restoreStateIfNeeded;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _EventPluginUtils = __webpack_require__(46);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Use to restore controlled state after a change event has fired.

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var restoreImpl = null;
var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = (0, _EventPluginUtils.getInstanceFromNode)(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  (0, _invariant2.default)(typeof restoreImpl === 'function', 'setRestoreImplementation() needs to be called to handle a target for controlled ' + 'events. This error is likely caused by a bug in React. Please file an issue.');
  var props = (0, _EventPluginUtils.getFiberCurrentPropsFromNode)(internalInstance.stateNode);
  restoreImpl(internalInstance.stateNode, internalInstance.type, props);
}

function setRestoreImplementation(impl) {
  restoreImpl = impl;
}

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function needsStateRestore() {
  return restoreTarget !== null || restoreQueue !== null;
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.batchedUpdates = batchedUpdates;
exports.interactiveUpdates = interactiveUpdates;
exports.flushInteractiveUpdates = flushInteractiveUpdates;
exports.setBatchingImplementation = setBatchingImplementation;

var _ReactControlledComponent = __webpack_require__(47);

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {
  return fn(bookkeeping);
}; /**
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */

var _interactiveUpdatesImpl = function _interactiveUpdatesImpl(fn, a, b) {
  return fn(a, b);
};
var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};

var isBatching = false;
function batchedUpdates(fn, bookkeeping) {
  if (isBatching) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(bookkeeping);
  }
  isBatching = true;
  try {
    return _batchedUpdatesImpl(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isBatching = false;
    var controlledComponentsHavePendingUpdates = (0, _ReactControlledComponent.needsStateRestore)();
    if (controlledComponentsHavePendingUpdates) {
      // If a controlled event was fired, we may need to restore the state of
      // the DOM node back to the controlled value. This is necessary when React
      // bails out of the update without touching the DOM.
      _flushInteractiveUpdatesImpl();
      (0, _ReactControlledComponent.restoreStateIfNeeded)();
    }
  }
}

function interactiveUpdates(fn, a, b) {
  return _interactiveUpdatesImpl(fn, a, b);
}

function flushInteractiveUpdates() {
  return _flushInteractiveUpdatesImpl();
}

function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
  _batchedUpdatesImpl = batchedUpdatesImpl;
  _interactiveUpdatesImpl = interactiveUpdatesImpl;
  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.track = track;
exports.updateValueIfChanged = updateValueIfChanged;
exports.stopTracking = stopTracking;


function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }
  var _get = descriptor.get,
      _set = descriptor.set;

  Object.defineProperty(node, valueField, {
    configurable: true,
    get: function get() {
      return _get.call(this);
    },
    set: function set(value) {
      currentValue = '' + value;
      _set.call(this, value);
    }
  });
  // We could've passed this the first time
  // but it triggers a bug in IE11 and Edge 14/15.
  // Calling defineProperty() again should be equivalent.
  // https://github.com/facebook/react/issues/11768
  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable
  });

  var tracker = {
    getValue: function getValue() {
      return currentValue;
    },
    setValue: function setValue(value) {
      currentValue = '' + value;
    },
    stopTracking: function stopTracking() {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

function stopTracking(node) {
  var tracker = getTracker(node);
  if (tracker) {
    tracker.stopTracking();
  }
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _checkPropTypes = __webpack_require__(33);

var _checkPropTypes2 = _interopRequireDefault(_checkPropTypes);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactDebugCurrentFrame = null;

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

if (true) {
  ReactDebugCurrentFrame = _ReactSharedInternals2.default.ReactDebugCurrentFrame;

  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function value(props, propName, componentName) {
      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function checked(props, propName, componentName) {
      if (props.onChange || props.readOnly || props.disabled || props[propName] == null) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {
    (0, _checkPropTypes2.default)(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame.getStackAddendum);
  };
}

exports.default = ReactControlledValuePropTypes;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

exports.default = getEventModifierState;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

var _objectIs = __webpack_require__(53);

var _objectIs2 = _interopRequireDefault(_objectIs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if ((0, _objectIs2.default)(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !(0, _objectIs2.default)(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

exports.default = shallowEqual;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

exports.default = is;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode = void 0;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
  // report Enter as charCode 10 when ctrl is pressed.
  if (charCode === 10) {
    charCode = 13;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

exports.default = getEventCharCode;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
exports.default = 1073741823;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ReactCurrentFiber = __webpack_require__(7);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _ReactTypeOfMode = __webpack_require__(13);

var _lowPriorityWarning = __webpack_require__(32);

var _lowPriorityWarning2 = _interopRequireDefault(_lowPriorityWarning);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var ReactStrictModeWarnings = {
  discardPendingWarnings: function discardPendingWarnings() {},
  flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},
  flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
  recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},
  recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
  recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
  flushLegacyContextWarning: function flushLegacyContextWarning() {}
};

if (true) {
  var LIFECYCLE_SUGGESTIONS = {
    UNSAFE_componentWillMount: 'componentDidMount',
    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',
    UNSAFE_componentWillUpdate: 'componentDidUpdate'
  };

  var pendingComponentWillMountWarnings = [];
  var pendingComponentWillReceivePropsWarnings = [];
  var pendingComponentWillUpdateWarnings = [];
  var pendingUnsafeLifecycleWarnings = new Map();
  var pendingLegacyContextWarning = new Map();

  // Tracks components we have already warned about.
  var didWarnAboutDeprecatedLifecycles = new Set();
  var didWarnAboutUnsafeLifecycles = new Set();
  var didWarnAboutLegacyContext = new Set();

  var setToSortedString = function setToSortedString(set) {
    var array = [];
    set.forEach(function (value) {
      array.push(value);
    });
    return array.sort().join(', ');
  };

  ReactStrictModeWarnings.discardPendingWarnings = function () {
    pendingComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUnsafeLifecycleWarnings = new Map();
    pendingLegacyContextWarning = new Map();
  };

  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
      var lifecyclesWarningMessages = [];

      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];
        if (lifecycleWarnings.length > 0) {
          var componentNames = new Set();
          lifecycleWarnings.forEach(function (fiber) {
            componentNames.add((0, _getComponentName2.default)(fiber.type) || 'Component');
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });

          var formatted = lifecycle.replace('UNSAFE_', '');
          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
          var sortedComponentNames = setToSortedString(componentNames);

          lifecyclesWarningMessages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));
        }
      });

      if (lifecyclesWarningMessages.length > 0) {
        var strictRootComponentStack = (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(strictRoot);

        (0, _warningWithoutStack2.default)(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\n\n%s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMessages.join('\n\n'));
      }
    });

    pendingUnsafeLifecycleWarnings = new Map();
  };

  var findStrictRoot = function findStrictRoot(fiber) {
    var maybeStrictRoot = null;

    var node = fiber;
    while (node !== null) {
      if (node.mode & _ReactTypeOfMode.StrictMode) {
        maybeStrictRoot = node;
      }
      node = node.return;
    }

    return maybeStrictRoot;
  };

  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
    if (pendingComponentWillMountWarnings.length > 0) {
      var uniqueNames = new Set();
      pendingComponentWillMountWarnings.forEach(function (fiber) {
        uniqueNames.add((0, _getComponentName2.default)(fiber.type) || 'Component');
        didWarnAboutDeprecatedLifecycles.add(fiber.type);
      });

      var sortedNames = setToSortedString(uniqueNames);

      (0, _lowPriorityWarning2.default)(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);

      pendingComponentWillMountWarnings = [];
    }

    if (pendingComponentWillReceivePropsWarnings.length > 0) {
      var _uniqueNames = new Set();
      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        _uniqueNames.add((0, _getComponentName2.default)(fiber.type) || 'Component');
        didWarnAboutDeprecatedLifecycles.add(fiber.type);
      });

      var _sortedNames = setToSortedString(_uniqueNames);

      (0, _lowPriorityWarning2.default)(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);

      pendingComponentWillReceivePropsWarnings = [];
    }

    if (pendingComponentWillUpdateWarnings.length > 0) {
      var _uniqueNames2 = new Set();
      pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        _uniqueNames2.add((0, _getComponentName2.default)(fiber.type) || 'Component');
        didWarnAboutDeprecatedLifecycles.add(fiber.type);
      });

      var _sortedNames2 = setToSortedString(_uniqueNames2);

      (0, _lowPriorityWarning2.default)(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);

      pendingComponentWillUpdateWarnings = [];
    }
  };

  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
    // Dedup strategy: Warn once per component.
    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
      return;
    }

    // Don't warn about react-lifecycles-compat polyfilled components.
    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
      pendingComponentWillMountWarnings.push(fiber);
    }
    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
      pendingComponentWillReceivePropsWarnings.push(fiber);
    }
    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
      pendingComponentWillUpdateWarnings.push(fiber);
    }
  };

  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);
    if (strictRoot === null) {
      (0, _warningWithoutStack2.default)(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
      return;
    }

    // Dedup strategy: Warn once per component.
    // This is difficult to track any other way since component names
    // are often vague and are likely to collide between 3rd party libraries.
    // An expand property is probably okay to use here since it's DEV-only,
    // and will only be set in the event of serious warnings.
    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
      return;
    }

    var warningsForRoot = void 0;
    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
      warningsForRoot = {
        UNSAFE_componentWillMount: [],
        UNSAFE_componentWillReceiveProps: [],
        UNSAFE_componentWillUpdate: []
      };

      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
    } else {
      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
    }

    var unsafeLifecycles = [];
    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === 'function') {
      unsafeLifecycles.push('UNSAFE_componentWillMount');
    }
    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');
    }
    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === 'function') {
      unsafeLifecycles.push('UNSAFE_componentWillUpdate');
    }

    if (unsafeLifecycles.length > 0) {
      unsafeLifecycles.forEach(function (lifecycle) {
        warningsForRoot[lifecycle].push(fiber);
      });
    }
  };

  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);
    if (strictRoot === null) {
      (0, _warningWithoutStack2.default)(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
      return;
    }

    // Dedup strategy: Warn once per component.
    if (didWarnAboutLegacyContext.has(fiber.type)) {
      return;
    }

    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
      if (warningsForRoot === undefined) {
        warningsForRoot = [];
        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
      }
      warningsForRoot.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
      var uniqueNames = new Set();
      fiberArray.forEach(function (fiber) {
        uniqueNames.add((0, _getComponentName2.default)(fiber.type) || 'Component');
        didWarnAboutLegacyContext.add(fiber.type);
      });

      var sortedNames = setToSortedString(uniqueNames);
      var strictRootComponentStack = (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(strictRoot);

      (0, _warningWithoutStack2.default)(false, 'Legacy context API has been detected within a strict-mode tree: %s' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, sortedNames);
    });
  };
}

exports.default = ReactStrictModeWarnings;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveDefaultProps = resolveDefaultProps;
exports.readLazyComponentType = readLazyComponentType;

var _ReactLazyComponent = __webpack_require__(44);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function resolveDefaultProps(Component, baseProps) {
  if (Component && Component.defaultProps) {
    // Resolve default props. Taken from ReactElement
    var props = Object.assign({}, baseProps);
    var defaultProps = Component.defaultProps;
    for (var propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
    return props;
  }
  return baseProps;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

function readLazyComponentType(lazyComponent) {
  var status = lazyComponent._status;
  var result = lazyComponent._result;
  switch (status) {
    case _ReactLazyComponent.Resolved:
      {
        var Component = result;
        return Component;
      }
    case _ReactLazyComponent.Rejected:
      {
        var error = result;
        throw error;
      }
    case _ReactLazyComponent.Pending:
      {
        var thenable = result;
        throw thenable;
      }
    default:
      {
        lazyComponent._status = _ReactLazyComponent.Pending;
        var ctor = lazyComponent._ctor;
        var _thenable = ctor();
        _thenable.then(function (moduleObject) {
          if (lazyComponent._status === _ReactLazyComponent.Pending) {
            var defaultExport = moduleObject.default;
            if (true) {
              if (defaultExport === undefined) {
                (0, _warning2.default)(false, 'lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            lazyComponent._status = _ReactLazyComponent.Resolved;
            lazyComponent._result = defaultExport;
          }
        }, function (error) {
          if (lazyComponent._status === _ReactLazyComponent.Pending) {
            lazyComponent._status = _ReactLazyComponent.Rejected;
            lazyComponent._result = error;
          }
        });
        // Handle synchronous thenables.
        switch (lazyComponent._status) {
          case _ReactLazyComponent.Resolved:
            return lazyComponent._result;
          case _ReactLazyComponent.Rejected:
            throw lazyComponent._result;
        }
        lazyComponent._result = _thenable;
        throw _thenable;
      }
  }
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopProfilerTimerIfRunningAndRecordDelta = exports.stopProfilerTimerIfRunning = exports.startProfilerTimer = exports.recordCommitTime = exports.getCommitTime = undefined;

var _ReactFeatureFlags = __webpack_require__(3);

var _ReactFiberHostConfig = __webpack_require__(11);

var commitTime = 0; /**
                     * Copyright (c) Facebook, Inc. and its affiliates.
                     *
                     * This source code is licensed under the MIT license found in the
                     * LICENSE file in the root directory of this source tree.
                     *
                     * 
                     */

var profilerStartTime = -1;

function getCommitTime() {
  return commitTime;
}

function recordCommitTime() {
  if (!_ReactFeatureFlags.enableProfilerTimer) {
    return;
  }
  commitTime = (0, _ReactFiberHostConfig.now)();
}

function startProfilerTimer(fiber) {
  if (!_ReactFeatureFlags.enableProfilerTimer) {
    return;
  }

  profilerStartTime = (0, _ReactFiberHostConfig.now)();

  if (fiber.actualStartTime < 0) {
    fiber.actualStartTime = (0, _ReactFiberHostConfig.now)();
  }
}

function stopProfilerTimerIfRunning(fiber) {
  if (!_ReactFeatureFlags.enableProfilerTimer) {
    return;
  }
  profilerStartTime = -1;
}

function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
  if (!_ReactFeatureFlags.enableProfilerTimer) {
    return;
  }

  if (profilerStartTime >= 0) {
    var elapsedTime = (0, _ReactFiberHostConfig.now)() - profilerStartTime;
    fiber.actualDuration += elapsedTime;
    if (overrideBaseTime) {
      fiber.selfBaseDuration = elapsedTime;
    }
    profilerStartTime = -1;
  }
}

exports.getCommitTime = getCommitTime;
exports.recordCommitTime = recordCommitTime;
exports.startProfilerTimer = startProfilerTimer;
exports.stopProfilerTimerIfRunning = stopProfilerTimerIfRunning;
exports.stopProfilerTimerIfRunningAndRecordDelta = stopProfilerTimerIfRunningAndRecordDelta;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

exports.default = isCustomComponent;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



// TODO: this is special because it gets imported during build.

module.exports = '16.8.2';

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _objectAssign = __webpack_require__(95);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _scheduler = __webpack_require__(62);

var _tracing = __webpack_require__(23);

var _ReactCurrentDispatcher = __webpack_require__(64);

var _ReactCurrentDispatcher2 = _interopRequireDefault(_ReactCurrentDispatcher);

var _ReactCurrentOwner = __webpack_require__(42);

var _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);

var _ReactDebugCurrentFrame = __webpack_require__(43);

var _ReactDebugCurrentFrame2 = _interopRequireDefault(_ReactDebugCurrentFrame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactSharedInternals = {
  ReactCurrentDispatcher: _ReactCurrentDispatcher2.default,
  ReactCurrentOwner: _ReactCurrentOwner2.default,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _objectAssign2.default
};

if (false) {
  // Re-export the schedule API(s) for UMD bundles.
  // This avoids introducing a dependency on a new UMD global in a minor update,
  // Since that would be a breaking change (e.g. for all existing CodeSandboxes).
  // This re-export is only required for UMD bundles;
  // CJS bundles use the shared NPM package.
  Object.assign(ReactSharedInternals, {
    Scheduler: {
      unstable_cancelCallback: _scheduler.unstable_cancelCallback,
      unstable_shouldYield: _scheduler.unstable_shouldYield,
      unstable_now: _scheduler.unstable_now,
      unstable_scheduleCallback: _scheduler.unstable_scheduleCallback,
      unstable_runWithPriority: _scheduler.unstable_runWithPriority,
      unstable_next: _scheduler.unstable_next,
      unstable_wrapCallback: _scheduler.unstable_wrapCallback,
      unstable_getFirstCallbackNode: _scheduler.unstable_getFirstCallbackNode,
      unstable_pauseExecution: _scheduler.unstable_pauseExecution,
      unstable_continueExecution: _scheduler.unstable_continueExecution,
      unstable_getCurrentPriorityLevel: _scheduler.unstable_getCurrentPriorityLevel
    },
    SchedulerTracing: {
      __interactionsRef: _tracing.__interactionsRef,
      __subscriberRef: _tracing.__subscriberRef,
      unstable_clear: _tracing.unstable_clear,
      unstable_getCurrent: _tracing.unstable_getCurrent,
      unstable_getThreadID: _tracing.unstable_getThreadID,
      unstable_subscribe: _tracing.unstable_subscribe,
      unstable_trace: _tracing.unstable_trace,
      unstable_unsubscribe: _tracing.unstable_unsubscribe,
      unstable_wrap: _tracing.unstable_wrap
    }
  });
}

if (true) {
  Object.assign(ReactSharedInternals, {
    // These should not be included in production.
    ReactDebugCurrentFrame: _ReactDebugCurrentFrame2.default,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}

exports.default = ReactSharedInternals;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Scheduler = __webpack_require__(96);

Object.keys(_Scheduler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Scheduler[key];
    }
  });
});

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__subscriberRef = exports.__interactionsRef = undefined;
exports.unstable_clear = unstable_clear;
exports.unstable_getCurrent = unstable_getCurrent;
exports.unstable_getThreadID = unstable_getThreadID;
exports.unstable_trace = unstable_trace;
exports.unstable_wrap = unstable_wrap;

var _ReactFeatureFlags = __webpack_require__(3);

var DEFAULT_THREAD_ID = 0;

// Counters used to generate unique IDs.
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var interactionIDCounter = 0;
var threadIDCounter = 0;

// Set of currently traced interactions.
// Interactions "stack"
// Meaning that newly traced interactions are appended to the previously active set.
// When an interaction goes out of scope, the previous set (if any) is restored.
var interactionsRef = null;

// Listener(s) to notify when interactions begin and end.
var subscriberRef = null;

if (_ReactFeatureFlags.enableSchedulerTracing) {
  exports.__interactionsRef = interactionsRef = {
    current: new Set()
  };
  exports.__subscriberRef = subscriberRef = {
    current: null
  };
}

exports.__interactionsRef = interactionsRef;
exports.__subscriberRef = subscriberRef;
function unstable_clear(callback) {
  if (!_ReactFeatureFlags.enableSchedulerTracing) {
    return callback();
  }

  var prevInteractions = interactionsRef.current;
  interactionsRef.current = new Set();

  try {
    return callback();
  } finally {
    interactionsRef.current = prevInteractions;
  }
}

function unstable_getCurrent() {
  if (!_ReactFeatureFlags.enableSchedulerTracing) {
    return null;
  } else {
    return interactionsRef.current;
  }
}

function unstable_getThreadID() {
  return ++threadIDCounter;
}

function unstable_trace(name, timestamp, callback) {
  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

  if (!_ReactFeatureFlags.enableSchedulerTracing) {
    return callback();
  }

  var interaction = {
    __count: 1,
    id: interactionIDCounter++,
    name: name,
    timestamp: timestamp
  };

  var prevInteractions = interactionsRef.current;

  // Traced interactions should stack/accumulate.
  // To do that, clone the current interactions.
  // The previous set will be restored upon completion.
  var interactions = new Set(prevInteractions);
  interactions.add(interaction);
  interactionsRef.current = interactions;

  var subscriber = subscriberRef.current;
  var returnValue = void 0;

  try {
    if (subscriber !== null) {
      subscriber.onInteractionTraced(interaction);
    }
  } finally {
    try {
      if (subscriber !== null) {
        subscriber.onWorkStarted(interactions, threadID);
      }
    } finally {
      try {
        returnValue = callback();
      } finally {
        interactionsRef.current = prevInteractions;

        try {
          if (subscriber !== null) {
            subscriber.onWorkStopped(interactions, threadID);
          }
        } finally {
          interaction.__count--;

          // If no async work was scheduled for this interaction,
          // Notify subscribers that it's completed.
          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        }
      }
    }
  }

  return returnValue;
}

function unstable_wrap(callback) {
  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

  if (!_ReactFeatureFlags.enableSchedulerTracing) {
    return callback;
  }

  var wrappedInteractions = interactionsRef.current;

  var subscriber = subscriberRef.current;
  if (subscriber !== null) {
    subscriber.onWorkScheduled(wrappedInteractions, threadID);
  }

  // Update the pending async work count for the current interactions.
  // Update after calling subscribers in case of error.
  wrappedInteractions.forEach(function (interaction) {
    interaction.__count++;
  });

  var hasRun = false;

  function wrapped() {
    var prevInteractions = interactionsRef.current;
    interactionsRef.current = wrappedInteractions;

    subscriber = subscriberRef.current;

    try {
      var returnValue = void 0;

      try {
        if (subscriber !== null) {
          subscriber.onWorkStarted(wrappedInteractions, threadID);
        }
      } finally {
        try {
          returnValue = callback.apply(undefined, arguments);
        } finally {
          interactionsRef.current = prevInteractions;

          if (subscriber !== null) {
            subscriber.onWorkStopped(wrappedInteractions, threadID);
          }
        }
      }

      return returnValue;
    } finally {
      if (!hasRun) {
        // We only expect a wrapped function to be executed once,
        // But in the event that it's executed more than once
        // Only decrement the outstanding interaction counts once.
        hasRun = true;

        // Update pending async counts for all wrapped interactions.
        // If this was the last scheduled async work for any of them,
        // Mark them as completed.
        wrappedInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        });
      }
    }
  }

  wrapped.cancel = function cancel() {
    subscriber = subscriberRef.current;

    try {
      if (subscriber !== null) {
        subscriber.onWorkCanceled(wrappedInteractions, threadID);
      }
    } finally {
      // Update pending async counts for all wrapped interactions.
      // If this was the last scheduled async work for any of them,
      // Mark them as completed.
      wrappedInteractions.forEach(function (interaction) {
        interaction.__count--;

        if (subscriber && interaction.__count === 0) {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        }
      });
    }
  };

  return wrapped;
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
}; /**
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    *
    * 
    */

exports.default = ReactCurrentDispatcher;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (name, source, ownerName) {
  var sourceInfo = '';
  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');
    if (true) {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);
        if (match) {
          var pathBeforeSlash = match[1];
          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }
    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }
  return '\n    in ' + (name || 'Unknown') + sourceInfo;
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.default = isValidElementType;

var _ReactSymbols = __webpack_require__(6);

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === _ReactSymbols.REACT_FRAGMENT_TYPE || type === _ReactSymbols.REACT_CONCURRENT_MODE_TYPE || type === _ReactSymbols.REACT_PROFILER_TYPE || type === _ReactSymbols.REACT_STRICT_MODE_TYPE || type === _ReactSymbols.REACT_SUSPENSE_TYPE || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && (type.$$typeof === _ReactSymbols.REACT_LAZY_TYPE || type.$$typeof === _ReactSymbols.REACT_MEMO_TYPE || type.$$typeof === _ReactSymbols.REACT_PROVIDER_TYPE || type.$$typeof === _ReactSymbols.REACT_CONTEXT_TYPE || type.$$typeof === _ReactSymbols.REACT_FORWARD_REF_TYPE);
}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  (0, _invariant2.default)(next != null, 'accumulateInto(...): Accumulated items must not be null or undefined.');

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

exports.default = accumulateInto;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

exports.default = forEachAccumulated;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

exports.default = isTextInputElement;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _HTMLNodeType = __webpack_require__(15);

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  // Fallback to nativeEvent.srcElement for IE9
  // https://github.com/facebook/react/issues/12506
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === _HTMLNodeType.TEXT_NODE ? target.parentNode : target;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

exports.default = getEventTarget;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ExecutionEnvironment = __webpack_require__(17);

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix) {
  if (!_ExecutionEnvironment.canUseDOM) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  return isSupported;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

exports.default = isEventSupported;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHostProps = getHostProps;
exports.initWrapperState = initWrapperState;
exports.updateChecked = updateChecked;
exports.updateWrapper = updateWrapper;
exports.postMountWrapper = postMountWrapper;
exports.restoreControlledState = restoreControlledState;
exports.setDefaultValue = setDefaultValue;

var _ReactCurrentFiber = __webpack_require__(7);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _DOMPropertyOperations = __webpack_require__(73);

var _ReactDOMComponentTree = __webpack_require__(16);

var _ToStringValue = __webpack_require__(35);

var _ReactControlledValuePropTypes = __webpack_require__(50);

var _ReactControlledValuePropTypes2 = _interopRequireDefault(_ReactControlledValuePropTypes);

var _inputValueTracking = __webpack_require__(49);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnValueDefaultValue = false; /**
                                       * Copyright (c) Facebook, Inc. and its affiliates.
                                       *
                                       * This source code is licensed under the MIT license found in the
                                       * LICENSE file in the root directory of this source tree.
                                       *
                                       * 
                                       */

// TODO: direct imports like some-package/src/* are bad. Fix me.

var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var checked = props.checked;

  var hostProps = Object.assign({}, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: undefined,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  if (true) {
    _ReactControlledValuePropTypes2.default.checkPropTypes('input', props);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      (0, _warning2.default)(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', (0, _ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull)() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      (0, _warning2.default)(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', (0, _ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull)() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var node = element;
  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;

  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: (0, _ToStringValue.getToStringValue)(props.value != null ? props.value : defaultValue),
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    (0, _DOMPropertyOperations.setValueForProperty)(node, 'checked', checked, false);
  }
}

function updateWrapper(element, props) {
  var node = element;
  if (true) {
    var _controlled = isControlled(props);

    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {
      (0, _warning2.default)(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {
      (0, _warning2.default)(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = (0, _ToStringValue.getToStringValue)(props.value);
  var type = props.type;

  if (value != null) {
    if (type === 'number') {
      if (value === 0 && node.value === '' ||
      // We explicitly want to coerce to number here if possible.
      // eslint-disable-next-line
      node.value != value) {
        node.value = (0, _ToStringValue.toString)(value);
      }
    } else if (node.value !== (0, _ToStringValue.toString)(value)) {
      node.value = (0, _ToStringValue.toString)(value);
    }
  } else if (type === 'submit' || type === 'reset') {
    // Submit/reset inputs need the attribute removed completely to avoid
    // blank-text buttons.
    node.removeAttribute('value');
    return;
  }

  if (_ReactFeatureFlags.disableInputAttributeSyncing) {
    // When not syncing the value attribute, React only assigns a new value
    // whenever the defaultValue React prop has changed. When not present,
    // React does nothing
    if (props.hasOwnProperty('defaultValue')) {
      setDefaultValue(node, props.type, (0, _ToStringValue.getToStringValue)(props.defaultValue));
    }
  } else {
    // When syncing the value attribute, the value comes from a cascade of
    // properties:
    //  1. The value React property
    //  2. The defaultValue React property
    //  3. Otherwise there should be no change
    if (props.hasOwnProperty('value')) {
      setDefaultValue(node, props.type, value);
    } else if (props.hasOwnProperty('defaultValue')) {
      setDefaultValue(node, props.type, (0, _ToStringValue.getToStringValue)(props.defaultValue));
    }
  }

  if (_ReactFeatureFlags.disableInputAttributeSyncing) {
    // When not syncing the checked attribute, the attribute is directly
    // controllable from the defaultValue React property. It needs to be
    // updated as new props come in.
    if (props.defaultChecked == null) {
      node.removeAttribute('checked');
    } else {
      node.defaultChecked = !!props.defaultChecked;
    }
  } else {
    // When syncing the checked attribute, it only changes when it needs
    // to be removed, such as transitioning from a checkbox into a text input
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props, isHydrating) {
  var node = element;

  // Do not assign value if it is already set. This prevents user text input
  // from being lost during SSR hydration.
  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
    var type = props.type;
    var isButton = type === 'submit' || type === 'reset';

    // Avoid setting value attribute on submit/reset inputs as it overrides the
    // default value provided by the browser. See: #12872
    if (isButton && (props.value === undefined || props.value === null)) {
      return;
    }

    var _initialValue = (0, _ToStringValue.toString)(node._wrapperState.initialValue);

    // Do not assign value if it is already set. This prevents user text input
    // from being lost during SSR hydration.
    if (!isHydrating) {
      if (_ReactFeatureFlags.disableInputAttributeSyncing) {
        var value = (0, _ToStringValue.getToStringValue)(props.value);

        // When not syncing the value attribute, the value property points
        // directly to the React prop. Only assign it if it exists.
        if (value != null) {
          // Always assign on buttons so that it is possible to assign an
          // empty string to clear button text.
          //
          // Otherwise, do not re-assign the value property if is empty. This
          // potentially avoids a DOM write and prevents Firefox (~60.0.1) from
          // prematurely marking required inputs as invalid. Equality is compared
          // to the current value in case the browser provided value is not an
          // empty string.
          if (isButton || value !== node.value) {
            node.value = (0, _ToStringValue.toString)(value);
          }
        }
      } else {
        // When syncing the value attribute, the value property should use
        // the wrapperState._initialValue property. This uses:
        //
        //   1. The value React property when present
        //   2. The defaultValue React property when present
        //   3. An empty string
        if (_initialValue !== node.value) {
          node.value = _initialValue;
        }
      }
    }

    if (_ReactFeatureFlags.disableInputAttributeSyncing) {
      // When not syncing the value attribute, assign the value attribute
      // directly from the defaultValue React property (when present)
      var defaultValue = (0, _ToStringValue.getToStringValue)(props.defaultValue);
      if (defaultValue != null) {
        node.defaultValue = (0, _ToStringValue.toString)(defaultValue);
      }
    } else {
      // Otherwise, the value attribute is synchronized to the property,
      // so we assign defaultValue to the same thing as the value property
      // assignment step above.
      node.defaultValue = _initialValue;
    }
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }

  if (_ReactFeatureFlags.disableInputAttributeSyncing) {
    // When not syncing the checked attribute, the checked property
    // never gets assigned. It must be manually set. We don't want
    // to do this when hydrating so that existing user input isn't
    // modified
    if (!isHydrating) {
      updateChecked(element, props);
    }

    // Only assign the checked attribute if it is defined. This saves
    // a DOM write when controlling the checked attribute isn't needed
    // (text inputs, submit/reset)
    if (props.hasOwnProperty('defaultChecked')) {
      node.defaultChecked = !node.defaultChecked;
      node.defaultChecked = !!props.defaultChecked;
    }
  } else {
    // When syncing the checked attribute, both the checked property and
    // attribute are assigned at the same time using defaultChecked. This uses:
    //
    //   1. The checked React property when present
    //   2. The defaultChecked React property when present
    //   3. Otherwise, false
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !!node._wrapperState.initialChecked;
  }

  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = (0, _ReactDOMComponentTree.getFiberCurrentPropsFromNode)(otherNode);
      (0, _invariant2.default)(otherProps, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.');

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      (0, _inputValueTracking.updateValueIfChanged)(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
function setDefaultValue(node, type, value) {
  if (
  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
  type !== 'number' || node.ownerDocument.activeElement !== node) {
    if (value == null) {
      node.defaultValue = (0, _ToStringValue.toString)(node._wrapperState.initialValue);
    } else if (node.defaultValue !== (0, _ToStringValue.toString)(value)) {
      node.defaultValue = (0, _ToStringValue.toString)(value);
    }
  }
}

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValueForProperty = getValueForProperty;
exports.getValueForAttribute = getValueForAttribute;
exports.setValueForProperty = setValueForProperty;

var _DOMProperty = __webpack_require__(26);

/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected, propertyInfo) {
  if (true) {
    if (propertyInfo.mustUseProperty) {
      var propertyName = propertyInfo.propertyName;

      return node[propertyName];
    } else {
      var attributeName = propertyInfo.attributeName;

      var stringValue = null;

      if (propertyInfo.type === _DOMProperty.OVERLOADED_BOOLEAN) {
        if (node.hasAttribute(attributeName)) {
          var value = node.getAttribute(attributeName);
          if (value === '') {
            return true;
          }
          if ((0, _DOMProperty.shouldRemoveAttribute)(name, expected, propertyInfo, false)) {
            return value;
          }
          if (value === '' + expected) {
            return expected;
          }
          return value;
        }
      } else if (node.hasAttribute(attributeName)) {
        if ((0, _DOMProperty.shouldRemoveAttribute)(name, expected, propertyInfo, false)) {
          // We had an attribute but shouldn't have had one, so read it
          // for the error message.
          return node.getAttribute(attributeName);
        }
        if (propertyInfo.type === _DOMProperty.BOOLEAN) {
          // If this was a boolean, it doesn't matter what the value is
          // the fact that we have it is the same as the expected.
          return expected;
        }
        // Even if this property uses a namespace we use getAttribute
        // because we assume its namespaced name is the same as our config.
        // To use getAttributeNS we need the local name which we don't have
        // in our config atm.
        stringValue = node.getAttribute(attributeName);
      }

      if ((0, _DOMProperty.shouldRemoveAttribute)(name, expected, propertyInfo, false)) {
        return stringValue === null ? expected : stringValue;
      } else if (stringValue === '' + expected) {
        return expected;
      } else {
        return stringValue;
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function getValueForAttribute(node, name, expected) {
  if (true) {
    if (!(0, _DOMProperty.isAttributeNameSafe)(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value, isCustomComponentTag) {
  var propertyInfo = (0, _DOMProperty.getPropertyInfo)(name);
  if ((0, _DOMProperty.shouldIgnoreAttribute)(name, propertyInfo, isCustomComponentTag)) {
    return;
  }
  if ((0, _DOMProperty.shouldRemoveAttribute)(name, value, propertyInfo, isCustomComponentTag)) {
    value = null;
  }
  // If the prop isn't in the special list, treat it as a simple attribute.
  if (isCustomComponentTag || propertyInfo === null) {
    if ((0, _DOMProperty.isAttributeNameSafe)(name)) {
      var _attributeName = name;
      if (value === null) {
        node.removeAttribute(_attributeName);
      } else {
        node.setAttribute(_attributeName, '' + value);
      }
    }
    return;
  }
  var mustUseProperty = propertyInfo.mustUseProperty;

  if (mustUseProperty) {
    var propertyName = propertyInfo.propertyName;

    if (value === null) {
      var type = propertyInfo.type;

      node[propertyName] = type === _DOMProperty.BOOLEAN ? false : '';
    } else {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyName] = value;
    }
    return;
  }
  // The rest are treated as attributes with special cases.
  var attributeName = propertyInfo.attributeName,
      attributeNamespace = propertyInfo.attributeNamespace;

  if (value === null) {
    node.removeAttribute(attributeName);
  } else {
    var _type = propertyInfo.type;

    var attributeValue = void 0;
    if (_type === _DOMProperty.BOOLEAN || _type === _DOMProperty.OVERLOADED_BOOLEAN && value === true) {
      attributeValue = '';
    } else {
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      attributeValue = '' + value;
    }
    if (attributeNamespace) {
      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
    } else {
      node.setAttribute(attributeName, attributeValue);
    }
  }
}

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticMouseEvent = __webpack_require__(27);

var _SyntheticMouseEvent2 = _interopRequireDefault(_SyntheticMouseEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */
var SyntheticPointerEvent = _SyntheticMouseEvent2.default.extend({
  pointerId: null,
  width: null,
  height: null,
  pressure: null,
  tangentialPressure: null,
  tiltX: null,
  tiltY: null,
  twist: null,
  pointerType: null,
  isPrimary: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticPointerEvent;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trapCapturedEvent = exports.trapBubbledEvent = exports.isEnabled = exports.setEnabled = undefined;
exports.listenTo = listenTo;
exports.isListeningToAllDependencies = isListeningToAllDependencies;

var _EventPluginRegistry = __webpack_require__(25);

var _DOMTopLevelEventTypes = __webpack_require__(14);

var _ReactDOMEventListener = __webpack_require__(76);

var _isEventSupported = __webpack_require__(71);

var _isEventSupported2 = _interopRequireDefault(_isEventSupported);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} mountAt Container where to mount the listener
 */
function listenTo(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = _EventPluginRegistry.registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      switch (dependency) {
        case _DOMTopLevelEventTypes.TOP_SCROLL:
          (0, _ReactDOMEventListener.trapCapturedEvent)(_DOMTopLevelEventTypes.TOP_SCROLL, mountAt);
          break;
        case _DOMTopLevelEventTypes.TOP_FOCUS:
        case _DOMTopLevelEventTypes.TOP_BLUR:
          (0, _ReactDOMEventListener.trapCapturedEvent)(_DOMTopLevelEventTypes.TOP_FOCUS, mountAt);
          (0, _ReactDOMEventListener.trapCapturedEvent)(_DOMTopLevelEventTypes.TOP_BLUR, mountAt);
          // We set the flag for a single dependency later in this function,
          // but this ensures we mark both as attached rather than just one.
          isListening[_DOMTopLevelEventTypes.TOP_BLUR] = true;
          isListening[_DOMTopLevelEventTypes.TOP_FOCUS] = true;
          break;
        case _DOMTopLevelEventTypes.TOP_CANCEL:
        case _DOMTopLevelEventTypes.TOP_CLOSE:
          if ((0, _isEventSupported2.default)((0, _DOMTopLevelEventTypes.getRawEventName)(dependency))) {
            (0, _ReactDOMEventListener.trapCapturedEvent)(dependency, mountAt);
          }
          break;
        case _DOMTopLevelEventTypes.TOP_INVALID:
        case _DOMTopLevelEventTypes.TOP_SUBMIT:
        case _DOMTopLevelEventTypes.TOP_RESET:
          // We listen to them on the target DOM elements.
          // Some of them bubble so we don't want them to fire twice.
          break;
        default:
          // By default, listen on the top level to all non-media events.
          // Media events don't bubble so adding the listener wouldn't do anything.
          var isMediaEvent = _DOMTopLevelEventTypes.mediaEventTypes.indexOf(dependency) !== -1;
          if (!isMediaEvent) {
            (0, _ReactDOMEventListener.trapBubbledEvent)(dependency, mountAt);
          }
          break;
      }
      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = _EventPluginRegistry.registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

exports.setEnabled = _ReactDOMEventListener.setEnabled;
exports.isEnabled = _ReactDOMEventListener.isEnabled;
exports.trapBubbledEvent = _ReactDOMEventListener.trapBubbledEvent;
exports.trapCapturedEvent = _ReactDOMEventListener.trapCapturedEvent;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._enabled = undefined;
exports.setEnabled = setEnabled;
exports.isEnabled = isEnabled;
exports.trapBubbledEvent = trapBubbledEvent;
exports.trapCapturedEvent = trapCapturedEvent;
exports.dispatchEvent = dispatchEvent;

var _ReactGenericBatching = __webpack_require__(48);

var _EventPluginHub = __webpack_require__(24);

var _reflection = __webpack_require__(36);

var _ReactWorkTags = __webpack_require__(4);

var _EventListener = __webpack_require__(125);

var _getEventTarget = __webpack_require__(70);

var _getEventTarget2 = _interopRequireDefault(_getEventTarget);

var _ReactDOMComponentTree = __webpack_require__(16);

var _SimpleEventPlugin = __webpack_require__(77);

var _SimpleEventPlugin2 = _interopRequireDefault(_SimpleEventPlugin);

var _DOMTopLevelEventTypes = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isInteractiveTopLevelEventType = _SimpleEventPlugin2.default.isInteractiveTopLevelEventType;


var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst.return) {
    inst = inst.return;
  }
  if (inst.tag !== _ReactWorkTags.HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevel(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = (0, _ReactDOMComponentTree.getClosestInstanceFromNode)(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    (0, _EventPluginHub.runExtractedEventsInBatch)(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, (0, _getEventTarget2.default)(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = exports._enabled = true;

function setEnabled(enabled) {
  exports._enabled = _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, element) {
  if (!element) {
    return null;
  }
  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;

  (0, _EventListener.addEventBubbleListener)(element, (0, _DOMTopLevelEventTypes.getRawEventName)(topLevelType),
  // Check if interactive and wrap in interactiveUpdates
  dispatch.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, element) {
  if (!element) {
    return null;
  }
  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;

  (0, _EventListener.addEventCaptureListener)(element, (0, _DOMTopLevelEventTypes.getRawEventName)(topLevelType),
  // Check if interactive and wrap in interactiveUpdates
  dispatch.bind(null, topLevelType));
}

function dispatchInteractiveEvent(topLevelType, nativeEvent) {
  (0, _ReactGenericBatching.interactiveUpdates)(dispatchEvent, topLevelType, nativeEvent);
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = (0, _getEventTarget2.default)(nativeEvent);
  var targetInst = (0, _ReactDOMComponentTree.getClosestInstanceFromNode)(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !(0, _reflection.isFiberMounted)(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    (0, _ReactGenericBatching.batchedUpdates)(handleTopLevel, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

var _EventPropagators = __webpack_require__(20);

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

var _DOMTopLevelEventTypes = __webpack_require__(14);

var DOMTopLevelEventTypes = _interopRequireWildcard(_DOMTopLevelEventTypes);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _SyntheticAnimationEvent = __webpack_require__(126);

var _SyntheticAnimationEvent2 = _interopRequireDefault(_SyntheticAnimationEvent);

var _SyntheticClipboardEvent = __webpack_require__(127);

var _SyntheticClipboardEvent2 = _interopRequireDefault(_SyntheticClipboardEvent);

var _SyntheticFocusEvent = __webpack_require__(128);

var _SyntheticFocusEvent2 = _interopRequireDefault(_SyntheticFocusEvent);

var _SyntheticKeyboardEvent = __webpack_require__(129);

var _SyntheticKeyboardEvent2 = _interopRequireDefault(_SyntheticKeyboardEvent);

var _SyntheticMouseEvent = __webpack_require__(27);

var _SyntheticMouseEvent2 = _interopRequireDefault(_SyntheticMouseEvent);

var _SyntheticPointerEvent = __webpack_require__(74);

var _SyntheticPointerEvent2 = _interopRequireDefault(_SyntheticPointerEvent);

var _SyntheticDragEvent = __webpack_require__(131);

var _SyntheticDragEvent2 = _interopRequireDefault(_SyntheticDragEvent);

var _SyntheticTouchEvent = __webpack_require__(132);

var _SyntheticTouchEvent2 = _interopRequireDefault(_SyntheticTouchEvent);

var _SyntheticTransitionEvent = __webpack_require__(133);

var _SyntheticTransitionEvent2 = _interopRequireDefault(_SyntheticTransitionEvent);

var _SyntheticUIEvent = __webpack_require__(28);

var _SyntheticUIEvent2 = _interopRequireDefault(_SyntheticUIEvent);

var _SyntheticWheelEvent = __webpack_require__(134);

var _SyntheticWheelEvent2 = _interopRequireDefault(_SyntheticWheelEvent);

var _getEventCharCode = __webpack_require__(54);

var _getEventCharCode2 = _interopRequireDefault(_getEventCharCode);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: [TOP_ABORT],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = new Map([
 *   [TOP_ABORT, { sameConfig }],
 * ]);
 */
var interactiveEventTypeNames = [[DOMTopLevelEventTypes.TOP_BLUR, 'blur'], [DOMTopLevelEventTypes.TOP_CANCEL, 'cancel'], [DOMTopLevelEventTypes.TOP_CLICK, 'click'], [DOMTopLevelEventTypes.TOP_CLOSE, 'close'], [DOMTopLevelEventTypes.TOP_CONTEXT_MENU, 'contextMenu'], [DOMTopLevelEventTypes.TOP_COPY, 'copy'], [DOMTopLevelEventTypes.TOP_CUT, 'cut'], [DOMTopLevelEventTypes.TOP_AUX_CLICK, 'auxClick'], [DOMTopLevelEventTypes.TOP_DOUBLE_CLICK, 'doubleClick'], [DOMTopLevelEventTypes.TOP_DRAG_END, 'dragEnd'], [DOMTopLevelEventTypes.TOP_DRAG_START, 'dragStart'], [DOMTopLevelEventTypes.TOP_DROP, 'drop'], [DOMTopLevelEventTypes.TOP_FOCUS, 'focus'], [DOMTopLevelEventTypes.TOP_INPUT, 'input'], [DOMTopLevelEventTypes.TOP_INVALID, 'invalid'], [DOMTopLevelEventTypes.TOP_KEY_DOWN, 'keyDown'], [DOMTopLevelEventTypes.TOP_KEY_PRESS, 'keyPress'], [DOMTopLevelEventTypes.TOP_KEY_UP, 'keyUp'], [DOMTopLevelEventTypes.TOP_MOUSE_DOWN, 'mouseDown'], [DOMTopLevelEventTypes.TOP_MOUSE_UP, 'mouseUp'], [DOMTopLevelEventTypes.TOP_PASTE, 'paste'], [DOMTopLevelEventTypes.TOP_PAUSE, 'pause'], [DOMTopLevelEventTypes.TOP_PLAY, 'play'], [DOMTopLevelEventTypes.TOP_POINTER_CANCEL, 'pointerCancel'], [DOMTopLevelEventTypes.TOP_POINTER_DOWN, 'pointerDown'], [DOMTopLevelEventTypes.TOP_POINTER_UP, 'pointerUp'], [DOMTopLevelEventTypes.TOP_RATE_CHANGE, 'rateChange'], [DOMTopLevelEventTypes.TOP_RESET, 'reset'], [DOMTopLevelEventTypes.TOP_SEEKED, 'seeked'], [DOMTopLevelEventTypes.TOP_SUBMIT, 'submit'], [DOMTopLevelEventTypes.TOP_TOUCH_CANCEL, 'touchCancel'], [DOMTopLevelEventTypes.TOP_TOUCH_END, 'touchEnd'], [DOMTopLevelEventTypes.TOP_TOUCH_START, 'touchStart'], [DOMTopLevelEventTypes.TOP_VOLUME_CHANGE, 'volumeChange']];
var nonInteractiveEventTypeNames = [[DOMTopLevelEventTypes.TOP_ABORT, 'abort'], [DOMTopLevelEventTypes.TOP_ANIMATION_END, 'animationEnd'], [DOMTopLevelEventTypes.TOP_ANIMATION_ITERATION, 'animationIteration'], [DOMTopLevelEventTypes.TOP_ANIMATION_START, 'animationStart'], [DOMTopLevelEventTypes.TOP_CAN_PLAY, 'canPlay'], [DOMTopLevelEventTypes.TOP_CAN_PLAY_THROUGH, 'canPlayThrough'], [DOMTopLevelEventTypes.TOP_DRAG, 'drag'], [DOMTopLevelEventTypes.TOP_DRAG_ENTER, 'dragEnter'], [DOMTopLevelEventTypes.TOP_DRAG_EXIT, 'dragExit'], [DOMTopLevelEventTypes.TOP_DRAG_LEAVE, 'dragLeave'], [DOMTopLevelEventTypes.TOP_DRAG_OVER, 'dragOver'], [DOMTopLevelEventTypes.TOP_DURATION_CHANGE, 'durationChange'], [DOMTopLevelEventTypes.TOP_EMPTIED, 'emptied'], [DOMTopLevelEventTypes.TOP_ENCRYPTED, 'encrypted'], [DOMTopLevelEventTypes.TOP_ENDED, 'ended'], [DOMTopLevelEventTypes.TOP_ERROR, 'error'], [DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE, 'gotPointerCapture'], [DOMTopLevelEventTypes.TOP_LOAD, 'load'], [DOMTopLevelEventTypes.TOP_LOADED_DATA, 'loadedData'], [DOMTopLevelEventTypes.TOP_LOADED_METADATA, 'loadedMetadata'], [DOMTopLevelEventTypes.TOP_LOAD_START, 'loadStart'], [DOMTopLevelEventTypes.TOP_LOST_POINTER_CAPTURE, 'lostPointerCapture'], [DOMTopLevelEventTypes.TOP_MOUSE_MOVE, 'mouseMove'], [DOMTopLevelEventTypes.TOP_MOUSE_OUT, 'mouseOut'], [DOMTopLevelEventTypes.TOP_MOUSE_OVER, 'mouseOver'], [DOMTopLevelEventTypes.TOP_PLAYING, 'playing'], [DOMTopLevelEventTypes.TOP_POINTER_MOVE, 'pointerMove'], [DOMTopLevelEventTypes.TOP_POINTER_OUT, 'pointerOut'], [DOMTopLevelEventTypes.TOP_POINTER_OVER, 'pointerOver'], [DOMTopLevelEventTypes.TOP_PROGRESS, 'progress'], [DOMTopLevelEventTypes.TOP_SCROLL, 'scroll'], [DOMTopLevelEventTypes.TOP_SEEKING, 'seeking'], [DOMTopLevelEventTypes.TOP_STALLED, 'stalled'], [DOMTopLevelEventTypes.TOP_SUSPEND, 'suspend'], [DOMTopLevelEventTypes.TOP_TIME_UPDATE, 'timeUpdate'], [DOMTopLevelEventTypes.TOP_TOGGLE, 'toggle'], [DOMTopLevelEventTypes.TOP_TOUCH_MOVE, 'touchMove'], [DOMTopLevelEventTypes.TOP_TRANSITION_END, 'transitionEnd'], [DOMTopLevelEventTypes.TOP_WAITING, 'waiting'], [DOMTopLevelEventTypes.TOP_WHEEL, 'wheel']];

var eventTypes = {};
var topLevelEventsToDispatchConfig = {};

function addEventTypeNameToConfig(_ref, isInteractive) {
  var _ref2 = _slicedToArray(_ref, 2),
      topEvent = _ref2[0],
      event = _ref2[1];

  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent],
    isInteractive: isInteractive
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
}

interactiveEventTypeNames.forEach(function (eventTuple) {
  addEventTypeNameToConfig(eventTuple, true);
});
nonInteractiveEventTypeNames.forEach(function (eventTuple) {
  addEventTypeNameToConfig(eventTuple, false);
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = [DOMTopLevelEventTypes.TOP_ABORT, DOMTopLevelEventTypes.TOP_CANCEL, DOMTopLevelEventTypes.TOP_CAN_PLAY, DOMTopLevelEventTypes.TOP_CAN_PLAY_THROUGH, DOMTopLevelEventTypes.TOP_CLOSE, DOMTopLevelEventTypes.TOP_DURATION_CHANGE, DOMTopLevelEventTypes.TOP_EMPTIED, DOMTopLevelEventTypes.TOP_ENCRYPTED, DOMTopLevelEventTypes.TOP_ENDED, DOMTopLevelEventTypes.TOP_ERROR, DOMTopLevelEventTypes.TOP_INPUT, DOMTopLevelEventTypes.TOP_INVALID, DOMTopLevelEventTypes.TOP_LOAD, DOMTopLevelEventTypes.TOP_LOADED_DATA, DOMTopLevelEventTypes.TOP_LOADED_METADATA, DOMTopLevelEventTypes.TOP_LOAD_START, DOMTopLevelEventTypes.TOP_PAUSE, DOMTopLevelEventTypes.TOP_PLAY, DOMTopLevelEventTypes.TOP_PLAYING, DOMTopLevelEventTypes.TOP_PROGRESS, DOMTopLevelEventTypes.TOP_RATE_CHANGE, DOMTopLevelEventTypes.TOP_RESET, DOMTopLevelEventTypes.TOP_SEEKED, DOMTopLevelEventTypes.TOP_SEEKING, DOMTopLevelEventTypes.TOP_STALLED, DOMTopLevelEventTypes.TOP_SUBMIT, DOMTopLevelEventTypes.TOP_SUSPEND, DOMTopLevelEventTypes.TOP_TIME_UPDATE, DOMTopLevelEventTypes.TOP_TOGGLE, DOMTopLevelEventTypes.TOP_VOLUME_CHANGE, DOMTopLevelEventTypes.TOP_WAITING];

var SimpleEventPlugin = {
  eventTypes: eventTypes,

  isInteractiveTopLevelEventType: function isInteractiveTopLevelEventType(topLevelType) {
    var config = topLevelEventsToDispatchConfig[topLevelType];
    return config !== undefined && config.isInteractive === true;
  },


  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor = void 0;
    switch (topLevelType) {
      case DOMTopLevelEventTypes.TOP_KEY_PRESS:
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if ((0, _getEventCharCode2.default)(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case DOMTopLevelEventTypes.TOP_KEY_DOWN:
      case DOMTopLevelEventTypes.TOP_KEY_UP:
        EventConstructor = _SyntheticKeyboardEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_BLUR:
      case DOMTopLevelEventTypes.TOP_FOCUS:
        EventConstructor = _SyntheticFocusEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_CLICK:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case DOMTopLevelEventTypes.TOP_AUX_CLICK:
      case DOMTopLevelEventTypes.TOP_DOUBLE_CLICK:
      case DOMTopLevelEventTypes.TOP_MOUSE_DOWN:
      case DOMTopLevelEventTypes.TOP_MOUSE_MOVE:
      case DOMTopLevelEventTypes.TOP_MOUSE_UP:
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case DOMTopLevelEventTypes.TOP_MOUSE_OUT:
      case DOMTopLevelEventTypes.TOP_MOUSE_OVER:
      case DOMTopLevelEventTypes.TOP_CONTEXT_MENU:
        EventConstructor = _SyntheticMouseEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_DRAG:
      case DOMTopLevelEventTypes.TOP_DRAG_END:
      case DOMTopLevelEventTypes.TOP_DRAG_ENTER:
      case DOMTopLevelEventTypes.TOP_DRAG_EXIT:
      case DOMTopLevelEventTypes.TOP_DRAG_LEAVE:
      case DOMTopLevelEventTypes.TOP_DRAG_OVER:
      case DOMTopLevelEventTypes.TOP_DRAG_START:
      case DOMTopLevelEventTypes.TOP_DROP:
        EventConstructor = _SyntheticDragEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_TOUCH_CANCEL:
      case DOMTopLevelEventTypes.TOP_TOUCH_END:
      case DOMTopLevelEventTypes.TOP_TOUCH_MOVE:
      case DOMTopLevelEventTypes.TOP_TOUCH_START:
        EventConstructor = _SyntheticTouchEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_ANIMATION_END:
      case DOMTopLevelEventTypes.TOP_ANIMATION_ITERATION:
      case DOMTopLevelEventTypes.TOP_ANIMATION_START:
        EventConstructor = _SyntheticAnimationEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_TRANSITION_END:
        EventConstructor = _SyntheticTransitionEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_SCROLL:
        EventConstructor = _SyntheticUIEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_WHEEL:
        EventConstructor = _SyntheticWheelEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_COPY:
      case DOMTopLevelEventTypes.TOP_CUT:
      case DOMTopLevelEventTypes.TOP_PASTE:
        EventConstructor = _SyntheticClipboardEvent2.default;
        break;
      case DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE:
      case DOMTopLevelEventTypes.TOP_LOST_POINTER_CAPTURE:
      case DOMTopLevelEventTypes.TOP_POINTER_CANCEL:
      case DOMTopLevelEventTypes.TOP_POINTER_DOWN:
      case DOMTopLevelEventTypes.TOP_POINTER_MOVE:
      case DOMTopLevelEventTypes.TOP_POINTER_OUT:
      case DOMTopLevelEventTypes.TOP_POINTER_OVER:
      case DOMTopLevelEventTypes.TOP_POINTER_UP:
        EventConstructor = _SyntheticPointerEvent2.default;
        break;
      default:
        if (true) {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            (0, _warningWithoutStack2.default)(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = _SyntheticEvent2.default;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    (0, _EventPropagators.accumulateTwoPhaseDispatches)(event);
    return event;
  }
};

exports.default = SimpleEventPlugin;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getActiveElement;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

module.exports = ReactFiberInstrumentation;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.markPendingPriorityLevel = markPendingPriorityLevel;
exports.markCommittedPriorityLevels = markCommittedPriorityLevels;
exports.hasLowerPriorityWork = hasLowerPriorityWork;
exports.isPriorityLevelSuspended = isPriorityLevelSuspended;
exports.markSuspendedPriorityLevel = markSuspendedPriorityLevel;
exports.markPingedPriorityLevel = markPingedPriorityLevel;
exports.findEarliestOutstandingPriorityLevel = findEarliestOutstandingPriorityLevel;
exports.didExpireAtExpirationTime = didExpireAtExpirationTime;

var _ReactFiberExpirationTime = __webpack_require__(9);

// TODO: Offscreen updates should never suspend. However, a promise that
// suspended inside an offscreen subtree should be able to ping at the priority
// of the outer render.

function markPendingPriorityLevel(root, expirationTime) {
  // If there's a gap between completing a failed root and retrying it,
  // additional updates may be scheduled. Clear `didError`, in case the update
  // is sufficient to fix the error.
  root.didError = false;

  // Update the latest and earliest pending times
  var earliestPendingTime = root.earliestPendingTime;
  if (earliestPendingTime === _ReactFiberExpirationTime.NoWork) {
    // No other pending updates.
    root.earliestPendingTime = root.latestPendingTime = expirationTime;
  } else {
    if (earliestPendingTime < expirationTime) {
      // This is the earliest pending update.
      root.earliestPendingTime = expirationTime;
    } else {
      var latestPendingTime = root.latestPendingTime;
      if (latestPendingTime > expirationTime) {
        // This is the latest pending update
        root.latestPendingTime = expirationTime;
      }
    }
  }
  findNextExpirationTimeToWorkOn(expirationTime, root);
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

function markCommittedPriorityLevels(root, earliestRemainingTime) {
  root.didError = false;

  if (earliestRemainingTime === _ReactFiberExpirationTime.NoWork) {
    // Fast path. There's no remaining work. Clear everything.
    root.earliestPendingTime = _ReactFiberExpirationTime.NoWork;
    root.latestPendingTime = _ReactFiberExpirationTime.NoWork;
    root.earliestSuspendedTime = _ReactFiberExpirationTime.NoWork;
    root.latestSuspendedTime = _ReactFiberExpirationTime.NoWork;
    root.latestPingedTime = _ReactFiberExpirationTime.NoWork;
    findNextExpirationTimeToWorkOn(_ReactFiberExpirationTime.NoWork, root);
    return;
  }

  if (earliestRemainingTime < root.latestPingedTime) {
    root.latestPingedTime = _ReactFiberExpirationTime.NoWork;
  }

  // Let's see if the previous latest known pending level was just flushed.
  var latestPendingTime = root.latestPendingTime;
  if (latestPendingTime !== _ReactFiberExpirationTime.NoWork) {
    if (latestPendingTime > earliestRemainingTime) {
      // We've flushed all the known pending levels.
      root.earliestPendingTime = root.latestPendingTime = _ReactFiberExpirationTime.NoWork;
    } else {
      var earliestPendingTime = root.earliestPendingTime;
      if (earliestPendingTime > earliestRemainingTime) {
        // We've flushed the earliest known pending level. Set this to the
        // latest pending time.
        root.earliestPendingTime = root.latestPendingTime;
      }
    }
  }

  // Now let's handle the earliest remaining level in the whole tree. We need to
  // decide whether to treat it as a pending level or as suspended. Check
  // it falls within the range of known suspended levels.

  var earliestSuspendedTime = root.earliestSuspendedTime;
  if (earliestSuspendedTime === _ReactFiberExpirationTime.NoWork) {
    // There's no suspended work. Treat the earliest remaining level as a
    // pending level.
    markPendingPriorityLevel(root, earliestRemainingTime);
    findNextExpirationTimeToWorkOn(_ReactFiberExpirationTime.NoWork, root);
    return;
  }

  var latestSuspendedTime = root.latestSuspendedTime;
  if (earliestRemainingTime < latestSuspendedTime) {
    // The earliest remaining level is later than all the suspended work. That
    // means we've flushed all the suspended work.
    root.earliestSuspendedTime = _ReactFiberExpirationTime.NoWork;
    root.latestSuspendedTime = _ReactFiberExpirationTime.NoWork;
    root.latestPingedTime = _ReactFiberExpirationTime.NoWork;

    // There's no suspended work. Treat the earliest remaining level as a
    // pending level.
    markPendingPriorityLevel(root, earliestRemainingTime);
    findNextExpirationTimeToWorkOn(_ReactFiberExpirationTime.NoWork, root);
    return;
  }

  if (earliestRemainingTime > earliestSuspendedTime) {
    // The earliest remaining time is earlier than all the suspended work.
    // Treat it as a pending update.
    markPendingPriorityLevel(root, earliestRemainingTime);
    findNextExpirationTimeToWorkOn(_ReactFiberExpirationTime.NoWork, root);
    return;
  }

  // The earliest remaining time falls within the range of known suspended
  // levels. We should treat this as suspended work.
  findNextExpirationTimeToWorkOn(_ReactFiberExpirationTime.NoWork, root);
}

function hasLowerPriorityWork(root, erroredExpirationTime) {
  var latestPendingTime = root.latestPendingTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  var latestPingedTime = root.latestPingedTime;
  return latestPendingTime !== _ReactFiberExpirationTime.NoWork && latestPendingTime < erroredExpirationTime || latestSuspendedTime !== _ReactFiberExpirationTime.NoWork && latestSuspendedTime < erroredExpirationTime || latestPingedTime !== _ReactFiberExpirationTime.NoWork && latestPingedTime < erroredExpirationTime;
}

function isPriorityLevelSuspended(root, expirationTime) {
  var earliestSuspendedTime = root.earliestSuspendedTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  return earliestSuspendedTime !== _ReactFiberExpirationTime.NoWork && expirationTime <= earliestSuspendedTime && expirationTime >= latestSuspendedTime;
}

function markSuspendedPriorityLevel(root, suspendedTime) {
  root.didError = false;
  clearPing(root, suspendedTime);

  // First, check the known pending levels and update them if needed.
  var earliestPendingTime = root.earliestPendingTime;
  var latestPendingTime = root.latestPendingTime;
  if (earliestPendingTime === suspendedTime) {
    if (latestPendingTime === suspendedTime) {
      // Both known pending levels were suspended. Clear them.
      root.earliestPendingTime = root.latestPendingTime = _ReactFiberExpirationTime.NoWork;
    } else {
      // The earliest pending level was suspended. Clear by setting it to the
      // latest pending level.
      root.earliestPendingTime = latestPendingTime;
    }
  } else if (latestPendingTime === suspendedTime) {
    // The latest pending level was suspended. Clear by setting it to the
    // latest pending level.
    root.latestPendingTime = earliestPendingTime;
  }

  // Finally, update the known suspended levels.
  var earliestSuspendedTime = root.earliestSuspendedTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  if (earliestSuspendedTime === _ReactFiberExpirationTime.NoWork) {
    // No other suspended levels.
    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
  } else {
    if (earliestSuspendedTime < suspendedTime) {
      // This is the earliest suspended level.
      root.earliestSuspendedTime = suspendedTime;
    } else if (latestSuspendedTime > suspendedTime) {
      // This is the latest suspended level
      root.latestSuspendedTime = suspendedTime;
    }
  }

  findNextExpirationTimeToWorkOn(suspendedTime, root);
}

function markPingedPriorityLevel(root, pingedTime) {
  root.didError = false;

  // TODO: When we add back resuming, we need to ensure the progressed work
  // is thrown out and not reused during the restarted render. One way to
  // invalidate the progressed work is to restart at expirationTime + 1.
  var latestPingedTime = root.latestPingedTime;
  if (latestPingedTime === _ReactFiberExpirationTime.NoWork || latestPingedTime > pingedTime) {
    root.latestPingedTime = pingedTime;
  }
  findNextExpirationTimeToWorkOn(pingedTime, root);
}

function clearPing(root, completedTime) {
  var latestPingedTime = root.latestPingedTime;
  if (latestPingedTime >= completedTime) {
    root.latestPingedTime = _ReactFiberExpirationTime.NoWork;
  }
}

function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
  var earliestExpirationTime = renderExpirationTime;

  var earliestPendingTime = root.earliestPendingTime;
  var earliestSuspendedTime = root.earliestSuspendedTime;
  if (earliestPendingTime > earliestExpirationTime) {
    earliestExpirationTime = earliestPendingTime;
  }
  if (earliestSuspendedTime > earliestExpirationTime) {
    earliestExpirationTime = earliestSuspendedTime;
  }
  return earliestExpirationTime;
}

function didExpireAtExpirationTime(root, currentTime) {
  var expirationTime = root.expirationTime;
  if (expirationTime !== _ReactFiberExpirationTime.NoWork && currentTime <= expirationTime) {
    // The root has expired. Flush all work up to the current time.
    root.nextExpirationTimeToWorkOn = currentTime;
  }
}

function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
  var earliestSuspendedTime = root.earliestSuspendedTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  var earliestPendingTime = root.earliestPendingTime;
  var latestPingedTime = root.latestPingedTime;

  // Work on the earliest pending time. Failing that, work on the latest
  // pinged time.
  var nextExpirationTimeToWorkOn = earliestPendingTime !== _ReactFiberExpirationTime.NoWork ? earliestPendingTime : latestPingedTime;

  // If there is no pending or pinged work, check if there's suspended work
  // that's lower priority than what we just completed.
  if (nextExpirationTimeToWorkOn === _ReactFiberExpirationTime.NoWork && (completedExpirationTime === _ReactFiberExpirationTime.NoWork || latestSuspendedTime < completedExpirationTime)) {
    // The lowest priority suspended work is the work most likely to be
    // committed next. Let's start rendering it again, so that if it times out,
    // it's ready to commit.
    nextExpirationTimeToWorkOn = latestSuspendedTime;
  }

  var expirationTime = nextExpirationTimeToWorkOn;
  if (expirationTime !== _ReactFiberExpirationTime.NoWork && earliestSuspendedTime > expirationTime) {
    // Expire using the earliest known expiration time.
    expirationTime = earliestSuspendedTime;
  }

  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
  root.expirationTime = expirationTime;
}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateClassInstance = exports.resumeMountClassInstance = exports.mountClassInstance = exports.constructClassInstance = exports.adoptClassInstance = exports.emptyRefsObject = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.applyDerivedStateFromProps = applyDerivedStateFromProps;

var _react = __webpack_require__(22);

var _react2 = _interopRequireDefault(_react);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactFeatureFlags = __webpack_require__(3);

var _ReactStrictModeWarnings = __webpack_require__(56);

var _ReactStrictModeWarnings2 = _interopRequireDefault(_ReactStrictModeWarnings);

var _reflection = __webpack_require__(36);

var _ReactInstanceMap = __webpack_require__(37);

var _shallowEqual = __webpack_require__(52);

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactSymbols = __webpack_require__(6);

var _ReactDebugFiberPerf = __webpack_require__(29);

var _ReactFiberLazyComponent = __webpack_require__(57);

var _ReactTypeOfMode = __webpack_require__(13);

var _ReactUpdateQueue = __webpack_require__(18);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactFiberContext = __webpack_require__(21);

var _ReactFiberNewContext = __webpack_require__(19);

var _ReactFiberScheduler = __webpack_require__(31);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fakeInternalInstance = {};
var isArray = Array.isArray;

// React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.
var emptyRefsObject = exports.emptyRefsObject = new _react2.default.Component().refs;

var didWarnAboutStateAssignmentForComponent = void 0;
var didWarnAboutUninitializedState = void 0;
var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
var didWarnAboutUndefinedDerivedState = void 0;
var warnOnUndefinedDerivedState = void 0;
var warnOnInvalidCallback = void 0;
var didWarnAboutDirectlyAssigningPropsToState = void 0;
var didWarnAboutContextTypeAndContextTypes = void 0;
var didWarnAboutInvalidateContextType = void 0;

if (true) {
  didWarnAboutStateAssignmentForComponent = new Set();
  didWarnAboutUninitializedState = new Set();
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
  didWarnAboutDirectlyAssigningPropsToState = new Set();
  didWarnAboutUndefinedDerivedState = new Set();
  didWarnAboutContextTypeAndContextTypes = new Set();
  didWarnAboutInvalidateContextType = new Set();

  var didWarnOnInvalidCallback = new Set();

  warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
    if (callback === null || typeof callback === 'function') {
      return;
    }
    var key = callerName + '_' + callback;
    if (!didWarnOnInvalidCallback.has(key)) {
      didWarnOnInvalidCallback.add(key);
      (0, _warningWithoutStack2.default)(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  };

  warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
    if (partialState === undefined) {
      var componentName = (0, _getComponentName2.default)(type) || 'Component';
      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
        didWarnAboutUndefinedDerivedState.add(componentName);
        (0, _warningWithoutStack2.default)(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
      }
    }
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function value() {
      (0, _invariant2.default)(false, '_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  var prevState = workInProgress.memoizedState;

  if (true) {
    if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
      // Invoke the function an extra time to help detect side-effects.
      getDerivedStateFromProps(nextProps, prevState);
    }
  }

  var partialState = getDerivedStateFromProps(nextProps, prevState);

  if (true) {
    warnOnUndefinedDerivedState(ctor, partialState);
  }
  // Merge the partial state and the previous state.
  var memoizedState = partialState === null || partialState === undefined ? prevState : Object.assign({}, prevState, partialState);
  workInProgress.memoizedState = memoizedState;

  // Once the update queue is empty, persist the derived state onto the
  // base state.
  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null && workInProgress.expirationTime === _ReactFiberExpirationTime.NoWork) {
    updateQueue.baseState = memoizedState;
  }
}

var classComponentUpdater = {
  isMounted: _reflection.isMounted,
  enqueueSetState: function enqueueSetState(inst, payload, callback) {
    var fiber = (0, _ReactInstanceMap.get)(inst);
    var currentTime = (0, _ReactFiberScheduler.requestCurrentTime)();
    var expirationTime = (0, _ReactFiberScheduler.computeExpirationForFiber)(currentTime, fiber);

    var update = (0, _ReactUpdateQueue.createUpdate)(expirationTime);
    update.payload = payload;
    if (callback !== undefined && callback !== null) {
      if (true) {
        warnOnInvalidCallback(callback, 'setState');
      }
      update.callback = callback;
    }

    (0, _ReactFiberScheduler.flushPassiveEffects)();
    (0, _ReactUpdateQueue.enqueueUpdate)(fiber, update);
    (0, _ReactFiberScheduler.scheduleWork)(fiber, expirationTime);
  },
  enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
    var fiber = (0, _ReactInstanceMap.get)(inst);
    var currentTime = (0, _ReactFiberScheduler.requestCurrentTime)();
    var expirationTime = (0, _ReactFiberScheduler.computeExpirationForFiber)(currentTime, fiber);

    var update = (0, _ReactUpdateQueue.createUpdate)(expirationTime);
    update.tag = _ReactUpdateQueue.ReplaceState;
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      if (true) {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      update.callback = callback;
    }

    (0, _ReactFiberScheduler.flushPassiveEffects)();
    (0, _ReactUpdateQueue.enqueueUpdate)(fiber, update);
    (0, _ReactFiberScheduler.scheduleWork)(fiber, expirationTime);
  },
  enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
    var fiber = (0, _ReactInstanceMap.get)(inst);
    var currentTime = (0, _ReactFiberScheduler.requestCurrentTime)();
    var expirationTime = (0, _ReactFiberScheduler.computeExpirationForFiber)(currentTime, fiber);

    var update = (0, _ReactUpdateQueue.createUpdate)(expirationTime);
    update.tag = _ReactUpdateQueue.ForceUpdate;

    if (callback !== undefined && callback !== null) {
      if (true) {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      update.callback = callback;
    }

    (0, _ReactFiberScheduler.flushPassiveEffects)();
    (0, _ReactUpdateQueue.enqueueUpdate)(fiber, update);
    (0, _ReactFiberScheduler.scheduleWork)(fiber, expirationTime);
  }
};

function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
  var instance = workInProgress.stateNode;
  if (typeof instance.shouldComponentUpdate === 'function') {
    (0, _ReactDebugFiberPerf.startPhaseTimer)(workInProgress, 'shouldComponentUpdate');
    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
    (0, _ReactDebugFiberPerf.stopPhaseTimer)();

    if (true) {
      (0, _warningWithoutStack2.default)(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', (0, _getComponentName2.default)(ctor) || 'Component');
    }

    return shouldUpdate;
  }

  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return !(0, _shallowEqual2.default)(oldProps, newProps) || !(0, _shallowEqual2.default)(oldState, newState);
  }

  return true;
}

function checkClassInstance(workInProgress, ctor, newProps) {
  var instance = workInProgress.stateNode;
  if (true) {
    var name = (0, _getComponentName2.default)(ctor) || 'Component';
    var renderPresent = instance.render;

    if (!renderPresent) {
      if (ctor.prototype && typeof ctor.prototype.render === 'function') {
        (0, _warningWithoutStack2.default)(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
      } else {
        (0, _warningWithoutStack2.default)(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
      }
    }

    var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
    (0, _warningWithoutStack2.default)(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
    var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
    (0, _warningWithoutStack2.default)(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
    var noInstancePropTypes = !instance.propTypes;
    (0, _warningWithoutStack2.default)(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
    var noInstanceContextType = !instance.contextType;
    (0, _warningWithoutStack2.default)(noInstanceContextType, 'contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);
    var noInstanceContextTypes = !instance.contextTypes;
    (0, _warningWithoutStack2.default)(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);

    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
      didWarnAboutContextTypeAndContextTypes.add(ctor);
      (0, _warningWithoutStack2.default)(false, '%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
    }

    var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
    (0, _warningWithoutStack2.default)(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
      (0, _warningWithoutStack2.default)(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', (0, _getComponentName2.default)(ctor) || 'A pure component');
    }
    var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
    (0, _warningWithoutStack2.default)(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
    var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
    (0, _warningWithoutStack2.default)(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
    var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
    (0, _warningWithoutStack2.default)(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
    var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';
    (0, _warningWithoutStack2.default)(noUnsafeComponentWillRecieveProps, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);
    var hasMutatedProps = instance.props !== newProps;
    (0, _warningWithoutStack2.default)(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
    var noInstanceDefaultProps = !instance.defaultProps;
    (0, _warningWithoutStack2.default)(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);

    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
      (0, _warningWithoutStack2.default)(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', (0, _getComponentName2.default)(ctor));
    }

    var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';
    (0, _warningWithoutStack2.default)(noInstanceGetDerivedStateFromProps, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== 'function';
    (0, _warningWithoutStack2.default)(noInstanceGetDerivedStateFromCatch, '%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== 'function';
    (0, _warningWithoutStack2.default)(noStaticGetSnapshotBeforeUpdate, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);
    var _state = instance.state;
    if (_state && ((typeof _state === 'undefined' ? 'undefined' : _typeof(_state)) !== 'object' || isArray(_state))) {
      (0, _warningWithoutStack2.default)(false, '%s.state: must be set to an object or null', name);
    }
    if (typeof instance.getChildContext === 'function') {
      (0, _warningWithoutStack2.default)(_typeof(ctor.childContextTypes) === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);
    }
  }
}

function adoptClassInstance(workInProgress, instance) {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance;
  // The instance needs access to the fiber so that it can schedule updates
  (0, _ReactInstanceMap.set)(instance, workInProgress);
  if (true) {
    instance._reactInternalInstance = fakeInternalInstance;
  }
}

function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
  var isLegacyContextConsumer = false;
  var unmaskedContext = _ReactFiberContext.emptyContextObject;
  var context = null;
  var contextType = ctor.contextType;
  if ((typeof contextType === 'undefined' ? 'undefined' : _typeof(contextType)) === 'object' && contextType !== null) {
    if (true) {
      if (contextType.$$typeof !== _ReactSymbols.REACT_CONTEXT_TYPE && !didWarnAboutInvalidateContextType.has(ctor)) {
        didWarnAboutInvalidateContextType.add(ctor);
        (0, _warningWithoutStack2.default)(false, '%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext(). ' + 'Did you accidentally pass the Context.Provider instead?', (0, _getComponentName2.default)(ctor) || 'Component');
      }
    }

    context = (0, _ReactFiberNewContext.readContext)(contextType);
  } else {
    unmaskedContext = (0, _ReactFiberContext.getUnmaskedContext)(workInProgress, ctor, true);
    var contextTypes = ctor.contextTypes;
    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
    context = isLegacyContextConsumer ? (0, _ReactFiberContext.getMaskedContext)(workInProgress, unmaskedContext) : _ReactFiberContext.emptyContextObject;
  }

  // Instantiate twice to help detect side-effects.
  if (true) {
    if (_ReactFeatureFlags.debugRenderPhaseSideEffects || _ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & _ReactTypeOfMode.StrictMode) {
      new ctor(props, context); // eslint-disable-line no-new
    }
  }

  var instance = new ctor(props, context);
  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
  adoptClassInstance(workInProgress, instance);

  if (true) {
    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
      var componentName = (0, _getComponentName2.default)(ctor) || 'Component';
      if (!didWarnAboutUninitializedState.has(componentName)) {
        didWarnAboutUninitializedState.add(componentName);
        (0, _warningWithoutStack2.default)(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
      }
    }

    // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Warn about these lifecycles if they are present.
    // Don't warn about react-lifecycles-compat polyfilled methods though.
    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
      var foundWillMountName = null;
      var foundWillReceivePropsName = null;
      var foundWillUpdateName = null;
      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
        foundWillMountName = 'componentWillMount';
      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
        foundWillMountName = 'UNSAFE_componentWillMount';
      }
      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
        foundWillReceivePropsName = 'componentWillReceiveProps';
      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
      }
      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
        foundWillUpdateName = 'componentWillUpdate';
      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
      }
      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var _componentName = (0, _getComponentName2.default)(ctor) || 'Component';
        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
          (0, _warningWithoutStack2.default)(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '');
        }
      }
    }
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // ReactFiberContext usually updates this cache but can't for newly-created instances.
  if (isLegacyContextConsumer) {
    (0, _ReactFiberContext.cacheContext)(workInProgress, unmaskedContext, context);
  }

  return instance;
}

function callComponentWillMount(workInProgress, instance) {
  (0, _ReactDebugFiberPerf.startPhaseTimer)(workInProgress, 'componentWillMount');
  var oldState = instance.state;

  if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  }
  if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  (0, _ReactDebugFiberPerf.stopPhaseTimer)();

  if (oldState !== instance.state) {
    if (true) {
      (0, _warningWithoutStack2.default)(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', (0, _getComponentName2.default)(workInProgress.type) || 'Component');
    }
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
  var oldState = instance.state;
  (0, _ReactDebugFiberPerf.startPhaseTimer)(workInProgress, 'componentWillReceiveProps');
  if (typeof instance.componentWillReceiveProps === 'function') {
    instance.componentWillReceiveProps(newProps, nextContext);
  }
  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  }
  (0, _ReactDebugFiberPerf.stopPhaseTimer)();

  if (instance.state !== oldState) {
    if (true) {
      var componentName = (0, _getComponentName2.default)(workInProgress.type) || 'Component';
      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
        didWarnAboutStateAssignmentForComponent.add(componentName);
        (0, _warningWithoutStack2.default)(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
      }
    }
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
  if (true) {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  var instance = workInProgress.stateNode;
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;

  var contextType = ctor.contextType;
  if ((typeof contextType === 'undefined' ? 'undefined' : _typeof(contextType)) === 'object' && contextType !== null) {
    instance.context = (0, _ReactFiberNewContext.readContext)(contextType);
  } else {
    var unmaskedContext = (0, _ReactFiberContext.getUnmaskedContext)(workInProgress, ctor, true);
    instance.context = (0, _ReactFiberContext.getMaskedContext)(workInProgress, unmaskedContext);
  }

  if (true) {
    if (instance.state === newProps) {
      var componentName = (0, _getComponentName2.default)(ctor) || 'Component';
      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
        (0, _warningWithoutStack2.default)(false, '%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
      }
    }

    if (workInProgress.mode & _ReactTypeOfMode.StrictMode) {
      _ReactStrictModeWarnings2.default.recordUnsafeLifecycleWarnings(workInProgress, instance);

      _ReactStrictModeWarnings2.default.recordLegacyContextWarning(workInProgress, instance);
    }

    if (_ReactFeatureFlags.warnAboutDeprecatedLifecycles) {
      _ReactStrictModeWarnings2.default.recordDeprecationWarnings(workInProgress, instance);
    }
  }

  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    (0, _ReactUpdateQueue.processUpdateQueue)(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
    instance.state = workInProgress.memoizedState;
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    instance.state = workInProgress.memoizedState;
  }

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
    callComponentWillMount(workInProgress, instance);
    // If we had additional state updates during this life-cycle, let's
    // process them now.
    updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      (0, _ReactUpdateQueue.processUpdateQueue)(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
      instance.state = workInProgress.memoizedState;
    }
  }

  if (typeof instance.componentDidMount === 'function') {
    workInProgress.effectTag |= _ReactSideEffectTags.Update;
  }
}

function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
  var instance = workInProgress.stateNode;

  var oldProps = workInProgress.memoizedProps;
  instance.props = oldProps;

  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = void 0;
  if ((typeof contextType === 'undefined' ? 'undefined' : _typeof(contextType)) === 'object' && contextType !== null) {
    nextContext = (0, _ReactFiberNewContext.readContext)(contextType);
  } else {
    var nextLegacyUnmaskedContext = (0, _ReactFiberContext.getUnmaskedContext)(workInProgress, ctor, true);
    nextContext = (0, _ReactFiberContext.getMaskedContext)(workInProgress, nextLegacyUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';

  // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  (0, _ReactUpdateQueue.resetHasForceUpdateBeforeProcessing)();

  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    (0, _ReactUpdateQueue.processUpdateQueue)(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
    newState = workInProgress.memoizedState;
  }
  if (oldProps === newProps && oldState === newState && !(0, _ReactFiberContext.hasContextChanged)() && !(0, _ReactUpdateQueue.checkHasForceUpdateAfterProcessing)()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= _ReactSideEffectTags.Update;
    }
    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = (0, _ReactUpdateQueue.checkHasForceUpdateAfterProcessing)() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
      (0, _ReactDebugFiberPerf.startPhaseTimer)(workInProgress, 'componentWillMount');
      if (typeof instance.componentWillMount === 'function') {
        instance.componentWillMount();
      }
      if (typeof instance.UNSAFE_componentWillMount === 'function') {
        instance.UNSAFE_componentWillMount();
      }
      (0, _ReactDebugFiberPerf.stopPhaseTimer)();
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= _ReactSideEffectTags.Update;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= _ReactSideEffectTags.Update;
    }

    // If shouldComponentUpdate returned false, we should still update the
    // memoized state to indicate that this work can be reused.
    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  }

  // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.
  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;

  return shouldUpdate;
}

// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
  var instance = workInProgress.stateNode;

  var oldProps = workInProgress.memoizedProps;
  instance.props = workInProgress.type === workInProgress.elementType ? oldProps : (0, _ReactFiberLazyComponent.resolveDefaultProps)(workInProgress.type, oldProps);

  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = void 0;
  if ((typeof contextType === 'undefined' ? 'undefined' : _typeof(contextType)) === 'object' && contextType !== null) {
    nextContext = (0, _ReactFiberNewContext.readContext)(contextType);
  } else {
    var nextUnmaskedContext = (0, _ReactFiberContext.getUnmaskedContext)(workInProgress, ctor, true);
    nextContext = (0, _ReactFiberContext.getMaskedContext)(workInProgress, nextUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';

  // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  (0, _ReactUpdateQueue.resetHasForceUpdateBeforeProcessing)();

  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    (0, _ReactUpdateQueue.processUpdateQueue)(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
    newState = workInProgress.memoizedState;
  }

  if (oldProps === newProps && oldState === newState && !(0, _ReactFiberContext.hasContextChanged)() && !(0, _ReactUpdateQueue.checkHasForceUpdateAfterProcessing)()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= _ReactSideEffectTags.Update;
      }
    }
    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= _ReactSideEffectTags.Snapshot;
      }
    }
    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = (0, _ReactUpdateQueue.checkHasForceUpdateAfterProcessing)() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
      (0, _ReactDebugFiberPerf.startPhaseTimer)(workInProgress, 'componentWillUpdate');
      if (typeof instance.componentWillUpdate === 'function') {
        instance.componentWillUpdate(newProps, newState, nextContext);
      }
      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
      }
      (0, _ReactDebugFiberPerf.stopPhaseTimer)();
    }
    if (typeof instance.componentDidUpdate === 'function') {
      workInProgress.effectTag |= _ReactSideEffectTags.Update;
    }
    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      workInProgress.effectTag |= _ReactSideEffectTags.Snapshot;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= _ReactSideEffectTags.Update;
      }
    }
    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= _ReactSideEffectTags.Snapshot;
      }
    }

    // If shouldComponentUpdate returned false, we should still update the
    // memoized props/state to indicate that this work can be reused.
    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  }

  // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.
  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;

  return shouldUpdate;
}

exports.adoptClassInstance = adoptClassInstance;
exports.constructClassInstance = constructClassInstance;
exports.mountClassInstance = mountClassInstance;
exports.resumeMountClassInstance = resumeMountClassInstance;
exports.updateClassInstance = updateClassInstance;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextOnlyDispatcher = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) 2013-present, Facebook, Inc.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.renderWithHooks = renderWithHooks;
exports.bailoutHooks = bailoutHooks;
exports.resetHooks = resetHooks;

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactFiberNewContext = __webpack_require__(19);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactHookEffectTags = __webpack_require__(83);

var _ReactFiberScheduler = __webpack_require__(31);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _objectIs = __webpack_require__(53);

var _objectIs2 = _interopRequireDefault(_objectIs);

var _ReactFiberBeginWork = __webpack_require__(40);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ReactCurrentDispatcher = _ReactSharedInternals2.default.ReactCurrentDispatcher;


var didWarnAboutMismatchedHooksForComponent = void 0;
if (true) {
  didWarnAboutMismatchedHooksForComponent = new Set();
}

// These are set right before calling the component.
var renderExpirationTime = _ReactFiberExpirationTime.NoWork;
// The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.
var currentlyRenderingFiber = null;

// Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.
var firstCurrentHook = null;
var currentHook = null;
var nextCurrentHook = null;
var firstWorkInProgressHook = null;
var workInProgressHook = null;
var nextWorkInProgressHook = null;

var remainingExpirationTime = _ReactFiberExpirationTime.NoWork;
var componentUpdateQueue = null;
var sideEffectTag = 0;

// Updates scheduled during render will trigger an immediate re-render at the
// end of the current pass. We can't store these updates on the normal queue,
// because if the work is aborted, they should be discarded. Because this is
// a relatively rare case, we also don't want to add an additional field to
// either the hook or queue object types. So we store them in a lazily create
// map of queue -> render-phase updates, which are discarded once the component
// completes without re-rendering.

// Whether an update was scheduled during the currently executing render pass.
var didScheduleRenderPhaseUpdate = false;
// Lazily created map of render-phase updates
var renderPhaseUpdates = null;
// Counter to prevent infinite loops.
var numberOfReRenders = 0;
var RE_RENDER_LIMIT = 25;

// In DEV, this is the name of the currently executing primitive hook
var currentHookNameInDev = null;

function warnOnHookMismatchInDev() {
  if (true) {
    var componentName = (0, _getComponentName2.default)(currentlyRenderingFiber.type);
    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
      didWarnAboutMismatchedHooksForComponent.add(componentName);

      var secondColumnStart = 22;

      var table = '';
      var prevHook = firstCurrentHook;
      var nextHook = firstWorkInProgressHook;
      var n = 1;
      while (prevHook !== null && nextHook !== null) {
        var oldHookName = prevHook._debugType;
        var newHookName = nextHook._debugType;

        var row = n + '. ' + oldHookName;

        // Extra space so second column lines up
        // lol @ IE not supporting String#repeat
        while (row.length < secondColumnStart) {
          row += ' ';
        }

        row += newHookName + '\n';

        table += row;
        prevHook = prevHook.next;
        nextHook = nextHook.next;
        n++;
      }

      (0, _warning2.default)(false, 'React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n' + '   Previous render    Next render\n' + '   -------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
    }
  }
}

function throwInvalidHookError() {
  (0, _invariant2.default)(false, 'Hooks can only be called inside the body of a function component. ' + '(https://fb.me/react-invalid-hook-call)');
}

function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) {
    if (true) {
      (0, _warning2.default)(false, '%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }
    return false;
  }

  if (true) {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      (0, _warning2.default)(false, 'The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, '[' + nextDeps.join(', ') + ']', '[' + prevDeps.join(', ') + ']');
    }
  }
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if ((0, _objectIs2.default)(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }
  return true;
}

function renderWithHooks(current, workInProgress, Component, props, refOrContext, nextRenderExpirationTime) {
  renderExpirationTime = nextRenderExpirationTime;
  currentlyRenderingFiber = workInProgress;
  firstCurrentHook = nextCurrentHook = current !== null ? current.memoizedState : null;

  // The following should have already been reset
  // currentHook = null;
  // workInProgressHook = null;

  // remainingExpirationTime = NoWork;
  // componentUpdateQueue = null;

  // didScheduleRenderPhaseUpdate = false;
  // renderPhaseUpdates = null;
  // numberOfReRenders = 0;
  // sideEffectTag = 0;

  if (true) {
    ReactCurrentDispatcher.current = nextCurrentHook === null ? HooksDispatcherOnMountInDEV : HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = nextCurrentHook === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
  }

  var children = Component(props, refOrContext);

  if (didScheduleRenderPhaseUpdate) {
    do {
      didScheduleRenderPhaseUpdate = false;
      numberOfReRenders += 1;

      // Start over from the beginning of the list
      firstCurrentHook = nextCurrentHook = current !== null ? current.memoizedState : null;
      nextWorkInProgressHook = firstWorkInProgressHook;

      currentHook = null;
      workInProgressHook = null;
      componentUpdateQueue = null;

      ReactCurrentDispatcher.current =  true ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnUpdate;

      children = Component(props, refOrContext);
    } while (didScheduleRenderPhaseUpdate);

    renderPhaseUpdates = null;
    numberOfReRenders = 0;
  }

  if (true) {
    currentHookNameInDev = null;
  }

  // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher.current = ContextOnlyDispatcher;

  var renderedWork = currentlyRenderingFiber;

  renderedWork.memoizedState = firstWorkInProgressHook;
  renderedWork.expirationTime = remainingExpirationTime;
  renderedWork.updateQueue = componentUpdateQueue;
  renderedWork.effectTag |= sideEffectTag;

  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;

  renderExpirationTime = _ReactFiberExpirationTime.NoWork;
  currentlyRenderingFiber = null;

  firstCurrentHook = null;
  currentHook = null;
  nextCurrentHook = null;
  firstWorkInProgressHook = null;
  workInProgressHook = null;
  nextWorkInProgressHook = null;

  remainingExpirationTime = _ReactFiberExpirationTime.NoWork;
  componentUpdateQueue = null;
  sideEffectTag = 0;

  // These were reset above
  // didScheduleRenderPhaseUpdate = false;
  // renderPhaseUpdates = null;
  // numberOfReRenders = 0;

  (0, _invariant2.default)(!didRenderTooFewHooks, 'Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');

  return children;
}

function bailoutHooks(current, workInProgress, expirationTime) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.effectTag &= ~(_ReactSideEffectTags.Passive | _ReactSideEffectTags.Update);
  if (current.expirationTime <= expirationTime) {
    current.expirationTime = _ReactFiberExpirationTime.NoWork;
  }
}

function resetHooks() {
  // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher.current = ContextOnlyDispatcher;

  // This is used to reset the state of this module when a component throws.
  // It's also called inside mountIndeterminateComponent if we determine the
  // component is a module-style component.
  renderExpirationTime = _ReactFiberExpirationTime.NoWork;
  currentlyRenderingFiber = null;

  firstCurrentHook = null;
  currentHook = null;
  nextCurrentHook = null;
  firstWorkInProgressHook = null;
  workInProgressHook = null;
  nextWorkInProgressHook = null;

  remainingExpirationTime = _ReactFiberExpirationTime.NoWork;
  componentUpdateQueue = null;
  sideEffectTag = 0;

  if (true) {
    currentHookNameInDev = null;
  }

  didScheduleRenderPhaseUpdate = false;
  renderPhaseUpdates = null;
  numberOfReRenders = 0;
}

function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,

    baseState: null,
    queue: null,
    baseUpdate: null,

    next: null
  };

  if (true) {
    hook._debugType = currentHookNameInDev;
  }
  if (workInProgressHook === null) {
    // This is the first hook in the list
    firstWorkInProgressHook = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}

function updateWorkInProgressHook() {
  // This function is used both for updates and for re-renders triggered by a
  // render phase update. It assumes there is either a current hook we can
  // clone, or a work-in-progress hook from a previous render pass that we can
  // use as a base. When we reach the end of the base list, we must switch to
  // the dispatcher used for mounts.
  if (nextWorkInProgressHook !== null) {
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;

    currentHook = nextCurrentHook;
    nextCurrentHook = currentHook !== null ? currentHook.next : null;
  } else {
    // Clone from the current hook.
    (0, _invariant2.default)(nextCurrentHook !== null, 'Rendered more hooks than during the previous render.');
    currentHook = nextCurrentHook;

    var newHook = {
      memoizedState: currentHook.memoizedState,

      baseState: currentHook.baseState,
      queue: currentHook.queue,
      baseUpdate: currentHook.baseUpdate,

      next: null
    };

    if (workInProgressHook === null) {
      // This is the first hook in the list.
      workInProgressHook = firstWorkInProgressHook = newHook;
    } else {
      // Append to the end of the list.
      workInProgressHook = workInProgressHook.next = newHook;
    }
    nextCurrentHook = currentHook.next;

    if (true) {
      newHook._debugType = currentHookNameInDev;
      if (currentHookNameInDev !== currentHook._debugType) {
        warnOnHookMismatchInDev();
      }
    }
  }
  return workInProgressHook;
}

function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null
  };
}

function basicStateReducer(state, action) {
  return typeof action === 'function' ? action(state) : action;
}

function mountContext(context, observedBits) {
  if (true) {
    mountWorkInProgressHook();
  }
  return (0, _ReactFiberNewContext.readContext)(context, observedBits);
}

function updateContext(context, observedBits) {
  if (true) {
    updateWorkInProgressHook();
  }
  return (0, _ReactFiberNewContext.readContext)(context, observedBits);
}

function mountReducer(reducer, initialArg, init) {
  var hook = mountWorkInProgressHook();
  var initialState = void 0;
  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = initialArg;
  }
  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    last: null,
    dispatch: null,
    eagerReducer: reducer,
    eagerState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null,
  // Flow doesn't know this is non-null, but we do.
  currentlyRenderingFiber, queue);
  return [hook.memoizedState, dispatch];
}

function updateReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;
  (0, _invariant2.default)(queue !== null, 'Should have a queue. This is likely a bug in React. Please file an issue.');

  if (numberOfReRenders > 0) {
    // This is a re-render. Apply the new render phase updates to the previous
    var _dispatch = queue.dispatch;
    if (renderPhaseUpdates !== null) {
      // Render phase updates are stored in a map of queue -> linked list
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
      if (firstRenderPhaseUpdate !== undefined) {
        renderPhaseUpdates.delete(queue);
        var newState = hook.memoizedState;
        var update = firstRenderPhaseUpdate;
        do {
          // Process this render phase update. We don't have to check the
          // priority because it will always be the same as the current
          // render's.
          var _action = update.action;
          newState = reducer(newState, _action);
          update = update.next;
        } while (update !== null);

        // Mark that the fiber performed work, but only if the new state is
        // different from the current state.
        if (!(0, _objectIs2.default)(newState, hook.memoizedState)) {
          (0, _ReactFiberBeginWork.markWorkInProgressReceivedUpdate)();
        }

        hook.memoizedState = newState;

        // Don't persist the state accumlated from the render phase updates to
        // the base state unless the queue is empty.
        // TODO: Not sure if this is the desired semantics, but it's what we
        // do for gDSFP. I can't remember why.
        if (hook.baseUpdate === queue.last) {
          hook.baseState = newState;
        }

        return [newState, _dispatch];
      }
    }
    return [hook.memoizedState, _dispatch];
  }

  // The last update in the entire queue
  var last = queue.last;
  // The last update that is part of the base state.
  var baseUpdate = hook.baseUpdate;
  var baseState = hook.baseState;

  // Find the first unprocessed update.
  var first = void 0;
  if (baseUpdate !== null) {
    if (last !== null) {
      // For the first update, the queue is a circular linked list where
      // `queue.last.next = queue.first`. Once the first update commits, and
      // the `baseUpdate` is no longer empty, we can unravel the list.
      last.next = null;
    }
    first = baseUpdate.next;
  } else {
    first = last !== null ? last.next : null;
  }
  if (first !== null) {
    var _newState = baseState;
    var newBaseState = null;
    var newBaseUpdate = null;
    var prevUpdate = baseUpdate;
    var _update = first;
    var didSkip = false;
    do {
      var updateExpirationTime = _update.expirationTime;
      if (updateExpirationTime < renderExpirationTime) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        if (!didSkip) {
          didSkip = true;
          newBaseUpdate = prevUpdate;
          newBaseState = _newState;
        }
        // Update the remaining priority in the queue.
        if (updateExpirationTime > remainingExpirationTime) {
          remainingExpirationTime = updateExpirationTime;
        }
      } else {
        // Process this update.
        if (_update.eagerReducer === reducer) {
          // If this update was processed eagerly, and its reducer matches the
          // current reducer, we can use the eagerly computed state.
          _newState = _update.eagerState;
        } else {
          var _action2 = _update.action;
          _newState = reducer(_newState, _action2);
        }
      }
      prevUpdate = _update;
      _update = _update.next;
    } while (_update !== null && _update !== first);

    if (!didSkip) {
      newBaseUpdate = prevUpdate;
      newBaseState = _newState;
    }

    // Mark that the fiber performed work, but only if the new state is
    // different from the current state.
    if (!(0, _objectIs2.default)(_newState, hook.memoizedState)) {
      (0, _ReactFiberBeginWork.markWorkInProgressReceivedUpdate)();
    }

    hook.memoizedState = _newState;
    hook.baseUpdate = newBaseUpdate;
    hook.baseState = newBaseState;

    queue.eagerReducer = reducer;
    queue.eagerState = _newState;
  }

  var dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}

function mountState(initialState) {
  var hook = mountWorkInProgressHook();
  if (typeof initialState === 'function') {
    initialState = initialState();
  }
  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    last: null,
    dispatch: null,
    eagerReducer: basicStateReducer,
    eagerState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null,
  // Flow doesn't know this is non-null, but we do.
  currentlyRenderingFiber, queue);
  return [hook.memoizedState, dispatch];
}

function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}

function pushEffect(tag, create, destroy, deps) {
  var effect = {
    tag: tag,
    create: create,
    destroy: destroy,
    deps: deps,
    // Circular
    next: null
  };
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    var _lastEffect = componentUpdateQueue.lastEffect;
    if (_lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      var firstEffect = _lastEffect.next;
      _lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}

function mountRef(initialValue) {
  var hook = mountWorkInProgressHook();
  var ref = { current: initialValue };
  if (true) {
    Object.seal(ref);
  }
  hook.memoizedState = ref;
  return ref;
}

function updateRef(initialValue) {
  var hook = updateWorkInProgressHook();
  return hook.memoizedState;
}

function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  sideEffectTag |= fiberEffectTag;
  hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);
}

function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var destroy = undefined;

  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        pushEffect(_ReactHookEffectTags.NoEffect, create, destroy, nextDeps);
        return;
      }
    }
  }

  sideEffectTag |= fiberEffectTag;
  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);
}

function mountEffect(create, deps) {
  return mountEffectImpl(_ReactSideEffectTags.Update | _ReactSideEffectTags.Passive, _ReactHookEffectTags.UnmountPassive | _ReactHookEffectTags.MountPassive, create, deps);
}

function updateEffect(create, deps) {
  return updateEffectImpl(_ReactSideEffectTags.Update | _ReactSideEffectTags.Passive, _ReactHookEffectTags.UnmountPassive | _ReactHookEffectTags.MountPassive, create, deps);
}

function mountLayoutEffect(create, deps) {
  return mountEffectImpl(_ReactSideEffectTags.Update, _ReactHookEffectTags.UnmountMutation | _ReactHookEffectTags.MountLayout, create, deps);
}

function updateLayoutEffect(create, deps) {
  return updateEffectImpl(_ReactSideEffectTags.Update, _ReactHookEffectTags.UnmountMutation | _ReactHookEffectTags.MountLayout, create, deps);
}

function imperativeHandleEffect(create, ref) {
  if (typeof ref === 'function') {
    var refCallback = ref;
    var _inst = create();
    refCallback(_inst);
    return function () {
      refCallback(null);
    };
  } else if (ref !== null && ref !== undefined) {
    var refObject = ref;
    if (true) {
      (0, _warning2.default)(refObject.hasOwnProperty('current'), 'Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
    }
    var _inst2 = create();
    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}

function mountImperativeHandle(ref, create, deps) {
  if (true) {
    (0, _warning2.default)(typeof create === 'function', 'Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create === 'undefined' ? 'undefined' : _typeof(create) : 'null');
  }

  // TODO: If deps are provided, should we skip comparing the ref itself?
  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;

  return mountEffectImpl(_ReactSideEffectTags.Update, _ReactHookEffectTags.UnmountMutation | _ReactHookEffectTags.MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function updateImperativeHandle(ref, create, deps) {
  if (true) {
    (0, _warning2.default)(typeof create === 'function', 'Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create === 'undefined' ? 'undefined' : _typeof(create) : 'null');
  }

  // TODO: If deps are provided, should we skip comparing the ref itself?
  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;

  return updateEffectImpl(_ReactSideEffectTags.Update, _ReactHookEffectTags.UnmountMutation | _ReactHookEffectTags.MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function mountDebugValue(value, formatterFn) {
  // This hook is normally a no-op.
  // The react-debug-hooks package injects its own implementation
  // so that e.g. DevTools can display custom hook values.
}

var updateDebugValue = mountDebugValue;

function mountCallback(callback, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;
  if (prevState !== null) {
    if (nextDeps !== null) {
      var prevDeps = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function mountMemo(nextCreate, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;
  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      var prevDeps = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }
  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

// in a test-like environment, we want to warn if dispatchAction()
// is called outside of a batchedUpdates/TestUtils.act(...) call.
var shouldWarnForUnbatchedSetState = false;

if (true) {
  // jest isn't a 'global', it's just exposed to tests via a wrapped function
  // further, this isn't a test file, so flow doesn't recognize the symbol. So...
  // $FlowExpectedError - because requirements don't give a damn about your type sigs.
  if ('undefined' !== typeof jest) {
    shouldWarnForUnbatchedSetState = true;
  }
}

function dispatchAction(fiber, queue, action) {
  (0, _invariant2.default)(numberOfReRenders < RE_RENDER_LIMIT, 'Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');

  if (true) {
    (0, _warning2.default)(arguments.length <= 3, "State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
  }

  var alternate = fiber.alternate;
  if (fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdate = true;
    var update = {
      expirationTime: renderExpirationTime,
      action: action,
      eagerReducer: null,
      eagerState: null,
      next: null
    };
    if (renderPhaseUpdates === null) {
      renderPhaseUpdates = new Map();
    }
    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
    if (firstRenderPhaseUpdate === undefined) {
      renderPhaseUpdates.set(queue, update);
    } else {
      // Append the update to the end of the list.
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
      while (lastRenderPhaseUpdate.next !== null) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }
      lastRenderPhaseUpdate.next = update;
    }
  } else {
    (0, _ReactFiberScheduler.flushPassiveEffects)();

    var currentTime = (0, _ReactFiberScheduler.requestCurrentTime)();
    var _expirationTime = (0, _ReactFiberScheduler.computeExpirationForFiber)(currentTime, fiber);

    var _update2 = {
      expirationTime: _expirationTime,
      action: action,
      eagerReducer: null,
      eagerState: null,
      next: null
    };

    // Append the update to the end of the list.
    var _last = queue.last;
    if (_last === null) {
      // This is the first update. Create a circular list.
      _update2.next = _update2;
    } else {
      var first = _last.next;
      if (first !== null) {
        // Still circular.
        _update2.next = first;
      }
      _last.next = _update2;
    }
    queue.last = _update2;

    if (fiber.expirationTime === _ReactFiberExpirationTime.NoWork && (alternate === null || alternate.expirationTime === _ReactFiberExpirationTime.NoWork)) {
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      var _eagerReducer = queue.eagerReducer;
      if (_eagerReducer !== null) {
        var prevDispatcher = void 0;
        if (true) {
          prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }
        try {
          var currentState = queue.eagerState;
          var _eagerState = _eagerReducer(currentState, action);
          // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.
          _update2.eagerReducer = _eagerReducer;
          _update2.eagerState = _eagerState;
          if ((0, _objectIs2.default)(_eagerState, currentState)) {
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            return;
          }
        } catch (error) {
          // Suppress the error. It will throw again in the render phase.
        } finally {
          if (true) {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        }
      }
    }
    if (true) {
      if (shouldWarnForUnbatchedSetState === true) {
        (0, _ReactFiberScheduler.warnIfNotCurrentlyBatchingInDev)(fiber);
      }
    }
    (0, _ReactFiberScheduler.scheduleWork)(fiber, _expirationTime);
  }
}

var ContextOnlyDispatcher = exports.ContextOnlyDispatcher = {
  readContext: _ReactFiberNewContext.readContext,

  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError
};

var HooksDispatcherOnMount = {
  readContext: _ReactFiberNewContext.readContext,

  useCallback: mountCallback,
  useContext: _ReactFiberNewContext.readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
  useDebugValue: mountDebugValue
};

var HooksDispatcherOnUpdate = {
  readContext: _ReactFiberNewContext.readContext,

  useCallback: updateCallback,
  useContext: _ReactFiberNewContext.readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState,
  useDebugValue: updateDebugValue
};

var HooksDispatcherOnMountInDEV = null;
var HooksDispatcherOnUpdateInDEV = null;
var InvalidNestedHooksDispatcherOnMountInDEV = null;
var InvalidNestedHooksDispatcherOnUpdateInDEV = null;

if (true) {
  var warnInvalidContextAccess = function warnInvalidContextAccess() {
    (0, _warning2.default)(false, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
  };

  var warnInvalidHookAccess = function warnInvalidHookAccess() {
    (0, _warning2.default)(false, 'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://fb.me/rules-of-hooks');
  };

  HooksDispatcherOnMountInDEV = {
    readContext: function readContext(context, observedBits) {
      return (0, _ReactFiberNewContext.readContext)(context, observedBits);
    },
    useCallback: function useCallback(callback, deps) {
      currentHookNameInDev = 'useCallback';
      return mountCallback(callback, deps);
    },
    useContext: function useContext(context, observedBits) {
      currentHookNameInDev = 'useContext';
      return mountContext(context, observedBits);
    },
    useEffect: function useEffect(create, deps) {
      currentHookNameInDev = 'useEffect';
      return mountEffect(create, deps);
    },
    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function useLayoutEffect(create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      return mountLayoutEffect(create, deps);
    },
    useMemo: function useMemo(create, deps) {
      currentHookNameInDev = 'useMemo';
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useReducer: function useReducer(reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useRef: function useRef(initialValue) {
      currentHookNameInDev = 'useRef';
      return mountRef(initialValue);
    },
    useState: function useState(initialState) {
      currentHookNameInDev = 'useState';
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useDebugValue: function useDebugValue(value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      return mountDebugValue(value, formatterFn);
    }
  };

  HooksDispatcherOnUpdateInDEV = {
    readContext: function readContext(context, observedBits) {
      return (0, _ReactFiberNewContext.readContext)(context, observedBits);
    },
    useCallback: function useCallback(callback, deps) {
      currentHookNameInDev = 'useCallback';
      return updateCallback(callback, deps);
    },
    useContext: function useContext(context, observedBits) {
      currentHookNameInDev = 'useContext';
      return updateContext(context, observedBits);
    },
    useEffect: function useEffect(create, deps) {
      currentHookNameInDev = 'useEffect';
      return updateEffect(create, deps);
    },
    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function useLayoutEffect(create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      return updateLayoutEffect(create, deps);
    },
    useMemo: function useMemo(create, deps) {
      currentHookNameInDev = 'useMemo';
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useReducer: function useReducer(reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useRef: function useRef(initialValue) {
      currentHookNameInDev = 'useRef';
      return updateRef(initialValue);
    },
    useState: function useState(initialState) {
      currentHookNameInDev = 'useState';
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useDebugValue: function useDebugValue(value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      return updateDebugValue(value, formatterFn);
    }
  };

  InvalidNestedHooksDispatcherOnMountInDEV = {
    readContext: function readContext(context, observedBits) {
      warnInvalidContextAccess();
      return (0, _ReactFiberNewContext.readContext)(context, observedBits);
    },
    useCallback: function useCallback(callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      return mountCallback(callback, deps);
    },
    useContext: function useContext(context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      return mountContext(context, observedBits);
    },
    useEffect: function useEffect(create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function useLayoutEffect(create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function useMemo(create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useReducer: function useReducer(reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useRef: function useRef(initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      return mountRef(initialValue);
    },
    useState: function useState(initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useDebugValue: function useDebugValue(value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      return mountDebugValue(value, formatterFn);
    }
  };

  InvalidNestedHooksDispatcherOnUpdateInDEV = {
    readContext: function readContext(context, observedBits) {
      warnInvalidContextAccess();
      return (0, _ReactFiberNewContext.readContext)(context, observedBits);
    },
    useCallback: function useCallback(callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      return updateCallback(callback, deps);
    },
    useContext: function useContext(context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      return updateContext(context, observedBits);
    },
    useEffect: function useEffect(create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function useLayoutEffect(create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function useMemo(create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useReducer: function useReducer(reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useRef: function useRef(initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      return updateRef(initialValue);
    },
    useState: function useState(initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      var prevDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher.current = prevDispatcher;
      }
    },
    useDebugValue: function useDebugValue(value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      return updateDebugValue(value, formatterFn);
    }
  };
}

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var NoEffect = /*             */exports.NoEffect = 0; /**
                                                       * Copyright (c) Facebook, Inc. and its affiliates.
                                                       *
                                                       * This source code is licensed under the MIT license found in the
                                                       * LICENSE file in the root directory of this source tree.
                                                       *
                                                       * 
                                                       */

var UnmountSnapshot = /*      */exports.UnmountSnapshot = 2;
var UnmountMutation = /*      */exports.UnmountMutation = 4;
var MountMutation = /*        */exports.MountMutation = 8;
var UnmountLayout = /*        */exports.UnmountLayout = 16;
var MountLayout = /*          */exports.MountLayout = 32;
var MountPassive = /*         */exports.MountPassive = 64;
var UnmountPassive = /*       */exports.UnmountPassive = 128;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popHydrationState = exports.skipPastDehydratedSuspenseInstance = exports.prepareToHydrateHostTextInstance = exports.prepareToHydrateHostInstance = exports.tryToClaimNextHydratableInstance = exports.resetHydrationState = exports.reenterHydrationStateFromDehydratedSuspenseInstance = exports.enterHydrationState = undefined;

var _ReactWorkTags = __webpack_require__(4);

var _ReactSideEffectTags = __webpack_require__(8);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _ReactFiber = __webpack_require__(30);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var hydrationParentFiber = null;
var nextHydratableInstance = null;
var isHydrating = false;

function enterHydrationState(fiber) {
  if (!_ReactFiberHostConfig.supportsHydration) {
    return false;
  }

  var parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = (0, _ReactFiberHostConfig.getFirstHydratableChild)(parentInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  return true;
}

function reenterHydrationStateFromDehydratedSuspenseInstance(fiber) {
  if (!_ReactFiberHostConfig.supportsHydration) {
    return false;
  }

  var suspenseInstance = fiber.stateNode;
  nextHydratableInstance = (0, _ReactFiberHostConfig.getNextHydratableSibling)(suspenseInstance);
  popToNextHostParent(fiber);
  isHydrating = true;
  return true;
}

function deleteHydratableInstance(returnFiber, instance) {
  if (true) {
    switch (returnFiber.tag) {
      case _ReactWorkTags.HostRoot:
        (0, _ReactFiberHostConfig.didNotHydrateContainerInstance)(returnFiber.stateNode.containerInfo, instance);
        break;
      case _ReactWorkTags.HostComponent:
        (0, _ReactFiberHostConfig.didNotHydrateInstance)(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
        break;
    }
  }

  var childToDelete = (0, _ReactFiber.createFiberFromHostInstanceForDeletion)();
  childToDelete.stateNode = instance;
  childToDelete.return = returnFiber;
  childToDelete.effectTag = _ReactSideEffectTags.Deletion;

  // This might seem like it belongs on progressedFirstDeletion. However,
  // these children are not part of the reconciliation list of children.
  // Even if we abort and rereconcile the children, that will try to hydrate
  // again and the nodes are still in the host tree so these will be
  // recreated.
  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = childToDelete;
    returnFiber.lastEffect = childToDelete;
  } else {
    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
  }
}

function insertNonHydratedInstance(returnFiber, fiber) {
  fiber.effectTag |= _ReactSideEffectTags.Placement;
  if (true) {
    switch (returnFiber.tag) {
      case _ReactWorkTags.HostRoot:
        {
          var parentContainer = returnFiber.stateNode.containerInfo;
          switch (fiber.tag) {
            case _ReactWorkTags.HostComponent:
              var type = fiber.type;
              var props = fiber.pendingProps;
              (0, _ReactFiberHostConfig.didNotFindHydratableContainerInstance)(parentContainer, type, props);
              break;
            case _ReactWorkTags.HostText:
              var text = fiber.pendingProps;
              (0, _ReactFiberHostConfig.didNotFindHydratableContainerTextInstance)(parentContainer, text);
              break;
            case _ReactWorkTags.SuspenseComponent:
              (0, _ReactFiberHostConfig.didNotFindHydratableContainerSuspenseInstance)(parentContainer);
              break;
          }
          break;
        }
      case _ReactWorkTags.HostComponent:
        {
          var parentType = returnFiber.type;
          var parentProps = returnFiber.memoizedProps;
          var parentInstance = returnFiber.stateNode;
          switch (fiber.tag) {
            case _ReactWorkTags.HostComponent:
              var _type = fiber.type;
              var _props = fiber.pendingProps;
              (0, _ReactFiberHostConfig.didNotFindHydratableInstance)(parentType, parentProps, parentInstance, _type, _props);
              break;
            case _ReactWorkTags.HostText:
              var _text = fiber.pendingProps;
              (0, _ReactFiberHostConfig.didNotFindHydratableTextInstance)(parentType, parentProps, parentInstance, _text);
              break;
            case _ReactWorkTags.SuspenseComponent:
              (0, _ReactFiberHostConfig.didNotFindHydratableSuspenseInstance)(parentType, parentProps, parentInstance);
              break;
          }
          break;
        }
      default:
        return;
    }
  }
}

function tryHydrate(fiber, nextInstance) {
  switch (fiber.tag) {
    case _ReactWorkTags.HostComponent:
      {
        var type = fiber.type;
        var props = fiber.pendingProps;
        var instance = (0, _ReactFiberHostConfig.canHydrateInstance)(nextInstance, type, props);
        if (instance !== null) {
          fiber.stateNode = instance;
          return true;
        }
        return false;
      }
    case _ReactWorkTags.HostText:
      {
        var text = fiber.pendingProps;
        var textInstance = (0, _ReactFiberHostConfig.canHydrateTextInstance)(nextInstance, text);
        if (textInstance !== null) {
          fiber.stateNode = textInstance;
          return true;
        }
        return false;
      }
    case _ReactWorkTags.SuspenseComponent:
      {
        if (_ReactFeatureFlags.enableSuspenseServerRenderer) {
          var suspenseInstance = (0, _ReactFiberHostConfig.canHydrateSuspenseInstance)(nextInstance);
          if (suspenseInstance !== null) {
            // Downgrade the tag to a dehydrated component until we've hydrated it.
            fiber.tag = _ReactWorkTags.DehydratedSuspenseComponent;
            fiber.stateNode = suspenseInstance;
            return true;
          }
        }
        return false;
      }
    default:
      return false;
  }
}

function tryToClaimNextHydratableInstance(fiber) {
  if (!isHydrating) {
    return;
  }
  var nextInstance = nextHydratableInstance;
  if (!nextInstance) {
    // Nothing to hydrate. Make it an insertion.
    insertNonHydratedInstance(hydrationParentFiber, fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
  var firstAttemptedInstance = nextInstance;
  if (!tryHydrate(fiber, nextInstance)) {
    // If we can't hydrate this instance let's try the next one.
    // We use this as a heuristic. It's based on intuition and not data so it
    // might be flawed or unnecessary.
    nextInstance = (0, _ReactFiberHostConfig.getNextHydratableSibling)(firstAttemptedInstance);
    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    // We matched the next one, we'll now assume that the first one was
    // superfluous and we'll delete it. Since we can't eagerly delete it
    // we'll have to schedule a deletion. To do that, this node needs a dummy
    // fiber associated with it.
    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
  }
  hydrationParentFiber = fiber;
  nextHydratableInstance = (0, _ReactFiberHostConfig.getFirstHydratableChild)(nextInstance);
}

function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
  if (!_ReactFiberHostConfig.supportsHydration) {
    (0, _invariant2.default)(false, 'Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');
  }

  var instance = fiber.stateNode;
  var updatePayload = (0, _ReactFiberHostConfig.hydrateInstance)(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
  // TODO: Type this specific to this type of component.
  fiber.updateQueue = updatePayload;
  // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update.
  if (updatePayload !== null) {
    return true;
  }
  return false;
}

function prepareToHydrateHostTextInstance(fiber) {
  if (!_ReactFiberHostConfig.supportsHydration) {
    (0, _invariant2.default)(false, 'Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');
  }

  var textInstance = fiber.stateNode;
  var textContent = fiber.memoizedProps;
  var shouldUpdate = (0, _ReactFiberHostConfig.hydrateTextInstance)(textInstance, textContent, fiber);
  if (true) {
    if (shouldUpdate) {
      // We assume that prepareToHydrateHostTextInstance is called in a context where the
      // hydration parent is the parent host component of this host text.
      var returnFiber = hydrationParentFiber;
      if (returnFiber !== null) {
        switch (returnFiber.tag) {
          case _ReactWorkTags.HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              (0, _ReactFiberHostConfig.didNotMatchHydratedContainerTextInstance)(parentContainer, textInstance, textContent);
              break;
            }
          case _ReactWorkTags.HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              (0, _ReactFiberHostConfig.didNotMatchHydratedTextInstance)(parentType, parentProps, parentInstance, textInstance, textContent);
              break;
            }
        }
      }
    }
  }
  return shouldUpdate;
}

function skipPastDehydratedSuspenseInstance(fiber) {
  if (!_ReactFiberHostConfig.supportsHydration) {
    (0, _invariant2.default)(false, 'Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');
  }
  var suspenseInstance = fiber.stateNode;
  (0, _invariant2.default)(suspenseInstance, 'Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');
  nextHydratableInstance = (0, _ReactFiberHostConfig.getNextHydratableInstanceAfterSuspenseInstance)(suspenseInstance);
}

function popToNextHostParent(fiber) {
  var parent = fiber.return;
  while (parent !== null && parent.tag !== _ReactWorkTags.HostComponent && parent.tag !== _ReactWorkTags.HostRoot && parent.tag !== _ReactWorkTags.DehydratedSuspenseComponent) {
    parent = parent.return;
  }
  hydrationParentFiber = parent;
}

function popHydrationState(fiber) {
  if (!_ReactFiberHostConfig.supportsHydration) {
    return false;
  }
  if (fiber !== hydrationParentFiber) {
    // We're deeper than the current hydration context, inside an inserted
    // tree.
    return false;
  }
  if (!isHydrating) {
    // If we're not currently hydrating but we're in a hydration context, then
    // we were an insertion and now need to pop up reenter hydration of our
    // siblings.
    popToNextHostParent(fiber);
    isHydrating = true;
    return false;
  }

  var type = fiber.type;

  // If we have any remaining hydratable nodes, we need to delete them now.
  // We only do this deeper than head and body since they tend to have random
  // other nodes in them. We also ignore components with pure text content in
  // side of them.
  // TODO: Better heuristic.
  if (fiber.tag !== _ReactWorkTags.HostComponent || type !== 'head' && type !== 'body' && !(0, _ReactFiberHostConfig.shouldSetTextContent)(type, fiber.memoizedProps)) {
    var nextInstance = nextHydratableInstance;
    while (nextInstance) {
      deleteHydratableInstance(fiber, nextInstance);
      nextInstance = (0, _ReactFiberHostConfig.getNextHydratableSibling)(nextInstance);
    }
  }

  popToNextHostParent(fiber);
  nextHydratableInstance = hydrationParentFiber ? (0, _ReactFiberHostConfig.getNextHydratableSibling)(fiber.stateNode) : null;
  return true;
}

function resetHydrationState() {
  if (!_ReactFiberHostConfig.supportsHydration) {
    return;
  }

  hydrationParentFiber = null;
  nextHydratableInstance = null;
  isHydrating = false;
}

exports.enterHydrationState = enterHydrationState;
exports.reenterHydrationStateFromDehydratedSuspenseInstance = reenterHydrationStateFromDehydratedSuspenseInstance;
exports.resetHydrationState = resetHydrationState;
exports.tryToClaimNextHydratableInstance = tryToClaimNextHydratableInstance;
exports.prepareToHydrateHostInstance = prepareToHydrateHostInstance;
exports.prepareToHydrateHostTextInstance = prepareToHydrateHostTextInstance;
exports.skipPastDehydratedSuspenseInstance = skipPastDehydratedSuspenseInstance;
exports.popHydrationState = popHydrationState;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCapturedValue = createCapturedValue;

var _ReactCurrentFiber = __webpack_require__(7);

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function createCapturedValue(value, source) {
  // If the value is an error, call this function immediately after it is thrown
  // so the stack is accurate.
  return {
    value: value,
    source: source,
    stack: (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(source)
  };
}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commitDetachRef = exports.commitAttachRef = exports.commitLifeCycles = exports.commitWork = exports.commitDeletion = exports.commitPlacement = exports.commitResetTextContent = exports.commitBeforeMutationLifeCycles = undefined;
exports.logError = logError;
exports.commitPassiveHookEffects = commitPassiveHookEffects;

var _tracing = __webpack_require__(23);

var _ReactFeatureFlags = __webpack_require__(3);

var _ReactWorkTags = __webpack_require__(4);

var _ReactErrorUtils = __webpack_require__(34);

var _ReactSideEffectTags = __webpack_require__(8);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactFiberDevToolsHook = __webpack_require__(39);

var _ReactDebugFiberPerf = __webpack_require__(29);

var _ReactCurrentFiber = __webpack_require__(7);

var _ReactFiberErrorLogger = __webpack_require__(145);

var _ReactFiberLazyComponent = __webpack_require__(57);

var _ReactProfilerTimer = __webpack_require__(58);

var _ReactUpdateQueue = __webpack_require__(18);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiberScheduler = __webpack_require__(31);

var _ReactHookEffectTags = __webpack_require__(83);

var _ReactFiberBeginWork = __webpack_require__(40);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnAboutUndefinedSnapshotBeforeUpdate = null; /**
                                                       * Copyright (c) Facebook, Inc. and its affiliates.
                                                       *
                                                       * This source code is licensed under the MIT license found in the
                                                       * LICENSE file in the root directory of this source tree.
                                                       *
                                                       * 
                                                       */

if (true) {
  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
}

var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;

function logError(boundary, errorInfo) {
  var source = errorInfo.source;
  var stack = errorInfo.stack;
  if (stack === null && source !== null) {
    stack = (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(source);
  }

  var capturedError = {
    componentName: source !== null ? (0, _getComponentName2.default)(source.type) : null,
    componentStack: stack !== null ? stack : '',
    error: errorInfo.value,
    errorBoundary: null,
    errorBoundaryName: null,
    errorBoundaryFound: false,
    willRetry: false
  };

  if (boundary !== null && boundary.tag === _ReactWorkTags.ClassComponent) {
    capturedError.errorBoundary = boundary.stateNode;
    capturedError.errorBoundaryName = (0, _getComponentName2.default)(boundary.type);
    capturedError.errorBoundaryFound = true;
    capturedError.willRetry = true;
  }

  try {
    (0, _ReactFiberErrorLogger.logCapturedError)(capturedError);
  } catch (e) {
    // This method must not throw, or React internal state will get messed up.
    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
    // we want to report this error outside of the normal stack as a last resort.
    // https://github.com/facebook/react/issues/13188
    setTimeout(function () {
      throw e;
    });
  }
}

var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current, instance) {
  (0, _ReactDebugFiberPerf.startPhaseTimer)(current, 'componentWillUnmount');
  instance.props = current.memoizedProps;
  instance.state = current.memoizedState;
  instance.componentWillUnmount();
  (0, _ReactDebugFiberPerf.stopPhaseTimer)();
};

// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current, instance) {
  if (true) {
    (0, _ReactErrorUtils.invokeGuardedCallback)(null, callComponentWillUnmountWithTimer, null, current, instance);
    if ((0, _ReactErrorUtils.hasCaughtError)()) {
      var unmountError = (0, _ReactErrorUtils.clearCaughtError)();
      (0, _ReactFiberScheduler.captureCommitPhaseError)(current, unmountError);
    }
  } else {
    try {
      callComponentWillUnmountWithTimer(current, instance);
    } catch (unmountError) {
      (0, _ReactFiberScheduler.captureCommitPhaseError)(current, unmountError);
    }
  }
}

function safelyDetachRef(current) {
  var ref = current.ref;
  if (ref !== null) {
    if (typeof ref === 'function') {
      if (true) {
        (0, _ReactErrorUtils.invokeGuardedCallback)(null, ref, null, null);
        if ((0, _ReactErrorUtils.hasCaughtError)()) {
          var refError = (0, _ReactErrorUtils.clearCaughtError)();
          (0, _ReactFiberScheduler.captureCommitPhaseError)(current, refError);
        }
      } else {
        try {
          ref(null);
        } catch (refError) {
          (0, _ReactFiberScheduler.captureCommitPhaseError)(current, refError);
        }
      }
    } else {
      ref.current = null;
    }
  }
}

function safelyCallDestroy(current, destroy) {
  if (true) {
    (0, _ReactErrorUtils.invokeGuardedCallback)(null, destroy, null);
    if ((0, _ReactErrorUtils.hasCaughtError)()) {
      var error = (0, _ReactErrorUtils.clearCaughtError)();
      (0, _ReactFiberScheduler.captureCommitPhaseError)(current, error);
    }
  } else {
    try {
      destroy();
    } catch (error) {
      (0, _ReactFiberScheduler.captureCommitPhaseError)(current, error);
    }
  }
}

function commitBeforeMutationLifeCycles(current, finishedWork) {
  switch (finishedWork.tag) {
    case _ReactWorkTags.FunctionComponent:
    case _ReactWorkTags.ForwardRef:
    case _ReactWorkTags.SimpleMemoComponent:
      {
        commitHookEffectList(_ReactHookEffectTags.UnmountSnapshot, _ReactHookEffectTags.NoEffect, finishedWork);
        return;
      }
    case _ReactWorkTags.ClassComponent:
      {
        if (finishedWork.effectTag & _ReactSideEffectTags.Snapshot) {
          if (current !== null) {
            var prevProps = current.memoizedProps;
            var prevState = current.memoizedState;
            (0, _ReactDebugFiberPerf.startPhaseTimer)(finishedWork, 'getSnapshotBeforeUpdate');
            var instance = finishedWork.stateNode;
            // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.
            if (true) {
              if (finishedWork.type === finishedWork.elementType && !_ReactFiberBeginWork.didWarnAboutReassigningProps) {
                (0, _warning2.default)(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
                (0, _warning2.default)(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
              }
            }
            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : (0, _ReactFiberLazyComponent.resolveDefaultProps)(finishedWork.type, prevProps), prevState);
            if (true) {
              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                didWarnSet.add(finishedWork.type);
                (0, _warningWithoutStack2.default)(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', (0, _getComponentName2.default)(finishedWork.type));
              }
            }
            instance.__reactInternalSnapshotBeforeUpdate = snapshot;
            (0, _ReactDebugFiberPerf.stopPhaseTimer)();
          }
        }
        return;
      }
    case _ReactWorkTags.HostRoot:
    case _ReactWorkTags.HostComponent:
    case _ReactWorkTags.HostText:
    case _ReactWorkTags.HostPortal:
    case _ReactWorkTags.IncompleteClassComponent:
      // Nothing to do for these component types
      return;
    default:
      {
        (0, _invariant2.default)(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
      }
  }
}

function commitHookEffectList(unmountTag, mountTag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;
    do {
      if ((effect.tag & unmountTag) !== _ReactHookEffectTags.NoEffect) {
        // Unmount
        var destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      if ((effect.tag & mountTag) !== _ReactHookEffectTags.NoEffect) {
        // Mount
        var create = effect.create;
        effect.destroy = create();

        if (true) {
          var _destroy = effect.destroy;
          if (_destroy !== undefined && typeof _destroy !== 'function') {
            var addendum = void 0;
            if (_destroy === null) {
              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
            } else if (typeof _destroy.then === 'function') {
              addendum = '\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, you may write an async function separately ' + 'and then call it from inside the effect:\n\n' + 'async function fetchComment(commentId) {\n' + '  // You can await here\n' + '}\n\n' + 'useEffect(() => {\n' + '  fetchComment(commentId);\n' + '}, [commentId]);\n\n' + 'In the future, React will provide a more idiomatic solution for data fetching ' + "that doesn't involve writing effects manually.";
            } else {
              addendum = ' You returned: ' + _destroy;
            }
            (0, _warningWithoutStack2.default)(false, 'An Effect function must not return anything besides a function, ' + 'which is used for clean-up.%s%s', addendum, (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(finishedWork));
          }
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function commitPassiveHookEffects(finishedWork) {
  commitHookEffectList(_ReactHookEffectTags.UnmountPassive, _ReactHookEffectTags.NoEffect, finishedWork);
  commitHookEffectList(_ReactHookEffectTags.NoEffect, _ReactHookEffectTags.MountPassive, finishedWork);
}

function commitLifeCycles(finishedRoot, current, finishedWork, committedExpirationTime) {
  switch (finishedWork.tag) {
    case _ReactWorkTags.FunctionComponent:
    case _ReactWorkTags.ForwardRef:
    case _ReactWorkTags.SimpleMemoComponent:
      {
        commitHookEffectList(_ReactHookEffectTags.UnmountLayout, _ReactHookEffectTags.MountLayout, finishedWork);
        break;
      }
    case _ReactWorkTags.ClassComponent:
      {
        var instance = finishedWork.stateNode;
        if (finishedWork.effectTag & _ReactSideEffectTags.Update) {
          if (current === null) {
            (0, _ReactDebugFiberPerf.startPhaseTimer)(finishedWork, 'componentDidMount');
            // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.
            if (true) {
              if (finishedWork.type === finishedWork.elementType && !_ReactFiberBeginWork.didWarnAboutReassigningProps) {
                (0, _warning2.default)(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
                (0, _warning2.default)(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
              }
            }
            instance.componentDidMount();
            (0, _ReactDebugFiberPerf.stopPhaseTimer)();
          } else {
            var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : (0, _ReactFiberLazyComponent.resolveDefaultProps)(finishedWork.type, current.memoizedProps);
            var prevState = current.memoizedState;
            (0, _ReactDebugFiberPerf.startPhaseTimer)(finishedWork, 'componentDidUpdate');
            // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.
            if (true) {
              if (finishedWork.type === finishedWork.elementType && !_ReactFiberBeginWork.didWarnAboutReassigningProps) {
                (0, _warning2.default)(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
                (0, _warning2.default)(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
              }
            }
            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
            (0, _ReactDebugFiberPerf.stopPhaseTimer)();
          }
        }
        var updateQueue = finishedWork.updateQueue;
        if (updateQueue !== null) {
          if (true) {
            if (finishedWork.type === finishedWork.elementType && !_ReactFiberBeginWork.didWarnAboutReassigningProps) {
              (0, _warning2.default)(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
              (0, _warning2.default)(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', (0, _getComponentName2.default)(finishedWork.type) || 'instance');
            }
          }
          // We could update instance props and state here,
          // but instead we rely on them being set during last render.
          // TODO: revisit this when we implement resuming.
          (0, _ReactUpdateQueue.commitUpdateQueue)(finishedWork, updateQueue, instance, committedExpirationTime);
        }
        return;
      }
    case _ReactWorkTags.HostRoot:
      {
        var _updateQueue = finishedWork.updateQueue;
        if (_updateQueue !== null) {
          var _instance = null;
          if (finishedWork.child !== null) {
            switch (finishedWork.child.tag) {
              case _ReactWorkTags.HostComponent:
                _instance = (0, _ReactFiberHostConfig.getPublicInstance)(finishedWork.child.stateNode);
                break;
              case _ReactWorkTags.ClassComponent:
                _instance = finishedWork.child.stateNode;
                break;
            }
          }
          (0, _ReactUpdateQueue.commitUpdateQueue)(finishedWork, _updateQueue, _instance, committedExpirationTime);
        }
        return;
      }
    case _ReactWorkTags.HostComponent:
      {
        var _instance2 = finishedWork.stateNode;

        // Renderers may schedule work to be done after host components are mounted
        // (eg DOM renderer may schedule auto-focus for inputs and form controls).
        // These effects should only be committed when components are first mounted,
        // aka when there is no current/alternate.
        if (current === null && finishedWork.effectTag & _ReactSideEffectTags.Update) {
          var type = finishedWork.type;
          var props = finishedWork.memoizedProps;
          (0, _ReactFiberHostConfig.commitMount)(_instance2, type, props, finishedWork);
        }

        return;
      }
    case _ReactWorkTags.HostText:
      {
        // We have no life-cycles associated with text.
        return;
      }
    case _ReactWorkTags.HostPortal:
      {
        // We have no life-cycles associated with portals.
        return;
      }
    case _ReactWorkTags.Profiler:
      {
        if (_ReactFeatureFlags.enableProfilerTimer) {
          var onRender = finishedWork.memoizedProps.onRender;

          if (_ReactFeatureFlags.enableSchedulerTracing) {
            onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, (0, _ReactProfilerTimer.getCommitTime)(), finishedRoot.memoizedInteractions);
          } else {
            onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, (0, _ReactProfilerTimer.getCommitTime)());
          }
        }
        return;
      }
    case _ReactWorkTags.SuspenseComponent:
      break;
    case _ReactWorkTags.IncompleteClassComponent:
      break;
    default:
      {
        (0, _invariant2.default)(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
      }
  }
}

function hideOrUnhideAllChildren(finishedWork, isHidden) {
  if (_ReactFiberHostConfig.supportsMutation) {
    // We only have the top Fiber that was inserted but we need to recurse down its
    var node = finishedWork;
    while (true) {
      if (node.tag === _ReactWorkTags.HostComponent) {
        var instance = node.stateNode;
        if (isHidden) {
          (0, _ReactFiberHostConfig.hideInstance)(instance);
        } else {
          (0, _ReactFiberHostConfig.unhideInstance)(node.stateNode, node.memoizedProps);
        }
      } else if (node.tag === _ReactWorkTags.HostText) {
        var _instance3 = node.stateNode;
        if (isHidden) {
          (0, _ReactFiberHostConfig.hideTextInstance)(_instance3);
        } else {
          (0, _ReactFiberHostConfig.unhideTextInstance)(_instance3, node.memoizedProps);
        }
      } else if (node.tag === _ReactWorkTags.SuspenseComponent && node.memoizedState !== null) {
        // Found a nested Suspense component that timed out. Skip over the
        var fallbackChildFragment = node.child.sibling;
        fallbackChildFragment.return = node;
        node = fallbackChildFragment;
        continue;
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === finishedWork) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
}

function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;
  if (ref !== null) {
    var instance = finishedWork.stateNode;
    var instanceToUse = void 0;
    switch (finishedWork.tag) {
      case _ReactWorkTags.HostComponent:
        instanceToUse = (0, _ReactFiberHostConfig.getPublicInstance)(instance);
        break;
      default:
        instanceToUse = instance;
    }
    if (typeof ref === 'function') {
      ref(instanceToUse);
    } else {
      if (true) {
        if (!ref.hasOwnProperty('current')) {
          (0, _warningWithoutStack2.default)(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', (0, _getComponentName2.default)(finishedWork.type), (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(finishedWork));
        }
      }

      ref.current = instanceToUse;
    }
  }
}

function commitDetachRef(current) {
  var currentRef = current.ref;
  if (currentRef !== null) {
    if (typeof currentRef === 'function') {
      currentRef(null);
    } else {
      currentRef.current = null;
    }
  }
}

// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current) {
  (0, _ReactFiberDevToolsHook.onCommitUnmount)(current);

  switch (current.tag) {
    case _ReactWorkTags.FunctionComponent:
    case _ReactWorkTags.ForwardRef:
    case _ReactWorkTags.MemoComponent:
    case _ReactWorkTags.SimpleMemoComponent:
      {
        var updateQueue = current.updateQueue;
        if (updateQueue !== null) {
          var lastEffect = updateQueue.lastEffect;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              var destroy = effect.destroy;
              if (destroy !== undefined) {
                safelyCallDestroy(current, destroy);
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        break;
      }
    case _ReactWorkTags.ClassComponent:
      {
        safelyDetachRef(current);
        var instance = current.stateNode;
        if (typeof instance.componentWillUnmount === 'function') {
          safelyCallComponentWillUnmount(current, instance);
        }
        return;
      }
    case _ReactWorkTags.HostComponent:
      {
        safelyDetachRef(current);
        return;
      }
    case _ReactWorkTags.HostPortal:
      {
        // TODO: this is recursive.
        // We are also not using this parent because
        // the portal will get pushed immediately.
        if (_ReactFiberHostConfig.supportsMutation) {
          unmountHostComponents(current);
        } else if (_ReactFiberHostConfig.supportsPersistence) {
          emptyPortalContainer(current);
        }
        return;
      }
  }
}

function commitNestedUnmounts(root) {
  // While we're inside a removed host node we don't want to call
  // removeChild on the inner nodes because they're removed by the top
  // call anyway. We also want to call componentWillUnmount on all
  // composites before this host node is removed from the tree. Therefore
  var node = root;
  while (true) {
    commitUnmount(node);
    // Visit children because they may contain more composite or host nodes.
    // Skip portals because commitUnmount() currently visits them recursively.
    if (node.child !== null && (
    // If we use mutation we drill down into portals using commitUnmount above.
    // If we don't use mutation we drill down into portals here instead.
    !_ReactFiberHostConfig.supportsMutation || node.tag !== _ReactWorkTags.HostPortal)) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === root) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === root) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function detachFiber(current) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  current.return = null;
  current.child = null;
  current.memoizedState = null;
  current.updateQueue = null;
  var alternate = current.alternate;
  if (alternate !== null) {
    alternate.return = null;
    alternate.child = null;
    alternate.memoizedState = null;
    alternate.updateQueue = null;
  }
}

function emptyPortalContainer(current) {
  if (!_ReactFiberHostConfig.supportsPersistence) {
    return;
  }

  var portal = current.stateNode;
  var containerInfo = portal.containerInfo;

  var emptyChildSet = (0, _ReactFiberHostConfig.createContainerChildSet)(containerInfo);
  (0, _ReactFiberHostConfig.replaceContainerChildren)(containerInfo, emptyChildSet);
}

function commitContainer(finishedWork) {
  if (!_ReactFiberHostConfig.supportsPersistence) {
    return;
  }

  switch (finishedWork.tag) {
    case _ReactWorkTags.ClassComponent:
      {
        return;
      }
    case _ReactWorkTags.HostComponent:
      {
        return;
      }
    case _ReactWorkTags.HostText:
      {
        return;
      }
    case _ReactWorkTags.HostRoot:
    case _ReactWorkTags.HostPortal:
      {
        var portalOrRoot = finishedWork.stateNode;
        var containerInfo = portalOrRoot.containerInfo,
            _pendingChildren = portalOrRoot.pendingChildren;

        (0, _ReactFiberHostConfig.replaceContainerChildren)(containerInfo, _pendingChildren);
        return;
      }
    default:
      {
        (0, _invariant2.default)(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
      }
  }
}

function getHostParentFiber(fiber) {
  var parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  (0, _invariant2.default)(false, 'Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');
}

function isHostParent(fiber) {
  return fiber.tag === _ReactWorkTags.HostComponent || fiber.tag === _ReactWorkTags.HostRoot || fiber.tag === _ReactWorkTags.HostPortal;
}

function getHostSibling(fiber) {
  // We're going to search forward into the tree until we find a sibling host
  // node. Unfortunately, if multiple insertions are done in a row we have to
  // search past them. This leads to exponential search for the next sibling.
  var node = fiber;
  siblings: while (true) {
    // If we didn't find anything, let's try the next sibling.
    while (node.sibling === null) {
      if (node.return === null || isHostParent(node.return)) {
        // If we pop out of the root or hit the parent the fiber we are the
        // last sibling.
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
    while (node.tag !== _ReactWorkTags.HostComponent && node.tag !== _ReactWorkTags.HostText && node.tag !== _ReactWorkTags.DehydratedSuspenseComponent) {
      // If it is not host node and, we might have a host node inside it.
      // Try to search down until we find one.
      if (node.effectTag & _ReactSideEffectTags.Placement) {
        // If we don't have a child, try the siblings instead.
        continue siblings;
      }
      // If we don't have a child, try the siblings instead.
      // We also skip portals because they are not part of this host tree.
      if (node.child === null || node.tag === _ReactWorkTags.HostPortal) {
        continue siblings;
      } else {
        node.child.return = node;
        node = node.child;
      }
    }
    // Check if this host node is stable or about to be placed.
    if (!(node.effectTag & _ReactSideEffectTags.Placement)) {
      // Found it!
      return node.stateNode;
    }
  }
}

function commitPlacement(finishedWork) {
  if (!_ReactFiberHostConfig.supportsMutation) {
    return;
  }

  // Recursively insert all host nodes into the parent.
  var parentFiber = getHostParentFiber(finishedWork);

  // Note: these two variables *must* always be updated together.
  var parent = void 0;
  var isContainer = void 0;

  switch (parentFiber.tag) {
    case _ReactWorkTags.HostComponent:
      parent = parentFiber.stateNode;
      isContainer = false;
      break;
    case _ReactWorkTags.HostRoot:
      parent = parentFiber.stateNode.containerInfo;
      isContainer = true;
      break;
    case _ReactWorkTags.HostPortal:
      parent = parentFiber.stateNode.containerInfo;
      isContainer = true;
      break;
    default:
      (0, _invariant2.default)(false, 'Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');
  }
  if (parentFiber.effectTag & _ReactSideEffectTags.ContentReset) {
    // Reset the text content of the parent before doing any insertions
    (0, _ReactFiberHostConfig.resetTextContent)(parent);
    // Clear ContentReset from the effect tag
    parentFiber.effectTag &= ~_ReactSideEffectTags.ContentReset;
  }

  var before = getHostSibling(finishedWork);
  // We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.
  var node = finishedWork;
  while (true) {
    if (node.tag === _ReactWorkTags.HostComponent || node.tag === _ReactWorkTags.HostText) {
      if (before) {
        if (isContainer) {
          (0, _ReactFiberHostConfig.insertInContainerBefore)(parent, node.stateNode, before);
        } else {
          (0, _ReactFiberHostConfig.insertBefore)(parent, node.stateNode, before);
        }
      } else {
        if (isContainer) {
          (0, _ReactFiberHostConfig.appendChildToContainer)(parent, node.stateNode);
        } else {
          (0, _ReactFiberHostConfig.appendChild)(parent, node.stateNode);
        }
      }
    } else if (node.tag === _ReactWorkTags.HostPortal) {
      // If the insertion itself is a portal, then we don't want to traverse
      // down its children. Instead, we'll get insertions from each child in
      // the portal directly.
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === finishedWork) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === finishedWork) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function unmountHostComponents(current) {
  // We only have the top Fiber that was deleted but we need to recurse down its
  var node = current;

  // Each iteration, currentParent is populated with node's host parent if not
  // currentParentIsValid.
  var currentParentIsValid = false;

  // Note: these two variables *must* always be updated together.
  var currentParent = void 0;
  var currentParentIsContainer = void 0;

  while (true) {
    if (!currentParentIsValid) {
      var parent = node.return;
      findParent: while (true) {
        (0, _invariant2.default)(parent !== null, 'Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');
        switch (parent.tag) {
          case _ReactWorkTags.HostComponent:
            currentParent = parent.stateNode;
            currentParentIsContainer = false;
            break findParent;
          case _ReactWorkTags.HostRoot:
            currentParent = parent.stateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;
          case _ReactWorkTags.HostPortal:
            currentParent = parent.stateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;
        }
        parent = parent.return;
      }
      currentParentIsValid = true;
    }

    if (node.tag === _ReactWorkTags.HostComponent || node.tag === _ReactWorkTags.HostText) {
      commitNestedUnmounts(node);
      // After all the children have unmounted, it is now safe to remove the
      // node from the tree.
      if (currentParentIsContainer) {
        (0, _ReactFiberHostConfig.removeChildFromContainer)(currentParent, node.stateNode);
      } else {
        (0, _ReactFiberHostConfig.removeChild)(currentParent, node.stateNode);
      }
      // Don't visit children because we already visited them.
    } else if (_ReactFeatureFlags.enableSuspenseServerRenderer && node.tag === _ReactWorkTags.DehydratedSuspenseComponent) {
      // Delete the dehydrated suspense boundary and all of its content.
      if (currentParentIsContainer) {
        (0, _ReactFiberHostConfig.clearSuspenseBoundaryFromContainer)(currentParent, node.stateNode);
      } else {
        (0, _ReactFiberHostConfig.clearSuspenseBoundary)(currentParent, node.stateNode);
      }
    } else if (node.tag === _ReactWorkTags.HostPortal) {
      if (node.child !== null) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        currentParentIsContainer = true;
        // Visit children because portals might contain host components.
        node.child.return = node;
        node = node.child;
        continue;
      }
    } else {
      commitUnmount(node);
      // Visit children because we may find more host components below.
      if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
    }
    if (node === current) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === current) {
        return;
      }
      node = node.return;
      if (node.tag === _ReactWorkTags.HostPortal) {
        // When we go out of the portal, we need to restore the parent.
        // Since we don't keep a stack of them, we will search for it.
        currentParentIsValid = false;
      }
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function commitDeletion(current) {
  if (_ReactFiberHostConfig.supportsMutation) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
  } else {
    // Detach refs and call componentWillUnmount() on the whole subtree.
    commitNestedUnmounts(current);
  }
  detachFiber(current);
}

function commitWork(current, finishedWork) {
  if (!_ReactFiberHostConfig.supportsMutation) {
    switch (finishedWork.tag) {
      case _ReactWorkTags.FunctionComponent:
      case _ReactWorkTags.ForwardRef:
      case _ReactWorkTags.MemoComponent:
      case _ReactWorkTags.SimpleMemoComponent:
        {
          // Note: We currently never use MountMutation, but useLayout uses
          // UnmountMutation.
          commitHookEffectList(_ReactHookEffectTags.UnmountMutation, _ReactHookEffectTags.MountMutation, finishedWork);
          return;
        }
    }

    commitContainer(finishedWork);
    return;
  }

  switch (finishedWork.tag) {
    case _ReactWorkTags.FunctionComponent:
    case _ReactWorkTags.ForwardRef:
    case _ReactWorkTags.MemoComponent:
    case _ReactWorkTags.SimpleMemoComponent:
      {
        // Note: We currently never use MountMutation, but useLayout uses
        // UnmountMutation.
        commitHookEffectList(_ReactHookEffectTags.UnmountMutation, _ReactHookEffectTags.MountMutation, finishedWork);
        return;
      }
    case _ReactWorkTags.ClassComponent:
      {
        return;
      }
    case _ReactWorkTags.HostComponent:
      {
        var instance = finishedWork.stateNode;
        if (instance != null) {
          // Commit the work prepared earlier.
          var newProps = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldProps = current !== null ? current.memoizedProps : newProps;
          var type = finishedWork.type;
          // TODO: Type the updateQueue to be specific to host components.
          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            (0, _ReactFiberHostConfig.commitUpdate)(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
        return;
      }
    case _ReactWorkTags.HostText:
      {
        (0, _invariant2.default)(finishedWork.stateNode !== null, 'This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');
        var textInstance = finishedWork.stateNode;
        var newText = finishedWork.memoizedProps;
        // For hydration we reuse the update path but we treat the oldProps
        // as the newProps. The updatePayload will contain the real change in
        // this case.
        var oldText = current !== null ? current.memoizedProps : newText;
        (0, _ReactFiberHostConfig.commitTextUpdate)(textInstance, oldText, newText);
        return;
      }
    case _ReactWorkTags.HostRoot:
      {
        return;
      }
    case _ReactWorkTags.Profiler:
      {
        return;
      }
    case _ReactWorkTags.SuspenseComponent:
      {
        var newState = finishedWork.memoizedState;

        var newDidTimeout = void 0;
        var primaryChildParent = finishedWork;
        if (newState === null) {
          newDidTimeout = false;
        } else {
          newDidTimeout = true;
          primaryChildParent = finishedWork.child;
          if (newState.timedOutAt === _ReactFiberExpirationTime.NoWork) {
            // If the children had not already timed out, record the time.
            // This is used to compute the elapsed time during subsequent
            // attempts to render the children.
            newState.timedOutAt = (0, _ReactFiberScheduler.requestCurrentTime)();
          }
        }

        if (primaryChildParent !== null) {
          hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
        }

        // If this boundary just timed out, then it will have a set of thenables.
        // For each thenable, attach a listener so that when it resolves, React
        // attempts to re-render the boundary in the primary (pre-timeout) state.
        var thenables = finishedWork.updateQueue;
        if (thenables !== null) {
          finishedWork.updateQueue = null;
          var retryCache = finishedWork.stateNode;
          if (retryCache === null) {
            retryCache = finishedWork.stateNode = new PossiblyWeakSet();
          }
          thenables.forEach(function (thenable) {
            // Memoize using the boundary fiber to prevent redundant listeners.
            var retry = _ReactFiberScheduler.retryTimedOutBoundary.bind(null, finishedWork, thenable);
            if (_ReactFeatureFlags.enableSchedulerTracing) {
              retry = (0, _tracing.unstable_wrap)(retry);
            }
            if (!retryCache.has(thenable)) {
              retryCache.add(thenable);
              thenable.then(retry, retry);
            }
          });
        }

        return;
      }
    case _ReactWorkTags.IncompleteClassComponent:
      {
        return;
      }
    default:
      {
        (0, _invariant2.default)(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
      }
  }
}

function commitResetTextContent(current) {
  if (!_ReactFiberHostConfig.supportsMutation) {
    return;
  }
  (0, _ReactFiberHostConfig.resetTextContent)(current.stateNode);
}

exports.commitBeforeMutationLifeCycles = commitBeforeMutationLifeCycles;
exports.commitResetTextContent = commitResetTextContent;
exports.commitPlacement = commitPlacement;
exports.commitDeletion = commitDeletion;
exports.commitWork = commitWork;
exports.commitLifeCycles = commitLifeCycles;
exports.commitAttachRef = commitAttachRef;
exports.commitDetachRef = commitDetachRef;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIntrinsicNamespace = getIntrinsicNamespace;
exports.getChildNamespace = getChildNamespace;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = exports.Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

exports.default = possibleStandardNames;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _react = __webpack_require__(22);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(108);

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Hooks() {
  var _useState = (0, _react.useState)(0),
      _useState2 = _slicedToArray(_useState, 2),
      count = _useState2[0],
      setCount = _useState2[1];

  return _react2.default.createElement(
    'div',
    null,
    _react2.default.createElement(
      'p',
      null,
      'you have clicked ',
      count,
      ' times'
    ),
    _react2.default.createElement(
      'button',
      { onClick: function onClick() {
          return setCount(count + 1);
        } },
      'Click me'
    )
  );
}

_reactDom2.default.render(_react2.default.createElement(Hooks, null), document.getElementById('root'));

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ReactVersion = __webpack_require__(60);

var _ReactVersion2 = _interopRequireDefault(_ReactVersion);

var _ReactSymbols = __webpack_require__(6);

var _ReactBaseClasses = __webpack_require__(91);

var _ReactCreateRef = __webpack_require__(93);

var _ReactChildren = __webpack_require__(94);

var _ReactElement = __webpack_require__(45);

var _ReactContext = __webpack_require__(100);

var _ReactLazy = __webpack_require__(101);

var _forwardRef = __webpack_require__(102);

var _forwardRef2 = _interopRequireDefault(_forwardRef);

var _memo = __webpack_require__(103);

var _memo2 = _interopRequireDefault(_memo);

var _ReactHooks = __webpack_require__(104);

var _ReactElementValidator = __webpack_require__(105);

var _ReactSharedInternals = __webpack_require__(61);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = {
  Children: {
    map: _ReactChildren.map,
    forEach: _ReactChildren.forEach,
    count: _ReactChildren.count,
    toArray: _ReactChildren.toArray,
    only: _ReactChildren.only
  },

  createRef: _ReactCreateRef.createRef,
  Component: _ReactBaseClasses.Component,
  PureComponent: _ReactBaseClasses.PureComponent,

  createContext: _ReactContext.createContext,
  forwardRef: _forwardRef2.default,
  lazy: _ReactLazy.lazy,
  memo: _memo2.default,

  useCallback: _ReactHooks.useCallback,
  useContext: _ReactHooks.useContext,
  useEffect: _ReactHooks.useEffect,
  useImperativeHandle: _ReactHooks.useImperativeHandle,
  useDebugValue: _ReactHooks.useDebugValue,
  useLayoutEffect: _ReactHooks.useLayoutEffect,
  useMemo: _ReactHooks.useMemo,
  useReducer: _ReactHooks.useReducer,
  useRef: _ReactHooks.useRef,
  useState: _ReactHooks.useState,

  Fragment: _ReactSymbols.REACT_FRAGMENT_TYPE,
  StrictMode: _ReactSymbols.REACT_STRICT_MODE_TYPE,
  Suspense: _ReactSymbols.REACT_SUSPENSE_TYPE,

  createElement:  true ? _ReactElementValidator.createElementWithValidation : _ReactElement.createElement,
  cloneElement:  true ? _ReactElementValidator.cloneElementWithValidation : _ReactElement.cloneElement,
  createFactory:  true ? _ReactElementValidator.createFactoryWithValidation : _ReactElement.createFactory,
  isValidElement: _ReactElement.isValidElement,

  version: _ReactVersion2.default,

  unstable_ConcurrentMode: _ReactSymbols.REACT_CONCURRENT_MODE_TYPE,
  unstable_Profiler: _ReactSymbols.REACT_PROFILER_TYPE,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: _ReactSharedInternals2.default
};

// Note: some APIs are added with feature flags.
// Make sure that stable builds for open source
// don't modify the React object to avoid deopts.
// Also let's not expose their names in stable builds.

if (_ReactFeatureFlags.enableStableConcurrentModeAPIs) {
  React.ConcurrentMode = _ReactSymbols.REACT_CONCURRENT_MODE_TYPE;
  React.Profiler = _ReactSymbols.REACT_PROFILER_TYPE;
  React.unstable_ConcurrentMode = undefined;
  React.unstable_Profiler = undefined;
}

exports.default = React;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PureComponent = exports.Component = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _lowPriorityWarning = __webpack_require__(32);

var _lowPriorityWarning2 = _interopRequireDefault(_lowPriorityWarning);

var _ReactNoopUpdateQueue = __webpack_require__(92);

var _ReactNoopUpdateQueue2 = _interopRequireDefault(_ReactNoopUpdateQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emptyObject = {};
if (true) {
  Object.freeze(emptyObject);
}

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  // If a component has string refs, we will assign a different object later.
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || _ReactNoopUpdateQueue2.default;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  (0, _invariant2.default)((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (true) {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function get() {
        (0, _lowPriorityWarning2.default)(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;

/**
 * Convenience component with default shallow equality check for sCU.
 */
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  // If a component has string refs, we will assign a different object later.
  this.refs = emptyObject;
  this.updater = updater || _ReactNoopUpdateQueue2.default;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
Object.assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

exports.Component = Component;
exports.PureComponent = PureComponent;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnStateUpdateForUnmountedComponent = {}; /**
                                                   * Copyright (c) Facebook, Inc. and its affiliates.
                                                   *
                                                   * This source code is licensed under the MIT license found in the
                                                   * LICENSE file in the root directory of this source tree.
                                                   */

function warnNoop(publicInstance, callerName) {
  if (true) {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    (0, _warningWithoutStack2.default)(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted(publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

exports.default = ReactNoopUpdateQueue;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRef = createRef;


// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };
  if (true) {
    Object.seal(refObject);
  }
  return refObject;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   * 
   */

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArray = exports.only = exports.count = exports.map = exports.forEach = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ReactSymbols = __webpack_require__(6);

var _ReactElement = __webpack_require__(45);

var _ReactDebugCurrentFrame = __webpack_require__(43);

var _ReactDebugCurrentFrame2 = _interopRequireDefault(_ReactDebugCurrentFrame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case _ReactSymbols.REACT_ELEMENT_TYPE:
          case _ReactSymbols.REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child = void 0;
  var nextName = void 0;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = (0, _ReactSymbols.getIteratorFn)(children);
    if (typeof iteratorFn === 'function') {
      if (true) {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          (0, _warning2.default)(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.');
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step = void 0;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      if (true) {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + _ReactDebugCurrentFrame2.default.getStackAddendum();
      }
      var childrenString = '' + children;
      (0, _invariant2.default)(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
      return c;
    });
  } else if (mappedChild != null) {
    if ((0, _ReactElement.isValidElement)(mappedChild)) {
      mappedChild = (0, _ReactElement.cloneAndReplaceKey)(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children) {
  return traverseAllChildren(children, function () {
    return null;
  }, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
    return child;
  });
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  (0, _invariant2.default)((0, _ReactElement.isValidElement)(children), 'React.Children.only expected to receive a single React element child.');
  return children;
}

exports.forEach = forEachChildren;
exports.map = mapChildren;
exports.count = countChildren;
exports.only = onlyChild;
exports.toArray = toArray;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unstable_now = exports.unstable_getFirstCallbackNode = exports.unstable_pauseExecution = exports.unstable_continueExecution = exports.unstable_shouldYield = exports.unstable_getCurrentPriorityLevel = exports.unstable_wrapCallback = exports.unstable_cancelCallback = exports.unstable_scheduleCallback = exports.unstable_next = exports.unstable_runWithPriority = exports.unstable_LowPriority = exports.unstable_IdlePriority = exports.unstable_NormalPriority = exports.unstable_UserBlockingPriority = exports.unstable_ImmediatePriority = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               */

/* eslint-disable no-var */

var _SchedulerFeatureFlags = __webpack_require__(98);

// TODO: Use symbols?
var ImmediatePriority = 1;
var UserBlockingPriority = 2;
var NormalPriority = 3;
var LowPriority = 4;
var IdlePriority = 5;

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var maxSigned31BitInt = 1073741823;

// Times out immediately
var IMMEDIATE_PRIORITY_TIMEOUT = -1;
// Eventually times out
var USER_BLOCKING_PRIORITY = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000;
// Never times out
var IDLE_PRIORITY = maxSigned31BitInt;

// Callbacks are stored as a circular, doubly linked list.
var firstCallbackNode = null;

var currentDidTimeout = false;
// Pausing the scheduler is useful for debugging.
var isSchedulerPaused = false;

var currentPriorityLevel = NormalPriority;
var currentEventStartTime = -1;
var currentExpirationTime = -1;

// This is set when a callback is being executed, to prevent re-entrancy.
var isExecutingCallback = false;

var isHostCallbackScheduled = false;

var hasNativePerformanceNow = (typeof performance === 'undefined' ? 'undefined' : _typeof(performance)) === 'object' && typeof performance.now === 'function';

function ensureHostCallbackIsScheduled() {
  if (isExecutingCallback) {
    // Don't schedule work yet; wait until the next time we yield.
    return;
  }
  // Schedule the host callback using the earliest expiration in the list.
  var expirationTime = firstCallbackNode.expirationTime;
  if (!isHostCallbackScheduled) {
    isHostCallbackScheduled = true;
  } else {
    // Cancel the existing host callback.
    cancelHostCallback();
  }
  _requestHostCallback(flushWork, expirationTime);
}

function flushFirstCallback() {
  var flushedNode = firstCallbackNode;

  // Remove the node from the list before calling the callback. That way the
  // list is in a consistent state even if the callback throws.
  var next = firstCallbackNode.next;
  if (firstCallbackNode === next) {
    // This is the last callback in the list.
    firstCallbackNode = null;
    next = null;
  } else {
    var lastCallbackNode = firstCallbackNode.previous;
    firstCallbackNode = lastCallbackNode.next = next;
    next.previous = lastCallbackNode;
  }

  flushedNode.next = flushedNode.previous = null;

  // Now it's safe to call the callback.
  var callback = flushedNode.callback;
  var expirationTime = flushedNode.expirationTime;
  var priorityLevel = flushedNode.priorityLevel;
  var previousPriorityLevel = currentPriorityLevel;
  var previousExpirationTime = currentExpirationTime;
  currentPriorityLevel = priorityLevel;
  currentExpirationTime = expirationTime;
  var continuationCallback;
  try {
    continuationCallback = callback();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
    currentExpirationTime = previousExpirationTime;
  }

  // A callback may return a continuation. The continuation should be scheduled
  // with the same priority and expiration as the just-finished callback.
  if (typeof continuationCallback === 'function') {
    var continuationNode = {
      callback: continuationCallback,
      priorityLevel: priorityLevel,
      expirationTime: expirationTime,
      next: null,
      previous: null
    };

    // Insert the new callback into the list, sorted by its expiration. This is
    // almost the same as the code in `scheduleCallback`, except the callback
    // is inserted into the list *before* callbacks of equal expiration instead
    // of after.
    if (firstCallbackNode === null) {
      // This is the first callback in the list.
      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;
    } else {
      var nextAfterContinuation = null;
      var node = firstCallbackNode;
      do {
        if (node.expirationTime >= expirationTime) {
          // This callback expires at or after the continuation. We will insert
          // the continuation *before* this callback.
          nextAfterContinuation = node;
          break;
        }
        node = node.next;
      } while (node !== firstCallbackNode);

      if (nextAfterContinuation === null) {
        // No equal or lower priority callback was found, which means the new
        // callback is the lowest priority callback in the list.
        nextAfterContinuation = firstCallbackNode;
      } else if (nextAfterContinuation === firstCallbackNode) {
        // The new callback is the highest priority callback in the list.
        firstCallbackNode = continuationNode;
        ensureHostCallbackIsScheduled();
      }

      var previous = nextAfterContinuation.previous;
      previous.next = nextAfterContinuation.previous = continuationNode;
      continuationNode.next = nextAfterContinuation;
      continuationNode.previous = previous;
    }
  }
}

function flushImmediateWork() {
  if (
  // Confirm we've exited the outer most event handler
  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {
    isExecutingCallback = true;
    try {
      do {
        flushFirstCallback();
      } while (
      // Keep flushing until there are no more immediate callbacks
      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);
    } finally {
      isExecutingCallback = false;
      if (firstCallbackNode !== null) {
        // There's still work remaining. Request another callback.
        ensureHostCallbackIsScheduled();
      } else {
        isHostCallbackScheduled = false;
      }
    }
  }
}

function flushWork(didTimeout) {
  // Exit right away if we're currently paused

  if (_SchedulerFeatureFlags.enableSchedulerDebugging && isSchedulerPaused) {
    return;
  }

  isExecutingCallback = true;
  var previousDidTimeout = currentDidTimeout;
  currentDidTimeout = didTimeout;
  try {
    if (didTimeout) {
      // Flush all the expired callbacks without yielding.
      while (firstCallbackNode !== null && !(_SchedulerFeatureFlags.enableSchedulerDebugging && isSchedulerPaused)) {
        // TODO Wrap in feature flag
        // Read the current time. Flush all the callbacks that expire at or
        // earlier than that time. Then read the current time again and repeat.
        // This optimizes for as few performance.now calls as possible.
        var currentTime = getCurrentTime();
        if (firstCallbackNode.expirationTime <= currentTime) {
          do {
            flushFirstCallback();
          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(_SchedulerFeatureFlags.enableSchedulerDebugging && isSchedulerPaused));
          continue;
        }
        break;
      }
    } else {
      // Keep flushing callbacks until we run out of time in the frame.
      if (firstCallbackNode !== null) {
        do {
          if (_SchedulerFeatureFlags.enableSchedulerDebugging && isSchedulerPaused) {
            break;
          }
          flushFirstCallback();
        } while (firstCallbackNode !== null && !shouldYieldToHost());
      }
    }
  } finally {
    isExecutingCallback = false;
    currentDidTimeout = previousDidTimeout;
    if (firstCallbackNode !== null) {
      // There's still work remaining. Request another callback.
      ensureHostCallbackIsScheduled();
    } else {
      isHostCallbackScheduled = false;
    }
    // Before exiting, flush all the immediate work that was scheduled.
    flushImmediateWork();
  }
}

function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;
    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  var previousEventStartTime = currentEventStartTime;
  currentPriorityLevel = priorityLevel;
  currentEventStartTime = getCurrentTime();

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
    currentEventStartTime = previousEventStartTime;

    // Before exiting, flush all the immediate work that was scheduled.
    flushImmediateWork();
  }
}

function unstable_next(eventHandler) {
  var priorityLevel = void 0;
  switch (currentPriorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
      // Shift down to normal priority
      priorityLevel = NormalPriority;
      break;
    default:
      // Anything lower than normal priority should remain at the current level.
      priorityLevel = currentPriorityLevel;
      break;
  }

  var previousPriorityLevel = currentPriorityLevel;
  var previousEventStartTime = currentEventStartTime;
  currentPriorityLevel = priorityLevel;
  currentEventStartTime = getCurrentTime();

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
    currentEventStartTime = previousEventStartTime;

    // Before exiting, flush all the immediate work that was scheduled.
    flushImmediateWork();
  }
}

function unstable_wrapCallback(callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    // This is a fork of runWithPriority, inlined for performance.
    var previousPriorityLevel = currentPriorityLevel;
    var previousEventStartTime = currentEventStartTime;
    currentPriorityLevel = parentPriorityLevel;
    currentEventStartTime = getCurrentTime();

    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
      currentEventStartTime = previousEventStartTime;
      flushImmediateWork();
    }
  };
}

function unstable_scheduleCallback(callback, deprecated_options) {
  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime();

  var expirationTime;
  if ((typeof deprecated_options === 'undefined' ? 'undefined' : _typeof(deprecated_options)) === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {
    // FIXME: Remove this branch once we lift expiration times out of React.
    expirationTime = startTime + deprecated_options.timeout;
  } else {
    switch (currentPriorityLevel) {
      case ImmediatePriority:
        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;
        break;
      case UserBlockingPriority:
        expirationTime = startTime + USER_BLOCKING_PRIORITY;
        break;
      case IdlePriority:
        expirationTime = startTime + IDLE_PRIORITY;
        break;
      case LowPriority:
        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;
        break;
      case NormalPriority:
      default:
        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;
    }
  }

  var newNode = {
    callback: callback,
    priorityLevel: currentPriorityLevel,
    expirationTime: expirationTime,
    next: null,
    previous: null
  };

  // Insert the new callback into the list, ordered first by expiration, then
  // by insertion. So the new callback is inserted any other callback with
  // equal expiration.
  if (firstCallbackNode === null) {
    // This is the first callback in the list.
    firstCallbackNode = newNode.next = newNode.previous = newNode;
    ensureHostCallbackIsScheduled();
  } else {
    var next = null;
    var node = firstCallbackNode;
    do {
      if (node.expirationTime > expirationTime) {
        // The new callback expires before this one.
        next = node;
        break;
      }
      node = node.next;
    } while (node !== firstCallbackNode);

    if (next === null) {
      // No callback with a later expiration was found, which means the new
      // callback has the latest expiration in the list.
      next = firstCallbackNode;
    } else if (next === firstCallbackNode) {
      // The new callback has the earliest expiration in the entire list.
      firstCallbackNode = newNode;
      ensureHostCallbackIsScheduled();
    }

    var previous = next.previous;
    previous.next = next.previous = newNode;
    newNode.next = next;
    newNode.previous = previous;
  }

  return newNode;
}

function unstable_pauseExecution() {
  isSchedulerPaused = true;
}

function unstable_continueExecution() {
  isSchedulerPaused = false;
  if (firstCallbackNode !== null) {
    ensureHostCallbackIsScheduled();
  }
}

function unstable_getFirstCallbackNode() {
  return firstCallbackNode;
}

function unstable_cancelCallback(callbackNode) {
  var next = callbackNode.next;
  if (next === null) {
    // Already cancelled.
    return;
  }

  if (next === callbackNode) {
    // This is the only scheduled callback. Clear the list.
    firstCallbackNode = null;
  } else {
    // Remove the callback from its position in the list.
    if (callbackNode === firstCallbackNode) {
      firstCallbackNode = next;
    }
    var previous = callbackNode.previous;
    previous.next = next;
    next.previous = previous;
  }

  callbackNode.next = callbackNode.previous = null;
}

function unstable_getCurrentPriorityLevel() {
  return currentPriorityLevel;
}

function unstable_shouldYield() {
  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());
}

// The remaining code is essentially a polyfill for requestIdleCallback. It
// works by scheduling a requestAnimationFrame, storing the time for the start
// of the frame, then scheduling a postMessage which gets scheduled after paint.
// Within the postMessage handler do as much work as possible until time + frame
// rate. By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

// We capture a local reference to any global, in case it gets polyfilled after
// this module is initially evaluated. We want to be using a
// consistent implementation.
var localDate = Date;

// This initialization code may run even on server environments if a component
// just imports ReactDOM (e.g. for findDOMNode). Some environments might not
// have setTimeout or clearTimeout. However, we always expect them to be defined
// on the client. https://github.com/facebook/react/pull/13088
var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;

// We don't expect either of these to necessarily be defined, but we will error
// later if they are missing on the client.
var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;
var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;

var getCurrentTime;

// requestAnimationFrame does not run when the tab is in the background. If
// we're backgrounded we prefer for that work to happen so that the page
// continues to load in the background. So we also schedule a 'setTimeout' as
// a fallback.
// TODO: Need a better heuristic for backgrounded work.
var ANIMATION_FRAME_TIMEOUT = 100;
var rAFID;
var rAFTimeoutID;
var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {
  // schedule rAF and also a setTimeout
  rAFID = localRequestAnimationFrame(function (timestamp) {
    // cancel the setTimeout
    localClearTimeout(rAFTimeoutID);
    callback(timestamp);
  });
  rAFTimeoutID = localSetTimeout(function () {
    // cancel the requestAnimationFrame
    localCancelAnimationFrame(rAFID);
    callback(getCurrentTime());
  }, ANIMATION_FRAME_TIMEOUT);
};

if (hasNativePerformanceNow) {
  var Performance = performance;
  exports.unstable_now = getCurrentTime = function getCurrentTime() {
    return Performance.now();
  };
} else {
  exports.unstable_now = getCurrentTime = function getCurrentTime() {
    return localDate.now();
  };
}

var _requestHostCallback;
var cancelHostCallback;
var shouldYieldToHost;

var globalValue = null;
if (typeof window !== 'undefined') {
  globalValue = window;
} else if (typeof global !== 'undefined') {
  globalValue = global;
}

if (globalValue && globalValue._schedMock) {
  // Dynamic injection, only for testing purposes.
  var globalImpl = globalValue._schedMock;
  _requestHostCallback = globalImpl[0];
  cancelHostCallback = globalImpl[1];
  shouldYieldToHost = globalImpl[2];
  exports.unstable_now = getCurrentTime = globalImpl[3];
} else if (
// If Scheduler runs in a non-DOM environment, it falls back to a naive
// implementation using setTimeout.
typeof window === 'undefined' ||
// Check if MessageChannel is supported, too.
typeof MessageChannel !== 'function') {
  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
  // fallback to a naive implementation.
  var _callback = null;
  var _flushCallback = function _flushCallback(didTimeout) {
    if (_callback !== null) {
      try {
        _callback(didTimeout);
      } finally {
        _callback = null;
      }
    }
  };
  _requestHostCallback = function requestHostCallback(cb, ms) {
    if (_callback !== null) {
      // Protect against re-entrancy.
      setTimeout(_requestHostCallback, 0, cb);
    } else {
      _callback = cb;
      setTimeout(_flushCallback, 0, false);
    }
  };
  cancelHostCallback = function cancelHostCallback() {
    _callback = null;
  };
  shouldYieldToHost = function shouldYieldToHost() {
    return false;
  };
} else {
  if (typeof console !== 'undefined') {
    // TODO: Remove fb.me link
    if (typeof localRequestAnimationFrame !== 'function') {
      console.error("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
    }
    if (typeof localCancelAnimationFrame !== 'function') {
      console.error("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
    }
  }

  var scheduledHostCallback = null;
  var isMessageEventScheduled = false;
  var timeoutTime = -1;

  var isAnimationFrameScheduled = false;

  var isFlushingHostCallback = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  shouldYieldToHost = function shouldYieldToHost() {
    return frameDeadline <= getCurrentTime();
  };

  // We use the postMessage trick to defer idle work until after the repaint.
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = function (event) {
    isMessageEventScheduled = false;

    var prevScheduledCallback = scheduledHostCallback;
    var prevTimeoutTime = timeoutTime;
    scheduledHostCallback = null;
    timeoutTime = -1;

    var currentTime = getCurrentTime();

    var didTimeout = false;
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrameWithTimeout(animationTick);
        }
        // Exit without invoking the callback.
        scheduledHostCallback = prevScheduledCallback;
        timeoutTime = prevTimeoutTime;
        return;
      }
    }

    if (prevScheduledCallback !== null) {
      isFlushingHostCallback = true;
      try {
        prevScheduledCallback(didTimeout);
      } finally {
        isFlushingHostCallback = false;
      }
    }
  };

  var animationTick = function animationTick(rafTime) {
    if (scheduledHostCallback !== null) {
      // Eagerly schedule the next animation callback at the beginning of the
      // frame. If the scheduler queue is not empty at the end of the frame, it
      // will continue flushing inside that callback. If the queue *is* empty,
      // then it will exit immediately. Posting the callback at the start of the
      // frame ensures it's fired within the earliest possible frame. If we
      // waited until the end of the frame to post the callback, we risk the
      // browser skipping a frame and not firing the callback until the frame
      // after that.
      requestAnimationFrameWithTimeout(animationTick);
    } else {
      // No pending work. Exit.
      isAnimationFrameScheduled = false;
      return;
    }

    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If the calculated frame time gets lower than 8, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isMessageEventScheduled) {
      isMessageEventScheduled = true;
      port.postMessage(undefined);
    }
  };

  _requestHostCallback = function _requestHostCallback(callback, absoluteTimeout) {
    scheduledHostCallback = callback;
    timeoutTime = absoluteTimeout;
    if (isFlushingHostCallback || absoluteTimeout < 0) {
      // Don't wait for the next frame. Continue working ASAP, in a new event.
      port.postMessage(undefined);
    } else if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrameWithTimeout(animationTick);
    }
  };

  cancelHostCallback = function cancelHostCallback() {
    scheduledHostCallback = null;
    isMessageEventScheduled = false;
    timeoutTime = -1;
  };
}

exports.unstable_ImmediatePriority = ImmediatePriority;
exports.unstable_UserBlockingPriority = UserBlockingPriority;
exports.unstable_NormalPriority = NormalPriority;
exports.unstable_IdlePriority = IdlePriority;
exports.unstable_LowPriority = LowPriority;
exports.unstable_runWithPriority = unstable_runWithPriority;
exports.unstable_next = unstable_next;
exports.unstable_scheduleCallback = unstable_scheduleCallback;
exports.unstable_cancelCallback = unstable_cancelCallback;
exports.unstable_wrapCallback = unstable_wrapCallback;
exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
exports.unstable_shouldYield = unstable_shouldYield;
exports.unstable_continueExecution = unstable_continueExecution;
exports.unstable_pauseExecution = unstable_pauseExecution;
exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
exports.unstable_now = getCurrentTime;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(97)))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

var enableSchedulerDebugging = exports.enableSchedulerDebugging = false;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unstable_subscribe = unstable_subscribe;
exports.unstable_unsubscribe = unstable_unsubscribe;

var _ReactFeatureFlags = __webpack_require__(3);

var _Tracing = __webpack_require__(63);

var subscribers = null; /**
                         * Copyright (c) Facebook, Inc. and its affiliates.
                         *
                         * This source code is licensed under the MIT license found in the
                         * LICENSE file in the root directory of this source tree.
                         *
                         * 
                         */

if (_ReactFeatureFlags.enableSchedulerTracing) {
  subscribers = new Set();
}

function unstable_subscribe(subscriber) {
  if (_ReactFeatureFlags.enableSchedulerTracing) {
    subscribers.add(subscriber);

    if (subscribers.size === 1) {
      _Tracing.__subscriberRef.current = {
        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
        onInteractionTraced: onInteractionTraced,
        onWorkCanceled: onWorkCanceled,
        onWorkScheduled: onWorkScheduled,
        onWorkStarted: onWorkStarted,
        onWorkStopped: onWorkStopped
      };
    }
  }
}

function unstable_unsubscribe(subscriber) {
  if (_ReactFeatureFlags.enableSchedulerTracing) {
    subscribers.delete(subscriber);

    if (subscribers.size === 0) {
      _Tracing.__subscriberRef.current = null;
    }
  }
}

function onInteractionTraced(interaction) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionTraced(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onInteractionScheduledWorkCompleted(interaction) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionScheduledWorkCompleted(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkScheduled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkScheduled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStarted(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStarted(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStopped(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStopped(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkCanceled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkCanceled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createContext = createContext;

var _ReactSymbols = __webpack_require__(6);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    if (true) {
      (0, _warningWithoutStack2.default)(calculateChangedBits === null || typeof calculateChangedBits === 'function', 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
    }
  }

  var context = {
    $$typeof: _ReactSymbols.REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };

  context.Provider = {
    $$typeof: _ReactSymbols.REACT_PROVIDER_TYPE,
    _context: context
  };

  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;

  if (true) {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: _ReactSymbols.REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    };
    // $FlowFixMe: Flow complains about not setting a value, which is intentional here
    Object.defineProperties(Consumer, {
      Provider: {
        get: function get() {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;
            (0, _warning2.default)(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }
          return context.Provider;
        },
        set: function set(_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function get() {
          return context._currentValue;
        },
        set: function set(_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function get() {
          return context._currentValue2;
        },
        set: function set(_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function get() {
          return context._threadCount;
        },
        set: function set(_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function get() {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;
            (0, _warning2.default)(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }
          return context.Consumer;
        }
      }
    });
    // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty
    context.Consumer = Consumer;
  } else {
    context.Consumer = context;
  }

  if (true) {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lazy = lazy;

var _ReactSymbols = __webpack_require__(6);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lazy(ctor) {
  var lazyType = {
    $$typeof: _ReactSymbols.REACT_LAZY_TYPE,
    _ctor: ctor,
    // React uses these fields to store the result.
    _status: -1,
    _result: null
  };

  if (true) {
    // In production, this would just set it on the object.
    var defaultProps = void 0;
    var propTypes = void 0;
    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function get() {
          return defaultProps;
        },
        set: function set(newDefaultProps) {
          (0, _warning2.default)(false, 'React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
          defaultProps = newDefaultProps;
          // Match production behavior more closely:
          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function get() {
          return propTypes;
        },
        set: function set(newPropTypes) {
          (0, _warning2.default)(false, 'React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
          propTypes = newPropTypes;
          // Match production behavior more closely:
          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

exports.default = forwardRef;

var _ReactSymbols = __webpack_require__(6);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function forwardRef(render) {
  if (true) {
    if (render != null && render.$$typeof === _ReactSymbols.REACT_MEMO_TYPE) {
      (0, _warningWithoutStack2.default)(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      (0, _warningWithoutStack2.default)(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render === 'undefined' ? 'undefined' : _typeof(render));
    } else {
      (0, _warningWithoutStack2.default)(
      // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object
      render.length === 0 || render.length === 2, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
    }

    if (render != null) {
      (0, _warningWithoutStack2.default)(render.defaultProps == null && render.propTypes == null, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
    }
  }

  return {
    $$typeof: _ReactSymbols.REACT_FORWARD_REF_TYPE,
    render: render
  };
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

exports.default = memo;

var _ReactSymbols = __webpack_require__(6);

var _isValidElementType = __webpack_require__(66);

var _isValidElementType2 = _interopRequireDefault(_isValidElementType);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function memo(type, compare) {
  if (true) {
    if (!(0, _isValidElementType2.default)(type)) {
      (0, _warningWithoutStack2.default)(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type === 'undefined' ? 'undefined' : _typeof(type));
    }
  }
  return {
    $$typeof: _ReactSymbols.REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };
}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useContext = useContext;
exports.useState = useState;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useEffect = useEffect;
exports.useLayoutEffect = useLayoutEffect;
exports.useCallback = useCallback;
exports.useMemo = useMemo;
exports.useImperativeHandle = useImperativeHandle;
exports.useDebugValue = useDebugValue;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ReactCurrentDispatcher = __webpack_require__(64);

var _ReactCurrentDispatcher2 = _interopRequireDefault(_ReactCurrentDispatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function resolveDispatcher() {
  var dispatcher = _ReactCurrentDispatcher2.default.current;
  (0, _invariant2.default)(dispatcher !== null, 'Hooks can only be called inside the body of a function component. ' + '(https://fb.me/react-invalid-hook-call)');
  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();
  if (true) {
    (0, _warning2.default)(unstable_observedBits === undefined, 'useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '');

    // TODO: add a more generic warning for invalid values.
    if (Context._context !== undefined) {
      var realContext = Context._context;
      // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.
      if (realContext.Consumer === Context) {
        (0, _warning2.default)(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        (0, _warning2.default)(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }
  return dispatcher.useContext(Context, unstable_observedBits);
}

function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}

function useEffect(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, inputs);
}

function useLayoutEffect(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, inputs);
}

function useCallback(callback, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, inputs);
}

function useMemo(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, inputs);
}

function useImperativeHandle(ref, create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, inputs);
}

function useDebugValue(value, formatterFn) {
  if (true) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

exports.createElementWithValidation = createElementWithValidation;
exports.createFactoryWithValidation = createFactoryWithValidation;
exports.cloneElementWithValidation = cloneElementWithValidation;

var _lowPriorityWarning = __webpack_require__(32);

var _lowPriorityWarning2 = _interopRequireDefault(_lowPriorityWarning);

var _isValidElementType = __webpack_require__(66);

var _isValidElementType2 = _interopRequireDefault(_isValidElementType);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _ReactSymbols = __webpack_require__(6);

var _checkPropTypes = __webpack_require__(33);

var _checkPropTypes2 = _interopRequireDefault(_checkPropTypes);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactCurrentOwner = __webpack_require__(42);

var _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);

var _ReactElement = __webpack_require__(45);

var _ReactDebugCurrentFrame = __webpack_require__(43);

var _ReactDebugCurrentFrame2 = _interopRequireDefault(_ReactDebugCurrentFrame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var propTypesMisspellWarningShown = void 0;

if (true) {
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (_ReactCurrentOwner2.default.current) {
    var name = (0, _getComponentName2.default)(_ReactCurrentOwner2.default.current.type);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== _ReactCurrentOwner2.default.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + (0, _getComponentName2.default)(element._owner.type) + '.';
  }

  (0, _ReactDebugCurrentFrame.setCurrentlyValidatingElement)(element);
  if (true) {
    (0, _warning2.default)(false, 'Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
  }
  (0, _ReactDebugCurrentFrame.setCurrentlyValidatingElement)(null);
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if ((0, _ReactElement.isValidElement)(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if ((0, _ReactElement.isValidElement)(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = (0, _ReactSymbols.getIteratorFn)(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step = void 0;
        while (!(step = iterator.next()).done) {
          if ((0, _ReactElement.isValidElement)(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var type = element.type;
  if (type === null || type === undefined || typeof type === 'string') {
    return;
  }
  var name = (0, _getComponentName2.default)(type);
  var propTypes = void 0;
  if (typeof type === 'function') {
    propTypes = type.propTypes;
  } else if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && (type.$$typeof === _ReactSymbols.REACT_FORWARD_REF_TYPE ||
  // Note: Memo only checks outer props here.
  // Inner props are checked in the reconciler.
  type.$$typeof === _ReactSymbols.REACT_MEMO_TYPE)) {
    propTypes = type.propTypes;
  } else {
    return;
  }
  if (propTypes) {
    (0, _ReactDebugCurrentFrame.setCurrentlyValidatingElement)(element);
    (0, _checkPropTypes2.default)(propTypes, element.props, 'prop', name, _ReactDebugCurrentFrame2.default.getStackAddendum);
    (0, _ReactDebugCurrentFrame.setCurrentlyValidatingElement)(null);
  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    (0, _warningWithoutStack2.default)(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof type.getDefaultProps === 'function') {
    (0, _warningWithoutStack2.default)(type.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  (0, _ReactDebugCurrentFrame.setCurrentlyValidatingElement)(fragment);

  var keys = Object.keys(fragment.props);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key !== 'children' && key !== 'key') {
      (0, _warning2.default)(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
      break;
    }
  }

  if (fragment.ref !== null) {
    (0, _warning2.default)(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
  }

  (0, _ReactDebugCurrentFrame.setCurrentlyValidatingElement)(null);
}

function createElementWithValidation(type, props, children) {
  var validType = (0, _isValidElementType2.default)(type);

  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString = void 0;
    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === _ReactSymbols.REACT_ELEMENT_TYPE) {
      typeString = '<' + ((0, _getComponentName2.default)(type.type) || 'Unknown') + ' />';
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type === 'undefined' ? 'undefined' : _typeof(type);
    }

    (0, _warning2.default)(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = _ReactElement.createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === _ReactSymbols.REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;
  // Legacy hook: remove it
  if (true) {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function get() {
        (0, _lowPriorityWarning2.default)(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = _ReactElement.cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



var ReactDOM = __webpack_require__(109);

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
module.exports = ReactDOM.default || ReactDOM;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(110);

__webpack_require__(111);

var _inline = __webpack_require__(138);

var _ReactPortal = __webpack_require__(147);

var _ExecutionEnvironment = __webpack_require__(17);

var _ReactGenericBatching = __webpack_require__(48);

var _ReactControlledComponent = __webpack_require__(47);

var _EventPluginHub = __webpack_require__(24);

var _EventPluginRegistry = __webpack_require__(25);

var _EventPropagators = __webpack_require__(20);

var _ReactInstanceMap = __webpack_require__(37);

var _ReactVersion = __webpack_require__(60);

var _ReactVersion2 = _interopRequireDefault(_ReactVersion);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _lowPriorityWarning = __webpack_require__(32);

var _lowPriorityWarning2 = _interopRequireDefault(_lowPriorityWarning);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactFeatureFlags = __webpack_require__(3);

var _ReactDOMComponentTree = __webpack_require__(16);

var _ReactDOMComponent = __webpack_require__(148);

var _ReactDOMEventListener = __webpack_require__(76);

var _HTMLNodeType = __webpack_require__(15);

var _DOMProperty = __webpack_require__(26);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: This type is shared between the reconciler and ReactDOM, but will
// eventually be lifted out to the renderer.
var ReactCurrentOwner = _ReactSharedInternals2.default.ReactCurrentOwner; /**
                                                                           * Copyright (c) Facebook, Inc. and its affiliates.
                                                                           *
                                                                           * This source code is licensed under the MIT license found in the
                                                                           * LICENSE file in the root directory of this source tree.
                                                                           *
                                                                           * 
                                                                           */

var topLevelUpdateWarnings = void 0;
var warnOnInvalidCallback = void 0;
var didWarnAboutUnstableCreatePortal = false;

if (true) {
  if (typeof Map !== 'function' ||
  // $FlowIssue Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' ||
  // $FlowIssue Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    (0, _warningWithoutStack2.default)(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
  }

  topLevelUpdateWarnings = function topLevelUpdateWarnings(container) {
    if (container._reactRootContainer && container.nodeType !== _HTMLNodeType.COMMENT_NODE) {
      var hostInstance = (0, _inline.findHostInstanceWithNoPortals)(container._reactRootContainer._internalRoot.current);
      if (hostInstance) {
        (0, _warningWithoutStack2.default)(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && (0, _ReactDOMComponentTree.getInstanceFromNode)(rootEl));

    (0, _warningWithoutStack2.default)(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    (0, _warningWithoutStack2.default)(container.nodeType !== _HTMLNodeType.ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  };

  warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
    (0, _warningWithoutStack2.default)(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };
}

(0, _ReactControlledComponent.setRestoreImplementation)(_ReactDOMComponent.restoreControlledState);

function ReactBatch(root) {
  var expirationTime = (0, _inline.computeUniqueAsyncExpiration)();
  this._expirationTime = expirationTime;
  this._root = root;
  this._next = null;
  this._callbacks = null;
  this._didComplete = false;
  this._hasChildren = false;
  this._children = null;
  this._defer = true;
}
ReactBatch.prototype.render = function (children) {
  (0, _invariant2.default)(this._defer, 'batch.render: Cannot render a batch that already committed.');
  this._hasChildren = true;
  this._children = children;
  var internalRoot = this._root._internalRoot;
  var expirationTime = this._expirationTime;
  var work = new ReactWork();
  (0, _inline.updateContainerAtExpirationTime)(children, internalRoot, null, expirationTime, work._onCommit);
  return work;
};
ReactBatch.prototype.then = function (onComplete) {
  if (this._didComplete) {
    onComplete();
    return;
  }
  var callbacks = this._callbacks;
  if (callbacks === null) {
    callbacks = this._callbacks = [];
  }
  callbacks.push(onComplete);
};
ReactBatch.prototype.commit = function () {
  var internalRoot = this._root._internalRoot;
  var firstBatch = internalRoot.firstBatch;
  (0, _invariant2.default)(this._defer && firstBatch !== null, 'batch.commit: Cannot commit a batch multiple times.');

  if (!this._hasChildren) {
    // This batch is empty. Return.
    this._next = null;
    this._defer = false;
    return;
  }

  var expirationTime = this._expirationTime;

  // Ensure this is the first batch in the list.
  if (firstBatch !== this) {
    // This batch is not the earliest batch. We need to move it to the front.
    // Update its expiration time to be the expiration time of the earliest
    // batch, so that we can flush it without flushing the other batches.
    if (this._hasChildren) {
      expirationTime = this._expirationTime = firstBatch._expirationTime;
      // Rendering this batch again ensures its children will be the final state
      // when we flush (updates are processed in insertion order: last
      // update wins).
      // TODO: This forces a restart. Should we print a warning?
      this.render(this._children);
    }

    // Remove the batch from the list.
    var previous = null;
    var batch = firstBatch;
    while (batch !== this) {
      previous = batch;
      batch = batch._next;
    }
    (0, _invariant2.default)(previous !== null, 'batch.commit: Cannot commit a batch multiple times.');
    previous._next = batch._next;

    // Add it to the front.
    this._next = firstBatch;
    firstBatch = internalRoot.firstBatch = this;
  }

  // Synchronously flush all the work up to this batch's expiration time.
  this._defer = false;
  (0, _inline.flushRoot)(internalRoot, expirationTime);

  // Pop the batch from the list.
  var next = this._next;
  this._next = null;
  firstBatch = internalRoot.firstBatch = next;

  // Append the next earliest batch's children to the update queue.
  if (firstBatch !== null && firstBatch._hasChildren) {
    firstBatch.render(firstBatch._children);
  }
};
ReactBatch.prototype._onComplete = function () {
  if (this._didComplete) {
    return;
  }
  this._didComplete = true;
  var callbacks = this._callbacks;
  if (callbacks === null) {
    return;
  }
  // TODO: Error handling.
  for (var i = 0; i < callbacks.length; i++) {
    var _callback = callbacks[i];
    _callback();
  }
};

function ReactWork() {
  this._callbacks = null;
  this._didCommit = false;
  // TODO: Avoid need to bind by replacing callbacks in the update queue with
  // list of Work objects.
  this._onCommit = this._onCommit.bind(this);
}
ReactWork.prototype.then = function (onCommit) {
  if (this._didCommit) {
    onCommit();
    return;
  }
  var callbacks = this._callbacks;
  if (callbacks === null) {
    callbacks = this._callbacks = [];
  }
  callbacks.push(onCommit);
};
ReactWork.prototype._onCommit = function () {
  if (this._didCommit) {
    return;
  }
  this._didCommit = true;
  var callbacks = this._callbacks;
  if (callbacks === null) {
    return;
  }
  // TODO: Error handling.
  for (var i = 0; i < callbacks.length; i++) {
    var _callback2 = callbacks[i];
    (0, _invariant2.default)(typeof _callback2 === 'function', 'Invalid argument passed as callback. Expected a function. Instead ' + 'received: %s', _callback2);
    _callback2();
  }
};

function ReactRoot(container, isConcurrent, hydrate) {
  var root = (0, _inline.createContainer)(container, isConcurrent, hydrate);
  this._internalRoot = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (true) {
    warnOnInvalidCallback(callback, 'render');
  }
  if (callback !== null) {
    work.then(callback);
  }
  (0, _inline.updateContainer)(children, root, null, work._onCommit);
  return work;
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (true) {
    warnOnInvalidCallback(callback, 'render');
  }
  if (callback !== null) {
    work.then(callback);
  }
  (0, _inline.updateContainer)(null, root, null, work._onCommit);
  return work;
};
ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (true) {
    warnOnInvalidCallback(callback, 'render');
  }
  if (callback !== null) {
    work.then(callback);
  }
  (0, _inline.updateContainer)(children, root, parentComponent, work._onCommit);
  return work;
};
ReactRoot.prototype.createBatch = function () {
  var batch = new ReactBatch(this);
  var expirationTime = batch._expirationTime;

  var internalRoot = this._internalRoot;
  var firstBatch = internalRoot.firstBatch;
  if (firstBatch === null) {
    internalRoot.firstBatch = batch;
    batch._next = null;
  } else {
    // Insert sorted by expiration time then insertion order
    var insertAfter = null;
    var insertBefore = firstBatch;
    while (insertBefore !== null && insertBefore._expirationTime >= expirationTime) {
      insertAfter = insertBefore;
      insertBefore = insertBefore._next;
    }
    batch._next = insertBefore;
    if (insertAfter !== null) {
      insertAfter._next = batch;
    }
  }

  return batch;
};

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === _HTMLNodeType.ELEMENT_NODE || node.nodeType === _HTMLNodeType.DOCUMENT_NODE || node.nodeType === _HTMLNodeType.DOCUMENT_FRAGMENT_NODE || node.nodeType === _HTMLNodeType.COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === _HTMLNodeType.DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === _HTMLNodeType.ELEMENT_NODE && rootElement.hasAttribute(_DOMProperty.ROOT_ATTRIBUTE_NAME));
}

(0, _ReactGenericBatching.setBatchingImplementation)(_inline.batchedUpdates, _inline.interactiveUpdates, _inline.flushInteractiveUpdates);

var warnedAboutHydrateAPI = false;

function legacyCreateRootFromDOMContainer(container, forceHydrate) {
  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  // First clear any existing content.
  if (!shouldHydrate) {
    var warned = false;
    var rootSibling = void 0;
    while (rootSibling = container.lastChild) {
      if (true) {
        if (!warned && rootSibling.nodeType === _HTMLNodeType.ELEMENT_NODE && rootSibling.hasAttribute(_DOMProperty.ROOT_ATTRIBUTE_NAME)) {
          warned = true;
          (0, _warningWithoutStack2.default)(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
        }
      }
      container.removeChild(rootSibling);
    }
  }
  if (true) {
    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
      warnedAboutHydrateAPI = true;
      (0, _lowPriorityWarning2.default)(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
    }
  }
  // Legacy roots are not async by default.
  var isConcurrent = false;
  return new ReactRoot(container, isConcurrent, shouldHydrate);
}

function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  if (true) {
    topLevelUpdateWarnings(container);
  }

  // TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.
  var root = container._reactRootContainer;
  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
    if (typeof callback === 'function') {
      var originalCallback = callback;
      callback = function callback() {
        var instance = (0, _inline.getPublicRootInstance)(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    (0, _inline.unbatchedUpdates)(function () {
      if (parentComponent != null) {
        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
      } else {
        root.render(children, callback);
      }
    });
  } else {
    if (typeof callback === 'function') {
      var _originalCallback = callback;
      callback = function callback() {
        var instance = (0, _inline.getPublicRootInstance)(root._internalRoot);
        _originalCallback.call(instance);
      };
    }
    // Update
    if (parentComponent != null) {
      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
    } else {
      root.render(children, callback);
    }
  }
  return (0, _inline.getPublicRootInstance)(root._internalRoot);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  (0, _invariant2.default)(isValidContainer(container), 'Target container is not a DOM element.');
  // TODO: pass ReactDOM portal implementation as third argument
  return (0, _ReactPortal.createPortal)(children, container, null, key);
}

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function findDOMNode(componentOrElement) {
    if (true) {
      var owner = ReactCurrentOwner.current;
      if (owner !== null && owner.stateNode !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        (0, _warningWithoutStack2.default)(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', (0, _getComponentName2.default)(owner.type) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === _HTMLNodeType.ELEMENT_NODE) {
      return componentOrElement;
    }
    if (true) {
      return (0, _inline.findHostInstanceWithWarning)(componentOrElement, 'findDOMNode');
    }
    return (0, _inline.findHostInstance)(componentOrElement);
  },
  hydrate: function hydrate(element, container, callback) {
    (0, _invariant2.default)(isValidContainer(container), 'Target container is not a DOM element.');
    if (true) {
      (0, _warningWithoutStack2.default)(!container._reactHasBeenPassedToCreateRootDEV, 'You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.%s(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?', _ReactFeatureFlags.enableStableConcurrentModeAPIs ? 'createRoot' : 'unstable_createRoot');
    }
    // TODO: throw or warn if we couldn't hydrate?
    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function render(element, container, callback) {
    (0, _invariant2.default)(isValidContainer(container), 'Target container is not a DOM element.');
    if (true) {
      (0, _warningWithoutStack2.default)(!container._reactHasBeenPassedToCreateRootDEV, 'You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.%s(). This is not supported. ' + 'Did you mean to call root.render(element)?', _ReactFeatureFlags.enableStableConcurrentModeAPIs ? 'createRoot' : 'unstable_createRoot');
    }
    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
    (0, _invariant2.default)(isValidContainer(containerNode), 'Target container is not a DOM element.');
    (0, _invariant2.default)(parentComponent != null && (0, _ReactInstanceMap.has)(parentComponent), 'parentComponent must be a valid React Component');
    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function unmountComponentAtNode(container) {
    (0, _invariant2.default)(isValidContainer(container), 'unmountComponentAtNode(...): Target container is not a DOM element.');

    if (true) {
      (0, _warningWithoutStack2.default)(!container._reactHasBeenPassedToCreateRootDEV, 'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.%s(). This is not supported. Did you mean to call root.unmount()?', _ReactFeatureFlags.enableStableConcurrentModeAPIs ? 'createRoot' : 'unstable_createRoot');
    }

    if (container._reactRootContainer) {
      if (true) {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !(0, _ReactDOMComponentTree.getInstanceFromNode)(rootEl);
        (0, _warningWithoutStack2.default)(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      (0, _inline.unbatchedUpdates)(function () {
        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      if (true) {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && (0, _ReactDOMComponentTree.getInstanceFromNode)(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === _HTMLNodeType.ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        (0, _warningWithoutStack2.default)(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: function unstable_createPortal() {
    if (!didWarnAboutUnstableCreatePortal) {
      didWarnAboutUnstableCreatePortal = true;
      (0, _lowPriorityWarning2.default)(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the "unstable_" prefix.');
    }
    return createPortal.apply(undefined, arguments);
  },


  unstable_batchedUpdates: _inline.batchedUpdates,

  unstable_interactiveUpdates: _inline.interactiveUpdates,

  flushSync: _inline.flushSync,

  unstable_createRoot: createRoot,
  unstable_flushControlled: _inline.flushControlled,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // Keep in sync with ReactDOMUnstableNativeDependencies.js
    // and ReactTestUtils.js. This is an array for better minification.
    Events: [_ReactDOMComponentTree.getInstanceFromNode, _ReactDOMComponentTree.getNodeFromInstance, _ReactDOMComponentTree.getFiberCurrentPropsFromNode, _EventPluginHub.injection.injectEventPluginsByName, _EventPluginRegistry.eventNameDispatchConfigs, _EventPropagators.accumulateTwoPhaseDispatches, _EventPropagators.accumulateDirectDispatches, _ReactControlledComponent.enqueueStateRestore, _ReactControlledComponent.restoreStateIfNeeded, _ReactDOMEventListener.dispatchEvent, _EventPluginHub.runEventsInBatch]
  }
};

function createRoot(container, options) {
  var functionName = _ReactFeatureFlags.enableStableConcurrentModeAPIs ? 'createRoot' : 'unstable_createRoot';
  (0, _invariant2.default)(isValidContainer(container), '%s(...): Target container is not a DOM element.', functionName);
  if (true) {
    (0, _warningWithoutStack2.default)(!container._reactRootContainer, 'You are calling ReactDOM.%s() on a container that was previously ' + 'passed to ReactDOM.render(). This is not supported.', _ReactFeatureFlags.enableStableConcurrentModeAPIs ? 'createRoot' : 'unstable_createRoot');
    container._reactHasBeenPassedToCreateRootDEV = true;
  }
  var hydrate = options != null && options.hydrate === true;
  return new ReactRoot(container, true, hydrate);
}

if (_ReactFeatureFlags.enableStableConcurrentModeAPIs) {
  ReactDOM.createRoot = createRoot;
  ReactDOM.unstable_createRoot = undefined;
}

var foundDevTools = (0, _inline.injectIntoDevTools)({
  findFiberByHostInstance: _ReactDOMComponentTree.getClosestInstanceFromNode,
  bundleType:  true ? 1 : 0,
  version: _ReactVersion2.default,
  rendererPackageName: 'react-dom'
});

if (true) {
  if (!foundDevTools && _ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}

exports.default = ReactDOM;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(22);

var _react2 = _interopRequireDefault(_react);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

(0, _invariant2.default)(_react2.default, 'ReactDOM was loaded before React. Make sure you load ' + 'the React package before loading ReactDOM.');

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _EventPluginHub = __webpack_require__(24);

var _EventPluginUtils = __webpack_require__(46);

var _ReactDOMComponentTree = __webpack_require__(16);

var _BeforeInputEventPlugin = __webpack_require__(113);

var _BeforeInputEventPlugin2 = _interopRequireDefault(_BeforeInputEventPlugin);

var _ChangeEventPlugin = __webpack_require__(120);

var _ChangeEventPlugin2 = _interopRequireDefault(_ChangeEventPlugin);

var _DOMEventPluginOrder = __webpack_require__(121);

var _DOMEventPluginOrder2 = _interopRequireDefault(_DOMEventPluginOrder);

var _EnterLeaveEventPlugin = __webpack_require__(122);

var _EnterLeaveEventPlugin2 = _interopRequireDefault(_EnterLeaveEventPlugin);

var _SelectEventPlugin = __webpack_require__(123);

var _SelectEventPlugin2 = _interopRequireDefault(_SelectEventPlugin);

var _SimpleEventPlugin = __webpack_require__(77);

var _SimpleEventPlugin2 = _interopRequireDefault(_SimpleEventPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
_EventPluginHub.injection.injectEventPluginOrder(_DOMEventPluginOrder2.default); /**
                                                                                  * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                  *
                                                                                  * This source code is licensed under the MIT license found in the
                                                                                  * LICENSE file in the root directory of this source tree.
                                                                                  */

(0, _EventPluginUtils.setComponentTree)(_ReactDOMComponentTree.getFiberCurrentPropsFromNode, _ReactDOMComponentTree.getInstanceFromNode, _ReactDOMComponentTree.getNodeFromInstance);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
_EventPluginHub.injection.injectEventPluginsByName({
  SimpleEventPlugin: _SimpleEventPlugin2.default,
  EnterLeaveEventPlugin: _EnterLeaveEventPlugin2.default,
  ChangeEventPlugin: _ChangeEventPlugin2.default,
  SelectEventPlugin: _SelectEventPlugin2.default,
  BeforeInputEventPlugin: _BeforeInputEventPlugin2.default
});

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    this.onError(error);
  }
};

if (true) {
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // unintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
      // If document doesn't exist we know for sure we will crash in this method
      // when we call document.createEvent(). However this can cause confusing
      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
      // So we preemptively throw with a better message instead.
      (0, _invariant2.default)(typeof document !== 'undefined', 'The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');
      var evt = document.createEvent('Event');

      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Keeps track of the value of window.event so that we can reset it
      // during the callback to let user code access window.event in the
      // browsers that support it.
      var windowEvent = window.event;

      // Keeps track of the descriptor of window.event to restore it after event
      // dispatching: https://github.com/facebook/react/issues/13688
      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);

        // We check for window.hasOwnProperty('event') to prevent the
        // window.event assignment in both IE <= 10 as they throw an error
        // "Member not found" in strict mode, and in Firefox which does not
        // support window.event.
        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
          window.event = windowEvent;
        }

        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function handleWindowError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
        if (event.defaultPrevented) {
          // Some other error handler has prevented default.
          // Browsers silence the error report if this happens.
          // We'll remember this to later decide whether to log it or not.
          if (error != null && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object') {
            try {
              error._suppressLogging = true;
            } catch (inner) {
              // Ignore.
            }
          }
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', handleWindowError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (windowEventDescriptor) {
        Object.defineProperty(window, 'event', windowEventDescriptor);
      }

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        this.onError(error);
      }

      // Remove our event listeners
      window.removeEventListener('error', handleWindowError);
    };

    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
  }
}

exports.default = invokeGuardedCallbackImpl;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

var _EventPropagators = __webpack_require__(20);

var _ExecutionEnvironment = __webpack_require__(17);

var _DOMTopLevelEventTypes = __webpack_require__(14);

var _FallbackCompositionState = __webpack_require__(117);

var _SyntheticCompositionEvent = __webpack_require__(118);

var _SyntheticCompositionEvent2 = _interopRequireDefault(_SyntheticCompositionEvent);

var _SyntheticInputEvent = __webpack_require__(119);

var _SyntheticInputEvent2 = _interopRequireDefault(_SyntheticInputEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = _ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (_ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = _ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode;

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = _ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: [_DOMTopLevelEventTypes.TOP_COMPOSITION_END, _DOMTopLevelEventTypes.TOP_KEY_PRESS, _DOMTopLevelEventTypes.TOP_TEXT_INPUT, _DOMTopLevelEventTypes.TOP_PASTE]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: [_DOMTopLevelEventTypes.TOP_BLUR, _DOMTopLevelEventTypes.TOP_COMPOSITION_END, _DOMTopLevelEventTypes.TOP_KEY_DOWN, _DOMTopLevelEventTypes.TOP_KEY_PRESS, _DOMTopLevelEventTypes.TOP_KEY_UP, _DOMTopLevelEventTypes.TOP_MOUSE_DOWN]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: [_DOMTopLevelEventTypes.TOP_BLUR, _DOMTopLevelEventTypes.TOP_COMPOSITION_START, _DOMTopLevelEventTypes.TOP_KEY_DOWN, _DOMTopLevelEventTypes.TOP_KEY_PRESS, _DOMTopLevelEventTypes.TOP_KEY_UP, _DOMTopLevelEventTypes.TOP_MOUSE_DOWN]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: [_DOMTopLevelEventTypes.TOP_BLUR, _DOMTopLevelEventTypes.TOP_COMPOSITION_UPDATE, _DOMTopLevelEventTypes.TOP_KEY_DOWN, _DOMTopLevelEventTypes.TOP_KEY_PRESS, _DOMTopLevelEventTypes.TOP_KEY_UP, _DOMTopLevelEventTypes.TOP_MOUSE_DOWN]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case _DOMTopLevelEventTypes.TOP_COMPOSITION_START:
      return eventTypes.compositionStart;
    case _DOMTopLevelEventTypes.TOP_COMPOSITION_END:
      return eventTypes.compositionEnd;
    case _DOMTopLevelEventTypes.TOP_COMPOSITION_UPDATE:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === _DOMTopLevelEventTypes.TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case _DOMTopLevelEventTypes.TOP_KEY_UP:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case _DOMTopLevelEventTypes.TOP_KEY_DOWN:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case _DOMTopLevelEventTypes.TOP_KEY_PRESS:
    case _DOMTopLevelEventTypes.TOP_MOUSE_DOWN:
    case _DOMTopLevelEventTypes.TOP_BLUR:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isUsingKoreanIME(nativeEvent) {
  return nativeEvent.locale === 'ko';
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType = void 0;
  var fallbackData = void 0;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = (0, _FallbackCompositionState.initialize)(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = (0, _FallbackCompositionState.getData)();
      }
    }
  }

  var event = _SyntheticCompositionEvent2.default.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  (0, _EventPropagators.accumulateTwoPhaseDispatches)(event);
  return event;
}

/**
 * @param {TopLevelType} topLevelType Number from `TopLevelType`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case _DOMTopLevelEventTypes.TOP_COMPOSITION_END:
      return getDataFromCustomEvent(nativeEvent);
    case _DOMTopLevelEventTypes.TOP_KEY_PRESS:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case _DOMTopLevelEventTypes.TOP_TEXT_INPUT:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to ignore it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === _DOMTopLevelEventTypes.TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = (0, _FallbackCompositionState.getData)();
      (0, _FallbackCompositionState.reset)();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case _DOMTopLevelEventTypes.TOP_PASTE:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case _DOMTopLevelEventTypes.TOP_KEY_PRESS:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case _DOMTopLevelEventTypes.TOP_COMPOSITION_END:
      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars = void 0;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = _SyntheticInputEvent2.default.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  (0, _EventPropagators.accumulateTwoPhaseDispatches)(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);

    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);

    if (composition === null) {
      return beforeInput;
    }

    if (beforeInput === null) {
      return composition;
    }

    return [composition, beforeInput];
  }
};

exports.default = BeforeInputEventPlugin;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLowestCommonAncestor = getLowestCommonAncestor;
exports.isAncestor = isAncestor;
exports.getParentInstance = getParentInstance;
exports.traverseTwoPhase = traverseTwoPhase;
exports.traverseEnterLeave = traverseEnterLeave;

var _ReactWorkTags = __webpack_require__(4);

function getParent(inst) {
  do {
    inst = inst.return;
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== _ReactWorkTags.HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  while (instB) {
    if (instA === instB || instA === instB.alternate) {
      return true;
    }
    instB = getParent(instB);
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i = void 0;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unsafeCastStringToDOMTopLevelType = unsafeCastStringToDOMTopLevelType;
exports.unsafeCastDOMTopLevelTypeToString = unsafeCastDOMTopLevelTypeToString;


// Do not uses the below two methods directly!
// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.
// (It is the only module that is allowed to access these methods.)

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function unsafeCastStringToDOMTopLevelType(topLevelType) {
  return topLevelType;
}

function unsafeCastDOMTopLevelTypeToString(topLevelType) {
  return topLevelType;
}

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ExecutionEnvironment = __webpack_require__(17);

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (_ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return eventName;
}

exports.default = getVendorPrefixedEventName;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialize = initialize;
exports.reset = reset;
exports.getData = getData;
exports.getText = getText;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */

var root = null;
var startText = null;
var fallbackText = null;

function initialize(nativeEventTarget) {
  root = nativeEventTarget;
  startText = getText();
  return true;
}

function reset() {
  root = null;
  startText = null;
  fallbackText = null;
}

function getData() {
  if (fallbackText) {
    return fallbackText;
  }

  var start = void 0;
  var startValue = startText;
  var startLength = startValue.length;
  var end = void 0;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  fallbackText = endValue.slice(start, sliceTail);
  return fallbackText;
}

function getText() {
  if ('value' in root) {
    return root.value;
  }
  return root.textContent;
}

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var SyntheticCompositionEvent = _SyntheticEvent2.default.extend({
  data: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticCompositionEvent;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var SyntheticInputEvent = _SyntheticEvent2.default.extend({
  data: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticInputEvent;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EventPluginHub = __webpack_require__(24);

var _EventPropagators = __webpack_require__(20);

var _ReactControlledComponent = __webpack_require__(47);

var _ReactGenericBatching = __webpack_require__(48);

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

var _isTextInputElement = __webpack_require__(69);

var _isTextInputElement2 = _interopRequireDefault(_isTextInputElement);

var _ExecutionEnvironment = __webpack_require__(17);

var _DOMTopLevelEventTypes = __webpack_require__(14);

var _getEventTarget = __webpack_require__(70);

var _getEventTarget2 = _interopRequireDefault(_getEventTarget);

var _isEventSupported = __webpack_require__(71);

var _isEventSupported2 = _interopRequireDefault(_isEventSupported);

var _ReactDOMComponentTree = __webpack_require__(16);

var _inputValueTracking = __webpack_require__(49);

var _ReactDOMInput = __webpack_require__(72);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: [_DOMTopLevelEventTypes.TOP_BLUR, _DOMTopLevelEventTypes.TOP_CHANGE, _DOMTopLevelEventTypes.TOP_CLICK, _DOMTopLevelEventTypes.TOP_FOCUS, _DOMTopLevelEventTypes.TOP_INPUT, _DOMTopLevelEventTypes.TOP_KEY_DOWN, _DOMTopLevelEventTypes.TOP_KEY_UP, _DOMTopLevelEventTypes.TOP_SELECTION_CHANGE]
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = _SyntheticEvent2.default.getPooled(eventTypes.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  (0, _ReactControlledComponent.enqueueStateRestore)(target);
  (0, _EventPropagators.accumulateTwoPhaseDispatches)(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, (0, _getEventTarget2.default)(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  (0, _ReactGenericBatching.batchedUpdates)(runEventInBatch, event);
}

function runEventInBatch(event) {
  (0, _EventPluginHub.runEventsInBatch)(event);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = (0, _ReactDOMComponentTree.getNodeFromInstance)(targetInst);
  if ((0, _inputValueTracking.updateValueIfChanged)(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === _DOMTopLevelEventTypes.TOP_CHANGE) {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (_ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = (0, _isEventSupported2.default)('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === _DOMTopLevelEventTypes.TOP_FOCUS) {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === _DOMTopLevelEventTypes.TOP_BLUR) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === _DOMTopLevelEventTypes.TOP_SELECTION_CHANGE || topLevelType === _DOMTopLevelEventTypes.TOP_KEY_UP || topLevelType === _DOMTopLevelEventTypes.TOP_KEY_DOWN) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === _DOMTopLevelEventTypes.TOP_CLICK) {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === _DOMTopLevelEventTypes.TOP_INPUT || topLevelType === _DOMTopLevelEventTypes.TOP_CHANGE) {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(node) {
  var state = node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  if (!_ReactFeatureFlags.disableInputAttributeSyncing) {
    // If controlled, assign the value attribute to the current value on blur
    (0, _ReactDOMInput.setDefaultValue)(node, 'number', node.value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? (0, _ReactDOMComponentTree.getNodeFromInstance)(targetInst) : window;

    var getTargetInstFunc = void 0,
        handleEventFunc = void 0;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if ((0, _isTextInputElement2.default)(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === _DOMTopLevelEventTypes.TOP_BLUR) {
      handleControlledInputBlur(targetNode);
    }
  }
};

exports.default = ChangeEventPlugin;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

exports.default = DOMEventPluginOrder;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EventPropagators = __webpack_require__(20);

var _DOMTopLevelEventTypes = __webpack_require__(14);

var _SyntheticMouseEvent = __webpack_require__(27);

var _SyntheticMouseEvent2 = _interopRequireDefault(_SyntheticMouseEvent);

var _SyntheticPointerEvent = __webpack_require__(74);

var _SyntheticPointerEvent2 = _interopRequireDefault(_SyntheticPointerEvent);

var _ReactDOMComponentTree = __webpack_require__(16);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: [_DOMTopLevelEventTypes.TOP_MOUSE_OUT, _DOMTopLevelEventTypes.TOP_MOUSE_OVER]
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: [_DOMTopLevelEventTypes.TOP_MOUSE_OUT, _DOMTopLevelEventTypes.TOP_MOUSE_OVER]
  },
  pointerEnter: {
    registrationName: 'onPointerEnter',
    dependencies: [_DOMTopLevelEventTypes.TOP_POINTER_OUT, _DOMTopLevelEventTypes.TOP_POINTER_OVER]
  },
  pointerLeave: {
    registrationName: 'onPointerLeave',
    dependencies: [_DOMTopLevelEventTypes.TOP_POINTER_OUT, _DOMTopLevelEventTypes.TOP_POINTER_OVER]
  }
}; /**
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    */

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var isOverEvent = topLevelType === _DOMTopLevelEventTypes.TOP_MOUSE_OVER || topLevelType === _DOMTopLevelEventTypes.TOP_POINTER_OVER;
    var isOutEvent = topLevelType === _DOMTopLevelEventTypes.TOP_MOUSE_OUT || topLevelType === _DOMTopLevelEventTypes.TOP_POINTER_OUT;

    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }

    if (!isOutEvent && !isOverEvent) {
      // Must not be a mouse or pointer in or out - ignoring.
      return null;
    }

    var win = void 0;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from = void 0;
    var to = void 0;
    if (isOutEvent) {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? (0, _ReactDOMComponentTree.getClosestInstanceFromNode)(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var eventInterface = void 0,
        leaveEventType = void 0,
        enterEventType = void 0,
        eventTypePrefix = void 0;

    if (topLevelType === _DOMTopLevelEventTypes.TOP_MOUSE_OUT || topLevelType === _DOMTopLevelEventTypes.TOP_MOUSE_OVER) {
      eventInterface = _SyntheticMouseEvent2.default;
      leaveEventType = eventTypes.mouseLeave;
      enterEventType = eventTypes.mouseEnter;
      eventTypePrefix = 'mouse';
    } else if (topLevelType === _DOMTopLevelEventTypes.TOP_POINTER_OUT || topLevelType === _DOMTopLevelEventTypes.TOP_POINTER_OVER) {
      eventInterface = _SyntheticPointerEvent2.default;
      leaveEventType = eventTypes.pointerLeave;
      enterEventType = eventTypes.pointerEnter;
      eventTypePrefix = 'pointer';
    }

    var fromNode = from == null ? win : (0, _ReactDOMComponentTree.getNodeFromInstance)(from);
    var toNode = to == null ? win : (0, _ReactDOMComponentTree.getNodeFromInstance)(to);

    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);
    leave.type = eventTypePrefix + 'leave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);
    enter.type = eventTypePrefix + 'enter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    (0, _EventPropagators.accumulateEnterLeaveDispatches)(leave, enter, from, to);

    return [leave, enter];
  }
};

exports.default = EnterLeaveEventPlugin;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EventPropagators = __webpack_require__(20);

var _ExecutionEnvironment = __webpack_require__(17);

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

var _isTextInputElement = __webpack_require__(69);

var _isTextInputElement2 = _interopRequireDefault(_isTextInputElement);

var _shallowEqual = __webpack_require__(52);

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _DOMTopLevelEventTypes = __webpack_require__(14);

var _ReactBrowserEventEmitter = __webpack_require__(75);

var _getActiveElement = __webpack_require__(78);

var _getActiveElement2 = _interopRequireDefault(_getActiveElement);

var _ReactDOMComponentTree = __webpack_require__(16);

var _ReactInputSelection = __webpack_require__(135);

var _HTMLNodeType = __webpack_require__(15);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var skipSelectionChangeEvent = _ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11; /**
                                                                                                                              * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                              *
                                                                                                                              * This source code is licensed under the MIT license found in the
                                                                                                                              * LICENSE file in the root directory of this source tree.
                                                                                                                              */

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: [_DOMTopLevelEventTypes.TOP_BLUR, _DOMTopLevelEventTypes.TOP_CONTEXT_MENU, _DOMTopLevelEventTypes.TOP_DRAG_END, _DOMTopLevelEventTypes.TOP_FOCUS, _DOMTopLevelEventTypes.TOP_KEY_DOWN, _DOMTopLevelEventTypes.TOP_KEY_UP, _DOMTopLevelEventTypes.TOP_MOUSE_DOWN, _DOMTopLevelEventTypes.TOP_MOUSE_UP, _DOMTopLevelEventTypes.TOP_SELECTION_CHANGE]
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && (0, _ReactInputSelection.hasSelectionCapabilities)(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else {
    var win = node.ownerDocument && node.ownerDocument.defaultView || window;
    var selection = win.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Get document associated with the event target.
 *
 * @param {object} nativeEventTarget
 * @return {Document}
 */
function getEventTargetDocument(eventTarget) {
  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === _HTMLNodeType.DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc = getEventTargetDocument(nativeEventTarget);

  if (mouseDown || activeElement == null || activeElement !== (0, _getActiveElement2.default)(doc)) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !(0, _shallowEqual2.default)(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = _SyntheticEvent2.default.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    (0, _EventPropagators.accumulateTwoPhaseDispatches)(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = getEventTargetDocument(nativeEventTarget);
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !(0, _ReactBrowserEventEmitter.isListeningToAllDependencies)('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? (0, _ReactDOMComponentTree.getNodeFromInstance)(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case _DOMTopLevelEventTypes.TOP_FOCUS:
        if ((0, _isTextInputElement2.default)(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case _DOMTopLevelEventTypes.TOP_BLUR:
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case _DOMTopLevelEventTypes.TOP_MOUSE_DOWN:
        mouseDown = true;
        break;
      case _DOMTopLevelEventTypes.TOP_CONTEXT_MENU:
      case _DOMTopLevelEventTypes.TOP_MOUSE_UP:
      case _DOMTopLevelEventTypes.TOP_DRAG_END:
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case _DOMTopLevelEventTypes.TOP_SELECTION_CHANGE:
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case _DOMTopLevelEventTypes.TOP_KEY_DOWN:
      case _DOMTopLevelEventTypes.TOP_KEY_UP:
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

exports.default = SelectEventPlugin;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFiberMounted = isFiberMounted;
exports.isMounted = isMounted;
exports.findCurrentFiberUsingSlowPath = findCurrentFiberUsingSlowPath;
exports.findCurrentHostFiber = findCurrentHostFiber;
exports.findCurrentHostFiberWithNoPortals = findCurrentHostFiberWithNoPortals;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactInstanceMap = __webpack_require__(37);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _ReactWorkTags = __webpack_require__(4);

var _ReactSideEffectTags = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var ReactCurrentOwner = _ReactSharedInternals2.default.ReactCurrentOwner;

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & _ReactSideEffectTags.Placement) !== _ReactSideEffectTags.NoEffect) {
      return MOUNTING;
    }
    while (node.return) {
      node = node.return;
      if ((node.effectTag & _ReactSideEffectTags.Placement) !== _ReactSideEffectTags.NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node.return) {
      node = node.return;
    }
  }
  if (node.tag === _ReactWorkTags.HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  if (true) {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === _ReactWorkTags.ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      (0, _warningWithoutStack2.default)(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', (0, _getComponentName2.default)(ownerFiber.type) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = (0, _ReactInstanceMap.get)(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  (0, _invariant2.default)(isFiberMountedImpl(fiber) === MOUNTED, 'Unable to find node on an unmounted component.');
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    (0, _invariant2.default)(state !== UNMOUNTED, 'Unable to find node on an unmounted component.');
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a.return;
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      (0, _invariant2.default)(false, 'Unable to find node on an unmounted component.');
    }

    if (a.return !== b.return) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        (0, _invariant2.default)(didFindChild, 'Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
      }
    }

    (0, _invariant2.default)(a.alternate === b, "Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  (0, _invariant2.default)(a.tag === _ReactWorkTags.HostRoot, 'Unable to find node on an unmounted component.');
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === _ReactWorkTags.HostComponent || node.tag === _ReactWorkTags.HostText) {
      return node;
    } else if (node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === _ReactWorkTags.HostComponent || node.tag === _ReactWorkTags.HostText) {
      return node;
    } else if (node.child && node.tag !== _ReactWorkTags.HostPortal) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addEventBubbleListener = addEventBubbleListener;
exports.addEventCaptureListener = addEventCaptureListener;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function addEventBubbleListener(element, eventType, listener) {
  element.addEventListener(eventType, listener, false);
}

function addEventCaptureListener(element, eventType, listener) {
  element.addEventListener(eventType, listener, true);
}

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var SyntheticAnimationEvent = _SyntheticEvent2.default.extend({
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticAnimationEvent;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var SyntheticClipboardEvent = _SyntheticEvent2.default.extend({
  clipboardData: function clipboardData(event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticClipboardEvent;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticUIEvent = __webpack_require__(28);

var _SyntheticUIEvent2 = _interopRequireDefault(_SyntheticUIEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticFocusEvent = _SyntheticUIEvent2.default.extend({
  relatedTarget: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticFocusEvent;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticUIEvent = __webpack_require__(28);

var _SyntheticUIEvent2 = _interopRequireDefault(_SyntheticUIEvent);

var _getEventCharCode = __webpack_require__(54);

var _getEventCharCode2 = _interopRequireDefault(_getEventCharCode);

var _getEventKey = __webpack_require__(130);

var _getEventKey2 = _interopRequireDefault(_getEventKey);

var _getEventModifierState = __webpack_require__(51);

var _getEventModifierState2 = _interopRequireDefault(_getEventModifierState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var SyntheticKeyboardEvent = _SyntheticUIEvent2.default.extend({
  key: _getEventKey2.default,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: _getEventModifierState2.default,
  // Legacy Interface
  charCode: function charCode(event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return (0, _getEventCharCode2.default)(event);
    }
    return 0;
  },
  keyCode: function keyCode(event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function which(event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return (0, _getEventCharCode2.default)(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
});

exports.default = SyntheticKeyboardEvent;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getEventCharCode = __webpack_require__(54);

var _getEventCharCode2 = _interopRequireDefault(_getEventCharCode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = (0, _getEventCharCode2.default)(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

exports.default = getEventKey;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticMouseEvent = __webpack_require__(27);

var _SyntheticMouseEvent2 = _interopRequireDefault(_SyntheticMouseEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticDragEvent = _SyntheticMouseEvent2.default.extend({
  dataTransfer: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticDragEvent;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticUIEvent = __webpack_require__(28);

var _SyntheticUIEvent2 = _interopRequireDefault(_SyntheticUIEvent);

var _getEventModifierState = __webpack_require__(51);

var _getEventModifierState2 = _interopRequireDefault(_getEventModifierState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var SyntheticTouchEvent = _SyntheticUIEvent2.default.extend({
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: _getEventModifierState2.default
});

exports.default = SyntheticTouchEvent;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticEvent = __webpack_require__(12);

var _SyntheticEvent2 = _interopRequireDefault(_SyntheticEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var SyntheticTransitionEvent = _SyntheticEvent2.default.extend({
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticTransitionEvent;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SyntheticMouseEvent = __webpack_require__(27);

var _SyntheticMouseEvent2 = _interopRequireDefault(_SyntheticMouseEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticWheelEvent = _SyntheticMouseEvent2.default.extend({
  deltaX: function deltaX(event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function deltaY(event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },

  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
}); /**
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

exports.default = SyntheticWheelEvent;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasSelectionCapabilities = hasSelectionCapabilities;
exports.getSelectionInformation = getSelectionInformation;
exports.restoreSelection = restoreSelection;
exports.getSelection = getSelection;
exports.setSelection = setSelection;

var _getActiveElement = __webpack_require__(78);

var _getActiveElement2 = _interopRequireDefault(_getActiveElement);

var _ReactDOMSelection = __webpack_require__(136);

var _HTMLNodeType = __webpack_require__(15);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isTextNode(node) {
  return node && node.nodeType === _HTMLNodeType.TEXT_NODE;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

function isInDocument(node) {
  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
}

function getActiveElementDeep() {
  var win = window;
  var element = (0, _getActiveElement2.default)();
  while (element instanceof win.HTMLIFrameElement) {
    // Accessing the contentDocument of a HTMLIframeElement can cause the browser
    // to throw, e.g. if it has a cross-origin src attribute
    try {
      win = element.contentDocument.defaultView;
    } catch (e) {
      return element;
    }
    element = (0, _getActiveElement2.default)(win.document);
  }
  return element;
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

/**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElementDeep();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElementDeep();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === _HTMLNodeType.ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    if (typeof priorFocusedElem.focus === 'function') {
      priorFocusedElem.focus();
    }

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = (0, _ReactDOMSelection.getOffsets)(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    (0, _ReactDOMSelection.setOffsets)(input, offsets);
  }
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffsets = getOffsets;
exports.getModernOffsetsFromPoints = getModernOffsetsFromPoints;
exports.setOffsets = setOffsets;

var _getNodeForCharacterOffset = __webpack_require__(137);

var _getNodeForCharacterOffset2 = _interopRequireDefault(_getNodeForCharacterOffset);

var _HTMLNodeType = __webpack_require__(15);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function getOffsets(outerNode) {
  var ownerDocument = outerNode.ownerDocument;

  var win = ownerDocument && ownerDocument.defaultView || window;
  var selection = win.getSelection && win.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === _HTMLNodeType.TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode && (focusOffset === 0 || node.nodeType === _HTMLNodeType.TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === _HTMLNodeType.TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  var doc = node.ownerDocument || document;
  var win = doc && doc.defaultView || window;

  // Edge fails with "Object expected" in some scenarios.
  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
  // fails when pasting 100+ items)
  if (!win.getSelection) {
    return;
  }

  var selection = win.getSelection();
  var length = node.textContent.length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = (0, _getNodeForCharacterOffset2.default)(node, start);
  var endMarker = (0, _getNodeForCharacterOffset2.default)(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = doc.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _HTMLNodeType = __webpack_require__(15);

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === _HTMLNodeType.TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

exports.default = getNodeForCharacterOffset;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ReactFiberReconciler = __webpack_require__(139);

Object.keys(_ReactFiberReconciler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _ReactFiberReconciler[key];
    }
  });
});

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findHostInstanceWithWarning = exports.findHostInstance = exports.flushSync = exports.flushControlled = exports.flushInteractiveUpdates = exports.interactiveUpdates = exports.syncUpdates = exports.deferredUpdates = exports.unbatchedUpdates = exports.batchedUpdates = exports.computeUniqueAsyncExpiration = exports.requestWork = exports.flushRoot = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * 
                                                                                                                                                                                                                                                                   */

exports.updateContainerAtExpirationTime = updateContainerAtExpirationTime;
exports.createContainer = createContainer;
exports.updateContainer = updateContainer;
exports.getPublicRootInstance = getPublicRootInstance;
exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;
exports.injectIntoDevTools = injectIntoDevTools;

var _reflection = __webpack_require__(36);

var _ReactInstanceMap = __webpack_require__(37);

var _ReactWorkTags = __webpack_require__(4);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiberContext = __webpack_require__(21);

var _ReactFiberRoot = __webpack_require__(140);

var _ReactFiberDevToolsHook = __webpack_require__(39);

var _ReactFiberScheduler = __webpack_require__(31);

var _ReactUpdateQueue = __webpack_require__(18);

var _ReactFiberInstrumentation = __webpack_require__(79);

var _ReactFiberInstrumentation2 = _interopRequireDefault(_ReactFiberInstrumentation);

var _ReactCurrentFiber = __webpack_require__(7);

var _ReactTypeOfMode = __webpack_require__(13);

var _ReactFiberExpirationTime = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
var didWarnAboutNestedUpdates = void 0;
var didWarnAboutFindNodeInStrictMode = void 0;

if (true) {
  didWarnAboutNestedUpdates = false;
  didWarnAboutFindNodeInStrictMode = {};
}

function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return _ReactFiberContext.emptyContextObject;
  }

  var fiber = (0, _ReactInstanceMap.get)(parentComponent);
  var parentContext = (0, _ReactFiberContext.findCurrentUnmaskedContext)(fiber);

  if (fiber.tag === _ReactWorkTags.ClassComponent) {
    var Component = fiber.type;
    if ((0, _ReactFiberContext.isContextProvider)(Component)) {
      return (0, _ReactFiberContext.processChildContext)(fiber, Component, parentContext);
    }
  }

  return parentContext;
}

function scheduleRootUpdate(current, element, expirationTime, callback) {
  if (true) {
    if (_ReactCurrentFiber.phase === 'render' && _ReactCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
      didWarnAboutNestedUpdates = true;
      (0, _warningWithoutStack2.default)(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', (0, _getComponentName2.default)(_ReactCurrentFiber.current.type) || 'Unknown');
    }
  }

  var update = (0, _ReactUpdateQueue.createUpdate)(expirationTime);
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = { element: element };

  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    (0, _warningWithoutStack2.default)(typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    update.callback = callback;
  }

  (0, _ReactFiberScheduler.flushPassiveEffects)();
  (0, _ReactUpdateQueue.enqueueUpdate)(current, update);
  (0, _ReactFiberScheduler.scheduleWork)(current, expirationTime);

  return expirationTime;
}

function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
  // TODO: If this is a nested container, this won't be the root.
  var current = container.current;

  if (true) {
    if (_ReactFiberInstrumentation2.default.debugTool) {
      if (current.alternate === null) {
        _ReactFiberInstrumentation2.default.debugTool.onMountContainer(container);
      } else if (element === null) {
        _ReactFiberInstrumentation2.default.debugTool.onUnmountContainer(container);
      } else {
        _ReactFiberInstrumentation2.default.debugTool.onUpdateContainer(container);
      }
    }
  }

  var context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  return scheduleRootUpdate(current, element, expirationTime, callback);
}

function findHostInstance(component) {
  var fiber = (0, _ReactInstanceMap.get)(component);
  if (fiber === undefined) {
    if (typeof component.render === 'function') {
      (0, _invariant2.default)(false, 'Unable to find node on an unmounted component.');
    } else {
      (0, _invariant2.default)(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));
    }
  }
  var hostFiber = (0, _reflection.findCurrentHostFiber)(fiber);
  if (hostFiber === null) {
    return null;
  }
  return hostFiber.stateNode;
}

function findHostInstanceWithWarning(component, methodName) {
  if (true) {
    var fiber = (0, _ReactInstanceMap.get)(component);
    if (fiber === undefined) {
      if (typeof component.render === 'function') {
        (0, _invariant2.default)(false, 'Unable to find node on an unmounted component.');
      } else {
        (0, _invariant2.default)(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));
      }
    }
    var hostFiber = (0, _reflection.findCurrentHostFiber)(fiber);
    if (hostFiber === null) {
      return null;
    }
    if (hostFiber.mode & _ReactTypeOfMode.StrictMode) {
      var componentName = (0, _getComponentName2.default)(fiber.type) || 'Component';
      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
        didWarnAboutFindNodeInStrictMode[componentName] = true;
        if (fiber.mode & _ReactTypeOfMode.StrictMode) {
          (0, _warningWithoutStack2.default)(false, '%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference.' + '\n%s' + '\n\nLearn more about using refs safely here:' + '\nhttps://fb.me/react-strict-mode-find-node', methodName, methodName, componentName, (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(hostFiber));
        } else {
          (0, _warningWithoutStack2.default)(false, '%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference.' + '\n%s' + '\n\nLearn more about using refs safely here:' + '\nhttps://fb.me/react-strict-mode-find-node', methodName, methodName, componentName, (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(hostFiber));
        }
      }
    }
    return hostFiber.stateNode;
  }
  return findHostInstance(component);
}

function createContainer(containerInfo, isConcurrent, hydrate) {
  return (0, _ReactFiberRoot.createFiberRoot)(containerInfo, isConcurrent, hydrate);
}

function updateContainer(element, container, parentComponent, callback) {
  var current = container.current;
  var currentTime = (0, _ReactFiberScheduler.requestCurrentTime)();
  var expirationTime = (0, _ReactFiberScheduler.computeExpirationForFiber)(currentTime, current);
  return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
}

exports.flushRoot = _ReactFiberScheduler.flushRoot;
exports.requestWork = _ReactFiberScheduler.requestWork;
exports.computeUniqueAsyncExpiration = _ReactFiberScheduler.computeUniqueAsyncExpiration;
exports.batchedUpdates = _ReactFiberScheduler.batchedUpdates;
exports.unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates;
exports.deferredUpdates = _ReactFiberScheduler.deferredUpdates;
exports.syncUpdates = _ReactFiberScheduler.syncUpdates;
exports.interactiveUpdates = _ReactFiberScheduler.interactiveUpdates;
exports.flushInteractiveUpdates = _ReactFiberScheduler.flushInteractiveUpdates;
exports.flushControlled = _ReactFiberScheduler.flushControlled;
exports.flushSync = _ReactFiberScheduler.flushSync;
function getPublicRootInstance(container) {
  var containerFiber = container.current;
  if (!containerFiber.child) {
    return null;
  }
  switch (containerFiber.child.tag) {
    case _ReactWorkTags.HostComponent:
      return (0, _ReactFiberHostConfig.getPublicInstance)(containerFiber.child.stateNode);
    default:
      return containerFiber.child.stateNode;
  }
}

exports.findHostInstance = findHostInstance;
exports.findHostInstanceWithWarning = findHostInstanceWithWarning;
function findHostInstanceWithNoPortals(fiber) {
  var hostFiber = (0, _reflection.findCurrentHostFiberWithNoPortals)(fiber);
  if (hostFiber === null) {
    return null;
  }
  return hostFiber.stateNode;
}

var overrideProps = null;

if (true) {
  var copyWithSetImpl = function copyWithSetImpl(obj, path, idx, value) {
    if (idx >= path.length) {
      return value;
    }
    var key = path[idx];
    var updated = Array.isArray(obj) ? obj.slice() : _extends({}, obj);
    // $FlowFixMe number or string is fine here
    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
    return updated;
  };

  var copyWithSet = function copyWithSet(obj, path, value) {
    return copyWithSetImpl(obj, path, 0, value);
  };

  // Support DevTools props for function components, forwardRef, memo, host components, etc.
  overrideProps = function overrideProps(fiber, path, value) {
    (0, _ReactFiberScheduler.flushPassiveEffects)();
    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }
    (0, _ReactFiberScheduler.scheduleWork)(fiber, _ReactFiberExpirationTime.Sync);
  };
}

function injectIntoDevTools(devToolsConfig) {
  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
  var ReactCurrentDispatcher = _ReactSharedInternals2.default.ReactCurrentDispatcher;


  return (0, _ReactFiberDevToolsHook.injectInternals)(_extends({}, devToolsConfig, {
    overrideProps: overrideProps,
    currentDispatcherRef: ReactCurrentDispatcher,
    findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
      var hostFiber = (0, _reflection.findCurrentHostFiber)(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    findFiberByHostInstance: function (_findFiberByHostInstance) {
      function findFiberByHostInstance(_x) {
        return _findFiberByHostInstance.apply(this, arguments);
      }

      findFiberByHostInstance.toString = function () {
        return _findFiberByHostInstance.toString();
      };

      return findFiberByHostInstance;
    }(function (instance) {
      if (!findFiberByHostInstance) {
        // Might not be implemented by the renderer.
        return null;
      }
      return findFiberByHostInstance(instance);
    })
  }));
}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFiberRoot = createFiberRoot;

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiber = __webpack_require__(30);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactFeatureFlags = __webpack_require__(3);

var _tracing = __webpack_require__(23);

// TODO: This should be lifted into the renderer.


// The following attributes are only used by interaction tracing builds.
// They enable interactions to be associated with their async work,
// And expose interaction metadata to the React DevTools Profiler plugin.
// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.


// Exported FiberRoot type includes all properties,
// To avoid requiring potentially error-prone :any casts throughout the project.
// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
// The types are defined separately within this file to ensure they stay in sync.
// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function createFiberRoot(containerInfo, isConcurrent, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = (0, _ReactFiber.createHostRootFiber)(isConcurrent);

  var root = void 0;
  if (_ReactFeatureFlags.enableSchedulerTracing) {
    root = {
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: _ReactFiberExpirationTime.NoWork,
      latestPendingTime: _ReactFiberExpirationTime.NoWork,
      earliestSuspendedTime: _ReactFiberExpirationTime.NoWork,
      latestSuspendedTime: _ReactFiberExpirationTime.NoWork,
      latestPingedTime: _ReactFiberExpirationTime.NoWork,

      pingCache: null,

      didError: false,

      pendingCommitExpirationTime: _ReactFiberExpirationTime.NoWork,
      finishedWork: null,
      timeoutHandle: _ReactFiberHostConfig.noTimeout,
      context: null,
      pendingContext: null,
      hydrate: hydrate,
      nextExpirationTimeToWorkOn: _ReactFiberExpirationTime.NoWork,
      expirationTime: _ReactFiberExpirationTime.NoWork,
      firstBatch: null,
      nextScheduledRoot: null,

      interactionThreadID: (0, _tracing.unstable_getThreadID)(),
      memoizedInteractions: new Set(),
      pendingInteractionMap: new Map()
    };
  } else {
    root = {
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      pingCache: null,

      earliestPendingTime: _ReactFiberExpirationTime.NoWork,
      latestPendingTime: _ReactFiberExpirationTime.NoWork,
      earliestSuspendedTime: _ReactFiberExpirationTime.NoWork,
      latestSuspendedTime: _ReactFiberExpirationTime.NoWork,
      latestPingedTime: _ReactFiberExpirationTime.NoWork,

      didError: false,

      pendingCommitExpirationTime: _ReactFiberExpirationTime.NoWork,
      finishedWork: null,
      timeoutHandle: _ReactFiberHostConfig.noTimeout,
      context: null,
      pendingContext: null,
      hydrate: hydrate,
      nextExpirationTimeToWorkOn: _ReactFiberExpirationTime.NoWork,
      expirationTime: _ReactFiberExpirationTime.NoWork,
      firstBatch: null,
      nextScheduledRoot: null
    };
  }

  uninitializedFiber.stateNode = root;

  // The reason for the way the Flow types are structured in this file,
  // Is to avoid needing :any casts everywhere interaction tracing fields are used.
  // Unfortunately that requires an :any cast for non-interaction tracing capable builds.
  // $FlowFixMe Remove this :any cast and replace it with something better.
  return root;
}

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mountChildFibers = exports.reconcileChildFibers = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.cloneChildFibers = cloneChildFibers;

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactSymbols = __webpack_require__(6);

var _ReactWorkTags = __webpack_require__(4);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactFiber = __webpack_require__(30);

var _ReactFiberClassComponent = __webpack_require__(81);

var _ReactCurrentFiber = __webpack_require__(7);

var _ReactTypeOfMode = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnAboutMaps = void 0;
var didWarnAboutGenerators = void 0;
var didWarnAboutStringRefInStrictMode = void 0;
var ownerHasKeyUseWarning = void 0;
var ownerHasFunctionTypeWarning = void 0;
var warnForMissingKey = function warnForMissingKey(child) {};

if (true) {
  didWarnAboutMaps = false;
  didWarnAboutGenerators = false;
  didWarnAboutStringRefInStrictMode = {};

  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  ownerHasKeyUseWarning = {};
  ownerHasFunctionTypeWarning = {};

  warnForMissingKey = function warnForMissingKey(child) {
    if (child === null || (typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    (0, _invariant2.default)(_typeof(child._store) === 'object', 'React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in a list should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (0, _ReactCurrentFiber.getCurrentFiberStackInDev)();
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    (0, _warning2.default)(false, 'Each child in a list should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.');
  };
}

var isArray = Array.isArray;

function coerceRef(returnFiber, current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function' && (typeof mixedRef === 'undefined' ? 'undefined' : _typeof(mixedRef)) !== 'object') {
    if (true) {
      if (returnFiber.mode & _ReactTypeOfMode.StrictMode) {
        var componentName = (0, _getComponentName2.default)(returnFiber.type) || 'Component';
        if (!didWarnAboutStringRefInStrictMode[componentName]) {
          (0, _warningWithoutStack2.default)(false, 'A string ref, "%s", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\n%s' + '\n\nLearn more about using refs safely here:' + '\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(returnFiber));
          didWarnAboutStringRefInStrictMode[componentName] = true;
        }
      }
    }

    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        (0, _invariant2.default)(ownerFiber.tag === _ReactWorkTags.ClassComponent, 'Function components cannot have refs. ' + 'Did you mean to use React.forwardRef()?');
        inst = ownerFiber.stateNode;
      }
      (0, _invariant2.default)(inst, 'Missing owner for string ref %s. This error is likely caused by a ' + 'bug in React. Please file an issue.', mixedRef);
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function ref(value) {
        var refs = inst.refs;
        if (refs === _ReactFiberClassComponent.emptyRefsObject) {
          // This is a lazy pooled frozen object, so we need to initialize.
          refs = inst.refs = {};
        }
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      (0, _invariant2.default)(typeof mixedRef === 'string', 'Expected ref to be a function, a string, an object returned by React.createRef(), or null.');
      (0, _invariant2.default)(element._owner, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of' + ' the following reasons:\n' + '1. You may be adding a ref to a function component\n' + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + '3. You have multiple copies of React loaded\n' + 'See https://fb.me/react-refs-must-have-owner for more information.', mixedRef);
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    if (true) {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (0, _ReactCurrentFiber.getCurrentFiberStackInDev)();
    }
    (0, _invariant2.default)(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (0, _ReactCurrentFiber.getCurrentFiberStackInDev)();

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  (0, _warning2.default)(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = _ReactSideEffectTags.Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = (0, _ReactFiber.createWorkInProgress)(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = _ReactSideEffectTags.Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = _ReactSideEffectTags.Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = _ReactSideEffectTags.Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== _ReactWorkTags.HostText) {
      // Insert
      var created = (0, _ReactFiber.createFiberFromText)(textContent, returnFiber.mode, expirationTime);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.elementType === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(returnFiber, current, element);
      existing.return = returnFiber;
      if (true) {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = (0, _ReactFiber.createFiberFromElement)(element, returnFiber.mode, expirationTime);
      created.ref = coerceRef(returnFiber, current, element);
      created.return = returnFiber;
      return created;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== _ReactWorkTags.HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = (0, _ReactFiber.createFiberFromPortal)(portal, returnFiber.mode, expirationTime);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== _ReactWorkTags.Fragment) {
      // Insert
      var created = (0, _ReactFiber.createFiberFromFragment)(fragment, returnFiber.mode, expirationTime, key);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = (0, _ReactFiber.createFiberFromText)('' + newChild, returnFiber.mode, expirationTime);
      created.return = returnFiber;
      return created;
    }

    if ((typeof newChild === 'undefined' ? 'undefined' : _typeof(newChild)) === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case _ReactSymbols.REACT_ELEMENT_TYPE:
          {
            var _created = (0, _ReactFiber.createFiberFromElement)(newChild, returnFiber.mode, expirationTime);
            _created.ref = coerceRef(returnFiber, null, newChild);
            _created.return = returnFiber;
            return _created;
          }
        case _ReactSymbols.REACT_PORTAL_TYPE:
          {
            var _created2 = (0, _ReactFiber.createFiberFromPortal)(newChild, returnFiber.mode, expirationTime);
            _created2.return = returnFiber;
            return _created2;
          }
      }

      if (isArray(newChild) || (0, _ReactSymbols.getIteratorFn)(newChild)) {
        var _created3 = (0, _ReactFiber.createFiberFromFragment)(newChild, returnFiber.mode, expirationTime, null);
        _created3.return = returnFiber;
        return _created3;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    if (true) {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if ((typeof newChild === 'undefined' ? 'undefined' : _typeof(newChild)) === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case _ReactSymbols.REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === _ReactSymbols.REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
        case _ReactSymbols.REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray(newChild) || (0, _ReactSymbols.getIteratorFn)(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    if (true) {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if ((typeof newChild === 'undefined' ? 'undefined' : _typeof(newChild)) === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case _ReactSymbols.REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === _ReactSymbols.REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }
        case _ReactSymbols.REACT_PORTAL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
          }
      }

      if (isArray(newChild) || (0, _ReactSymbols.getIteratorFn)(newChild)) {
        var _matchedFiber3 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    if (true) {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    if (true) {
      if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case _ReactSymbols.REACT_ELEMENT_TYPE:
        case _ReactSymbols.REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          (0, _warning2.default)(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from both ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    if (true) {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = (0, _ReactSymbols.getIteratorFn)(newChildrenIterable);
    (0, _invariant2.default)(typeof iteratorFn === 'function', 'An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');

    if (true) {
      // We don't support rendering Generators because it's a mutation.
      // See https://github.com/facebook/react/issues/12995
      if (typeof Symbol === 'function' &&
      // $FlowFixMe Flow doesn't know about toStringTag
      newChildrenIterable[Symbol.toStringTag] === 'Generator') {
        (0, _warning2.default)(didWarnAboutGenerators, 'Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
        didWarnAboutGenerators = true;
      }

      // Warn about using Maps as children
      if (newChildrenIterable.entries === iteratorFn) {
        (0, _warning2.default)(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.');
        didWarnAboutMaps = true;
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    (0, _invariant2.default)(newChildren != null, 'An iterable object provided no iterator.');

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === _ReactWorkTags.HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = (0, _ReactFiber.createFiberFromText)(textContent, returnFiber.mode, expirationTime);
    created.return = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === _ReactWorkTags.Fragment ? element.type === _ReactSymbols.REACT_FRAGMENT_TYPE : child.elementType === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === _ReactSymbols.REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(returnFiber, child, element);
          existing.return = returnFiber;
          if (true) {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === _ReactSymbols.REACT_FRAGMENT_TYPE) {
      var created = (0, _ReactFiber.createFiberFromFragment)(element.props.children, returnFiber.mode, expirationTime, element.key);
      created.return = returnFiber;
      return created;
    } else {
      var _created4 = (0, _ReactFiber.createFiberFromElement)(element, returnFiber.mode, expirationTime);
      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
      _created4.return = returnFiber;
      return _created4;
    }
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === _ReactWorkTags.HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = (0, _ReactFiber.createFiberFromPortal)(portal, returnFiber.mode, expirationTime);
    created.return = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    var isUnkeyedTopLevelFragment = (typeof newChild === 'undefined' ? 'undefined' : _typeof(newChild)) === 'object' && newChild !== null && newChild.type === _ReactSymbols.REACT_FRAGMENT_TYPE && newChild.key === null;
    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = (typeof newChild === 'undefined' ? 'undefined' : _typeof(newChild)) === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case _ReactSymbols.REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));
        case _ReactSymbols.REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if ((0, _ReactSymbols.getIteratorFn)(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    if (true) {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case _ReactWorkTags.ClassComponent:
          {
            if (true) {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case _ReactWorkTags.FunctionComponent:
          {
            var Component = returnFiber.type;
            (0, _invariant2.default)(false, '%s(...): Nothing was returned from render. This usually means a ' + 'return statement is missing. Or, to render nothing, ' + 'return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = exports.reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = exports.mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current, workInProgress) {
  (0, _invariant2.default)(current === null || workInProgress.child === current.child, 'Resuming work not yet implemented.');

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = (0, _ReactFiber.createWorkInProgress)(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild.return = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = (0, _ReactFiber.createWorkInProgress)(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild.return = workInProgress;
  }
  newChild.sibling = null;
}

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.completeWork = undefined;

var _ReactWorkTags = __webpack_require__(4);

var _ReactSideEffectTags = __webpack_require__(8);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _ReactFiberHostConfig = __webpack_require__(11);

var _ReactFiberHostContext = __webpack_require__(41);

var _ReactFiberContext = __webpack_require__(21);

var _ReactFiberNewContext = __webpack_require__(19);

var _ReactFiberHydrationContext = __webpack_require__(84);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function markUpdate(workInProgress) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.effectTag |= _ReactSideEffectTags.Update;
}

function markRef(workInProgress) {
  workInProgress.effectTag |= _ReactSideEffectTags.Ref;
}

var _appendAllChildren = void 0;
var updateHostContainer = void 0;
var updateHostComponent = void 0;
var updateHostText = void 0;
if (_ReactFiberHostConfig.supportsMutation) {
  // Mutation mode

  _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === _ReactWorkTags.HostComponent || node.tag === _ReactWorkTags.HostText) {
        (0, _ReactFiberHostConfig.appendInitialChild)(parent, node.stateNode);
      } else if (node.tag === _ReactWorkTags.HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  updateHostContainer = function updateHostContainer(workInProgress) {
    // Noop
  };
  updateHostComponent = function updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance) {
    // If we have an alternate, that means this is an update and we need to
    // schedule a side-effect to do the updates.
    var oldProps = current.memoizedProps;
    if (oldProps === newProps) {
      // In mutation mode, this is sufficient for a bailout because
      // we won't touch this node even if children changed.
      return;
    }

    // If we get updated because one of our children updated, we don't
    // have newProps so we'll have to reuse them.
    // TODO: Split the update API as separate for the props vs. children.
    // Even better would be if children weren't special cased at all tho.
    var instance = workInProgress.stateNode;
    var currentHostContext = (0, _ReactFiberHostContext.getHostContext)();
    // TODO: Experiencing an error where oldProps is null. Suggests a host
    // component is hitting the resume path. Figure out why. Possibly
    // related to `hidden`.
    var updatePayload = (0, _ReactFiberHostConfig.prepareUpdate)(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
    // TODO: Type this specific to this type of component.
    workInProgress.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update. All the work is done in commitWork.
    if (updatePayload) {
      markUpdate(workInProgress);
    }
  };
  updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
    // If the text differs, mark it as an update. All the work in done in commitWork.
    if (oldText !== newText) {
      markUpdate(workInProgress);
    }
  };
} else if (_ReactFiberHostConfig.supportsPersistence) {
  // Persistent host tree mode

  _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      // eslint-disable-next-line no-labels
      branches: if (node.tag === _ReactWorkTags.HostComponent) {
        var instance = node.stateNode;
        if (needsVisibilityToggle) {
          var props = node.memoizedProps;
          var type = node.type;
          if (isHidden) {
            // This child is inside a timed out tree. Hide it.
            instance = (0, _ReactFiberHostConfig.cloneHiddenInstance)(instance, type, props, node);
          } else {
            // This child was previously inside a timed out tree. If it was not
            // updated during this render, it may need to be unhidden. Clone
            // again to be sure.
            instance = (0, _ReactFiberHostConfig.cloneUnhiddenInstance)(instance, type, props, node);
          }
          node.stateNode = instance;
        }
        (0, _ReactFiberHostConfig.appendInitialChild)(parent, instance);
      } else if (node.tag === _ReactWorkTags.HostText) {
        var _instance = node.stateNode;
        if (needsVisibilityToggle) {
          var text = node.memoizedProps;
          var rootContainerInstance = (0, _ReactFiberHostContext.getRootHostContainer)();
          var currentHostContext = (0, _ReactFiberHostContext.getHostContext)();
          if (isHidden) {
            _instance = (0, _ReactFiberHostConfig.createHiddenTextInstance)(text, rootContainerInstance, currentHostContext, workInProgress);
          } else {
            _instance = (0, _ReactFiberHostConfig.createTextInstance)(text, rootContainerInstance, currentHostContext, workInProgress);
          }
          node.stateNode = _instance;
        }
        (0, _ReactFiberHostConfig.appendInitialChild)(parent, _instance);
      } else if (node.tag === _ReactWorkTags.HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.tag === _ReactWorkTags.SuspenseComponent) {
        var current = node.alternate;
        if (current !== null) {
          var oldState = current.memoizedState;
          var newState = node.memoizedState;
          var oldIsHidden = oldState !== null;
          var newIsHidden = newState !== null;
          if (oldIsHidden !== newIsHidden) {
            // The placeholder either just timed out or switched back to the normal
            // children after having previously timed out. Toggle the visibility of
            // the direct host children.
            var primaryChildParent = newIsHidden ? node.child : node;
            if (primaryChildParent !== null) {
              _appendAllChildren(parent, primaryChildParent, true, newIsHidden);
            }
            // eslint-disable-next-line no-labels
            break branches;
          }
        }
        if (node.child !== null) {
          // Continue traversing like normal
          node.child.return = node;
          node = node.child;
          continue;
        }
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      // $FlowFixMe This is correct but Flow is confused by the labeled break.
      node = node;
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  // An unfortunate fork of appendAllChildren because we have two different parent types.
  var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      // eslint-disable-next-line no-labels
      branches: if (node.tag === _ReactWorkTags.HostComponent) {
        var instance = node.stateNode;
        if (needsVisibilityToggle) {
          var props = node.memoizedProps;
          var type = node.type;
          if (isHidden) {
            // This child is inside a timed out tree. Hide it.
            instance = (0, _ReactFiberHostConfig.cloneHiddenInstance)(instance, type, props, node);
          } else {
            // This child was previously inside a timed out tree. If it was not
            // updated during this render, it may need to be unhidden. Clone
            // again to be sure.
            instance = (0, _ReactFiberHostConfig.cloneUnhiddenInstance)(instance, type, props, node);
          }
          node.stateNode = instance;
        }
        (0, _ReactFiberHostConfig.appendChildToContainerChildSet)(containerChildSet, instance);
      } else if (node.tag === _ReactWorkTags.HostText) {
        var _instance2 = node.stateNode;
        if (needsVisibilityToggle) {
          var text = node.memoizedProps;
          var rootContainerInstance = (0, _ReactFiberHostContext.getRootHostContainer)();
          var currentHostContext = (0, _ReactFiberHostContext.getHostContext)();
          if (isHidden) {
            _instance2 = (0, _ReactFiberHostConfig.createHiddenTextInstance)(text, rootContainerInstance, currentHostContext, workInProgress);
          } else {
            _instance2 = (0, _ReactFiberHostConfig.createTextInstance)(text, rootContainerInstance, currentHostContext, workInProgress);
          }
          node.stateNode = _instance2;
        }
        (0, _ReactFiberHostConfig.appendChildToContainerChildSet)(containerChildSet, _instance2);
      } else if (node.tag === _ReactWorkTags.HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.tag === _ReactWorkTags.SuspenseComponent) {
        var current = node.alternate;
        if (current !== null) {
          var oldState = current.memoizedState;
          var newState = node.memoizedState;
          var oldIsHidden = oldState !== null;
          var newIsHidden = newState !== null;
          if (oldIsHidden !== newIsHidden) {
            // The placeholder either just timed out or switched back to the normal
            // children after having previously timed out. Toggle the visibility of
            // the direct host children.
            var primaryChildParent = newIsHidden ? node.child : node;
            if (primaryChildParent !== null) {
              appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, newIsHidden);
            }
            // eslint-disable-next-line no-labels
            break branches;
          }
        }
        if (node.child !== null) {
          // Continue traversing like normal
          node.child.return = node;
          node = node.child;
          continue;
        }
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      // $FlowFixMe This is correct but Flow is confused by the labeled break.
      node = node;
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  };
  updateHostContainer = function updateHostContainer(workInProgress) {
    var portalOrRoot = workInProgress.stateNode;
    var childrenUnchanged = workInProgress.firstEffect === null;
    if (childrenUnchanged) {
      // No changes, just reuse the existing instance.
    } else {
      var container = portalOrRoot.containerInfo;
      var newChildSet = (0, _ReactFiberHostConfig.createContainerChildSet)(container);
      // If children might have changed, we have to add them all to the set.
      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
      portalOrRoot.pendingChildren = newChildSet;
      // Schedule an update on the container to swap out the container.
      markUpdate(workInProgress);
      (0, _ReactFiberHostConfig.finalizeContainerChildren)(container, newChildSet);
    }
  };
  updateHostComponent = function updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance) {
    var currentInstance = current.stateNode;
    var oldProps = current.memoizedProps;
    // If there are no effects associated with this node, then none of our children had any updates.
    // This guarantees that we can reuse all of them.
    var childrenUnchanged = workInProgress.firstEffect === null;
    if (childrenUnchanged && oldProps === newProps) {
      // No changes, just reuse the existing instance.
      // Note that this might release a previous clone.
      workInProgress.stateNode = currentInstance;
      return;
    }
    var recyclableInstance = workInProgress.stateNode;
    var currentHostContext = (0, _ReactFiberHostContext.getHostContext)();
    var updatePayload = null;
    if (oldProps !== newProps) {
      updatePayload = (0, _ReactFiberHostConfig.prepareUpdate)(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
    }
    if (childrenUnchanged && updatePayload === null) {
      // No changes, just reuse the existing instance.
      // Note that this might release a previous clone.
      workInProgress.stateNode = currentInstance;
      return;
    }
    var newInstance = (0, _ReactFiberHostConfig.cloneInstance)(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
    if ((0, _ReactFiberHostConfig.finalizeInitialChildren)(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
      markUpdate(workInProgress);
    }
    workInProgress.stateNode = newInstance;
    if (childrenUnchanged) {
      // If there are no other effects in this tree, we need to flag this node as having one.
      // Even though we're not going to use it for anything.
      // Otherwise parents won't know that there are new children to propagate upwards.
      markUpdate(workInProgress);
    } else {
      // If children might have changed, we have to add them all to the set.
      _appendAllChildren(newInstance, workInProgress, false, false);
    }
  };
  updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
    if (oldText !== newText) {
      // If the text content differs, we'll create a new text instance for it.
      var rootContainerInstance = (0, _ReactFiberHostContext.getRootHostContainer)();
      var currentHostContext = (0, _ReactFiberHostContext.getHostContext)();
      workInProgress.stateNode = (0, _ReactFiberHostConfig.createTextInstance)(newText, rootContainerInstance, currentHostContext, workInProgress);
      // We'll have to mark it as having an effect, even though we won't use the effect for anything.
      // This lets the parents know that at least one of their children has changed.
      markUpdate(workInProgress);
    }
  };
} else {
  // No host operations
  updateHostContainer = function updateHostContainer(workInProgress) {
    // Noop
  };
  updateHostComponent = function updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance) {
    // Noop
  };
  updateHostText = function updateHostText(current, workInProgress, oldText, newText) {
    // Noop
  };
}

function completeWork(current, workInProgress, renderExpirationTime) {
  var newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case _ReactWorkTags.IndeterminateComponent:
      break;
    case _ReactWorkTags.LazyComponent:
      break;
    case _ReactWorkTags.SimpleMemoComponent:
    case _ReactWorkTags.FunctionComponent:
      break;
    case _ReactWorkTags.ClassComponent:
      {
        var Component = workInProgress.type;
        if ((0, _ReactFiberContext.isContextProvider)(Component)) {
          (0, _ReactFiberContext.popContext)(workInProgress);
        }
        break;
      }
    case _ReactWorkTags.HostRoot:
      {
        (0, _ReactFiberHostContext.popHostContainer)(workInProgress);
        (0, _ReactFiberContext.popTopLevelContextObject)(workInProgress);
        var fiberRoot = workInProgress.stateNode;
        if (fiberRoot.pendingContext) {
          fiberRoot.context = fiberRoot.pendingContext;
          fiberRoot.pendingContext = null;
        }
        if (current === null || current.child === null) {
          // If we hydrated, pop so that we can delete any remaining children
          // that weren't hydrated.
          (0, _ReactFiberHydrationContext.popHydrationState)(workInProgress);
          // This resets the hacky state to fix isMounted before committing.
          // TODO: Delete this when we delete isMounted and findDOMNode.
          workInProgress.effectTag &= ~_ReactSideEffectTags.Placement;
        }
        updateHostContainer(workInProgress);
        break;
      }
    case _ReactWorkTags.HostComponent:
      {
        (0, _ReactFiberHostContext.popHostContext)(workInProgress);
        var rootContainerInstance = (0, _ReactFiberHostContext.getRootHostContainer)();
        var type = workInProgress.type;
        if (current !== null && workInProgress.stateNode != null) {
          updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);

          if (current.ref !== workInProgress.ref) {
            markRef(workInProgress);
          }
        } else {
          if (!newProps) {
            (0, _invariant2.default)(workInProgress.stateNode !== null, 'We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');
            // This can happen when we abort work.
            break;
          }

          var currentHostContext = (0, _ReactFiberHostContext.getHostContext)();
          // TODO: Move createInstance to beginWork and keep it on a context
          // "stack" as the parent. Then append children as we go in beginWork
          // or completeWork depending on we want to add then top->down or
          // bottom->up. Top->down is faster in IE11.
          var wasHydrated = (0, _ReactFiberHydrationContext.popHydrationState)(workInProgress);
          if (wasHydrated) {
            // TODO: Move this and createInstance step into the beginPhase
            // to consolidate.
            if ((0, _ReactFiberHydrationContext.prepareToHydrateHostInstance)(workInProgress, rootContainerInstance, currentHostContext)) {
              // If changes to the hydrated node needs to be applied at the
              // commit-phase we mark this as such.
              markUpdate(workInProgress);
            }
          } else {
            var instance = (0, _ReactFiberHostConfig.createInstance)(type, newProps, rootContainerInstance, currentHostContext, workInProgress);

            _appendAllChildren(instance, workInProgress, false, false);

            // Certain renderers require commit-time effects for initial mount.
            // (eg DOM renderer supports auto-focus for certain elements).
            // Make sure such renderers get scheduled for later work.
            if ((0, _ReactFiberHostConfig.finalizeInitialChildren)(instance, type, newProps, rootContainerInstance, currentHostContext)) {
              markUpdate(workInProgress);
            }
            workInProgress.stateNode = instance;
          }

          if (workInProgress.ref !== null) {
            // If there is a ref on a host node we need to schedule a callback
            markRef(workInProgress);
          }
        }
        break;
      }
    case _ReactWorkTags.HostText:
      {
        var newText = newProps;
        if (current && workInProgress.stateNode != null) {
          var oldText = current.memoizedProps;
          // If we have an alternate, that means this is an update and we need
          // to schedule a side-effect to do the updates.
          updateHostText(current, workInProgress, oldText, newText);
        } else {
          if (typeof newText !== 'string') {
            (0, _invariant2.default)(workInProgress.stateNode !== null, 'We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');
            // This can happen when we abort work.
          }
          var _rootContainerInstance = (0, _ReactFiberHostContext.getRootHostContainer)();
          var _currentHostContext = (0, _ReactFiberHostContext.getHostContext)();
          var _wasHydrated = (0, _ReactFiberHydrationContext.popHydrationState)(workInProgress);
          if (_wasHydrated) {
            if ((0, _ReactFiberHydrationContext.prepareToHydrateHostTextInstance)(workInProgress)) {
              markUpdate(workInProgress);
            }
          } else {
            workInProgress.stateNode = (0, _ReactFiberHostConfig.createTextInstance)(newText, _rootContainerInstance, _currentHostContext, workInProgress);
          }
        }
        break;
      }
    case _ReactWorkTags.ForwardRef:
      break;
    case _ReactWorkTags.SuspenseComponent:
      {
        var nextState = workInProgress.memoizedState;
        if ((workInProgress.effectTag & _ReactSideEffectTags.DidCapture) !== _ReactSideEffectTags.NoEffect) {
          // Something suspended. Re-render with the fallback children.
          workInProgress.expirationTime = renderExpirationTime;
          // Do not reset the effect list.
          return workInProgress;
        }

        var nextDidTimeout = nextState !== null;
        var prevDidTimeout = current !== null && current.memoizedState !== null;

        if (current !== null && !nextDidTimeout && prevDidTimeout) {
          // We just switched from the fallback to the normal children. Delete
          // the fallback.
          // TODO: Would it be better to store the fallback fragment on
          var currentFallbackChild = current.child.sibling;
          if (currentFallbackChild !== null) {
            // Deletions go at the beginning of the return fiber's effect list
            var first = workInProgress.firstEffect;
            if (first !== null) {
              workInProgress.firstEffect = currentFallbackChild;
              currentFallbackChild.nextEffect = first;
            } else {
              workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
              currentFallbackChild.nextEffect = null;
            }
            currentFallbackChild.effectTag = _ReactSideEffectTags.Deletion;
          }
        }

        if (nextDidTimeout || prevDidTimeout) {
          // If the children are hidden, or if they were previous hidden, schedule
          // an effect to toggle their visibility. This is also used to attach a
          // retry listener to the promise.
          workInProgress.effectTag |= _ReactSideEffectTags.Update;
        }
        break;
      }
    case _ReactWorkTags.Fragment:
      break;
    case _ReactWorkTags.Mode:
      break;
    case _ReactWorkTags.Profiler:
      break;
    case _ReactWorkTags.HostPortal:
      (0, _ReactFiberHostContext.popHostContainer)(workInProgress);
      updateHostContainer(workInProgress);
      break;
    case _ReactWorkTags.ContextProvider:
      // Pop provider fiber
      (0, _ReactFiberNewContext.popProvider)(workInProgress);
      break;
    case _ReactWorkTags.ContextConsumer:
      break;
    case _ReactWorkTags.MemoComponent:
      break;
    case _ReactWorkTags.IncompleteClassComponent:
      {
        // Same as class component case. I put it down here so that the tags are
        // sequential to ensure this switch is compiled to a jump table.
        var _Component = workInProgress.type;
        if ((0, _ReactFiberContext.isContextProvider)(_Component)) {
          (0, _ReactFiberContext.popContext)(workInProgress);
        }
        break;
      }
    case _ReactWorkTags.DehydratedSuspenseComponent:
      {
        if (_ReactFeatureFlags.enableSuspenseServerRenderer) {
          if (current === null) {
            var _wasHydrated2 = (0, _ReactFiberHydrationContext.popHydrationState)(workInProgress);
            (0, _invariant2.default)(_wasHydrated2, 'A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');
            (0, _ReactFiberHydrationContext.skipPastDehydratedSuspenseInstance)(workInProgress);
          } else if ((workInProgress.effectTag & _ReactSideEffectTags.DidCapture) === _ReactSideEffectTags.NoEffect) {
            // This boundary did not suspend so it's now hydrated.
            // To handle any future suspense cases, we're going to now upgrade it
            // to a Suspense component. We detach it from the existing current fiber.
            current.alternate = null;
            workInProgress.alternate = null;
            workInProgress.tag = _ReactWorkTags.SuspenseComponent;
            workInProgress.memoizedState = null;
            workInProgress.stateNode = null;
          }
        }
        break;
      }
    default:
      (0, _invariant2.default)(false, 'Unknown unit of work tag. This error is likely caused by a bug in ' + 'React. Please file an issue.');
  }

  return null;
}

exports.completeWork = completeWork;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createClassErrorUpdate = exports.createRootErrorUpdate = exports.unwindInterruptedWork = exports.unwindWork = exports.throwException = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

var _tracing = __webpack_require__(23);

var _getComponentName = __webpack_require__(5);

var _getComponentName2 = _interopRequireDefault(_getComponentName);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactWorkTags = __webpack_require__(4);

var _ReactSideEffectTags = __webpack_require__(8);

var _ReactFeatureFlags = __webpack_require__(3);

var _ReactTypeOfMode = __webpack_require__(13);

var _ReactFiberSuspenseComponent = __webpack_require__(144);

var _ReactCapturedValue = __webpack_require__(85);

var _ReactUpdateQueue = __webpack_require__(18);

var _ReactFiberCommitWork = __webpack_require__(86);

var _ReactCurrentFiber = __webpack_require__(7);

var _ReactFiberHostContext = __webpack_require__(41);

var _ReactFiberContext = __webpack_require__(21);

var _ReactFiberNewContext = __webpack_require__(19);

var _ReactFiberScheduler = __webpack_require__(31);

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _maxSigned31BitInt = __webpack_require__(55);

var _maxSigned31BitInt2 = _interopRequireDefault(_maxSigned31BitInt);

var _ReactFiberExpirationTime = __webpack_require__(9);

var _ReactFiberPendingPriority = __webpack_require__(80);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;

function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
  var update = (0, _ReactUpdateQueue.createUpdate)(expirationTime);
  // Unmount the root by rendering null.
  update.tag = _ReactUpdateQueue.CaptureUpdate;
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = { element: null };
  var error = errorInfo.value;
  update.callback = function () {
    (0, _ReactFiberScheduler.onUncaughtError)(error);
    (0, _ReactFiberCommitWork.logError)(fiber, errorInfo);
  };
  return update;
}

function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
  var update = (0, _ReactUpdateQueue.createUpdate)(expirationTime);
  update.tag = _ReactUpdateQueue.CaptureUpdate;
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if (typeof getDerivedStateFromError === 'function') {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromError(error);
    };
  }

  var inst = fiber.stateNode;
  if (inst !== null && typeof inst.componentDidCatch === 'function') {
    update.callback = function callback() {
      if (typeof getDerivedStateFromError !== 'function') {
        // To preserve the preexisting retry behavior of error boundaries,
        // we keep track of which ones already failed during this batch.
        // This gets reset before we yield back to the browser.
        // TODO: Warn in strict mode if getDerivedStateFromError is
        // not defined.
        (0, _ReactFiberScheduler.markLegacyErrorBoundaryAsFailed)(this);
      }
      var error = errorInfo.value;
      var stack = errorInfo.stack;
      (0, _ReactFiberCommitWork.logError)(fiber, errorInfo);
      this.componentDidCatch(error, {
        componentStack: stack !== null ? stack : ''
      });
      if (true) {
        if (typeof getDerivedStateFromError !== 'function') {
          // If componentDidCatch is the only error boundary method defined,
          // then it needs to call setState to recover from errors.
          // If no state update is scheduled then the boundary will swallow the error.
          (0, _warningWithoutStack2.default)(fiber.expirationTime === _ReactFiberExpirationTime.Sync, '%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', (0, _getComponentName2.default)(fiber.type) || 'Unknown');
        }
      }
    };
  }
  return update;
}

function attachPingListener(root, renderExpirationTime, thenable) {
  // Attach a listener to the promise to "ping" the root and retry. But
  // only if one does not already exist for the current render expiration
  // time (which acts like a "thread ID" here).
  var pingCache = root.pingCache;
  var threadIDs = void 0;
  if (pingCache === null) {
    pingCache = root.pingCache = new PossiblyWeakMap();
    threadIDs = new Set();
    pingCache.set(thenable, threadIDs);
  } else {
    threadIDs = pingCache.get(thenable);
    if (threadIDs === undefined) {
      threadIDs = new Set();
      pingCache.set(thenable, threadIDs);
    }
  }
  if (!threadIDs.has(renderExpirationTime)) {
    // Memoize using the thread ID to prevent redundant listeners.
    threadIDs.add(renderExpirationTime);
    var ping = _ReactFiberScheduler.pingSuspendedRoot.bind(null, root, thenable, renderExpirationTime);
    if (_ReactFeatureFlags.enableSchedulerTracing) {
      ping = (0, _tracing.unstable_wrap)(ping);
    }
    thenable.then(ping, ping);
  }
}

function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
  // The source fiber did not complete.
  sourceFiber.effectTag |= _ReactSideEffectTags.Incomplete;
  // Its effect list is no longer valid.
  sourceFiber.firstEffect = sourceFiber.lastEffect = null;

  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.then === 'function') {
    // This is a thenable.
    var thenable = value;

    // Find the earliest timeout threshold of all the placeholders in the
    // ancestor path. We could avoid this traversal by storing the thresholds on
    // the stack, but we choose not to because we only hit this path if we're
    // IO-bound (i.e. if something suspends). Whereas the stack is used even in
    // the non-IO- bound case.
    var _workInProgress = returnFiber;
    var earliestTimeoutMs = -1;
    var startTimeMs = -1;
    do {
      if (_workInProgress.tag === _ReactWorkTags.SuspenseComponent) {
        var current = _workInProgress.alternate;
        if (current !== null) {
          var currentState = current.memoizedState;
          if (currentState !== null) {
            // Reached a boundary that already timed out. Do not search
            // any further.
            var timedOutAt = currentState.timedOutAt;
            startTimeMs = (0, _ReactFiberExpirationTime.expirationTimeToMs)(timedOutAt);
            // Do not search any further.
            break;
          }
        }
        var timeoutPropMs = _workInProgress.pendingProps.maxDuration;
        if (typeof timeoutPropMs === 'number') {
          if (timeoutPropMs <= 0) {
            earliestTimeoutMs = 0;
          } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
            earliestTimeoutMs = timeoutPropMs;
          }
        }
      }
      // If there is a DehydratedSuspenseComponent we don't have to do anything because
      // if something suspends inside it, we will simply leave that as dehydrated. It
      // will never timeout.
      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null);

    // Schedule the nearest Suspense to re-render the timed out view.
    _workInProgress = returnFiber;
    do {
      if (_workInProgress.tag === _ReactWorkTags.SuspenseComponent && (0, _ReactFiberSuspenseComponent.shouldCaptureSuspense)(_workInProgress)) {
        // Found the nearest boundary.

        // Stash the promise on the boundary fiber. If the boundary times out, we'll
        var thenables = _workInProgress.updateQueue;
        if (thenables === null) {
          var updateQueue = new Set();
          updateQueue.add(thenable);
          _workInProgress.updateQueue = updateQueue;
        } else {
          thenables.add(thenable);
        }

        // If the boundary is outside of concurrent mode, we should *not*
        // suspend the commit. Pretend as if the suspended component rendered
        // null and keep rendering. In the commit phase, we'll schedule a
        // subsequent synchronous update to re-render the Suspense.
        //
        // Note: It doesn't matter whether the component that suspended was
        // inside a concurrent mode tree. If the Suspense is outside of it, we
        // should *not* suspend the commit.
        if ((_workInProgress.mode & _ReactTypeOfMode.ConcurrentMode) === _ReactSideEffectTags.NoEffect) {
          _workInProgress.effectTag |= _ReactSideEffectTags.DidCapture;

          // We're going to commit this fiber even though it didn't complete.
          // But we shouldn't call any lifecycle methods or callbacks. Remove
          // all lifecycle effect tags.
          sourceFiber.effectTag &= ~(_ReactSideEffectTags.LifecycleEffectMask | _ReactSideEffectTags.Incomplete);

          if (sourceFiber.tag === _ReactWorkTags.ClassComponent) {
            var currentSourceFiber = sourceFiber.alternate;
            if (currentSourceFiber === null) {
              // This is a new mount. Change the tag so it's not mistaken for a
              // completed class component. For example, we should not call
              // componentWillUnmount if it is deleted.
              sourceFiber.tag = _ReactWorkTags.IncompleteClassComponent;
            } else {
              // When we try rendering again, we should not reuse the current fiber,
              // since it's known to be in an inconsistent state. Use a force updte to
              // prevent a bail out.
              var update = (0, _ReactUpdateQueue.createUpdate)(_ReactFiberExpirationTime.Sync);
              update.tag = _ReactUpdateQueue.ForceUpdate;
              (0, _ReactUpdateQueue.enqueueUpdate)(sourceFiber, update);
            }
          }

          // The source fiber did not complete. Mark it with Sync priority to
          // indicate that it still has pending work.
          sourceFiber.expirationTime = _ReactFiberExpirationTime.Sync;

          // Exit without suspending.
          return;
        }

        // Confirmed that the boundary is in a concurrent mode tree. Continue
        // with the normal suspend path.

        attachPingListener(root, renderExpirationTime, thenable);

        var absoluteTimeoutMs = void 0;
        if (earliestTimeoutMs === -1) {
          // If no explicit threshold is given, default to an arbitrarily large
          // value. The actual size doesn't matter because the threshold for the
          // whole tree will be clamped to the expiration time.
          absoluteTimeoutMs = _maxSigned31BitInt2.default;
        } else {
          if (startTimeMs === -1) {
            // This suspend happened outside of any already timed-out
            // placeholders. We don't know exactly when the update was
            // scheduled, but we can infer an approximate start time from the
            // expiration time. First, find the earliest uncommitted expiration
            // time in the tree, including work that is suspended. Then subtract
            // the offset used to compute an async update's expiration time.
            // This will cause high priority (interactive) work to expire
            // earlier than necessary, but we can account for this by adjusting
            // for the Just Noticeable Difference.
            var earliestExpirationTime = (0, _ReactFiberPendingPriority.findEarliestOutstandingPriorityLevel)(root, renderExpirationTime);
            var earliestExpirationTimeMs = (0, _ReactFiberExpirationTime.expirationTimeToMs)(earliestExpirationTime);
            startTimeMs = earliestExpirationTimeMs - _ReactFiberExpirationTime.LOW_PRIORITY_EXPIRATION;
          }
          absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
        }

        // Mark the earliest timeout in the suspended fiber's ancestor path.
        // After completing the root, we'll take the largest of all the
        // suspended fiber's timeouts and use it to compute a timeout for the
        // whole tree.
        (0, _ReactFiberScheduler.renderDidSuspend)(root, absoluteTimeoutMs, renderExpirationTime);

        _workInProgress.effectTag |= _ReactSideEffectTags.ShouldCapture;
        _workInProgress.expirationTime = renderExpirationTime;
        return;
      } else if (_ReactFeatureFlags.enableSuspenseServerRenderer && _workInProgress.tag === _ReactWorkTags.DehydratedSuspenseComponent) {
        attachPingListener(root, renderExpirationTime, thenable);

        // Since we already have a current fiber, we can eagerly add a retry listener.
        var retryCache = _workInProgress.memoizedState;
        if (retryCache === null) {
          retryCache = _workInProgress.memoizedState = new PossiblyWeakSet();
          var _current = _workInProgress.alternate;
          (0, _invariant2.default)(_current, 'A dehydrated suspense boundary must commit before trying to render. ' + 'This is probably a bug in React.');
          _current.memoizedState = retryCache;
        }
        // Memoize using the boundary fiber to prevent redundant listeners.
        if (!retryCache.has(thenable)) {
          retryCache.add(thenable);
          var retry = _ReactFiberScheduler.retryTimedOutBoundary.bind(null, _workInProgress, thenable);
          if (_ReactFeatureFlags.enableSchedulerTracing) {
            retry = (0, _tracing.unstable_wrap)(retry);
          }
          thenable.then(retry, retry);
        }
        _workInProgress.effectTag |= _ReactSideEffectTags.ShouldCapture;
        _workInProgress.expirationTime = renderExpirationTime;
        return;
      }
      // This boundary already captured during this render. Continue to the next
      // boundary.
      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null);
    // No boundary was found. Fallthrough to error mode.
    // TODO: Use invariant so the message is stripped in prod?
    value = new Error(((0, _getComponentName2.default)(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.' + (0, _ReactCurrentFiber.getStackByFiberInDevAndProd)(sourceFiber));
  }

  // We didn't find a boundary that could handle this type of exception. Start
  // over and traverse parent path again, this time treating the exception
  // as an error.
  (0, _ReactFiberScheduler.renderDidError)();
  value = (0, _ReactCapturedValue.createCapturedValue)(value, sourceFiber);
  var workInProgress = returnFiber;
  do {
    switch (workInProgress.tag) {
      case _ReactWorkTags.HostRoot:
        {
          var _errorInfo = value;
          workInProgress.effectTag |= _ReactSideEffectTags.ShouldCapture;
          workInProgress.expirationTime = renderExpirationTime;
          var _update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);
          (0, _ReactUpdateQueue.enqueueCapturedUpdate)(workInProgress, _update);
          return;
        }
      case _ReactWorkTags.ClassComponent:
        // Capture and retry
        var errorInfo = value;
        var ctor = workInProgress.type;
        var instance = workInProgress.stateNode;
        if ((workInProgress.effectTag & _ReactSideEffectTags.DidCapture) === _ReactSideEffectTags.NoEffect && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !(0, _ReactFiberScheduler.isAlreadyFailedLegacyErrorBoundary)(instance))) {
          workInProgress.effectTag |= _ReactSideEffectTags.ShouldCapture;
          workInProgress.expirationTime = renderExpirationTime;
          // Schedule the error boundary to re-render using updated state
          var _update2 = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);
          (0, _ReactUpdateQueue.enqueueCapturedUpdate)(workInProgress, _update2);
          return;
        }
        break;
      default:
        break;
    }
    workInProgress = workInProgress.return;
  } while (workInProgress !== null);
}

function unwindWork(workInProgress, renderExpirationTime) {
  switch (workInProgress.tag) {
    case _ReactWorkTags.ClassComponent:
      {
        var Component = workInProgress.type;
        if ((0, _ReactFiberContext.isContextProvider)(Component)) {
          (0, _ReactFiberContext.popContext)(workInProgress);
        }
        var effectTag = workInProgress.effectTag;
        if (effectTag & _ReactSideEffectTags.ShouldCapture) {
          workInProgress.effectTag = effectTag & ~_ReactSideEffectTags.ShouldCapture | _ReactSideEffectTags.DidCapture;
          return workInProgress;
        }
        return null;
      }
    case _ReactWorkTags.HostRoot:
      {
        (0, _ReactFiberHostContext.popHostContainer)(workInProgress);
        (0, _ReactFiberContext.popTopLevelContextObject)(workInProgress);
        var _effectTag = workInProgress.effectTag;
        (0, _invariant2.default)((_effectTag & _ReactSideEffectTags.DidCapture) === _ReactSideEffectTags.NoEffect, 'The root failed to unmount after an error. This is likely a bug in ' + 'React. Please file an issue.');
        workInProgress.effectTag = _effectTag & ~_ReactSideEffectTags.ShouldCapture | _ReactSideEffectTags.DidCapture;
        return workInProgress;
      }
    case _ReactWorkTags.HostComponent:
      {
        // TODO: popHydrationState
        (0, _ReactFiberHostContext.popHostContext)(workInProgress);
        return null;
      }
    case _ReactWorkTags.SuspenseComponent:
      {
        var _effectTag2 = workInProgress.effectTag;
        if (_effectTag2 & _ReactSideEffectTags.ShouldCapture) {
          workInProgress.effectTag = _effectTag2 & ~_ReactSideEffectTags.ShouldCapture | _ReactSideEffectTags.DidCapture;
          // Captured a suspense effect. Re-render the boundary.
          return workInProgress;
        }
        return null;
      }
    case _ReactWorkTags.DehydratedSuspenseComponent:
      {
        if (_ReactFeatureFlags.enableSuspenseServerRenderer) {
          // TODO: popHydrationState
          var _effectTag3 = workInProgress.effectTag;
          if (_effectTag3 & _ReactSideEffectTags.ShouldCapture) {
            workInProgress.effectTag = _effectTag3 & ~_ReactSideEffectTags.ShouldCapture | _ReactSideEffectTags.DidCapture;
            // Captured a suspense effect. Re-render the boundary.
            return workInProgress;
          }
        }
        return null;
      }
    case _ReactWorkTags.HostPortal:
      (0, _ReactFiberHostContext.popHostContainer)(workInProgress);
      return null;
    case _ReactWorkTags.ContextProvider:
      (0, _ReactFiberNewContext.popProvider)(workInProgress);
      return null;
    default:
      return null;
  }
}

function unwindInterruptedWork(interruptedWork) {
  switch (interruptedWork.tag) {
    case _ReactWorkTags.ClassComponent:
      {
        var childContextTypes = interruptedWork.type.childContextTypes;
        if (childContextTypes !== null && childContextTypes !== undefined) {
          (0, _ReactFiberContext.popContext)(interruptedWork);
        }
        break;
      }
    case _ReactWorkTags.HostRoot:
      {
        (0, _ReactFiberHostContext.popHostContainer)(interruptedWork);
        (0, _ReactFiberContext.popTopLevelContextObject)(interruptedWork);
        break;
      }
    case _ReactWorkTags.HostComponent:
      {
        (0, _ReactFiberHostContext.popHostContext)(interruptedWork);
        break;
      }
    case _ReactWorkTags.HostPortal:
      (0, _ReactFiberHostContext.popHostContainer)(interruptedWork);
      break;
    case _ReactWorkTags.ContextProvider:
      (0, _ReactFiberNewContext.popProvider)(interruptedWork);
      break;
    default:
      break;
  }
}

exports.throwException = throwException;
exports.unwindWork = unwindWork;
exports.unwindInterruptedWork = unwindInterruptedWork;
exports.createRootErrorUpdate = createRootErrorUpdate;
exports.createClassErrorUpdate = createClassErrorUpdate;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldCaptureSuspense = shouldCaptureSuspense;
function shouldCaptureSuspense(workInProgress) {
  // In order to capture, the Suspense component must have a fallback prop.
  if (workInProgress.memoizedProps.fallback === undefined) {
    return false;
  }
  // If it was the primary children that just suspended, capture and render the
  // fallback. Otherwise, don't capture and bubble to the next boundary.
  var nextState = workInProgress.memoizedState;
  return nextState === null;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logCapturedError = logCapturedError;

var _ReactFiberErrorDialog = __webpack_require__(146);

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function logCapturedError(capturedError) {
  var logError = (0, _ReactFiberErrorDialog.showErrorDialog)(capturedError);

  // Allow injected showErrorDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  if (true) {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;

    // Browsers support silencing uncaught errors by calling
    // `preventDefault()` in window `error` handler.
    // We record this information as an expando on the error.

    if (error != null && error._suppressLogging) {
      if (errorBoundaryFound && willRetry) {
        // The error is recoverable and was silenced.
        // Ignore it and don't print the stack addendum.
        // This is handy for testing error boundaries without noise.
        return;
      }
      // The error is fatal. Since the silencing might have
      // been accidental, we'll surface it anyway.
      // However, the browser would have silenced the original error
      // so we'll print it first, and then print the stack addendum.
      console.error(error);
      // For a more detailed description of this block, see:
      // https://github.com/facebook/react/pull/13384
    }

    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  } else {
    // In production, we print the error directly.
    // This will include the message, the JS stack, and anything the browser wants to show.
    // We pass the error object instead of custom message so that the browser displays the error natively.
    console.error(error);
  }
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showErrorDialog = showErrorDialog;


// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(capturedError) {
  return true;
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPortal = createPortal;

var _ReactSymbols = __webpack_require__(6);

function createPortal(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: _ReactSymbols.REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

// TODO: direct imports like some-package/src/* are bad. Fix me.


exports.trapClickOnNonInteractiveElement = trapClickOnNonInteractiveElement;
exports.createElement = createElement;
exports.createTextNode = createTextNode;
exports.setInitialProperties = setInitialProperties;
exports.diffProperties = diffProperties;
exports.updateProperties = updateProperties;
exports.diffHydratedProperties = diffHydratedProperties;
exports.diffHydratedText = diffHydratedText;
exports.warnForUnmatchedText = warnForUnmatchedText;
exports.warnForDeletedHydratableElement = warnForDeletedHydratableElement;
exports.warnForDeletedHydratableText = warnForDeletedHydratableText;
exports.warnForInsertedHydratedElement = warnForInsertedHydratedElement;
exports.warnForInsertedHydratedText = warnForInsertedHydratedText;
exports.restoreControlledState = restoreControlledState;

var _ReactCurrentFiber = __webpack_require__(7);

var _EventPluginRegistry = __webpack_require__(25);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ExecutionEnvironment = __webpack_require__(17);

var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _DOMPropertyOperations = __webpack_require__(73);

var _ReactDOMInput = __webpack_require__(72);

var _ReactDOMOption = __webpack_require__(149);

var _ReactDOMSelect = __webpack_require__(150);

var _ReactDOMTextarea = __webpack_require__(151);

var _inputValueTracking = __webpack_require__(49);

var _setInnerHTML = __webpack_require__(152);

var _setInnerHTML2 = _interopRequireDefault(_setInnerHTML);

var _setTextContent = __webpack_require__(154);

var _setTextContent2 = _interopRequireDefault(_setTextContent);

var _DOMTopLevelEventTypes = __webpack_require__(14);

var _ReactBrowserEventEmitter = __webpack_require__(75);

var _CSSPropertyOperations = __webpack_require__(155);

var _DOMNamespaces = __webpack_require__(87);

var _DOMProperty = __webpack_require__(26);

var _assertValidProps = __webpack_require__(161);

var _assertValidProps2 = _interopRequireDefault(_assertValidProps);

var _HTMLNodeType = __webpack_require__(15);

var _isCustomComponent = __webpack_require__(59);

var _isCustomComponent2 = _interopRequireDefault(_isCustomComponent);

var _possibleStandardNames = __webpack_require__(88);

var _possibleStandardNames2 = _interopRequireDefault(_possibleStandardNames);

var _ReactDOMInvalidARIAHook = __webpack_require__(164);

var _ReactDOMNullInputValuePropHook = __webpack_require__(166);

var _ReactDOMUnknownPropertyHook = __webpack_require__(167);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = _DOMNamespaces.Namespaces.html;


var warnedUnknownTags = void 0;
var suppressHydrationWarning = void 0;

var validatePropertiesInDevelopment = void 0;
var warnForTextDifference = void 0;
var warnForPropDifference = void 0;
var warnForExtraAttributes = void 0;
var warnForInvalidEventListener = void 0;
var canDiffStyleForHydrationWarning = void 0;

var normalizeMarkupForTextOrAttribute = void 0;
var normalizeHTML = void 0;

if (true) {
  warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true,
    // Electron ships a custom <webview> tag to display external web content in
    // an isolated frame and process.
    // This tag is not present in non Electron environments such as JSDom which
    // is often used for testing purposes.
    // @see https://electronjs.org/docs/api/webview-tag
    webview: true
  };

  validatePropertiesInDevelopment = function validatePropertiesInDevelopment(type, props) {
    (0, _ReactDOMInvalidARIAHook.validateProperties)(type, props);
    (0, _ReactDOMNullInputValuePropHook.validateProperties)(type, props);
    (0, _ReactDOMUnknownPropertyHook.validateProperties)(type, props, /* canUseEventSystem */true);
  };

  // IE 11 parses & normalizes the style attribute as opposed to other
  // browsers. It adds spaces and sorts the properties in some
  // non-alphabetical order. Handling that would require sorting CSS
  // properties in the client & server versions or applying
  // `expectedStyle` to a temporary DOM node to read its `style` attribute
  // normalized. Since it only affects IE, we're skipping style warnings
  // in that browser completely in favor of doing all that work.
  // See https://github.com/facebook/react/issues/11807
  canDiffStyleForHydrationWarning = _ExecutionEnvironment.canUseDOM && !document.documentMode;

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  normalizeMarkupForTextOrAttribute = function normalizeMarkupForTextOrAttribute(markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  warnForTextDifference = function warnForTextDifference(serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    (0, _warningWithoutStack2.default)(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  warnForPropDifference = function warnForPropDifference(propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    (0, _warningWithoutStack2.default)(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  warnForExtraAttributes = function warnForExtraAttributes(attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    (0, _warningWithoutStack2.default)(false, 'Extra attributes from the server: %s', names);
  };

  warnForInvalidEventListener = function warnForInvalidEventListener(registrationName, listener) {
    if (listener === false) {
      (0, _warning2.default)(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
    } else {
      (0, _warning2.default)(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener));
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  normalizeHTML = function normalizeHTML(parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === _HTMLNodeType.DOCUMENT_NODE || rootContainerElement.nodeType === _HTMLNodeType.DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  (0, _ReactBrowserEventEmitter.listenTo)(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === _HTMLNodeType.DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

function noop() {}

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = noop;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      if (true) {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      (0, _CSSPropertyOperations.setValueForStyles)(domElement, nextProp);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        (0, _setInnerHTML2.default)(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          (0, _setTextContent2.default)(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        (0, _setTextContent2.default)(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We could have excluded it in the property list instead of
      // adding a special case here, but then it wouldn't be emitted
      // on server rendering (but we *do* want to emit it in SSR).
    } else if (_EventPluginRegistry.registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (nextProp != null) {
      (0, _DOMPropertyOperations.setValueForProperty)(domElement, propKey, nextProp, isCustomComponentTag);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      (0, _CSSPropertyOperations.setValueForStyles)(domElement, propValue);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      (0, _setInnerHTML2.default)(domElement, propValue);
    } else if (propKey === CHILDREN) {
      (0, _setTextContent2.default)(domElement, propValue);
    } else {
      (0, _DOMPropertyOperations.setValueForProperty)(domElement, propKey, propValue, isCustomComponentTag);
    }
  }
}

function createElement(type, props, rootContainerElement, parentNamespace) {
  var isCustomComponentTag = void 0;

  // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement = void 0;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = (0, _DOMNamespaces.getIntrinsicNamespace)(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    if (true) {
      isCustomComponentTag = (0, _isCustomComponent2.default)(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      (0, _warning2.default)(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
      // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple`
      // attribute on `select`s needs to be added before `option`s are inserted. This prevents
      // a bug where the `select` does not scroll to the correct option because singular
      // `select` elements automatically pick the first item.
      // See https://github.com/facebook/react/issues/13222
      if (type === 'select' && props.multiple) {
        var node = domElement;
        node.multiple = true;
      }
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  if (true) {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        (0, _warning2.default)(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = (0, _isCustomComponent2.default)(tag, rawProps);
  if (true) {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      (0, _warning2.default)(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', (0, _ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull)() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props = void 0;
  switch (tag) {
    case 'iframe':
    case 'object':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_LOAD, domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var i = 0; i < _DOMTopLevelEventTypes.mediaEventTypes.length; i++) {
        (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.mediaEventTypes[i], domElement);
      }
      props = rawProps;
      break;
    case 'source':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_ERROR, domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
    case 'link':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_ERROR, domElement);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_LOAD, domElement);
      props = rawProps;
      break;
    case 'form':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_RESET, domElement);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_SUBMIT, domElement);
      props = rawProps;
      break;
    case 'details':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_TOGGLE, domElement);
      props = rawProps;
      break;
    case 'input':
      (0, _ReactDOMInput.initWrapperState)(domElement, rawProps);
      props = (0, _ReactDOMInput.getHostProps)(domElement, rawProps);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      (0, _ReactDOMOption.validateProps)(domElement, rawProps);
      props = (0, _ReactDOMOption.getHostProps)(domElement, rawProps);
      break;
    case 'select':
      (0, _ReactDOMSelect.initWrapperState)(domElement, rawProps);
      props = (0, _ReactDOMSelect.getHostProps)(domElement, rawProps);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      (0, _ReactDOMTextarea.initWrapperState)(domElement, rawProps);
      props = (0, _ReactDOMTextarea.getHostProps)(domElement, rawProps);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  (0, _assertValidProps2.default)(tag, props);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      (0, _inputValueTracking.track)(domElement);
      (0, _ReactDOMInput.postMountWrapper)(domElement, rawProps, false);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      (0, _inputValueTracking.track)(domElement);
      (0, _ReactDOMTextarea.postMountWrapper)(domElement, rawProps);
      break;
    case 'option':
      (0, _ReactDOMOption.postMountWrapper)(domElement, rawProps);
      break;
    case 'select':
      (0, _ReactDOMSelect.postMountWrapper)(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  if (true) {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps = void 0;
  var nextProps = void 0;
  switch (tag) {
    case 'input':
      lastProps = (0, _ReactDOMInput.getHostProps)(domElement, lastRawProps);
      nextProps = (0, _ReactDOMInput.getHostProps)(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = (0, _ReactDOMOption.getHostProps)(domElement, lastRawProps);
      nextProps = (0, _ReactDOMOption.getHostProps)(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = (0, _ReactDOMSelect.getHostProps)(domElement, lastRawProps);
      nextProps = (0, _ReactDOMSelect.getHostProps)(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = (0, _ReactDOMTextarea.getHostProps)(domElement, lastRawProps);
      nextProps = (0, _ReactDOMTextarea.getHostProps)(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  (0, _assertValidProps2.default)(tag, nextProps);

  var propKey = void 0;
  var styleName = void 0;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (_EventPluginRegistry.registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      if (true) {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) {
      // Noop
    } else if (_EventPluginRegistry.registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    if (true) {
      (0, _CSSPropertyOperations.validateShorthandPropertyCollisionInDev)(styleUpdates, nextProps[STYLE]);
    }
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    (0, _ReactDOMInput.updateChecked)(domElement, nextRawProps);
  }

  var wasCustomComponentTag = (0, _isCustomComponent2.default)(tag, lastRawProps);
  var isCustomComponentTag = (0, _isCustomComponent2.default)(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      (0, _ReactDOMInput.updateWrapper)(domElement, nextRawProps);
      break;
    case 'textarea':
      (0, _ReactDOMTextarea.updateWrapper)(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      (0, _ReactDOMSelect.postUpdateWrapper)(domElement, nextRawProps);
      break;
  }
}

function getPossibleStandardName(propName) {
  if (true) {
    var lowerCasedName = propName.toLowerCase();
    if (!_possibleStandardNames2.default.hasOwnProperty(lowerCasedName)) {
      return null;
    }
    return _possibleStandardNames2.default[lowerCasedName] || null;
  }
  return null;
}

function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  var isCustomComponentTag = void 0;
  var extraAttributeNames = void 0;

  if (true) {
    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
    isCustomComponentTag = (0, _isCustomComponent2.default)(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      (0, _warning2.default)(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', (0, _ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull)() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_LOAD, domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var i = 0; i < _DOMTopLevelEventTypes.mediaEventTypes.length; i++) {
        (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.mediaEventTypes[i], domElement);
      }
      break;
    case 'source':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_ERROR, domElement);
      break;
    case 'img':
    case 'image':
    case 'link':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_ERROR, domElement);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_LOAD, domElement);
      break;
    case 'form':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_RESET, domElement);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_SUBMIT, domElement);
      break;
    case 'details':
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_TOGGLE, domElement);
      break;
    case 'input':
      (0, _ReactDOMInput.initWrapperState)(domElement, rawProps);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      (0, _ReactDOMOption.validateProps)(domElement, rawProps);
      break;
    case 'select':
      (0, _ReactDOMSelect.initWrapperState)(domElement, rawProps);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      (0, _ReactDOMTextarea.initWrapperState)(domElement, rawProps);
      (0, _ReactBrowserEventEmitter.trapBubbledEvent)(_DOMTopLevelEventTypes.TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  (0, _assertValidProps2.default)(tag, rawProps);

  if (true) {
    extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var _i = 0; _i < attributes.length; _i++) {
      var name = attributes[_i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[_i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (_EventPluginRegistry.registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (true &&
    // Convince Flow we've calculated it (it's DEV-only in this method.)
    typeof isCustomComponentTag === 'boolean') {
      // Validate that the properties correspond to their expected values.
      var serverValue = void 0;
      var propertyInfo = (0, _DOMProperty.getPropertyInfo)(propKey);
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var serverHTML = domElement.innerHTML;
        var nextHtml = nextProp ? nextProp[HTML] : undefined;
        var expectedHTML = normalizeHTML(domElement, nextHtml != null ? nextHtml : '');
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey);

        if (canDiffStyleForHydrationWarning) {
          var expectedStyle = (0, _CSSPropertyOperations.createDangerousStringForStyles)(nextProp);
          serverValue = domElement.getAttribute('style');
          if (expectedStyle !== serverValue) {
            warnForPropDifference(propKey, serverValue, expectedStyle);
          }
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey.toLowerCase());
        serverValue = (0, _DOMPropertyOperations.getValueForAttribute)(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (!(0, _DOMProperty.shouldIgnoreAttribute)(propKey, propertyInfo, isCustomComponentTag) && !(0, _DOMProperty.shouldRemoveAttribute)(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
        var isMismatchDueToBadCasing = false;
        if (propertyInfo !== null) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames.delete(propertyInfo.attributeName);
          serverValue = (0, _DOMPropertyOperations.getValueForProperty)(domElement, propKey, nextProp, propertyInfo);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = (0, _DOMNamespaces.getIntrinsicNamespace)(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey.toLowerCase());
          } else {
            var standardName = getPossibleStandardName(propKey);
            if (standardName !== null && standardName !== propKey) {
              // If an SVG prop is supplied with bad casing, it will
              // be successfully parsed from HTML, but will produce a mismatch
              // (and would be incorrectly rendered on the client).
              // However, we already warn about bad casing elsewhere.
              // So we'll skip the misleading extra mismatch warning in this case.
              isMismatchDueToBadCasing = true;
              // $FlowFixMe - Should be inferred as not undefined.
              extraAttributeNames.delete(standardName);
            }
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey);
          }
          serverValue = (0, _DOMPropertyOperations.getValueForAttribute)(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  if (true) {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      (0, _inputValueTracking.track)(domElement);
      (0, _ReactDOMInput.postMountWrapper)(domElement, rawProps, true);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      (0, _inputValueTracking.track)(domElement);
      (0, _ReactDOMTextarea.postMountWrapper)(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText(textNode, text) {
  if (true) {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement(parentNode, child) {
  if (true) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    (0, _warningWithoutStack2.default)(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText(parentNode, child) {
  if (true) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    (0, _warningWithoutStack2.default)(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement(parentNode, tag, props) {
  if (true) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    (0, _warningWithoutStack2.default)(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText(parentNode, text) {
  if (true) {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    (0, _warningWithoutStack2.default)(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      (0, _ReactDOMInput.restoreControlledState)(domElement, props);
      return;
    case 'textarea':
      (0, _ReactDOMTextarea.restoreControlledState)(domElement, props);
      return;
    case 'select':
      (0, _ReactDOMSelect.restoreControlledState)(domElement, props);
      return;
  }
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

exports.validateProps = validateProps;
exports.postMountWrapper = postMountWrapper;
exports.getHostProps = getHostProps;

var _react = __webpack_require__(22);

var _react2 = _interopRequireDefault(_react);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ToStringValue = __webpack_require__(35);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnSelectedSetOnOption = false;
var didWarnInvalidChild = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children. We'll warn if they are invalid
  // during validateProps() which runs for hydration too.
  // Note that this would throw on non-element objects.
  // Elements are stringified (which is normally irrelevant
  // but matters for <fbt>).
  _react2.default.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    content += child;
    // Note: we don't warn about invalid children here.
    // Instead, this is done separately below so that
    // it happens during the hydration codepath too.
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  if (true) {
    // This mirrors the codepath above, but runs for hydration too.
    // Warn about invalid children here so that client and hydration are consistent.
    // TODO: this seems like it could cause a DEV-only throw for hydration
    // if children contains a non-element object. We should try to avoid that.
    if (_typeof(props.children) === 'object' && props.children !== null) {
      _react2.default.Children.forEach(props.children, function (child) {
        if (child == null) {
          return;
        }
        if (typeof child === 'string' || typeof child === 'number') {
          return;
        }
        if (typeof child.type !== 'string') {
          return;
        }
        if (!didWarnInvalidChild) {
          didWarnInvalidChild = true;
          (0, _warning2.default)(false, 'Only strings and numbers are supported as <option> children.');
        }
      });
    }

    // TODO: Remove support for `selected` in <option>.
    if (props.selected != null && !didWarnSelectedSetOnOption) {
      (0, _warning2.default)(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
      didWarnSelectedSetOnOption = true;
    }
  }
}

function postMountWrapper(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', (0, _ToStringValue.toString)((0, _ToStringValue.getToStringValue)(props.value)));
  }
}

function getHostProps(element, props) {
  var hostProps = _extends({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHostProps = getHostProps;
exports.initWrapperState = initWrapperState;
exports.postMountWrapper = postMountWrapper;
exports.postUpdateWrapper = postUpdateWrapper;
exports.restoreControlledState = restoreControlledState;

var _ReactCurrentFiber = __webpack_require__(7);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ReactControlledValuePropTypes = __webpack_require__(50);

var _ReactControlledValuePropTypes2 = _interopRequireDefault(_ReactControlledValuePropTypes);

var _ToStringValue = __webpack_require__(35);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnValueDefaultValue = void 0;

if (true) {
  didWarnValueDefaultValue = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = (0, _ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull)();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  _ReactControlledValuePropTypes2.default.checkPropTypes('select', props);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      (0, _warning2.default)(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      (0, _warning2.default)(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = (0, _ToStringValue.toString)((0, _ToStringValue.getToStringValue)(propValue));
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps(element, props) {
  return Object.assign({}, props, {
    value: undefined
  });
}

function initWrapperState(element, props) {
  var node = element;
  if (true) {
    checkSelectPropTypes(props);
  }

  node._wrapperState = {
    wasMultiple: !!props.multiple
  };

  if (true) {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      (0, _warning2.default)(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue = true;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * 
                                                                                                                                                                                                                                                                   */

exports.getHostProps = getHostProps;
exports.initWrapperState = initWrapperState;
exports.updateWrapper = updateWrapper;
exports.postMountWrapper = postMountWrapper;
exports.restoreControlledState = restoreControlledState;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ReactControlledValuePropTypes = __webpack_require__(50);

var _ReactControlledValuePropTypes2 = _interopRequireDefault(_ReactControlledValuePropTypes);

var _ReactCurrentFiber = __webpack_require__(7);

var _ToStringValue = __webpack_require__(35);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps(element, props) {
  var node = element;
  (0, _invariant2.default)(props.dangerouslySetInnerHTML == null, '`dangerouslySetInnerHTML` does not make sense on <textarea>.');

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _extends({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: (0, _ToStringValue.toString)(node._wrapperState.initialValue)
  });

  return hostProps;
}

function initWrapperState(element, props) {
  var node = element;
  if (true) {
    _ReactControlledValuePropTypes2.default.checkPropTypes('textarea', props);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      (0, _warning2.default)(false, '%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', (0, _ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull)() || 'A component');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      if (true) {
        (0, _warning2.default)(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      (0, _invariant2.default)(defaultValue == null, 'If you supply `defaultValue` on a <textarea>, do not pass children.');
      if (Array.isArray(children)) {
        (0, _invariant2.default)(children.length <= 1, '<textarea> can only have at most one child.');
        children = children[0];
      }

      defaultValue = children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: (0, _ToStringValue.getToStringValue)(initialValue)
  };
}

function updateWrapper(element, props) {
  var node = element;
  var value = (0, _ToStringValue.getToStringValue)(props.value);
  var defaultValue = (0, _ToStringValue.getToStringValue)(props.defaultValue);
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = (0, _ToStringValue.toString)(value);
    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null && node.defaultValue !== newValue) {
      node.defaultValue = newValue;
    }
  }
  if (defaultValue != null) {
    node.defaultValue = (0, _ToStringValue.toString)(defaultValue);
  }
}

function postMountWrapper(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState(element, props) {
  // DOM component is still mounted; update
  updateWrapper(element, props);
}

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _DOMNamespaces = __webpack_require__(87);

var _createMicrosoftUnsafeLocalFunction = __webpack_require__(153);

var _createMicrosoftUnsafeLocalFunction2 = _interopRequireDefault(_createMicrosoftUnsafeLocalFunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// SVG temp container for IE lacking innerHTML
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = (0, _createMicrosoftUnsafeLocalFunction2.default)(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === _DOMNamespaces.Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

exports.default = setInnerHTML;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

exports.default = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _HTMLNodeType = __webpack_require__(15);

/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === _HTMLNodeType.TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}; /**
    * Copyright (c) Facebook, Inc. and its affiliates.
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE file in the root directory of this source tree.
    *
    * 
    */

exports.default = setTextContent;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDangerousStringForStyles = createDangerousStringForStyles;
exports.setValueForStyles = setValueForStyles;
exports.validateShorthandPropertyCollisionInDev = validateShorthandPropertyCollisionInDev;

var _CSSShorthandProperty = __webpack_require__(156);

var _dangerousStyleValue = __webpack_require__(157);

var _dangerousStyleValue2 = _interopRequireDefault(_dangerousStyleValue);

var _hyphenateStyleName = __webpack_require__(159);

var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);

var _warnValidStyle = __webpack_require__(160);

var _warnValidStyle2 = _interopRequireDefault(_warnValidStyle);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function createDangerousStringForStyles(styles) {
  if (true) {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + (0, _hyphenateStyleName2.default)(styleName) + ':';
        serialized += (0, _dangerousStyleValue2.default)(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    if (true) {
      if (!isCustomProperty) {
        (0, _warnValidStyle2.default)(styleName, styles[styleName]);
      }
    }
    var styleValue = (0, _dangerousStyleValue2.default)(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

function isValueEmpty(value) {
  return value == null || typeof value === 'boolean' || value === '';
}

/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */
function expandShorthandMap(styles) {
  var expanded = {};
  for (var key in styles) {
    var longhands = _CSSShorthandProperty.shorthandToLonghand[key] || [key];
    for (var i = 0; i < longhands.length; i++) {
      expanded[longhands[i]] = key;
    }
  }
  return expanded;
}

/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */
function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
  if (!_ReactFeatureFlags.warnAboutShorthandPropertyCollision) {
    return;
  }

  if (!nextStyles) {
    return;
  }

  var expandedUpdates = expandShorthandMap(styleUpdates);
  var expandedStyles = expandShorthandMap(nextStyles);
  var warnedAbout = {};
  for (var key in expandedUpdates) {
    var originalKey = expandedUpdates[key];
    var correctOriginalKey = expandedStyles[key];
    if (correctOriginalKey && originalKey !== correctOriginalKey) {
      var warningKey = originalKey + ',' + correctOriginalKey;
      if (warnedAbout[warningKey]) {
        continue;
      }
      warnedAbout[warningKey] = true;
      (0, _warning2.default)(false, '%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
    }
  }
}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand = exports.shorthandToLonghand = {
  animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],
  background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],
  backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
  border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
  borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
  borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
  borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
  borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],
  borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
  borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
  borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
  borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],
  borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
  borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
  borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
  columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
  columns: ['columnCount', 'columnWidth'],
  flex: ['flexBasis', 'flexGrow', 'flexShrink'],
  flexFlow: ['flexDirection', 'flexWrap'],
  font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],
  fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],
  gap: ['columnGap', 'rowGap'],
  grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
  gridColumn: ['gridColumnEnd', 'gridColumnStart'],
  gridColumnGap: ['columnGap'],
  gridGap: ['columnGap', 'rowGap'],
  gridRow: ['gridRowEnd', 'gridRowStart'],
  gridRowGap: ['rowGap'],
  gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
  margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
  marker: ['markerEnd', 'markerMid', 'markerStart'],
  mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],
  maskPosition: ['maskPositionX', 'maskPositionY'],
  outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
  overflow: ['overflowX', 'overflowY'],
  padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
  placeContent: ['alignContent', 'justifyContent'],
  placeItems: ['alignItems', 'justifyItems'],
  placeSelf: ['alignSelf', 'justifySelf'],
  textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
  textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
  transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
  wordWrap: ['overflowWrap']
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CSSProperty = __webpack_require__(158);

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(_CSSProperty.isUnitlessNumber.hasOwnProperty(name) && _CSSProperty.isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
} /**
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

exports.default = dangerousStyleValue;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = exports.isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hyphenateStyleName;
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */
function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warnValidStyle = function warnValidStyle() {}; /**
                                                    * Copyright (c) Facebook, Inc. and its affiliates.
                                                    *
                                                    * This source code is licensed under the MIT license found in the
                                                    * LICENSE file in the root directory of this source tree.
                                                    */

if (true) {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function camelize(string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    (0, _warning2.default)(false, 'Unsupported style property %s. Did you mean %s?', name,
    // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern, 'ms-')));
  };

  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    (0, _warning2.default)(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    (0, _warning2.default)(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    (0, _warning2.default)(false, '`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function warnStyleValueIsInfinity(name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    (0, _warning2.default)(false, '`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function warnValidStyle(name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

exports.default = warnValidStyle;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

// TODO: We can remove this if we add invariantWithStack()
// or add stack by default to invariants where possible.


var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _ReactSharedInternals = __webpack_require__(10);

var _ReactSharedInternals2 = _interopRequireDefault(_ReactSharedInternals);

var _voidElementTags = __webpack_require__(162);

var _voidElementTags2 = _interopRequireDefault(_voidElementTags);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HTML = '__html';

var ReactDebugCurrentFrame = null;
if (true) {
  ReactDebugCurrentFrame = _ReactSharedInternals2.default.ReactDebugCurrentFrame;
}

function assertValidProps(tag, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (_voidElementTags2.default[tag]) {
    (0, _invariant2.default)(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must neither have `children` nor ' + 'use `dangerouslySetInnerHTML`.%s', tag,  true ? ReactDebugCurrentFrame.getStackAddendum() : '');
  }
  if (props.dangerouslySetInnerHTML != null) {
    (0, _invariant2.default)(props.children == null, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
    (0, _invariant2.default)(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.');
  }
  if (true) {
    (0, _warning2.default)(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
  }
  (0, _invariant2.default)(props.style == null || _typeof(props.style) === 'object', 'The `style` prop expects a mapping from style properties to values, ' + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + 'using JSX.%s',  true ? ReactDebugCurrentFrame.getStackAddendum() : '');
}

exports.default = assertValidProps;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                   */

var _omittedCloseTags = __webpack_require__(163);

var _omittedCloseTags2 = _interopRequireDefault(_omittedCloseTags);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _extends({
  menuitem: true
}, _omittedCloseTags2.default);

exports.default = voidElementTags;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

exports.default = omittedCloseTags;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateProperties = validateProperties;

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _DOMProperty = __webpack_require__(26);

var _isCustomComponent = __webpack_require__(59);

var _isCustomComponent2 = _interopRequireDefault(_isCustomComponent);

var _validAriaProperties = __webpack_require__(165);

var _validAriaProperties2 = _interopRequireDefault(_validAriaProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + _DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + _DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = _validAriaProperties2.default.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      (0, _warning2.default)(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      (0, _warning2.default)(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = _validAriaProperties2.default.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      (0, _warning2.default)(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    (0, _warning2.default)(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  } else if (invalidProps.length > 1) {
    (0, _warning2.default)(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  }
}

function validateProperties(type, props) {
  if ((0, _isCustomComponent2.default)(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

exports.default = ariaProperties;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateProperties = validateProperties;

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var didWarnValueNull = false; /**
                               * Copyright (c) Facebook, Inc. and its affiliates.
                               *
                               * This source code is licensed under the MIT license found in the
                               * LICENSE file in the root directory of this source tree.
                               */

function validateProperties(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      (0, _warning2.default)(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
    } else {
      (0, _warning2.default)(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
    }
  }
}

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               */

exports.validateProperties = validateProperties;

var _EventPluginRegistry = __webpack_require__(25);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _DOMProperty = __webpack_require__(26);

var _isCustomComponent = __webpack_require__(59);

var _isCustomComponent2 = _interopRequireDefault(_isCustomComponent);

var _possibleStandardNames = __webpack_require__(88);

var _possibleStandardNames2 = _interopRequireDefault(_possibleStandardNames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validateProperty = function validateProperty() {};

if (true) {
  var warnedProperties = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA = new RegExp('^(aria)-[' + _DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel = new RegExp('^(aria)[A-Z][' + _DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty = function validateProperty(tagName, name, value, canUseEventSystem) {
    if (_hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      (0, _warning2.default)(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (_EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = _EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? _EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        (0, _warning2.default)(false, 'Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
        warnedProperties[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        (0, _warning2.default)(false, 'Unknown event handler property `%s`. It will be ignored.', name);
        warnedProperties[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        (0, _warning2.default)(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }
      warnedProperties[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA.test(name) || rARIACamel.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      (0, _warning2.default)(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      (0, _warning2.default)(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      (0, _warning2.default)(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value === 'undefined' ? 'undefined' : _typeof(value));
      warnedProperties[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      (0, _warning2.default)(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
      warnedProperties[name] = true;
      return true;
    }

    var propertyInfo = (0, _DOMProperty.getPropertyInfo)(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === _DOMProperty.RESERVED;

    // Known attributes should match the casing specified in the property config.
    if (_possibleStandardNames2.default.hasOwnProperty(lowerCasedName)) {
      var standardName = _possibleStandardNames2.default[lowerCasedName];
      if (standardName !== name) {
        (0, _warning2.default)(false, 'Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
        warnedProperties[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      (0, _warning2.default)(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
      warnedProperties[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && (0, _DOMProperty.shouldRemoveAttributeWithWarning)(name, value, propertyInfo, false)) {
      if (value) {
        (0, _warning2.default)(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        (0, _warning2.default)(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }
      warnedProperties[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if ((0, _DOMProperty.shouldRemoveAttributeWithWarning)(name, value, propertyInfo, false)) {
      warnedProperties[name] = true;
      return false;
    }

    // Warn when passing the strings 'false' or 'true' into a boolean prop
    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === _DOMProperty.BOOLEAN) {
      (0, _warning2.default)(false, 'Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
      warnedProperties[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function warnUnknownProperties(type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    (0, _warning2.default)(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  } else if (unknownProps.length > 1) {
    (0, _warning2.default)(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  }
};

function validateProperties(type, props, canUseEventSystem) {
  if ((0, _isCustomComponent2.default)(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ReactDOMHostConfig = __webpack_require__(169);

Object.keys(_ReactDOMHostConfig).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _ReactDOMHostConfig[key];
    }
  });
});

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supportsHydration = exports.supportsMutation = exports.cancelPassiveEffects = exports.schedulePassiveEffects = exports.noTimeout = exports.cancelTimeout = exports.scheduleTimeout = exports.isPrimaryRenderer = exports.cancelDeferredCallback = exports.shouldYield = exports.scheduleDeferredCallback = exports.now = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                               * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * 
                                                                                                                                                                                                                                                                               */

// Unused


var _scheduler = __webpack_require__(62);

Object.defineProperty(exports, 'now', {
  enumerable: true,
  get: function get() {
    return _scheduler.unstable_now;
  }
});
Object.defineProperty(exports, 'scheduleDeferredCallback', {
  enumerable: true,
  get: function get() {
    return _scheduler.unstable_scheduleCallback;
  }
});
Object.defineProperty(exports, 'shouldYield', {
  enumerable: true,
  get: function get() {
    return _scheduler.unstable_shouldYield;
  }
});
Object.defineProperty(exports, 'cancelDeferredCallback', {
  enumerable: true,
  get: function get() {
    return _scheduler.unstable_cancelCallback;
  }
});

var _HostConfigWithNoPersistence = __webpack_require__(170);

Object.keys(_HostConfigWithNoPersistence).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _HostConfigWithNoPersistence[key];
    }
  });
});
exports.getRootHostContext = getRootHostContext;
exports.getChildHostContext = getChildHostContext;
exports.getPublicInstance = getPublicInstance;
exports.prepareForCommit = prepareForCommit;
exports.resetAfterCommit = resetAfterCommit;
exports.createInstance = createInstance;
exports.appendInitialChild = appendInitialChild;
exports.finalizeInitialChildren = finalizeInitialChildren;
exports.prepareUpdate = prepareUpdate;
exports.shouldSetTextContent = shouldSetTextContent;
exports.shouldDeprioritizeSubtree = shouldDeprioritizeSubtree;
exports.createTextInstance = createTextInstance;
exports.commitMount = commitMount;
exports.commitUpdate = commitUpdate;
exports.resetTextContent = resetTextContent;
exports.commitTextUpdate = commitTextUpdate;
exports.appendChild = appendChild;
exports.appendChildToContainer = appendChildToContainer;
exports.insertBefore = insertBefore;
exports.insertInContainerBefore = insertInContainerBefore;
exports.removeChild = removeChild;
exports.removeChildFromContainer = removeChildFromContainer;
exports.clearSuspenseBoundary = clearSuspenseBoundary;
exports.clearSuspenseBoundaryFromContainer = clearSuspenseBoundaryFromContainer;
exports.hideInstance = hideInstance;
exports.hideTextInstance = hideTextInstance;
exports.unhideInstance = unhideInstance;
exports.unhideTextInstance = unhideTextInstance;
exports.canHydrateInstance = canHydrateInstance;
exports.canHydrateTextInstance = canHydrateTextInstance;
exports.canHydrateSuspenseInstance = canHydrateSuspenseInstance;
exports.getNextHydratableSibling = getNextHydratableSibling;
exports.getFirstHydratableChild = getFirstHydratableChild;
exports.hydrateInstance = hydrateInstance;
exports.hydrateTextInstance = hydrateTextInstance;
exports.getNextHydratableInstanceAfterSuspenseInstance = getNextHydratableInstanceAfterSuspenseInstance;
exports.didNotMatchHydratedContainerTextInstance = didNotMatchHydratedContainerTextInstance;
exports.didNotMatchHydratedTextInstance = didNotMatchHydratedTextInstance;
exports.didNotHydrateContainerInstance = didNotHydrateContainerInstance;
exports.didNotHydrateInstance = didNotHydrateInstance;
exports.didNotFindHydratableContainerInstance = didNotFindHydratableContainerInstance;
exports.didNotFindHydratableContainerTextInstance = didNotFindHydratableContainerTextInstance;
exports.didNotFindHydratableContainerSuspenseInstance = didNotFindHydratableContainerSuspenseInstance;
exports.didNotFindHydratableInstance = didNotFindHydratableInstance;
exports.didNotFindHydratableTextInstance = didNotFindHydratableTextInstance;
exports.didNotFindHydratableSuspenseInstance = didNotFindHydratableSuspenseInstance;

var _ReactDOMComponentTree = __webpack_require__(16);

var _ReactDOMComponent = __webpack_require__(148);

var _ReactInputSelection = __webpack_require__(135);

var _setTextContent = __webpack_require__(154);

var _setTextContent2 = _interopRequireDefault(_setTextContent);

var _validateDOMNesting = __webpack_require__(171);

var _ReactBrowserEventEmitter = __webpack_require__(75);

var _DOMNamespaces = __webpack_require__(87);

var _HTMLNodeType = __webpack_require__(15);

var _dangerousStyleValue = __webpack_require__(157);

var _dangerousStyleValue2 = _interopRequireDefault(_dangerousStyleValue);

var _ReactFeatureFlags = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SUPPRESS_HYDRATION_WARNING = void 0;
if (true) {
  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
}

var SUSPENSE_START_DATA = '$';
var SUSPENSE_END_DATA = '/$';

var STYLE = 'style';

var eventsEnabled = null;
var selectionInformation = null;

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

function getRootHostContext(rootContainerInstance) {
  var type = void 0;
  var namespace = void 0;
  var nodeType = rootContainerInstance.nodeType;
  switch (nodeType) {
    case _HTMLNodeType.DOCUMENT_NODE:
    case _HTMLNodeType.DOCUMENT_FRAGMENT_NODE:
      {
        type = nodeType === _HTMLNodeType.DOCUMENT_NODE ? '#document' : '#fragment';
        var root = rootContainerInstance.documentElement;
        namespace = root ? root.namespaceURI : (0, _DOMNamespaces.getChildNamespace)(null, '');
        break;
      }
    default:
      {
        var container = nodeType === _HTMLNodeType.COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
        var ownNamespace = container.namespaceURI || null;
        type = container.tagName;
        namespace = (0, _DOMNamespaces.getChildNamespace)(ownNamespace, type);
        break;
      }
  }
  if (true) {
    var validatedTag = type.toLowerCase();
    var _ancestorInfo = (0, _validateDOMNesting.updatedAncestorInfo)(null, validatedTag);
    return { namespace: namespace, ancestorInfo: _ancestorInfo };
  }
  return namespace;
}

function getChildHostContext(parentHostContext, type, rootContainerInstance) {
  if (true) {
    var parentHostContextDev = parentHostContext;
    var _namespace = (0, _DOMNamespaces.getChildNamespace)(parentHostContextDev.namespace, type);
    var _ancestorInfo2 = (0, _validateDOMNesting.updatedAncestorInfo)(parentHostContextDev.ancestorInfo, type);
    return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
  }
  var parentNamespace = parentHostContext;
  return (0, _DOMNamespaces.getChildNamespace)(parentNamespace, type);
}

function getPublicInstance(instance) {
  return instance;
}

function prepareForCommit(containerInfo) {
  eventsEnabled = (0, _ReactBrowserEventEmitter.isEnabled)();
  selectionInformation = (0, _ReactInputSelection.getSelectionInformation)();
  (0, _ReactBrowserEventEmitter.setEnabled)(false);
}

function resetAfterCommit(containerInfo) {
  (0, _ReactInputSelection.restoreSelection)(selectionInformation);
  selectionInformation = null;
  (0, _ReactBrowserEventEmitter.setEnabled)(eventsEnabled);
  eventsEnabled = null;
}

function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  var parentNamespace = void 0;
  if (true) {
    // TODO: take namespace into account when validating.
    var hostContextDev = hostContext;
    (0, _validateDOMNesting.validateDOMNesting)(type, null, hostContextDev.ancestorInfo);
    if (typeof props.children === 'string' || typeof props.children === 'number') {
      var string = '' + props.children;
      var ownAncestorInfo = (0, _validateDOMNesting.updatedAncestorInfo)(hostContextDev.ancestorInfo, type);
      (0, _validateDOMNesting.validateDOMNesting)(null, string, ownAncestorInfo);
    }
    parentNamespace = hostContextDev.namespace;
  } else {
    parentNamespace = hostContext;
  }
  var domElement = (0, _ReactDOMComponent.createElement)(type, props, rootContainerInstance, parentNamespace);
  (0, _ReactDOMComponentTree.precacheFiberNode)(internalInstanceHandle, domElement);
  (0, _ReactDOMComponentTree.updateFiberProps)(domElement, props);
  return domElement;
}

function appendInitialChild(parentInstance, child) {
  parentInstance.appendChild(child);
}

function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
  (0, _ReactDOMComponent.setInitialProperties)(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}

function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
  if (true) {
    var hostContextDev = hostContext;
    if (_typeof(newProps.children) !== _typeof(oldProps.children) && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
      var string = '' + newProps.children;
      var ownAncestorInfo = (0, _validateDOMNesting.updatedAncestorInfo)(hostContextDev.ancestorInfo, type);
      (0, _validateDOMNesting.validateDOMNesting)(null, string, ownAncestorInfo);
    }
  }
  return (0, _ReactDOMComponent.diffProperties)(domElement, type, oldProps, newProps, rootContainerInstance);
}

function shouldSetTextContent(type, props) {
  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || _typeof(props.dangerouslySetInnerHTML) === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
}

function shouldDeprioritizeSubtree(type, props) {
  return !!props.hidden;
}

function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
  if (true) {
    var hostContextDev = hostContext;
    (0, _validateDOMNesting.validateDOMNesting)(null, text, hostContextDev.ancestorInfo);
  }
  var textNode = (0, _ReactDOMComponent.createTextNode)(text, rootContainerInstance);
  (0, _ReactDOMComponentTree.precacheFiberNode)(internalInstanceHandle, textNode);
  return textNode;
}

var isPrimaryRenderer = exports.isPrimaryRenderer = true;
// This initialization code may run even on server environments
// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.
var scheduleTimeout = exports.scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
var cancelTimeout = exports.cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
var noTimeout = exports.noTimeout = -1;
var schedulePassiveEffects = exports.schedulePassiveEffects = _scheduler.unstable_scheduleCallback;
var cancelPassiveEffects = exports.cancelPassiveEffects = _scheduler.unstable_cancelCallback;

// -------------------
//     Mutation
// -------------------

var supportsMutation = exports.supportsMutation = true;

function commitMount(domElement, type, newProps, internalInstanceHandle) {
  // Despite the naming that might imply otherwise, this method only
  // fires if there is an `Update` effect scheduled during mounting.
  // This happens if `finalizeInitialChildren` returns `true` (which it
  // does to implement the `autoFocus` attribute on the client). But
  // there are also other cases when this might happen (such as patching
  // up text content during hydration mismatch). So we'll check this again.
  if (shouldAutoFocusHostComponent(type, newProps)) {
    domElement.focus();
  }
}

function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  (0, _ReactDOMComponentTree.updateFiberProps)(domElement, newProps);
  // Apply the diff to the DOM node.
  (0, _ReactDOMComponent.updateProperties)(domElement, updatePayload, type, oldProps, newProps);
}

function resetTextContent(domElement) {
  (0, _setTextContent2.default)(domElement, '');
}

function commitTextUpdate(textInstance, oldText, newText) {
  textInstance.nodeValue = newText;
}

function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}

function appendChildToContainer(container, child) {
  var parentNode = void 0;
  if (container.nodeType === _HTMLNodeType.COMMENT_NODE) {
    parentNode = container.parentNode;
    parentNode.insertBefore(child, container);
  } else {
    parentNode = container;
    parentNode.appendChild(child);
  }
  // This container might be used for a portal.
  // If something inside a portal is clicked, that click should bubble
  // through the React tree. However, on Mobile Safari the click would
  // never bubble through the *DOM* tree unless an ancestor with onclick
  // event exists. So we wouldn't see it and dispatch it.
  // This is why we ensure that non React root containers have inline onclick
  // defined.
  // https://github.com/facebook/react/issues/11918
  var reactRootContainer = container._reactRootContainer;
  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
    // TODO: This cast may not be sound for SVG, MathML or custom elements.
    (0, _ReactDOMComponent.trapClickOnNonInteractiveElement)(parentNode);
  }
}

function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

function insertInContainerBefore(container, child, beforeChild) {
  if (container.nodeType === _HTMLNodeType.COMMENT_NODE) {
    container.parentNode.insertBefore(child, beforeChild);
  } else {
    container.insertBefore(child, beforeChild);
  }
}

function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}

function removeChildFromContainer(container, child) {
  if (container.nodeType === _HTMLNodeType.COMMENT_NODE) {
    container.parentNode.removeChild(child);
  } else {
    container.removeChild(child);
  }
}

function clearSuspenseBoundary(parentInstance, suspenseInstance) {
  var node = suspenseInstance;
  // Delete all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.
  var depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && nextNode.nodeType === _HTMLNodeType.COMMENT_NODE) {
      var data = nextNode.data;
      if (data === SUSPENSE_END_DATA) {
        if (depth === 0) {
          parentInstance.removeChild(nextNode);
          return;
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_START_DATA) {
        depth++;
      }
    }
    node = nextNode;
  } while (node);
  // TODO: Warn, we didn't find the end comment boundary.
}

function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
  if (container.nodeType === _HTMLNodeType.COMMENT_NODE) {
    clearSuspenseBoundary(container.parentNode, suspenseInstance);
  } else if (container.nodeType === _HTMLNodeType.ELEMENT_NODE) {
    clearSuspenseBoundary(container, suspenseInstance);
  } else {
    // Document nodes should never contain suspense boundaries.
  }
}

function hideInstance(instance) {
  // TODO: Does this work for all element types? What about MathML? Should we
  // pass host context to this method?
  instance = instance;
  instance.style.display = 'none';
}

function hideTextInstance(textInstance) {
  textInstance.nodeValue = '';
}

function unhideInstance(instance, props) {
  instance = instance;
  var styleProp = props[STYLE];
  var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
  instance.style.display = (0, _dangerousStyleValue2.default)('display', display);
}

function unhideTextInstance(textInstance, text) {
  textInstance.nodeValue = text;
}

// -------------------
//     Hydration
// -------------------

var supportsHydration = exports.supportsHydration = true;

function canHydrateInstance(instance, type, props) {
  if (instance.nodeType !== _HTMLNodeType.ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
    return null;
  }
  // This has now been refined to an element node.
  return instance;
}

function canHydrateTextInstance(instance, text) {
  if (text === '' || instance.nodeType !== _HTMLNodeType.TEXT_NODE) {
    // Empty strings are not parsed by HTML so there won't be a correct match here.
    return null;
  }
  // This has now been refined to a text node.
  return instance;
}

function canHydrateSuspenseInstance(instance) {
  if (instance.nodeType !== _HTMLNodeType.COMMENT_NODE) {
    // Empty strings are not parsed by HTML so there won't be a correct match here.
    return null;
  }
  // This has now been refined to a suspense node.
  return instance;
}

function getNextHydratableSibling(instance) {
  var node = instance.nextSibling;
  // Skip non-hydratable nodes.
  while (node && node.nodeType !== _HTMLNodeType.ELEMENT_NODE && node.nodeType !== _HTMLNodeType.TEXT_NODE && (!_ReactFeatureFlags.enableSuspenseServerRenderer || node.nodeType !== _HTMLNodeType.COMMENT_NODE || node.data !== SUSPENSE_START_DATA)) {
    node = node.nextSibling;
  }
  return node;
}

function getFirstHydratableChild(parentInstance) {
  var next = parentInstance.firstChild;
  // Skip non-hydratable nodes.
  while (next && next.nodeType !== _HTMLNodeType.ELEMENT_NODE && next.nodeType !== _HTMLNodeType.TEXT_NODE && (!_ReactFeatureFlags.enableSuspenseServerRenderer || next.nodeType !== _HTMLNodeType.COMMENT_NODE || next.data !== SUSPENSE_START_DATA)) {
    next = next.nextSibling;
  }
  return next;
}

function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  (0, _ReactDOMComponentTree.precacheFiberNode)(internalInstanceHandle, instance);
  // TODO: Possibly defer this until the commit phase where all the events
  // get attached.
  (0, _ReactDOMComponentTree.updateFiberProps)(instance, props);
  var parentNamespace = void 0;
  if (true) {
    var hostContextDev = hostContext;
    parentNamespace = hostContextDev.namespace;
  } else {
    parentNamespace = hostContext;
  }
  return (0, _ReactDOMComponent.diffHydratedProperties)(instance, type, props, parentNamespace, rootContainerInstance);
}

function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
  (0, _ReactDOMComponentTree.precacheFiberNode)(internalInstanceHandle, textInstance);
  return (0, _ReactDOMComponent.diffHydratedText)(textInstance, text);
}

function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
  var node = suspenseInstance.nextSibling;
  // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.
  var depth = 0;
  while (node) {
    if (node.nodeType === _HTMLNodeType.COMMENT_NODE) {
      var data = node.data;
      if (data === SUSPENSE_END_DATA) {
        if (depth === 0) {
          return getNextHydratableSibling(node);
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_START_DATA) {
        depth++;
      }
    }
    node = node.nextSibling;
  }
  // TODO: Warn, we didn't find the end comment boundary.
  return null;
}

function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
  if (true) {
    (0, _ReactDOMComponent.warnForUnmatchedText)(textInstance, text);
  }
}

function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    (0, _ReactDOMComponent.warnForUnmatchedText)(textInstance, text);
  }
}

function didNotHydrateContainerInstance(parentContainer, instance) {
  if (true) {
    if (instance.nodeType === _HTMLNodeType.ELEMENT_NODE) {
      (0, _ReactDOMComponent.warnForDeletedHydratableElement)(parentContainer, instance);
    } else if (instance.nodeType === _HTMLNodeType.COMMENT_NODE) {
      // TODO: warnForDeletedHydratableSuspenseBoundary
    } else {
      (0, _ReactDOMComponent.warnForDeletedHydratableText)(parentContainer, instance);
    }
  }
}

function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    if (instance.nodeType === _HTMLNodeType.ELEMENT_NODE) {
      (0, _ReactDOMComponent.warnForDeletedHydratableElement)(parentInstance, instance);
    } else if (instance.nodeType === _HTMLNodeType.COMMENT_NODE) {
      // TODO: warnForDeletedHydratableSuspenseBoundary
    } else {
      (0, _ReactDOMComponent.warnForDeletedHydratableText)(parentInstance, instance);
    }
  }
}

function didNotFindHydratableContainerInstance(parentContainer, type, props) {
  if (true) {
    (0, _ReactDOMComponent.warnForInsertedHydratedElement)(parentContainer, type, props);
  }
}

function didNotFindHydratableContainerTextInstance(parentContainer, text) {
  if (true) {
    (0, _ReactDOMComponent.warnForInsertedHydratedText)(parentContainer, text);
  }
}

function didNotFindHydratableContainerSuspenseInstance(parentContainer) {
  if (true) {
    // TODO: warnForInsertedHydratedSupsense(parentContainer);
  }
}

function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    (0, _ReactDOMComponent.warnForInsertedHydratedElement)(parentInstance, type, props);
  }
}

function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    (0, _ReactDOMComponent.warnForInsertedHydratedText)(parentInstance, text);
  }
}

function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    // TODO: warnForInsertedHydratedSuspense(parentInstance);
  }
}

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHiddenTextInstance = exports.cloneUnhiddenInstance = exports.cloneHiddenInstance = exports.replaceContainerChildren = exports.finalizeContainerChildren = exports.appendChildToContainerChildSet = exports.createContainerChildSet = exports.cloneInstance = exports.supportsPersistence = undefined;

var _invariant = __webpack_require__(0);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Renderers that don't support persistence
// can re-export everything from this module.

function shim() {
  (0, _invariant2.default)(false, 'The current renderer does not support persistence. ' + 'This error is likely caused by a bug in React. ' + 'Please file an issue.');
}

// Persistence (when unsupported)
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var supportsPersistence = exports.supportsPersistence = false;
var cloneInstance = exports.cloneInstance = shim;
var createContainerChildSet = exports.createContainerChildSet = shim;
var appendChildToContainerChildSet = exports.appendChildToContainerChildSet = shim;
var finalizeContainerChildren = exports.finalizeContainerChildren = shim;
var replaceContainerChildren = exports.replaceContainerChildren = shim;
var cloneHiddenInstance = exports.cloneHiddenInstance = shim;
var cloneUnhiddenInstance = exports.cloneUnhiddenInstance = shim;
var createHiddenTextInstance = exports.createHiddenTextInstance = shim;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateDOMNesting = exports.updatedAncestorInfo = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Copyright (c) Facebook, Inc. and its affiliates.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                                                                                   */

// TODO: direct imports like some-package/src/* are bad. Fix me.


var _warningWithoutStack = __webpack_require__(1);

var _warningWithoutStack2 = _interopRequireDefault(_warningWithoutStack);

var _ReactCurrentFiber = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validateDOMNesting = function validateDOMNesting() {};
var updatedAncestorInfo = function updatedAncestorInfo() {};

if (true) {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  exports.updatedAncestorInfo = updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag) {
    var ancestorInfo = _extends({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  exports.validateDOMNesting = validateDOMNesting = function validateDOMNesting(childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      (0, _warningWithoutStack2.default)(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = (0, _ReactCurrentFiber.getCurrentFiberStackInDev)();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      (0, _warningWithoutStack2.default)(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      (0, _warningWithoutStack2.default)(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };
}

exports.updatedAncestorInfo = updatedAncestorInfo;
exports.validateDOMNesting = validateDOMNesting;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWVkMjBlZThlOGJiY2YwYzMwNGIiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zaGFyZWQvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL1JlYWN0V29ya1RhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL2dldENvbXBvbmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL1JlYWN0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEN1cnJlbnRGaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zaGFyZWQvUmVhY3RTaWRlRWZmZWN0VGFncy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL1JlYWN0U2hhcmVkSW50ZXJuYWxzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJIb3N0Q29uZmlnLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL2V2ZW50cy9TeW50aGV0aWNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdFR5cGVPZk1vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvRE9NVG9wTGV2ZWxFdmVudFR5cGVzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0hUTUxOb2RlVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlck5ld0NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvZXZlbnRzL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2NoZWR1bGVyL3RyYWNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvZXZlbnRzL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL2V2ZW50cy9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0RPTVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljVUlFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdERlYnVnRmliZXJQZXJmLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclNjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zaGFyZWQvbG93UHJpb3JpdHlXYXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3NoYXJlZC9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvVG9TdHJpbmdWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3JlZmxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclN0YWNrLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJEZXZUb29sc0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckJlZ2luV29yay5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVySG9zdENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdERlYnVnQ3VycmVudEZyYW1lLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3NoYXJlZC9SZWFjdExhenlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9ldmVudHMvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9ldmVudHMvUmVhY3RDb250cm9sbGVkQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL2V2ZW50cy9SZWFjdEdlbmVyaWNCYXRjaGluZy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9pbnB1dFZhbHVlVHJhY2tpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3NoYXJlZC9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL29iamVjdElzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvbWF4U2lnbmVkMzFCaXRJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckxhenlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RQcm9maWxlclRpbWVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2lzQ3VzdG9tQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3NoYXJlZC9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0U2hhcmVkSW50ZXJuYWxzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3NjaGVkdWxlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zY2hlZHVsZXIvc3JjL1RyYWNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0Q3VycmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL2Rlc2NyaWJlQ29tcG9uZW50RnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL2lzVmFsaWRFbGVtZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9ldmVudHMvYWNjdW11bGF0ZUludG8uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvZXZlbnRzL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zaGFyZWQvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljUG9pbnRlckV2ZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9SZWFjdERPTUV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJQZW5kaW5nUHJpb3JpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJIb29rcy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEhvb2tFZmZlY3RUYWdzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0Q2FwdHVyZWRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyQ29tbWl0V29yay5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9ET01OYW1lc3BhY2VzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL3Bvc3NpYmxlU3RhbmRhcmROYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0LWVudi9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdEJhc2VDbGFzc2VzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RDcmVhdGVSZWYuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2NoZWR1bGVyL3NyYy9TY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zY2hlZHVsZXIvc3JjL1NjaGVkdWxlckZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9zY2hlZHVsZXIvc3JjL1RyYWNpbmdTdWJzY3JpcHRpb25zLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0TGF6eS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC9zcmMvZm9yd2FyZFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC9zcmMvbWVtby5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RIb29rcy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9SZWFjdERPTS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9jaGVja1JlYWN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NQ2xpZW50SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3NoYXJlZC9pbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL1JlYWN0VHJlZVRyYXZlcnNhbC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9ldmVudHMvVG9wTGV2ZWxFdmVudFR5cGVzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvRE9NRXZlbnRQbHVnaW5PcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclRyZWVSZWZsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL2lubGluZS5kb20uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclJvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RDaGlsZEZpYmVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJDb21wbGV0ZVdvcmsuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclVud2luZFdvcmsuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclN1c3BlbnNlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJFcnJvckxvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyRXJyb3JEaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL1JlYWN0UG9ydGFsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NT3B0aW9uLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0NTU1Nob3J0aGFuZFByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvQ1NTUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL3dhcm5WYWxpZFN0eWxlLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2Fzc2VydFZhbGlkUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvdm9pZEVsZW1lbnRUYWdzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL29taXR0ZWRDbG9zZVRhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvUmVhY3RET01JbnZhbGlkQVJJQUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvdmFsaWRBcmlhUHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL2ZvcmtzL1JlYWN0RmliZXJIb3N0Q29uZmlnLmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9SZWFjdERPTUhvc3RDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvc2hhcmVkL0hvc3RDb25maWdXaXRoTm9QZXJzaXN0ZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC92YWxpZGF0ZURPTU5lc3RpbmcuanMiXSwibmFtZXMiOlsiaW52YXJpYW50IiwidmFsaWRhdGVGb3JtYXQiLCJfX0RFVl9fIiwiZm9ybWF0IiwidW5kZWZpbmVkIiwiRXJyb3IiLCJjb25kaXRpb24iLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJlcnJvciIsImFyZ3MiLCJhcmdJbmRleCIsInJlcGxhY2UiLCJuYW1lIiwiZnJhbWVzVG9Qb3AiLCJ3YXJuaW5nV2l0aG91dFN0YWNrIiwibGVuZ3RoIiwiY29uc29sZSIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsInVuc2hpZnQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsIm1lc3NhZ2UiLCJ4Iiwid2FybmluZyIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJSZWFjdFNoYXJlZEludGVybmFscyIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImFkZFVzZXJUaW1pbmdMaXN0ZW5lciIsImVuYWJsZVVzZXJUaW1pbmdBUEkiLCJkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMiLCJkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlIiwicmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJ3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyIsImVuYWJsZVByb2ZpbGVyVGltZXIiLCJfX1BST0ZJTEVfXyIsImVuYWJsZVNjaGVkdWxlclRyYWNpbmciLCJlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyIiwiZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nIiwiZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZyIsImVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcyIsIndhcm5BYm91dFNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uIiwiRnVuY3Rpb25Db21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJIb3N0Um9vdCIsIkhvc3RQb3J0YWwiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJGb3J3YXJkUmVmIiwiUHJvZmlsZXIiLCJTdXNwZW5zZUNvbXBvbmVudCIsIk1lbW9Db21wb25lbnQiLCJTaW1wbGVNZW1vQ29tcG9uZW50IiwiTGF6eUNvbXBvbmVudCIsIkluY29tcGxldGVDbGFzc0NvbXBvbmVudCIsIkRlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJmdW5jdGlvbk5hbWUiLCJkaXNwbGF5TmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJ0eXBlIiwidGFnIiwiUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCIkJHR5cGVvZiIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwicmVuZGVyIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwidGhlbmFibGUiLCJyZXNvbHZlZFRoZW5hYmxlIiwiZ2V0SXRlcmF0b3JGbiIsImhhc1N5bWJvbCIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX0FTWU5DX01PREVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldiIsInJlc2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudFBoYXNlIiwiZGVzY3JpYmVGaWJlciIsImZpYmVyIiwib3duZXIiLCJfZGVidWdPd25lciIsInNvdXJjZSIsIl9kZWJ1Z1NvdXJjZSIsIm93bmVyTmFtZSIsIndvcmtJblByb2dyZXNzIiwiaW5mbyIsIm5vZGUiLCJyZXR1cm4iLCJjdXJyZW50IiwicGhhc2UiLCJnZXRDdXJyZW50U3RhY2siLCJsaWZlQ3ljbGVQaGFzZSIsIk5vRWZmZWN0IiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIlBsYWNlbWVudEFuZFVwZGF0ZSIsIkRlbGV0aW9uIiwiQ29udGVudFJlc2V0IiwiQ2FsbGJhY2siLCJEaWRDYXB0dXJlIiwiUmVmIiwiU25hcHNob3QiLCJQYXNzaXZlIiwiTGlmZWN5Y2xlRWZmZWN0TWFzayIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJleHBpcmF0aW9uVGltZVRvTXMiLCJjb21wdXRlQXN5bmNFeHBpcmF0aW9uIiwiY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbiIsIk5vV29yayIsIk5ldmVyIiwiU3luYyIsIk1BWF9TSUdORURfMzFfQklUX0lOVCIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtcyIsImV4cGlyYXRpb25UaW1lIiwiY2VpbGluZyIsIm51bSIsInByZWNpc2lvbiIsImNvbXB1dGVFeHBpcmF0aW9uQnVja2V0IiwiY3VycmVudFRpbWUiLCJleHBpcmF0aW9uSW5NcyIsImJ1Y2tldFNpemVNcyIsIkxPV19QUklPUklUWV9FWFBJUkFUSU9OIiwiTE9XX1BSSU9SSVRZX0JBVENIX1NJWkUiLCJISUdIX1BSSU9SSVRZX0VYUElSQVRJT04iLCJISUdIX1BSSU9SSVRZX0JBVENIX1NJWkUiLCJSZWFjdCIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwic3NzIiwiRVZFTlRfUE9PTF9TSVpFIiwiRXZlbnRJbnRlcmZhY2UiLCJ0YXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiZXZlbnQiLCJEYXRlIiwibm93IiwiZGVmYXVsdFByZXZlbnRlZCIsImlzVHJ1c3RlZCIsImZ1bmN0aW9uVGhhdFJldHVybnNUcnVlIiwiZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlIiwiU3ludGhldGljRXZlbnQiLCJkaXNwYXRjaENvbmZpZyIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudCIsIm5hdGl2ZUV2ZW50VGFyZ2V0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsIl90YXJnZXRJbnN0IiwiSW50ZXJmYWNlIiwiY29uc3RydWN0b3IiLCJwcm9wTmFtZSIsImhhc093blByb3BlcnR5Iiwibm9ybWFsaXplIiwicmV0dXJuVmFsdWUiLCJPYmplY3QiLCJhc3NpZ24iLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiaXNQZXJzaXN0ZW50IiwiZGVzdHJ1Y3RvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbiIsIl9kaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaEluc3RhbmNlcyIsImV4dGVuZCIsIlN1cGVyIiwiRSIsIkNsYXNzIiwiYXJndW1lbnRzIiwiYWRkRXZlbnRQb29saW5nVG8iLCJnZXRWYWwiLCJpc0Z1bmN0aW9uIiwiY29uZmlndXJhYmxlIiwic2V0IiwiZ2V0IiwidmFsIiwiYWN0aW9uIiwid2FybiIsInJlc3VsdCIsIndhcm5pbmdDb25kaXRpb24iLCJnZXRQb29sZWRFdmVudCIsIm5hdGl2ZUluc3QiLCJFdmVudENvbnN0cnVjdG9yIiwiZXZlbnRQb29sIiwiaW5zdGFuY2UiLCJwb3AiLCJyZWxlYXNlUG9vbGVkRXZlbnQiLCJwdXNoIiwiZ2V0UG9vbGVkIiwicmVsZWFzZSIsIk5vQ29udGV4dCIsIkNvbmN1cnJlbnRNb2RlIiwiU3RyaWN0TW9kZSIsIlByb2ZpbGVNb2RlIiwiZ2V0UmF3RXZlbnROYW1lIiwiVE9QX0FCT1JUIiwiVE9QX0FOSU1BVElPTl9FTkQiLCJUT1BfQU5JTUFUSU9OX0lURVJBVElPTiIsIlRPUF9BTklNQVRJT05fU1RBUlQiLCJUT1BfQkxVUiIsIlRPUF9DQU5fUExBWSIsIlRPUF9DQU5fUExBWV9USFJPVUdIIiwiVE9QX0NBTkNFTCIsIlRPUF9DSEFOR0UiLCJUT1BfQ0xJQ0siLCJUT1BfQ0xPU0UiLCJUT1BfQ09NUE9TSVRJT05fRU5EIiwiVE9QX0NPTVBPU0lUSU9OX1NUQVJUIiwiVE9QX0NPTVBPU0lUSU9OX1VQREFURSIsIlRPUF9DT05URVhUX01FTlUiLCJUT1BfQ09QWSIsIlRPUF9DVVQiLCJUT1BfRE9VQkxFX0NMSUNLIiwiVE9QX0FVWF9DTElDSyIsIlRPUF9EUkFHIiwiVE9QX0RSQUdfRU5EIiwiVE9QX0RSQUdfRU5URVIiLCJUT1BfRFJBR19FWElUIiwiVE9QX0RSQUdfTEVBVkUiLCJUT1BfRFJBR19PVkVSIiwiVE9QX0RSQUdfU1RBUlQiLCJUT1BfRFJPUCIsIlRPUF9EVVJBVElPTl9DSEFOR0UiLCJUT1BfRU1QVElFRCIsIlRPUF9FTkNSWVBURUQiLCJUT1BfRU5ERUQiLCJUT1BfRVJST1IiLCJUT1BfRk9DVVMiLCJUT1BfR09UX1BPSU5URVJfQ0FQVFVSRSIsIlRPUF9JTlBVVCIsIlRPUF9JTlZBTElEIiwiVE9QX0tFWV9ET1dOIiwiVE9QX0tFWV9QUkVTUyIsIlRPUF9LRVlfVVAiLCJUT1BfTE9BRCIsIlRPUF9MT0FEX1NUQVJUIiwiVE9QX0xPQURFRF9EQVRBIiwiVE9QX0xPQURFRF9NRVRBREFUQSIsIlRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRSIsIlRPUF9NT1VTRV9ET1dOIiwiVE9QX01PVVNFX01PVkUiLCJUT1BfTU9VU0VfT1VUIiwiVE9QX01PVVNFX09WRVIiLCJUT1BfTU9VU0VfVVAiLCJUT1BfUEFTVEUiLCJUT1BfUEFVU0UiLCJUT1BfUExBWSIsIlRPUF9QTEFZSU5HIiwiVE9QX1BPSU5URVJfQ0FOQ0VMIiwiVE9QX1BPSU5URVJfRE9XTiIsIlRPUF9QT0lOVEVSX0VOVEVSIiwiVE9QX1BPSU5URVJfTEVBVkUiLCJUT1BfUE9JTlRFUl9NT1ZFIiwiVE9QX1BPSU5URVJfT1VUIiwiVE9QX1BPSU5URVJfT1ZFUiIsIlRPUF9QT0lOVEVSX1VQIiwiVE9QX1BST0dSRVNTIiwiVE9QX1JBVEVfQ0hBTkdFIiwiVE9QX1JFU0VUIiwiVE9QX1NDUk9MTCIsIlRPUF9TRUVLRUQiLCJUT1BfU0VFS0lORyIsIlRPUF9TRUxFQ1RJT05fQ0hBTkdFIiwiVE9QX1NUQUxMRUQiLCJUT1BfU1VCTUlUIiwiVE9QX1NVU1BFTkQiLCJUT1BfVEVYVF9JTlBVVCIsIlRPUF9USU1FX1VQREFURSIsIlRPUF9UT0dHTEUiLCJUT1BfVE9VQ0hfQ0FOQ0VMIiwiVE9QX1RPVUNIX0VORCIsIlRPUF9UT1VDSF9NT1ZFIiwiVE9QX1RPVUNIX1NUQVJUIiwiVE9QX1RSQU5TSVRJT05fRU5EIiwiVE9QX1ZPTFVNRV9DSEFOR0UiLCJUT1BfV0FJVElORyIsIlRPUF9XSEVFTCIsIm1lZGlhRXZlbnRUeXBlcyIsInRvcExldmVsVHlwZSIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwicHJlY2FjaGVGaWJlck5vZGUiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSIsInVwZGF0ZUZpYmVyUHJvcHMiLCJyYW5kb21LZXkiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkiLCJob3N0SW5zdCIsInBhcmVudE5vZGUiLCJpbnN0Iiwic3RhdGVOb2RlIiwicHJvcHMiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVVcGRhdGVRdWV1ZSIsImNyZWF0ZVVwZGF0ZSIsImVucXVldWVVcGRhdGUiLCJlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJyZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZyIsImNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmciLCJjb21taXRVcGRhdGVRdWV1ZSIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiRm9yY2VVcGRhdGUiLCJDYXB0dXJlVXBkYXRlIiwiaGFzRm9yY2VVcGRhdGUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlIiwicmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJiYXNlU3RhdGUiLCJxdWV1ZSIsImZpcnN0VXBkYXRlIiwibGFzdFVwZGF0ZSIsImZpcnN0Q2FwdHVyZWRVcGRhdGUiLCJsYXN0Q2FwdHVyZWRVcGRhdGUiLCJmaXJzdEVmZmVjdCIsImxhc3RFZmZlY3QiLCJmaXJzdENhcHR1cmVkRWZmZWN0IiwibGFzdENhcHR1cmVkRWZmZWN0IiwiY2xvbmVVcGRhdGVRdWV1ZSIsImN1cnJlbnRRdWV1ZSIsInBheWxvYWQiLCJjYWxsYmFjayIsIm5leHQiLCJuZXh0RWZmZWN0IiwiYXBwZW5kVXBkYXRlVG9RdWV1ZSIsInVwZGF0ZSIsImFsdGVybmF0ZSIsInF1ZXVlMSIsInF1ZXVlMiIsInVwZGF0ZVF1ZXVlIiwibWVtb2l6ZWRTdGF0ZSIsIndvcmtJblByb2dyZXNzUXVldWUiLCJlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmUiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJtb2RlIiwibmV4dFN0YXRlIiwiZWZmZWN0VGFnIiwicGFydGlhbFN0YXRlIiwicmVuZGVyRXhwaXJhdGlvblRpbWUiLCJuZXdCYXNlU3RhdGUiLCJuZXdGaXJzdFVwZGF0ZSIsIm5ld0V4cGlyYXRpb25UaW1lIiwicmVzdWx0U3RhdGUiLCJ1cGRhdGVFeHBpcmF0aW9uVGltZSIsIm5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUiLCJjYWxsQ2FsbGJhY2siLCJjb250ZXh0IiwiZmluaXNoZWRXb3JrIiwiZmluaXNoZWRRdWV1ZSIsImNvbW1pdFVwZGF0ZUVmZmVjdHMiLCJlZmZlY3QiLCJyZXNldENvbnRleHREZXBlbmRlbmNlcyIsImVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJwdXNoUHJvdmlkZXIiLCJwb3BQcm92aWRlciIsImNhbGN1bGF0ZUNoYW5nZWRCaXRzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInByZXBhcmVUb1JlYWRDb250ZXh0IiwicmVhZENvbnRleHQiLCJ2YWx1ZUN1cnNvciIsInJlbmRlcmVyU2lnaWwiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciIsImxhc3RDb250ZXh0RGVwZW5kZW5jeSIsImxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCIsImlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJwcm92aWRlckZpYmVyIiwibmV4dFZhbHVlIiwiX2NvbnRleHQiLCJpc1ByaW1hcnlSZW5kZXJlciIsIl9jdXJyZW50VmFsdWUiLCJfY3VycmVudFJlbmRlcmVyIiwiX2N1cnJlbnRWYWx1ZTIiLCJfY3VycmVudFJlbmRlcmVyMiIsImN1cnJlbnRWYWx1ZSIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJjaGFuZ2VkQml0cyIsIl9jYWxjdWxhdGVDaGFuZ2VkQml0cyIsInNjaGVkdWxlV29ya09uUGFyZW50UGF0aCIsInBhcmVudCIsImNoaWxkRXhwaXJhdGlvblRpbWUiLCJjaGlsZCIsIm5leHRGaWJlciIsImxpc3QiLCJjb250ZXh0RGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeSIsImZpcnN0Iiwib2JzZXJ2ZWRCaXRzIiwic2libGluZyIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJyZXNvbHZlZE9ic2VydmVkQml0cyIsImNvbnRleHRJdGVtIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0IiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwicmVnaXN0cmF0aW9uTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsImxpc3RlbmVyIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImFjY3VtdWxhdGVEaXNwYXRjaGVzIiwiaWdub3JlZERpcmVjdGlvbiIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlIiwiZXZlbnRzIiwibGVhdmUiLCJlbnRlciIsImZyb20iLCJ0byIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsImZyZWV6ZSIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJDb21wb25lbnQiLCJkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIiLCJpc0NvbnRleHRQcm92aWRlciIsImNhY2hlQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQiLCJnZXRNYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwia2V5IiwiaGFzQ29udGV4dENoYW5nZWQiLCJjaGlsZENvbnRleHRUeXBlcyIsInBvcENvbnRleHQiLCJwb3BUb3BMZXZlbENvbnRleHRPYmplY3QiLCJwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwiZGlkQ2hhbmdlIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJnZXRDaGlsZENvbnRleHQiLCJjb21wb25lbnROYW1lIiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInB1c2hDb250ZXh0UHJvdmlkZXIiLCJtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZhdWx0IiwiZ2V0TGlzdGVuZXIiLCJydW5FdmVudHNJbkJhdGNoIiwicnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaCIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImRpc2FibGVkIiwiaW5qZWN0aW9uIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsImV4dHJhY3RFdmVudHMiLCJpIiwicGx1Z2lucyIsInBvc3NpYmxlUGx1Z2luIiwiZXh0cmFjdGVkRXZlbnRzIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJldmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5Nb2R1bGUiLCJwbHVnaW5JbmRleCIsImluZGV4T2YiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudFR5cGVzIiwiZXZlbnROYW1lIiwicHVibGlzaEV2ZW50Rm9yUGx1Z2luIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwibG93ZXJDYXNlZE5hbWUiLCJ0b0xvd2VyQ2FzZSIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJvbmRibGNsaWNrIiwiaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiQXJyYXkiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInNob3VsZElnbm9yZUF0dHJpYnV0ZSIsInNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nIiwic2hvdWxkUmVtb3ZlQXR0cmlidXRlIiwiZ2V0UHJvcGVydHlJbmZvIiwiUkVTRVJWRUQiLCJTVFJJTkciLCJCT09MRUFOSVNIX1NUUklORyIsIkJPT0xFQU4iLCJPVkVSTE9BREVEX0JPT0xFQU4iLCJOVU1FUklDIiwiUE9TSVRJVkVfTlVNRVJJQyIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiSURfQVRUUklCVVRFX05BTUUiLCJST09UX0FUVFJJQlVURV9OQU1FIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiYXR0cmlidXRlTmFtZSIsInRlc3QiLCJwcm9wZXJ0eUluZm8iLCJpc0N1c3RvbUNvbXBvbmVudFRhZyIsInZhbHVlIiwiYWNjZXB0c0Jvb2xlYW5zIiwicHJlZml4IiwiaXNOYU4iLCJwcm9wZXJ0aWVzIiwiUHJvcGVydHlJbmZvUmVjb3JkIiwibXVzdFVzZVByb3BlcnR5IiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwiZm9yRWFjaCIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsInRva2VuIiwidG9VcHBlckNhc2UiLCJwcmV2aW91c1NjcmVlblgiLCJwcmV2aW91c1NjcmVlblkiLCJpc01vdmVtZW50WFNldCIsImlzTW92ZW1lbnRZU2V0IiwiU3ludGhldGljTW91c2VFdmVudCIsIlN5bnRoZXRpY1VJRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRNb2RpZmllclN0YXRlIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiYnV0dG9uIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInNyY0VsZW1lbnQiLCJ0b0VsZW1lbnQiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJ2aWV3IiwiZGV0YWlsIiwicmVjb3JkRWZmZWN0IiwicmVjb3JkU2NoZWR1bGVVcGRhdGUiLCJzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyIiwic3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyIiwic3RhcnRXb3JrVGltZXIiLCJjYW5jZWxXb3JrVGltZXIiLCJzdG9wV29ya1RpbWVyIiwic3RvcEZhaWxlZFdvcmtUaW1lciIsInN0YXJ0UGhhc2VUaW1lciIsInN0b3BQaGFzZVRpbWVyIiwic3RhcnRXb3JrTG9vcFRpbWVyIiwic3RvcFdvcmtMb29wVGltZXIiLCJzdGFydENvbW1pdFRpbWVyIiwic3RvcENvbW1pdFRpbWVyIiwic3RhcnRDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lciIsInN0b3BDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lciIsInN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwicmVhY3RFbW9qaSIsIndhcm5pbmdFbW9qaSIsInN1cHBvcnRzVXNlclRpbWluZyIsInBlcmZvcm1hbmNlIiwibWFyayIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsImN1cnJlbnRGaWJlciIsImN1cnJlbnRQaGFzZSIsImN1cnJlbnRQaGFzZUZpYmVyIiwiaXNDb21taXR0aW5nIiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0IiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UiLCJjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wIiwiZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQiLCJpc1dhaXRpbmdGb3JDYWxsYmFjayIsImxhYmVsc0luQ3VycmVudENvbW1pdCIsIlNldCIsImZvcm1hdE1hcmtOYW1lIiwibWFya05hbWUiLCJmb3JtYXRMYWJlbCIsImxhYmVsIiwic3VmZml4IiwiYmVnaW5NYXJrIiwiY2xlYXJNYXJrIiwiZW5kTWFyayIsImZvcm1hdHRlZE1hcmtOYW1lIiwiZm9ybWF0dGVkTGFiZWwiLCJlcnIiLCJnZXRGaWJlck1hcmtOYW1lIiwiZGVidWdJRCIsImdldEZpYmVyTGFiZWwiLCJpc01vdW50ZWQiLCJiZWdpbkZpYmVyTWFyayIsIl9kZWJ1Z0lEIiwiaGFzIiwiYWRkIiwiY2xlYXJGaWJlck1hcmsiLCJlbmRGaWJlck1hcmsiLCJzaG91bGRJZ25vcmVGaWJlciIsImNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQiLCJwYXVzZVRpbWVycyIsIl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nIiwicmVzdW1lVGltZXJzUmVjdXJzaXZlbHkiLCJyZXN1bWVUaW1lcnMiLCJkaWRFeHBpcmUiLCJuZXh0VW5pdE9mV29yayIsImludGVycnVwdGVkQnkiLCJkaWRDb21wbGV0ZVJvb3QiLCJjbGVhciIsImNvdW50IiwiaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCIsInJlc29sdmVMYXp5Q29tcG9uZW50VGFnIiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFViIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwidGVzdE1hcCIsIk1hcCIsInRlc3RTZXQiLCJkZWJ1Z0NvdW50ZXIiLCJGaWJlck5vZGUiLCJwZW5kaW5nUHJvcHMiLCJlbGVtZW50VHlwZSIsImluZGV4IiwicmVmIiwibWVtb2l6ZWRQcm9wcyIsImFjdHVhbER1cmF0aW9uIiwiTnVtYmVyIiwiTmFOIiwiYWN0dWFsU3RhcnRUaW1lIiwic2VsZkJhc2VEdXJhdGlvbiIsInRyZWVCYXNlRHVyYXRpb24iLCJjcmVhdGVGaWJlciIsInNob3VsZENvbnN0cnVjdCIsImlzUmVhY3RDb21wb25lbnQiLCJkZWZhdWx0UHJvcHMiLCJpc0NvbmN1cnJlbnQiLCJpc0RldlRvb2xzUHJlc2VudCIsImZpYmVyVGFnIiwicmVzb2x2ZWRUeXBlIiwiZ2V0VGFnIiwiY2hpbGRyZW4iLCJjcmVhdGVGaWJlckZyb21Nb2RlIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJrZXlzIiwiZWxlbWVudCIsIl9vd25lciIsIl9zb3VyY2UiLCJlbGVtZW50cyIsImlkIiwib25SZW5kZXIiLCJjb250ZW50IiwicG9ydGFsIiwiY29udGFpbmVySW5mbyIsInBlbmRpbmdDaGlsZHJlbiIsImltcGxlbWVudGF0aW9uIiwid2FybklmTm90Q3VycmVudGx5QmF0Y2hpbmdJbkRldiIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJSZWFjdEN1cnJlbnRPd25lciIsImRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiIsImRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCIsIndhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkIiwid2FybkFib3V0SW52YWxpZFVwZGF0ZXMiLCJfX2ludGVyYWN0aW9uc1JlZiIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCIsImlzQ2xhc3MiLCJSZWFjdEN1cnJlbnRGaWJlclBoYXNlIiwibGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiIsImlzV29ya2luZyIsIm5leHRSb290IiwibmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIiwibmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIiwibmV4dFJlbmRlckRpZEVycm9yIiwicm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMiLCJwYXNzaXZlRWZmZWN0Q2FsbGJhY2tIYW5kbGUiLCJwYXNzaXZlRWZmZWN0Q2FsbGJhY2siLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsInN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMiLCJyZXBsYXlVbml0T2ZXb3JrIiwibWF5UmVwbGF5RmFpbGVkVW5pdE9mV29yayIsImlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yayIsIm9yaWdpbmFsUmVwbGF5RXJyb3IiLCJyZXRocm93T3JpZ2luYWxFcnJvciIsImZhaWxlZFVuaXRPZldvcmsiLCJ0aHJvd25WYWx1ZSIsImlzWWllbGR5IiwidGhlbiIsIndvcmtMb29wIiwicmVwbGF5RXJyb3IiLCJfc3VwcHJlc3NMb2dnaW5nIiwiaW5uZXIiLCJyZXNldFN0YWNrIiwiaW50ZXJydXB0ZWRXb3JrIiwiUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MiLCJkaXNjYXJkUGVuZGluZ1dhcm5pbmdzIiwiY29tbWl0QWxsSG9zdEVmZmVjdHMiLCJwcmltYXJ5RWZmZWN0VGFnIiwiY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlY3ljbGVzIiwiY29tbWl0QWxsTGlmZUN5Y2xlcyIsImZpbmlzaGVkUm9vdCIsImNvbW1pdHRlZEV4cGlyYXRpb25UaW1lIiwiZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncyIsImNvbW1pdFBhc3NpdmVFZmZlY3RzIiwicm9vdCIsInByZXZpb3VzSXNSZW5kZXJpbmciLCJpc1JlbmRlcmluZyIsImRpZEVycm9yIiwiY29tbWl0UGFzc2l2ZUhvb2tFZmZlY3RzIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJyb290RXhwaXJhdGlvblRpbWUiLCJyZXF1ZXN0V29yayIsImlzQmF0Y2hpbmdVcGRhdGVzIiwicGVyZm9ybVN5bmNXb3JrIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsIm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQiLCJmbHVzaFBhc3NpdmVFZmZlY3RzIiwiY29tbWl0Um9vdCIsInBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSIsInVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0IiwiY2hpbGRFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCIsImVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCIsInByZXZJbnRlcmFjdGlvbnMiLCJtZW1vaXplZEludGVyYWN0aW9ucyIsImJpbmQiLCJOb3JtYWxQcmlvcml0eSIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24iLCJkZWJ1Z1Rvb2wiLCJvbkNvbW1pdFdvcmsiLCJ1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0IiwiY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0IiwiZWFybGllc3RSZW1haW5pbmdUaW1lQWZ0ZXJDb21taXQiLCJvbkNvbW1pdCIsInN1YnNjcmliZXIiLCJfX3N1YnNjcmliZXJSZWYiLCJzaXplIiwidGhyZWFkSUQiLCJjb21wdXRlVGhyZWFkSUQiLCJpbnRlcmFjdGlvblRocmVhZElEIiwib25Xb3JrU3RvcHBlZCIsImhhc1VuaGFuZGxlZEVycm9yIiwidW5oYW5kbGVkRXJyb3IiLCJwZW5kaW5nSW50ZXJhY3Rpb25NYXAiLCJzY2hlZHVsZWRJbnRlcmFjdGlvbnMiLCJzY2hlZHVsZWRFeHBpcmF0aW9uVGltZSIsImRlbGV0ZSIsImludGVyYWN0aW9uIiwiX19jb3VudCIsIm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkIiwicmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIiwicmVuZGVyVGltZSIsIm5ld0NoaWxkRXhwaXJhdGlvblRpbWUiLCJzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMiLCJjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lIiwiY29tcGxldGVVbml0T2ZXb3JrIiwicmV0dXJuRmliZXIiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJzaG91bGRZaWVsZFRvUmVuZGVyZXIiLCJyZW5kZXJSb290IiwicHJldmlvdXNEaXNwYXRjaGVyIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwibmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24iLCJpbnRlcmFjdGlvbnMiLCJvbldvcmtTdGFydGVkIiwiZGlkRmF0YWwiLCJtYXlSZXBsYXkiLCJvblVuY2F1Z2h0RXJyb3IiLCJzb3VyY2VGaWJlciIsIm9uRmF0YWwiLCJvbllpZWxkIiwicm9vdFdvcmtJblByb2dyZXNzIiwic3VzcGVuZGVkRXhwaXJhdGlvblRpbWUiLCJvblN1c3BlbmQiLCJlYXJsaWVzdEV4cGlyYXRpb25UaW1lIiwiZWFybGllc3RFeHBpcmF0aW9uVGltZU1zIiwiY3VycmVudFRpbWVNcyIsInJlcXVlc3RDdXJyZW50VGltZSIsIm1zVW50aWxUaW1lb3V0Iiwib25Db21wbGV0ZSIsImN0b3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVycm9ySW5mbyIsInNjaGVkdWxlV29yayIsInJvb3RGaWJlciIsImNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24iLCJjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyIiwicHJpb3JpdHlMZXZlbCIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJMb3dQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsImxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUiLCJyZW5kZXJEaWRTdXNwZW5kIiwiYWJzb2x1dGVUaW1lb3V0TXMiLCJzdXNwZW5kZWRUaW1lIiwicmVuZGVyRGlkRXJyb3IiLCJwaW5nU3VzcGVuZGVkUm9vdCIsInBpbmdUaW1lIiwicGluZ0NhY2hlIiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwiYm91bmRhcnlGaWJlciIsInJldHJ5Q2FjaGUiLCJyZXRyeVRpbWUiLCJzY2hlZHVsZVdvcmtUb1Jvb3QiLCJwZW5kaW5nSW50ZXJhY3Rpb25zIiwib25Xb3JrU2NoZWR1bGVkIiwibmVzdGVkVXBkYXRlQ291bnQiLCJORVNURURfVVBEQVRFX0xJTUlUIiwic3luY1VwZGF0ZXMiLCJmbiIsImZpcnN0U2NoZWR1bGVkUm9vdCIsImxhc3RTY2hlZHVsZWRSb290IiwiY2FsbGJhY2tFeHBpcmF0aW9uVGltZSIsImNhbGxiYWNrSUQiLCJuZXh0Rmx1c2hlZFJvb3QiLCJuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIiwiaXNVbmJhdGNoaW5nVXBkYXRlcyIsImNvbXBsZXRlZEJhdGNoZXMiLCJvcmlnaW5hbFN0YXJ0VGltZU1zIiwiY3VycmVudFJlbmRlcmVyVGltZSIsImN1cnJlbnRTY2hlZHVsZXJUaW1lIiwibGFzdENvbW1pdHRlZFJvb3REdXJpbmdUaGlzQmF0Y2giLCJyZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lIiwic2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uVGltZSIsImN1cnJlbnRNcyIsImV4cGlyYXRpb25UaW1lTXMiLCJ0aW1lb3V0IiwicGVyZm9ybUFzeW5jV29yayIsInRpbWVvdXRIYW5kbGUiLCJvblRpbWVvdXQiLCJmbHVzaFJvb3QiLCJmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCIsImFkZFJvb3RUb1NjaGVkdWxlIiwicGVyZm9ybVdvcmtPblJvb3QiLCJuZXh0U2NoZWR1bGVkUm9vdCIsInJlbWFpbmluZ0V4cGlyYXRpb25UaW1lIiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJkaWRZaWVsZCIsInBlcmZvcm1Xb3JrIiwibWluRXhwaXJhdGlvblRpbWUiLCJmaW5pc2hSZW5kZXJpbmciLCJiYXRjaGVzIiwiYmF0Y2giLCJfb25Db21wbGV0ZSIsImNvbXBsZXRlUm9vdCIsIm5vVGltZW91dCIsImZpcnN0QmF0Y2giLCJfZXhwaXJhdGlvblRpbWUiLCJfZGVmZXIiLCJiYXRjaGVkVXBkYXRlcyIsInByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMiLCJ1bmJhdGNoZWRVcGRhdGVzIiwiZmx1c2hTeW5jIiwiaW50ZXJhY3RpdmVVcGRhdGVzIiwiZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMiLCJmbHVzaENvbnRyb2xsZWQiLCJkZWZlcnJlZFVwZGF0ZXMiLCJTY2hlZHVsZXJfbmV4dCIsImxvd1ByaW9yaXR5V2FybmluZyIsInByaW50V2FybmluZyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwicmVxdWlyZSIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInRleHQiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsImhhc0NhdWdodEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsImhhc0Vycm9yIiwiY2F1Z2h0RXJyb3IiLCJoYXNSZXRocm93RXJyb3IiLCJyZXRocm93RXJyb3IiLCJyZXBvcnRlciIsIm9uRXJyb3IiLCJmdW5jIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCIsImdldFRvU3RyaW5nVmFsdWUiLCJyZW1vdmUiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJpc0VtcHR5IiwiY3Vyc29yIiwiY2hlY2tUaGF0U3RhY2tJc0VtcHR5IiwicmVzZXRTdGFja0FmdGVyRmF0YWxFcnJvckluRGV2IiwiaW5qZWN0SW50ZXJuYWxzIiwib25Db21taXRSb290Iiwib25Db21taXRVbm1vdW50Iiwib25Db21taXRGaWJlclJvb3QiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsImhhc0xvZ2dlZEVycm9yIiwiY2F0Y2hFcnJvcnMiLCJhcmciLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpbnRlcm5hbHMiLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJyZW5kZXJlcklEIiwiaW5qZWN0IiwicmVjb25jaWxlQ2hpbGRyZW4iLCJtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSIsImRpZFJlY2VpdmVVcGRhdGUiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnMiLCJkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIiwibmV4dENoaWxkcmVuIiwiZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZSIsInVwZGF0ZUZvcndhcmRSZWYiLCJpbm5lclByb3BUeXBlcyIsInByb3BUeXBlcyIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50IiwiY29tcGFyZSIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJjdXJyZW50Q2hpbGQiLCJwcmV2UHJvcHMiLCJzaGFsbG93RXF1YWwiLCJuZXdDaGlsZCIsIm91dGVyTWVtb1R5cGUiLCJvdXRlclByb3BUeXBlcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlRnJhZ21lbnQiLCJ1cGRhdGVNb2RlIiwidXBkYXRlUHJvZmlsZXIiLCJtYXJrUmVmIiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0Iiwic2hvdWxkVXBkYXRlIiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJkaWRDYXB0dXJlRXJyb3IiLCJzdGF0ZSIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJwZW5kaW5nQ29udGV4dCIsInVwZGF0ZUhvc3RSb290IiwicHJldkNoaWxkcmVuIiwiaHlkcmF0ZSIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0IiwibW91bnRMYXp5Q29tcG9uZW50IiwiX2N1cnJlbnQiLCJyZXNvbHZlZFRhZyIsInJlc29sdmVkUHJvcHMiLCJoaW50IiwibW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIndhcm5pbmdLZXkiLCJkZWJ1Z1NvdXJjZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImNvbnRleHRUeXBlIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJuZXh0RGlkVGltZW91dCIsInRpbWVkT3V0QXQiLCJmYWxsYmFjayIsInVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCIsIm5leHRGYWxsYmFja0NoaWxkcmVuIiwicHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJwcm9ncmVzc2VkU3RhdGUiLCJwcm9ncmVzc2VkUHJpbWFyeUNoaWxkIiwiZmFsbGJhY2tDaGlsZEZyYWdtZW50IiwibmV4dFByaW1hcnlDaGlsZHJlbiIsInByZXZEaWRUaW1lb3V0IiwiY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50IiwiY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsImhpZGRlbkNoaWxkIiwiY3VycmVudFByaW1hcnlDaGlsZCIsInByaW1hcnlDaGlsZCIsImxhc3QiLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJuZXdQcm9wcyIsIm9sZFByb3BzIiwicHJvdmlkZXJQcm9wVHlwZXMiLCJuZXdDaGlsZHJlbiIsImhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciIsInVwZGF0ZUNvbnRleHRDb25zdW1lciIsIkNvbnN1bWVyIiwidW5zdGFibGVfb2JzZXJ2ZWRCaXRzIiwiYmVnaW5Xb3JrIiwiZGlkVGltZW91dCIsInByaW1hcnlDaGlsZEV4cGlyYXRpb25UaW1lIiwidW5yZXNvbHZlZFByb3BzIiwiTk9fQ09OVEVYVCIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJyZXF1aXJlZENvbnRleHQiLCJnZXRSb290SG9zdENvbnRhaW5lciIsInJvb3RJbnN0YW5jZSIsInB1c2hIb3N0Q29udGFpbmVyIiwibmV4dFJvb3RJbnN0YW5jZSIsIm5leHRSb290Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJnZXRIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGV4dCIsIm5leHRDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsImN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiaW1wbCIsInJlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudCIsIlBlbmRpbmciLCJSZXNvbHZlZCIsIlJlamVjdGVkIiwibGF6eUNvbXBvbmVudCIsIl9zdGF0dXMiLCJfcmVzdWx0IiwiY3JlYXRlRmFjdG9yeSIsImNsb25lQW5kUmVwbGFjZUtleSIsImNsb25lRWxlbWVudCIsImlzVmFsaWRFbGVtZW50IiwiUkVTRVJWRURfUFJPUFMiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50Iiwic2VsZiIsIl9zdG9yZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImZhY3RvcnkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwib2JqZWN0Iiwic2V0Q29tcG9uZW50VHJlZSIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlciIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUiLCJleGVjdXRlRGlyZWN0RGlzcGF0Y2giLCJoYXNEaXNwYXRjaGVzIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZUltcGwiLCJnZXRJbnN0YW5jZUZyb21Ob2RlSW1wbCIsImdldE5vZGVGcm9tSW5zdGFuY2VJbXBsIiwidmFsaWRhdGVFdmVudERpc3BhdGNoZXMiLCJkaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSW5zdGFuY2VzIiwibGlzdGVuZXJzSXNBcnIiLCJpc0FycmF5IiwibGlzdGVuZXJzTGVuIiwiaW5zdGFuY2VzSXNBcnIiLCJpbnN0YW5jZXNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbCIsInJldCIsImRpc3BhdGNoTGlzdGVuZXIiLCJkaXNwYXRjaEluc3RhbmNlIiwicmVzIiwic2V0UmVzdG9yZUltcGxlbWVudGF0aW9uIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsIm5lZWRzU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJyZXN0b3JlSW1wbCIsInJlc3RvcmVUYXJnZXQiLCJyZXN0b3JlUXVldWUiLCJyZXN0b3JlU3RhdGVPZlRhcmdldCIsImludGVybmFsSW5zdGFuY2UiLCJxdWV1ZWRUYXJnZXRzIiwic2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbiIsIl9iYXRjaGVkVXBkYXRlc0ltcGwiLCJib29ra2VlcGluZyIsIl9pbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsIiwiX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCIsImlzQmF0Y2hpbmciLCJjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzSW1wbCIsImludGVyYWN0aXZlVXBkYXRlc0ltcGwiLCJmbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwiLCJ0cmFjayIsInVwZGF0ZVZhbHVlSWZDaGFuZ2VkIiwic3RvcFRyYWNraW5nIiwiaXNDaGVja2FibGUiLCJlbGVtIiwibm9kZU5hbWUiLCJnZXRUcmFja2VyIiwiX3ZhbHVlVHJhY2tlciIsImRldGFjaFRyYWNrZXIiLCJnZXRWYWx1ZUZyb21Ob2RlIiwiY2hlY2tlZCIsInRyYWNrVmFsdWVPbk5vZGUiLCJ2YWx1ZUZpZWxkIiwiZGVzY3JpcHRvciIsInRyYWNrZXIiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwibGFzdFZhbHVlIiwiUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMiLCJoYXNSZWFkT25seVZhbHVlIiwiY2hlY2tib3giLCJpbWFnZSIsImhpZGRlbiIsInJhZGlvIiwicmVzZXQiLCJzdWJtaXQiLCJvbkNoYW5nZSIsInJlYWRPbmx5IiwidGFnTmFtZSIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJpcyIsInkiLCJnZXRFdmVudENoYXJDb2RlIiwiY2hhckNvZGUiLCJrZXlDb2RlIiwicmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwiTElGRUNZQ0xFX1NVR0dFU1RJT05TIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzZXRUb1NvcnRlZFN0cmluZyIsImFycmF5Iiwic29ydCIsImpvaW4iLCJsaWZlY3ljbGVXYXJuaW5nc01hcCIsInN0cmljdFJvb3QiLCJsaWZlY3ljbGVzV2FybmluZ01lc3NhZ2VzIiwibGlmZWN5Y2xlV2FybmluZ3MiLCJsaWZlY3ljbGUiLCJjb21wb25lbnROYW1lcyIsImZvcm1hdHRlZCIsInN1Z2dlc3Rpb24iLCJzb3J0ZWRDb21wb25lbnROYW1lcyIsInN0cmljdFJvb3RDb21wb25lbnRTdGFjayIsImZpbmRTdHJpY3RSb290IiwibWF5YmVTdHJpY3RSb290IiwidW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIndhcm5pbmdzRm9yUm9vdCIsInVuc2FmZUxpZmVjeWNsZXMiLCJmaWJlckFycmF5IiwicmVzb2x2ZURlZmF1bHRQcm9wcyIsInJlYWRMYXp5Q29tcG9uZW50VHlwZSIsImJhc2VQcm9wcyIsInN0YXR1cyIsIl9jdG9yIiwiZGVmYXVsdEV4cG9ydCIsIm1vZHVsZU9iamVjdCIsImNvbW1pdFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsImdldENvbW1pdFRpbWUiLCJyZWNvcmRDb21taXRUaW1lIiwic3RhcnRQcm9maWxlclRpbWVyIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmciLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhIiwib3ZlcnJpZGVCYXNlVGltZSIsImVsYXBzZWRUaW1lIiwiaXNDdXN0b21Db21wb25lbnQiLCJfX1VNRF9fIiwiU2NoZWR1bGVyIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInVuc3RhYmxlX25vdyIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkiLCJ1bnN0YWJsZV9uZXh0IiwidW5zdGFibGVfd3JhcENhbGxiYWNrIiwidW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUiLCJ1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uIiwidW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwiLCJTY2hlZHVsZXJUcmFjaW5nIiwidW5zdGFibGVfY2xlYXIiLCJ1bnN0YWJsZV9nZXRDdXJyZW50IiwidW5zdGFibGVfZ2V0VGhyZWFkSUQiLCJ1bnN0YWJsZV9zdWJzY3JpYmUiLCJ1bnN0YWJsZV90cmFjZSIsInVuc3RhYmxlX3Vuc3Vic2NyaWJlIiwidW5zdGFibGVfd3JhcCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJERUZBVUxUX1RIUkVBRF9JRCIsImludGVyYWN0aW9uSURDb3VudGVyIiwidGhyZWFkSURDb3VudGVyIiwiaW50ZXJhY3Rpb25zUmVmIiwic3Vic2NyaWJlclJlZiIsInRpbWVzdGFtcCIsIm9uSW50ZXJhY3Rpb25UcmFjZWQiLCJ3cmFwcGVkSW50ZXJhY3Rpb25zIiwiaGFzUnVuIiwid3JhcHBlZCIsImNhbmNlbCIsIm9uV29ya0NhbmNlbGVkIiwic291cmNlSW5mbyIsInBhdGgiLCJCRUZPUkVfU0xBU0hfUkUiLCJtYXRjaCIsInBhdGhCZWZvcmVTbGFzaCIsImZvbGRlck5hbWUiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJhY2N1bXVsYXRlSW50byIsImNvbmNhdCIsImZvckVhY2hBY2N1bXVsYXRlZCIsImFyciIsImNiIiwic2NvcGUiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiY29sb3IiLCJkYXRlIiwiZGF0ZXRpbWUiLCJlbWFpbCIsIm1vbnRoIiwibnVtYmVyIiwicGFzc3dvcmQiLCJyYW5nZSIsInNlYXJjaCIsInRlbCIsInRpbWUiLCJ1cmwiLCJ3ZWVrIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiZ2V0RXZlbnRUYXJnZXQiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsIm5vZGVUeXBlIiwiaXNFdmVudFN1cHBvcnRlZCIsImV2ZW50TmFtZVN1ZmZpeCIsImlzU3VwcG9ydGVkIiwic2V0QXR0cmlidXRlIiwiZ2V0SG9zdFByb3BzIiwiaW5pdFdyYXBwZXJTdGF0ZSIsInVwZGF0ZUNoZWNrZWQiLCJ1cGRhdGVXcmFwcGVyIiwicG9zdE1vdW50V3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUiLCJzZXREZWZhdWx0VmFsdWUiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImhvc3RQcm9wcyIsImRlZmF1bHRDaGVja2VkIiwiX3dyYXBwZXJTdGF0ZSIsImluaXRpYWxDaGVja2VkIiwiaW5pdGlhbFZhbHVlIiwiY29udHJvbGxlZCIsInJlbW92ZUF0dHJpYnV0ZSIsImlzSHlkcmF0aW5nIiwiaXNCdXR0b24iLCJ1cGRhdGVOYW1lZENvdXNpbnMiLCJyb290Tm9kZSIsInF1ZXJ5Um9vdCIsImdyb3VwIiwicXVlcnlTZWxlY3RvckFsbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJvdGhlck5vZGUiLCJmb3JtIiwib3RoZXJQcm9wcyIsIm93bmVyRG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZ2V0VmFsdWVGb3JQcm9wZXJ0eSIsImdldFZhbHVlRm9yQXR0cmlidXRlIiwic2V0VmFsdWVGb3JQcm9wZXJ0eSIsImV4cGVjdGVkIiwic3RyaW5nVmFsdWUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVWYWx1ZSIsInNldEF0dHJpYnV0ZU5TIiwiU3ludGhldGljUG9pbnRlckV2ZW50IiwicG9pbnRlcklkIiwid2lkdGgiLCJoZWlnaHQiLCJwcmVzc3VyZSIsInRhbmdlbnRpYWxQcmVzc3VyZSIsInRpbHRYIiwidGlsdFkiLCJ0d2lzdCIsInBvaW50ZXJUeXBlIiwiaXNQcmltYXJ5IiwibGlzdGVuVG8iLCJpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJpc0xpc3RlbmluZyIsImlzTWVkaWFFdmVudCIsInNldEVuYWJsZWQiLCJpc0VuYWJsZWQiLCJ0cmFwQnViYmxlZEV2ZW50IiwidHJhcENhcHR1cmVkRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlIiwiU2ltcGxlRXZlbnRQbHVnaW4iLCJDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUiLCJjYWxsYmFja0Jvb2trZWVwaW5nUG9vbCIsImZpbmRSb290Q29udGFpbmVyTm9kZSIsImdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsImFuY2VzdG9ycyIsInJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJoYW5kbGVUb3BMZXZlbCIsImJvb2tLZWVwaW5nIiwiYW5jZXN0b3IiLCJfZW5hYmxlZCIsImVuYWJsZWQiLCJkaXNwYXRjaCIsImRpc3BhdGNoSW50ZXJhY3RpdmVFdmVudCIsIkRPTVRvcExldmVsRXZlbnRUeXBlcyIsImludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMiLCJub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzIiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnIiwidG9wRXZlbnQiLCJjYXBpdGFsaXplZEV2ZW50Iiwib25FdmVudCIsImJ1YmJsZWQiLCJjYXB0dXJlZCIsImV2ZW50VHVwbGUiLCJrbm93bkhUTUxUb3BMZXZlbFR5cGVzIiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJnZXRBY3RpdmVFbGVtZW50IiwiZG9jIiwiYm9keSIsIm1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbCIsIm1hcmtDb21taXR0ZWRQcmlvcml0eUxldmVscyIsImhhc0xvd2VyUHJpb3JpdHlXb3JrIiwiaXNQcmlvcml0eUxldmVsU3VzcGVuZGVkIiwibWFya1N1c3BlbmRlZFByaW9yaXR5TGV2ZWwiLCJtYXJrUGluZ2VkUHJpb3JpdHlMZXZlbCIsImZpbmRFYXJsaWVzdE91dHN0YW5kaW5nUHJpb3JpdHlMZXZlbCIsImRpZEV4cGlyZUF0RXhwaXJhdGlvblRpbWUiLCJlYXJsaWVzdFBlbmRpbmdUaW1lIiwibGF0ZXN0UGVuZGluZ1RpbWUiLCJmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24iLCJlYXJsaWVzdFJlbWFpbmluZ1RpbWUiLCJlYXJsaWVzdFN1c3BlbmRlZFRpbWUiLCJsYXRlc3RTdXNwZW5kZWRUaW1lIiwibGF0ZXN0UGluZ2VkVGltZSIsImVycm9yZWRFeHBpcmF0aW9uVGltZSIsImNsZWFyUGluZyIsInBpbmdlZFRpbWUiLCJjb21wbGV0ZWRUaW1lIiwiY29tcGxldGVkRXhwaXJhdGlvblRpbWUiLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZW1wdHlSZWZzT2JqZWN0IiwicmVmcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiY2FsbGVyTmFtZSIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJub0dldEluaXRpYWxTdGF0ZU9uRVM2IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJub0dldERlZmF1bHRQcm9wc09uRVM2IiwiZ2V0RGVmYXVsdFByb3BzIiwibm9JbnN0YW5jZVByb3BUeXBlcyIsIm5vSW5zdGFuY2VDb250ZXh0VHlwZSIsIm5vSW5zdGFuY2VDb250ZXh0VHlwZXMiLCJub0NvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsIm5vQ29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFVubW91bnQiLCJub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsIm5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsIm5vSW5zdGFuY2VEZWZhdWx0UHJvcHMiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIiwibm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImFkb3B0Q2xhc3NJbnN0YW5jZSIsInVwZGF0ZXIiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsImlzTGVnYWN5Q29udGV4dENvbnN1bWVyIiwiZm91bmRXaWxsTW91bnROYW1lIiwiZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSIsImZvdW5kV2lsbFVwZGF0ZU5hbWUiLCJuZXdBcGlOYW1lIiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwiY29tcG9uZW50RGlkTW91bnQiLCJyZXN1bWVNb3VudENsYXNzSW5zdGFuY2UiLCJvbGRDb250ZXh0IiwibmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCIsImhhc05ld0xpZmVjeWNsZXMiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwibmV4dFVubWFza2VkQ29udGV4dCIsInJlbmRlcldpdGhIb29rcyIsImJhaWxvdXRIb29rcyIsInJlc2V0SG9va3MiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJmaXJzdEN1cnJlbnRIb29rIiwiY3VycmVudEhvb2siLCJuZXh0Q3VycmVudEhvb2siLCJmaXJzdFdvcmtJblByb2dyZXNzSG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsIm5leHRXb3JrSW5Qcm9ncmVzc0hvb2siLCJjb21wb25lbnRVcGRhdGVRdWV1ZSIsInNpZGVFZmZlY3RUYWciLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwicmVuZGVyUGhhc2VVcGRhdGVzIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJjdXJyZW50SG9va05hbWVJbkRldiIsIndhcm5Pbkhvb2tNaXNtYXRjaEluRGV2Iiwic2Vjb25kQ29sdW1uU3RhcnQiLCJ0YWJsZSIsInByZXZIb29rIiwibmV4dEhvb2siLCJuIiwib2xkSG9va05hbWUiLCJfZGVidWdUeXBlIiwibmV3SG9va05hbWUiLCJyb3ciLCJ0aHJvd0ludmFsaWRIb29rRXJyb3IiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwicmVmT3JDb250ZXh0IiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnQiLCJIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZSIsInJlbmRlcmVkV29yayIsImRpZFJlbmRlclRvb0Zld0hvb2tzIiwiUGFzc2l2ZUVmZmVjdCIsIlVwZGF0ZUVmZmVjdCIsIm1vdW50V29ya0luUHJvZ3Jlc3NIb29rIiwiYmFzZVVwZGF0ZSIsInVwZGF0ZVdvcmtJblByb2dyZXNzSG9vayIsIm5ld0hvb2siLCJjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJtb3VudENvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwibW91bnRSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJpbml0IiwiaW5pdGlhbFN0YXRlIiwiZWFnZXJSZWR1Y2VyIiwiZWFnZXJTdGF0ZSIsImRpc3BhdGNoQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsImZpcnN0UmVuZGVyUGhhc2VVcGRhdGUiLCJuZXdCYXNlVXBkYXRlIiwicHJldlVwZGF0ZSIsImRpZFNraXAiLCJtb3VudFN0YXRlIiwidXBkYXRlU3RhdGUiLCJwdXNoRWZmZWN0IiwiY3JlYXRlIiwiZGVzdHJveSIsImRlcHMiLCJtb3VudFJlZiIsInNlYWwiLCJ1cGRhdGVSZWYiLCJtb3VudEVmZmVjdEltcGwiLCJmaWJlckVmZmVjdFRhZyIsImhvb2tFZmZlY3RUYWciLCJ1cGRhdGVFZmZlY3RJbXBsIiwicHJldkVmZmVjdCIsIk5vSG9va0VmZmVjdCIsIm1vdW50RWZmZWN0IiwiVW5tb3VudFBhc3NpdmUiLCJNb3VudFBhc3NpdmUiLCJ1cGRhdGVFZmZlY3QiLCJtb3VudExheW91dEVmZmVjdCIsIlVubW91bnRNdXRhdGlvbiIsIk1vdW50TGF5b3V0IiwidXBkYXRlTGF5b3V0RWZmZWN0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNhbGxiYWNrIiwicmVmT2JqZWN0IiwibW91bnRJbXBlcmF0aXZlSGFuZGxlIiwiZWZmZWN0RGVwcyIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudERlYnVnVmFsdWUiLCJmb3JtYXR0ZXJGbiIsInVwZGF0ZURlYnVnVmFsdWUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsInNob3VsZFdhcm5Gb3JVbmJhdGNoZWRTZXRTdGF0ZSIsImplc3QiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJwcmV2RGlzcGF0Y2hlciIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiY3VycmVudFN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VEZWJ1Z1ZhbHVlIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIndhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsIlVubW91bnRTbmFwc2hvdCIsIk1vdW50TXV0YXRpb24iLCJVbm1vdW50TGF5b3V0IiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZW50ZXJIeWRyYXRpb25TdGF0ZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwicGFyZW50SW5zdGFuY2UiLCJyZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJzdXNwZW5zZUluc3RhbmNlIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsImRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImNoaWxkVG9EZWxldGUiLCJpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlIiwicGFyZW50Q29udGFpbmVyIiwicGFyZW50VHlwZSIsInBhcmVudFByb3BzIiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInRleHRJbnN0YW5jZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJob3N0Q29udGV4dCIsInVwZGF0ZVBheWxvYWQiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInRleHRDb250ZW50Iiwic2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsInBvcEh5ZHJhdGlvblN0YXRlIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsImNyZWF0ZUNhcHR1cmVkVmFsdWUiLCJsb2dFcnJvciIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiUG9zc2libHlXZWFrU2V0IiwiV2Vha1NldCIsImJvdW5kYXJ5IiwiY2FwdHVyZWRFcnJvciIsImNvbXBvbmVudFN0YWNrIiwiZXJyb3JCb3VuZGFyeSIsImVycm9yQm91bmRhcnlOYW1lIiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwid2lsbFJldHJ5Iiwic2V0VGltZW91dCIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudEVycm9yIiwic2FmZWx5RGV0YWNoUmVmIiwicmVmRXJyb3IiLCJzYWZlbHlDYWxsRGVzdHJveSIsImNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyIsImNvbW1pdEhvb2tFZmZlY3RMaXN0Iiwic25hcHNob3QiLCJkaWRXYXJuU2V0IiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJ1bm1vdW50VGFnIiwibW91bnRUYWciLCJhZGRlbmR1bSIsImNvbW1pdExpZmVDeWNsZXMiLCJoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbiIsImlzSGlkZGVuIiwic3VwcG9ydHNNdXRhdGlvbiIsImNvbW1pdEF0dGFjaFJlZiIsImluc3RhbmNlVG9Vc2UiLCJjb21taXREZXRhY2hSZWYiLCJjdXJyZW50UmVmIiwiY29tbWl0VW5tb3VudCIsInVubW91bnRIb3N0Q29tcG9uZW50cyIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImNvbW1pdE5lc3RlZFVubW91bnRzIiwiZGV0YWNoRmliZXIiLCJlbXB0eUNoaWxkU2V0IiwiY29tbWl0Q29udGFpbmVyIiwicG9ydGFsT3JSb290IiwiZ2V0SG9zdFBhcmVudEZpYmVyIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJzaWJsaW5ncyIsImNvbW1pdFBsYWNlbWVudCIsInBhcmVudEZpYmVyIiwiaXNDb250YWluZXIiLCJiZWZvcmUiLCJjdXJyZW50UGFyZW50SXNWYWxpZCIsImN1cnJlbnRQYXJlbnQiLCJjdXJyZW50UGFyZW50SXNDb250YWluZXIiLCJmaW5kUGFyZW50IiwiY29tbWl0RGVsZXRpb24iLCJjb21taXRXb3JrIiwibmV3VGV4dCIsIm9sZFRleHQiLCJuZXdEaWRUaW1lb3V0IiwicHJpbWFyeUNoaWxkUGFyZW50IiwidGhlbmFibGVzIiwicmV0cnkiLCJjb21taXRSZXNldFRleHRDb250ZW50IiwiZ2V0SW50cmluc2ljTmFtZXNwYWNlIiwiZ2V0Q2hpbGROYW1lc3BhY2UiLCJIVE1MX05BTUVTUEFDRSIsIk1BVEhfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIk5hbWVzcGFjZXMiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwicGFyZW50TmFtZXNwYWNlIiwicG9zc2libGVTdGFuZGFyZE5hbWVzIiwiYWNjZXB0IiwiYWNjZXB0Y2hhcnNldCIsImFjY2Vzc2tleSIsImFsbG93ZnVsbHNjcmVlbiIsImFsdCIsImFzIiwiYXN5bmMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNhcHR1cmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzcyIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHMiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGF0YSIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZGVmZXIiLCJkaXIiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJmb3JtbWV0aG9kIiwiZm9ybWFjdGlvbiIsImZvcm1lbmN0eXBlIiwiZm9ybW5vdmFsaWRhdGUiLCJmb3JtdGFyZ2V0IiwiZnJhbWVib3JkZXIiLCJoZWFkZXJzIiwiaGlnaCIsImhyZWYiLCJocmVmbGFuZyIsImh0bWxmb3IiLCJodHRwZXF1aXYiLCJpY29uIiwiaW5uZXJodG1sIiwiaW5wdXRtb2RlIiwiaW50ZWdyaXR5IiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhbmciLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub21vZHVsZSIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93c3BhbiIsInNhbmRib3giLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2hhcGUiLCJzaXplcyIsInNwYW4iLCJzcGVsbGNoZWNrIiwic3JjIiwic3JjZG9jIiwic3JjbGFuZyIsInNyY3NldCIsInN0YXJ0Iiwic3RlcCIsInN0eWxlIiwic3VtbWFyeSIsInRhYmluZGV4IiwidGl0bGUiLCJ1c2VtYXAiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yaW50ZXJwb2xhdGlvbiIsImNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnMiLCJjb2xvcnByb2ZpbGUiLCJjb2xvcnJlbmRlcmluZyIsImNvbnRlbnRzY3JpcHR0eXBlIiwiY29udGVudHN0eWxldHlwZSIsImN4IiwiY3kiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImVuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhuYW1lIiwiZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWwiLCJnbHlwaG9yaWVudGF0aW9udmVydGljYWwiLCJnbHlwaHJlZiIsImdyYWRpZW50dHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyIsImhhbmdpbmciLCJob3JpemFkdngiLCJob3Jpem9yaWdpbngiLCJpZGVvZ3JhcGhpYyIsImltYWdlcmVuZGVyaW5nIiwiaW4yIiwiaW4iLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImsiLCJrZXJuZWxtYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIiwia2VybmluZyIsImtleXBvaW50cyIsImtleXNwbGluZXMiLCJrZXl0aW1lcyIsImxlbmd0aGFkanVzdCIsImxldHRlcnNwYWNpbmciLCJsaWdodGluZ2NvbG9yIiwibGltaXRpbmdjb25lYW5nbGUiLCJsb2NhbCIsIm1hcmtlcmVuZCIsIm1hcmtlcmhlaWdodCIsIm1hcmtlcm1pZCIsIm1hcmtlcnN0YXJ0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2siLCJtYXNrY29udGVudHVuaXRzIiwibWFza3VuaXRzIiwibWF0aGVtYXRpY2FsIiwibnVtb2N0YXZlcyIsIm9mZnNldCIsIm9wYWNpdHkiLCJvcGVyYXRvciIsIm9yZGVyIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInIiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJlc3VsdHMiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWN1cml0eSIsInNlZWQiLCJzaGFwZXJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyY29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRtZXRob2QiLCJzdGFydG9mZnNldCIsInN0ZGRldmlhdGlvbiIsInN0ZW1oIiwic3RlbXYiLCJzdGl0Y2h0aWxlcyIsInN0b3Bjb2xvciIsInN0b3BvcGFjaXR5Iiwic3RyaWtldGhyb3VnaHBvc2l0aW9uIiwic3RyaWtldGhyb3VnaHRoaWNrbmVzcyIsInN0cmluZyIsInN0cm9rZSIsInN0cm9rZWRhc2hhcnJheSIsInN0cm9rZWRhc2hvZmZzZXQiLCJzdHJva2VsaW5lY2FwIiwic3Ryb2tlbGluZWpvaW4iLCJzdHJva2VtaXRlcmxpbWl0Iiwic3Ryb2tld2lkdGgiLCJzdHJva2VvcGFjaXR5Iiwic3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nIiwic3VwcHJlc3NoeWRyYXRpb253YXJuaW5nIiwic3VyZmFjZXNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyIsInRhcmdldHgiLCJ0YXJnZXR5IiwidGV4dGFuY2hvciIsInRleHRkZWNvcmF0aW9uIiwidGV4dGxlbmd0aCIsInRleHRyZW5kZXJpbmciLCJ0cmFuc2Zvcm0iLCJ0eXBlb2YiLCJ1MSIsInUyIiwidW5kZXJsaW5lcG9zaXRpb24iLCJ1bmRlcmxpbmV0aGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZWJpZGkiLCJ1bmljb2RlcmFuZ2UiLCJ1bml0c3BlcmVtIiwidW5zZWxlY3RhYmxlIiwidmFscGhhYmV0aWMiLCJ2ZWN0b3JlZmZlY3QiLCJ2ZXJzaW9uIiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwiSG9va3MiLCJzZXRDb3VudCIsIlJlYWN0RE9NIiwiZ2V0RWxlbWVudEJ5SWQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJvbmx5IiwiY3JlYXRlUmVmIiwiUHVyZUNvbXBvbmVudCIsImNyZWF0ZUNvbnRleHQiLCJmb3J3YXJkUmVmIiwibGF6eSIsIm1lbW8iLCJTdXNwZW5zZSIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsImNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwiY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIiwiUmVhY3RWZXJzaW9uIiwidW5zdGFibGVfQ29uY3VycmVudE1vZGUiLCJ1bnN0YWJsZV9Qcm9maWxlciIsImVtcHR5T2JqZWN0IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiZm5OYW1lIiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNvbXBsZXRlU3RhdGUiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJlc2NhcGUiLCJlc2NhcGVSZWdleCIsImVzY2FwZXJMb29rdXAiLCJlc2NhcGVkU3RyaW5nIiwiZGlkV2FybkFib3V0TWFwcyIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwiUE9PTF9TSVpFIiwidHJhdmVyc2VDb250ZXh0UG9vbCIsImdldFBvb2xlZFRyYXZlcnNlQ29udGV4dCIsIm1hcFJlc3VsdCIsImtleVByZWZpeCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsInRyYXZlcnNlQ29udGV4dCIsInJlbGVhc2VUcmF2ZXJzZUNvbnRleHQiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCIsIm5hbWVTb0ZhciIsImludm9rZUNhbGxiYWNrIiwiZ2V0Q29tcG9uZW50S2V5IiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwiaWkiLCJkb25lIiwiY2hpbGRyZW5TdHJpbmciLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwiY29tcG9uZW50IiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJvbmx5Q2hpbGQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwidGVzdDMiLCJzcGxpdCIsImxldHRlciIsInN5bWJvbHMiLCJzIiwibWF4U2lnbmVkMzFCaXRJbnQiLCJJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCIsIlVTRVJfQkxPQ0tJTkdfUFJJT1JJVFkiLCJOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCIsIkxPV19QUklPUklUWV9USU1FT1VUIiwiSURMRV9QUklPUklUWSIsImZpcnN0Q2FsbGJhY2tOb2RlIiwiY3VycmVudERpZFRpbWVvdXQiLCJpc1NjaGVkdWxlclBhdXNlZCIsImN1cnJlbnRQcmlvcml0eUxldmVsIiwiY3VycmVudEV2ZW50U3RhcnRUaW1lIiwiY3VycmVudEV4cGlyYXRpb25UaW1lIiwiaXNFeGVjdXRpbmdDYWxsYmFjayIsImlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIiwiaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3ciLCJlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCIsImNhbmNlbEhvc3RDYWxsYmFjayIsInJlcXVlc3RIb3N0Q2FsbGJhY2siLCJmbHVzaFdvcmsiLCJmbHVzaEZpcnN0Q2FsbGJhY2siLCJmbHVzaGVkTm9kZSIsImxhc3RDYWxsYmFja05vZGUiLCJwcmV2aW91cyIsInByZXZpb3VzUHJpb3JpdHlMZXZlbCIsInByZXZpb3VzRXhwaXJhdGlvblRpbWUiLCJjb250aW51YXRpb25DYWxsYmFjayIsImNvbnRpbnVhdGlvbk5vZGUiLCJuZXh0QWZ0ZXJDb250aW51YXRpb24iLCJmbHVzaEltbWVkaWF0ZVdvcmsiLCJwcmV2aW91c0RpZFRpbWVvdXQiLCJnZXRDdXJyZW50VGltZSIsInNob3VsZFlpZWxkVG9Ib3N0IiwiZXZlbnRIYW5kbGVyIiwicHJldmlvdXNFdmVudFN0YXJ0VGltZSIsInBhcmVudFByaW9yaXR5TGV2ZWwiLCJkZXByZWNhdGVkX29wdGlvbnMiLCJzdGFydFRpbWUiLCJuZXdOb2RlIiwiY2FsbGJhY2tOb2RlIiwibG9jYWxEYXRlIiwibG9jYWxTZXRUaW1lb3V0IiwibG9jYWxDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJsb2NhbFJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImxvY2FsQ2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIkFOSU1BVElPTl9GUkFNRV9USU1FT1VUIiwickFGSUQiLCJyQUZUaW1lb3V0SUQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVXaXRoVGltZW91dCIsIlBlcmZvcm1hbmNlIiwiZ2xvYmFsVmFsdWUiLCJnbG9iYWwiLCJfc2NoZWRNb2NrIiwiZ2xvYmFsSW1wbCIsIk1lc3NhZ2VDaGFubmVsIiwiX2NhbGxiYWNrIiwiX2ZsdXNoQ2FsbGJhY2siLCJzY2hlZHVsZWRIb3N0Q2FsbGJhY2siLCJpc01lc3NhZ2VFdmVudFNjaGVkdWxlZCIsInRpbWVvdXRUaW1lIiwiaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCIsImlzRmx1c2hpbmdIb3N0Q2FsbGJhY2siLCJmcmFtZURlYWRsaW5lIiwicHJldmlvdXNGcmFtZVRpbWUiLCJhY3RpdmVGcmFtZVRpbWUiLCJjaGFubmVsIiwicG9ydCIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwcmV2U2NoZWR1bGVkQ2FsbGJhY2siLCJwcmV2VGltZW91dFRpbWUiLCJhbmltYXRpb25UaWNrIiwicmFmVGltZSIsIm5leHRGcmFtZVRpbWUiLCJwb3N0TWVzc2FnZSIsImFic29sdXRlVGltZW91dCIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX0xvd1ByaW9yaXR5IiwiZyIsImV2YWwiLCJzdWJzY3JpYmVycyIsImRpZENhdGNoRXJyb3IiLCJfdGhyZWFkQ291bnQiLCJQcm92aWRlciIsImhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX1Byb3ZpZGVyIiwibGF6eVR5cGUiLCJuZXdEZWZhdWx0UHJvcHMiLCJuZXdQcm9wVHlwZXMiLCJyZXNvbHZlRGlzcGF0Y2hlciIsImRpc3BhdGNoZXIiLCJDb250ZXh0IiwicmVhbENvbnRleHQiLCJpbnB1dHMiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZWxlbWVudFByb3BzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJ2YWxpZFR5cGUiLCJ0eXBlU3RyaW5nIiwidmFsaWRhdGVkRmFjdG9yeSIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJkcmFpbmluZyIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJJdGVtIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsInRvcExldmVsVXBkYXRlV2FybmluZ3MiLCJkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCIsImNvbnRhaW5lciIsIl9yZWFjdFJvb3RDb250YWluZXIiLCJob3N0SW5zdGFuY2UiLCJfaW50ZXJuYWxSb290IiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsImhhc05vblJvb3RSZWFjdENoaWxkIiwiUmVhY3RCYXRjaCIsIl9yb290IiwiX25leHQiLCJfY2FsbGJhY2tzIiwiX2RpZENvbXBsZXRlIiwiX2hhc0NoaWxkcmVuIiwiX2NoaWxkcmVuIiwiaW50ZXJuYWxSb290Iiwid29yayIsIlJlYWN0V29yayIsIl9vbkNvbW1pdCIsImNhbGxiYWNrcyIsImNvbW1pdCIsIl9kaWRDb21taXQiLCJSZWFjdFJvb3QiLCJ1bm1vdW50IiwibGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwicGFyZW50Q29tcG9uZW50IiwiY3JlYXRlQmF0Y2giLCJpbnNlcnRBZnRlciIsImluc2VydEJlZm9yZSIsImlzVmFsaWRDb250YWluZXIiLCJub2RlVmFsdWUiLCJkb2N1bWVudEVsZW1lbnQiLCJmaXJzdENoaWxkIiwic2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljIiwicm9vdEVsZW1lbnQiLCJ3YXJuZWRBYm91dEh5ZHJhdGVBUEkiLCJsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lciIsImZvcmNlSHlkcmF0ZSIsInNob3VsZEh5ZHJhdGUiLCJ3YXJuZWQiLCJyb290U2libGluZyIsImxhc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwibGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJvcmlnaW5hbENhbGxiYWNrIiwiY3JlYXRlUG9ydGFsIiwiZmluZERPTU5vZGUiLCJjb21wb25lbnRPckVsZW1lbnQiLCJ3YXJuZWRBYm91dFJlZnNJblJlbmRlciIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsIl9yZWFjdEhhc0JlZW5QYXNzZWRUb0NyZWF0ZVJvb3RERVYiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImNvbnRhaW5lck5vZGUiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwicmVuZGVyZWRCeURpZmZlcmVudFJlYWN0IiwiaXNDb250YWluZXJSZWFjdFJvb3QiLCJ1bnN0YWJsZV9jcmVhdGVQb3J0YWwiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX2ludGVyYWN0aXZlVXBkYXRlcyIsInVuc3RhYmxlX2NyZWF0ZVJvb3QiLCJjcmVhdGVSb290IiwidW5zdGFibGVfZmx1c2hDb250cm9sbGVkIiwiRXZlbnRzIiwiRXZlbnRQbHVnaW5IdWJJbmplY3Rpb24iLCJvcHRpb25zIiwiZm91bmREZXZUb29scyIsImZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwiYnVuZGxlVHlwZSIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJ0b3AiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJwcm90b2NvbCIsIkRPTUV2ZW50UGx1Z2luT3JkZXIiLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJDaGFuZ2VFdmVudFBsdWdpbiIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiQmVmb3JlSW5wdXRFdmVudFBsdWdpbiIsImZ1bmNBcmdzIiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImludm9rZUd1YXJkZWRDYWxsYmFja0RldiIsImV2dCIsIndpbmRvd0V2ZW50Iiwid2luZG93RXZlbnREZXNjcmlwdG9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImhhbmRsZVdpbmRvd0Vycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdEV2ZW50IiwiRU5EX0tFWUNPREVTIiwiU1RBUlRfS0VZQ09ERSIsImNhblVzZUNvbXBvc2l0aW9uRXZlbnQiLCJkb2N1bWVudE1vZGUiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJiZWZvcmVJbnB1dCIsImNvbXBvc2l0aW9uRW5kIiwiY29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uVXBkYXRlIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJpc1VzaW5nS29yZWFuSU1FIiwibG9jYWxlIiwiaXNDb21wb3NpbmciLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImV2ZW50VHlwZSIsImZhbGxiYWNrRGF0YSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsIndoaWNoIiwiY2hhcnMiLCJnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMiLCJjaGFyIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJTeW50aGV0aWNJbnB1dEV2ZW50IiwiY29tcG9zaXRpb24iLCJnZXRMb3dlc3RDb21tb25BbmNlc3RvciIsImlzQW5jZXN0b3IiLCJnZXRQYXJlbnRJbnN0YW5jZSIsInRyYXZlcnNlVHdvUGhhc2UiLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJnZXRQYXJlbnQiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiYXJnRnJvbSIsImFyZ1RvIiwiY29tbW9uIiwicGF0aEZyb20iLCJwYXRoVG8iLCJ1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUiLCJ1bnNhZmVDYXN0RE9NVG9wTGV2ZWxUeXBlVG9TdHJpbmciLCJtYWtlUHJlZml4TWFwIiwic3R5bGVQcm9wIiwicHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXhlcyIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsInByZWZpeGVkRXZlbnROYW1lcyIsImFuaW1hdGlvbiIsInRyYW5zaXRpb24iLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsInByZWZpeE1hcCIsImluaXRpYWxpemUiLCJnZXREYXRhIiwiZ2V0VGV4dCIsInN0YXJ0VGV4dCIsImZhbGxiYWNrVGV4dCIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiY2hhbmdlIiwiY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50IiwiYWN0aXZlRWxlbWVudEluc3QiLCJzaG91bGRVc2VDaGFuZ2VFdmVudCIsIm1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQiLCJydW5FdmVudEluQmF0Y2giLCJnZXRJbnN0SWZWYWx1ZUNoYW5nZWQiLCJ0YXJnZXROb2RlIiwiZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50IiwiaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwic3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiYXR0YWNoRXZlbnQiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiZGV0YWNoRXZlbnQiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCIsImhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIiLCJfaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsInBvaW50ZXJFbnRlciIsInBvaW50ZXJMZWF2ZSIsImlzT3ZlckV2ZW50IiwiaXNPdXRFdmVudCIsIndpbiIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwicmVsYXRlZCIsImV2ZW50SW50ZXJmYWNlIiwibGVhdmVFdmVudFR5cGUiLCJlbnRlckV2ZW50VHlwZSIsImV2ZW50VHlwZVByZWZpeCIsImZyb21Ob2RlIiwidG9Ob2RlIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50Iiwic2VsZWN0IiwibGFzdFNlbGVjdGlvbiIsIm1vdXNlRG93biIsImdldFNlbGVjdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiZ2V0RXZlbnRUYXJnZXREb2N1bWVudCIsImV2ZW50VGFyZ2V0IiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiY29udGVudEVkaXRhYmxlIiwiaXNGaWJlck1vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiTU9VTlRJTkciLCJNT1VOVEVEIiwiVU5NT1VOVEVEIiwiaXNGaWJlck1vdW50ZWRJbXBsIiwib3duZXJGaWJlciIsImFzc2VydElzTW91bnRlZCIsInBhcmVudEEiLCJwYXJlbnRCIiwiZGlkRmluZENoaWxkIiwiYWRkRXZlbnRCdWJibGVMaXN0ZW5lciIsImFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyIiwiYW5pbWF0aW9uTmFtZSIsInBzZXVkb0VsZW1lbnQiLCJjbGlwYm9hcmREYXRhIiwiZ2V0RXZlbnRLZXkiLCJyZXBlYXQiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJkYXRhVHJhbnNmZXIiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiZGVsdGFYIiwid2hlZWxEZWx0YVgiLCJkZWx0YVkiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJkZWx0YVoiLCJkZWx0YU1vZGUiLCJoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMiLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJzZXRTZWxlY3Rpb24iLCJpc1RleHROb2RlIiwiY29udGFpbnNOb2RlIiwib3V0ZXJOb2RlIiwiaW5uZXJOb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImlzSW5Eb2N1bWVudCIsImdldEFjdGl2ZUVsZW1lbnREZWVwIiwiSFRNTElGcmFtZUVsZW1lbnQiLCJjb250ZW50RG9jdW1lbnQiLCJmb2N1c2VkRWxlbSIsInNlbGVjdGlvblJhbmdlIiwicHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiIsImN1ckZvY3VzZWRFbGVtIiwicHJpb3JGb2N1c2VkRWxlbSIsInByaW9yU2VsZWN0aW9uUmFuZ2UiLCJsZWZ0Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImZvY3VzIiwiaW5wdXQiLCJvZmZzZXRzIiwiZ2V0T2Zmc2V0cyIsImdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzIiwic2V0T2Zmc2V0cyIsInJhbmdlQ291bnQiLCJpbmRleFdpdGhpbkFuY2hvciIsImluZGV4V2l0aGluRm9jdXMiLCJvdXRlciIsIm5leHRTaWJsaW5nIiwidGVtcCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwic2V0RW5kIiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwidXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZSIsImNyZWF0ZUNvbnRhaW5lciIsInVwZGF0ZUNvbnRhaW5lciIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsImRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJzY2hlZHVsZVJvb3RVcGRhdGUiLCJSZWFjdEN1cnJlbnRGaWJlckN1cnJlbnQiLCJvbk1vdW50Q29udGFpbmVyIiwib25Vbm1vdW50Q29udGFpbmVyIiwib25VcGRhdGVDb250YWluZXIiLCJmaW5kSG9zdEluc3RhbmNlIiwiaG9zdEZpYmVyIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nIiwiY29udGFpbmVyRmliZXIiLCJvdmVycmlkZVByb3BzIiwiY29weVdpdGhTZXRJbXBsIiwib2JqIiwiaWR4IiwidXBkYXRlZCIsImNvcHlXaXRoU2V0IiwiZGV2VG9vbHNDb25maWciLCJjdXJyZW50RGlzcGF0Y2hlclJlZiIsImZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyIiwiY3JlYXRlRmliZXJSb290IiwidW5pbml0aWFsaXplZEZpYmVyIiwiY2xvbmVDaGlsZEZpYmVycyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGUiLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuRm9yTWlzc2luZ0tleSIsImNvZXJjZVJlZiIsIm1peGVkUmVmIiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlUG9ydGFsIiwiY3JlYXRlQ2hpbGQiLCJ1cGRhdGVTbG90Iiwib2xkRmliZXIiLCJ1cGRhdGVGcm9tTWFwIiwibmV3SWR4IiwibWF0Y2hlZEZpYmVyIiwid2Fybk9uSW52YWxpZEtleSIsImtub3duS2V5cyIsInJlY29uY2lsZUNoaWxkcmVuQXJyYXkiLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwidG9TdHJpbmdUYWciLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQiLCJpc09iamVjdCIsIl9pc01vY2tGdW5jdGlvbiIsIm1vdW50Q2hpbGRGaWJlcnMiLCJtYXJrVXBkYXRlIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwibmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwiY3VycmVudEhvc3RDb250ZXh0IiwiYnJhbmNoZXMiLCJvbGRJc0hpZGRlbiIsIm5ld0lzSGlkZGVuIiwiYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciIsImNvbnRhaW5lckNoaWxkU2V0IiwiY2hpbGRyZW5VbmNoYW5nZWQiLCJuZXdDaGlsZFNldCIsImN1cnJlbnRJbnN0YW5jZSIsInJlY3ljbGFibGVJbnN0YW5jZSIsIm5ld0luc3RhbmNlIiwiY29tcGxldGVXb3JrIiwiZmliZXJSb290Iiwid2FzSHlkcmF0ZWQiLCJjdXJyZW50RmFsbGJhY2tDaGlsZCIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwiYXR0YWNoUGluZ0xpc3RlbmVyIiwidGhyZWFkSURzIiwicGluZyIsInRocm93RXhjZXB0aW9uIiwiZWFybGllc3RUaW1lb3V0TXMiLCJzdGFydFRpbWVNcyIsInRpbWVvdXRQcm9wTXMiLCJtYXhEdXJhdGlvbiIsImN1cnJlbnRTb3VyY2VGaWJlciIsInVud2luZFdvcmsiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJzaG91bGRDYXB0dXJlU3VzcGVuc2UiLCJsb2dDYXB0dXJlZEVycm9yIiwiY29tcG9uZW50TmFtZU1lc3NhZ2UiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbWJpbmVkTWVzc2FnZSIsInNob3dFcnJvckRpYWxvZyIsInRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJzZXRJbml0aWFsUHJvcGVydGllcyIsImRpZmZQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydGllcyIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRUZXh0Iiwid2FybkZvclVubWF0Y2hlZFRleHQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCIsImRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uIiwiZGlkV2FyblNoYWR5RE9NIiwiREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwiLCJTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkciLCJTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyIsIkFVVE9GT0NVUyIsIkNISUxEUkVOIiwiU1RZTEUiLCJIVE1MIiwid2FybmVkVW5rbm93blRhZ3MiLCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50Iiwid2FybkZvclRleHREaWZmZXJlbmNlIiwid2FybkZvclByb3BEaWZmZXJlbmNlIiwid2FybkZvckV4dHJhQXR0cmlidXRlcyIsIndhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciIsImNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmciLCJub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUiLCJub3JtYWxpemVIVE1MIiwiZGlhbG9nIiwid2VidmlldyIsIk5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCIsIk5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCIsIm1hcmt1cCIsIm1hcmt1cFN0cmluZyIsInNlcnZlclRleHQiLCJjbGllbnRUZXh0Iiwibm9ybWFsaXplZENsaWVudFRleHQiLCJub3JtYWxpemVkU2VydmVyVGV4dCIsInNlcnZlclZhbHVlIiwiY2xpZW50VmFsdWUiLCJub3JtYWxpemVkQ2xpZW50VmFsdWUiLCJub3JtYWxpemVkU2VydmVyVmFsdWUiLCJhdHRyaWJ1dGVOYW1lcyIsIm5hbWVzIiwidGVzdEVsZW1lbnQiLCJuYW1lc3BhY2VVUkkiLCJjcmVhdGVFbGVtZW50TlMiLCJpbm5lckhUTUwiLCJlbnN1cmVMaXN0ZW5pbmdUbyIsInJvb3RDb250YWluZXJFbGVtZW50IiwiaXNEb2N1bWVudE9yRnJhZ21lbnQiLCJnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIiLCJvbmNsaWNrIiwic2V0SW5pdGlhbERPTVByb3BlcnRpZXMiLCJkb21FbGVtZW50IiwicHJvcEtleSIsIm5leHRQcm9wIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ3YXNDdXN0b21Db21wb25lbnRUYWciLCJwcm9wVmFsdWUiLCJkaXYiLCJyYXdQcm9wcyIsInNoYWR5Um9vdCIsIm9uQ2xpY2siLCJsYXN0UmF3UHJvcHMiLCJuZXh0UmF3UHJvcHMiLCJsYXN0UHJvcHMiLCJzdHlsZU5hbWUiLCJzdHlsZVVwZGF0ZXMiLCJsYXN0U3R5bGUiLCJsYXN0UHJvcCIsImxhc3RIdG1sIiwiZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInNlcnZlckhUTUwiLCJleHBlY3RlZEhUTUwiLCJleHBlY3RlZFN0eWxlIiwiaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nIiwib3duTmFtZXNwYWNlIiwic3RhbmRhcmROYW1lIiwidGV4dE5vZGUiLCJpc0RpZmZlcmVudCIsInZhbGlkYXRlUHJvcHMiLCJkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiIsImRpZFdhcm5JbnZhbGlkQ2hpbGQiLCJmbGF0dGVuQ2hpbGRyZW4iLCJwb3N0VXBkYXRlV3JhcHBlciIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJ1cGRhdGVPcHRpb25zIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiZGVmYXVsdFNlbGVjdGVkIiwid2FzTXVsdGlwbGUiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwicmV1c2FibGVTVkdDb250YWluZXIiLCJzZXRJbm5lckhUTUwiLCJzdmdOb2RlIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJzZXRUZXh0Q29udGVudCIsImNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyIsInNldFZhbHVlRm9yU3R5bGVzIiwidmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2Iiwic3R5bGVzIiwic2VyaWFsaXplZCIsImRlbGltaXRlciIsInN0eWxlVmFsdWUiLCJpc0N1c3RvbVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJpc1ZhbHVlRW1wdHkiLCJleHBhbmRTaG9ydGhhbmRNYXAiLCJleHBhbmRlZCIsImxvbmdoYW5kcyIsInNob3J0aGFuZFRvTG9uZ2hhbmQiLCJuZXh0U3R5bGVzIiwiZXhwYW5kZWRVcGRhdGVzIiwiZXhwYW5kZWRTdHlsZXMiLCJ3YXJuZWRBYm91dCIsIm9yaWdpbmFsS2V5IiwiY29ycmVjdE9yaWdpbmFsS2V5IiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRQb3NpdGlvbiIsImJvcmRlciIsImJvcmRlckJsb2NrRW5kIiwiYm9yZGVyQmxvY2tTdGFydCIsImJvcmRlckJvdHRvbSIsImJvcmRlckNvbG9yIiwiYm9yZGVySW1hZ2UiLCJib3JkZXJJbmxpbmVFbmQiLCJib3JkZXJJbmxpbmVTdGFydCIsImJvcmRlckxlZnQiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJSaWdodCIsImJvcmRlclN0eWxlIiwiYm9yZGVyVG9wIiwiYm9yZGVyV2lkdGgiLCJjb2x1bW5SdWxlIiwiY29sdW1ucyIsImZsZXgiLCJmbGV4RmxvdyIsImZvbnQiLCJmb250VmFyaWFudCIsImdhcCIsImdyaWQiLCJncmlkQXJlYSIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uR2FwIiwiZ3JpZEdhcCIsImdyaWRSb3ciLCJncmlkUm93R2FwIiwiZ3JpZFRlbXBsYXRlIiwibGlzdFN0eWxlIiwibWFyZ2luIiwibWFza1Bvc2l0aW9uIiwib3V0bGluZSIsInBhZGRpbmciLCJwbGFjZUNvbnRlbnQiLCJwbGFjZUl0ZW1zIiwicGxhY2VTZWxmIiwidGV4dERlY29yYXRpb24iLCJ0ZXh0RW1waGFzaXMiLCJ3b3JkV3JhcCIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJpc1VuaXRsZXNzTnVtYmVyIiwidHJpbSIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW5FbmQiLCJncmlkQ29sdW1uU3BhbiIsImdyaWRDb2x1bW5TdGFydCIsImZvbnRXZWlnaHQiLCJsaW5lQ2xhbXAiLCJsaW5lSGVpZ2h0Iiwib3JwaGFucyIsInRhYlNpemUiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJ6b29tIiwiZmlsbE9wYWNpdHkiLCJmbG9vZE9wYWNpdHkiLCJzdG9wT3BhY2l0eSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwicHJlZml4S2V5IiwiY2hhckF0Iiwic3Vic3RyaW5nIiwicHJvcCIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsInVwcGVyY2FzZVBhdHRlcm4iLCJtc1BhdHRlcm4iLCJ3YXJuVmFsaWRTdHlsZSIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsImh5cGhlblBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJjYW1lbGl6ZSIsIl8iLCJjaGFyYWN0ZXIiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsImFzc2VydFZhbGlkUHJvcHMiLCJ2b2lkRWxlbWVudFRhZ3MiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJtZW51aXRlbSIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJhcmVhIiwiYmFzZSIsImJyIiwiY29sIiwiZW1iZWQiLCJociIsImltZyIsImtleWdlbiIsImxpbmsiLCJtZXRhIiwicGFyYW0iLCJ3YnIiLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJ3YXJuZWRQcm9wZXJ0aWVzIiwickFSSUEiLCJyQVJJQUNhbWVsIiwidmFsaWRhdGVQcm9wZXJ0eSIsImFyaWFOYW1lIiwiY29ycmVjdE5hbWUiLCJ2YWxpZEFyaWFQcm9wZXJ0aWVzIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJhcmlhUHJvcGVydGllcyIsImRpZFdhcm5WYWx1ZU51bGwiLCJFVkVOVF9OQU1FX1JFR0VYIiwiSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYIiwiY2FuVXNlRXZlbnRTeXN0ZW0iLCJpc1Jlc2VydmVkIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsImdldFB1YmxpY0luc3RhbmNlIiwicHJlcGFyZUZvckNvbW1pdCIsInJlc2V0QWZ0ZXJDb21taXQiLCJjcmVhdGVJbnN0YW5jZSIsImFwcGVuZEluaXRpYWxDaGlsZCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsInNob3VsZFNldFRleHRDb250ZW50Iiwic2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImNvbW1pdE1vdW50IiwiY29tbWl0VXBkYXRlIiwicmVzZXRUZXh0Q29udGVudCIsImNvbW1pdFRleHRVcGRhdGUiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwiaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJTdXNwZW5zZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlIiwiU1VTUEVOU0VfU1RBUlRfREFUQSIsIlNVU1BFTlNFX0VORF9EQVRBIiwiZXZlbnRzRW5hYmxlZCIsInNlbGVjdGlvbkluZm9ybWF0aW9uIiwic2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCIsImF1dG9Gb2N1cyIsIm5hbWVzcGFjZSIsInZhbGlkYXRlZFRhZyIsImFuY2VzdG9ySW5mbyIsInBhcmVudEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHREZXYiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJfX2h0bWwiLCJzY2hlZHVsZVRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0Iiwic2NoZWR1bGVQYXNzaXZlRWZmZWN0cyIsInNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayIsImNhbmNlbFBhc3NpdmVFZmZlY3RzIiwiY2FuY2VsRGVmZXJyZWRDYWxsYmFjayIsInJlYWN0Um9vdENvbnRhaW5lciIsImJlZm9yZUNoaWxkIiwibmV4dE5vZGUiLCJzaGltIiwiY2xvbmVJbnN0YW5jZSIsImNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwiZmluYWxpemVDb250YWluZXJDaGlsZHJlbiIsInJlcGxhY2VDb250YWluZXJDaGlsZHJlbiIsImNsb25lSGlkZGVuSW5zdGFuY2UiLCJjbG9uZVVuaGlkZGVuSW5zdGFuY2UiLCJjcmVhdGVIaWRkZW5UZXh0SW5zdGFuY2UiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwic3BlY2lhbFRhZ3MiLCJpblNjb3BlVGFncyIsImJ1dHRvblNjb3BlVGFncyIsImltcGxpZWRFbmRUYWdzIiwiZW1wdHlBbmNlc3RvckluZm8iLCJmb3JtVGFnIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJwVGFnSW5CdXR0b25TY29wZSIsImxpc3RJdGVtVGFnQXV0b2Nsb3NpbmciLCJkbEl0ZW1UYWdBdXRvY2xvc2luZyIsIm9sZEluZm8iLCJpc1RhZ1ZhbGlkV2l0aFBhcmVudCIsInBhcmVudFRhZyIsImZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWciLCJkaWRXYXJuIiwiY2hpbGRUYWciLCJjaGlsZFRleHQiLCJwYXJlbnRJbmZvIiwiaW52YWxpZFBhcmVudCIsImludmFsaWRBbmNlc3RvciIsImludmFsaWRQYXJlbnRPckFuY2VzdG9yIiwiYW5jZXN0b3JUYWciLCJ3YXJuS2V5IiwidGFnRGlzcGxheU5hbWUiLCJ3aGl0ZXNwYWNlSW5mbyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBMkQ7QUFDM0Q7QUFDQTtBQUNBLFdBQUc7O0FBRUgsb0RBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOzs7O0FBSUE7QUFDQSxzREFBOEM7QUFDOUM7QUFDQTtBQUNBLG9DQUE0QjtBQUM1QixxQ0FBNkI7QUFDN0IseUNBQWlDOztBQUVqQywrQ0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxxQ0FBNkI7QUFDN0IscUNBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBLDREQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFhLDRCQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0EsOENBQXNDLHVCQUF1Qjs7QUFFN0Q7QUFDQTs7Ozs7Ozs7Ozs7OztrQkN0ckJ3QkEsUztBQTdCeEI7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7O0FBV0EsSUFBSUMsaUJBQWlCLDBCQUFNLENBQUUsQ0FBN0I7O0FBRUEsSUFBSUMsSUFBSixFQUFhO0FBQ1hELG1CQUFpQix3QkFBU0UsTUFBVCxFQUFpQjtBQUNoQyxRQUFJQSxXQUFXQyxTQUFmLEVBQTBCO0FBQ3hCLFlBQU0sSUFBSUMsS0FBSixDQUFVLDhDQUFWLENBQU47QUFDRDtBQUNGLEdBSkQ7QUFLRDs7QUFFYyxTQUFTTCxTQUFULENBQW1CTSxTQUFuQixFQUE4QkgsTUFBOUIsRUFBc0NJLENBQXRDLEVBQXlDQyxDQUF6QyxFQUE0Q0MsQ0FBNUMsRUFBK0NDLENBQS9DLEVBQWtEQyxDQUFsRCxFQUFxREMsQ0FBckQsRUFBd0Q7QUFDckVYLGlCQUFlRSxNQUFmOztBQUVBLE1BQUksQ0FBQ0csU0FBTCxFQUFnQjtBQUNkLFFBQUlPLGNBQUo7QUFDQSxRQUFJVixXQUFXQyxTQUFmLEVBQTBCO0FBQ3hCUyxjQUFRLElBQUlSLEtBQUosQ0FDTix1RUFDRSw2REFGSSxDQUFSO0FBSUQsS0FMRCxNQUtPO0FBQ0wsVUFBTVMsT0FBTyxDQUFDUCxDQUFELEVBQUlDLENBQUosRUFBT0MsQ0FBUCxFQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLENBQWhCLENBQWI7QUFDQSxVQUFJRyxXQUFXLENBQWY7QUFDQUYsY0FBUSxJQUFJUixLQUFKLENBQ05GLE9BQU9hLE9BQVAsQ0FBZSxLQUFmLEVBQXNCLFlBQVc7QUFDL0IsZUFBT0YsS0FBS0MsVUFBTCxDQUFQO0FBQ0QsT0FGRCxDQURNLENBQVI7QUFLQUYsWUFBTUksSUFBTixHQUFhLHFCQUFiO0FBQ0Q7O0FBRURKLFVBQU1LLFdBQU4sR0FBb0IsQ0FBcEIsQ0FsQmMsQ0FrQlM7QUFDdkIsVUFBTUwsS0FBTjtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7O0FDckREOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQSxJQUFJTSxzQkFBc0IsK0JBQU0sQ0FBRSxDQUFsQzs7QUFFQSxJQUFJakIsSUFBSixFQUFhO0FBQ1hpQix3QkFBc0IsNkJBQVNiLFNBQVQsRUFBb0JILE1BQXBCLEVBQXFDO0FBQUEsc0NBQU5XLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUN6RCxRQUFJWCxXQUFXQyxTQUFmLEVBQTBCO0FBQ3hCLFlBQU0sSUFBSUMsS0FBSixDQUNKLDBFQUNFLGtCQUZFLENBQU47QUFJRDtBQUNELFFBQUlTLEtBQUtNLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBLFlBQU0sSUFBSWYsS0FBSixDQUNKLCtEQURJLENBQU47QUFHRDtBQUNELFFBQUlDLFNBQUosRUFBZTtBQUNiO0FBQ0Q7QUFDRCxRQUFJLE9BQU9lLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbEMsVUFBTUMsaUJBQWlCUixLQUFLUyxHQUFMLENBQVM7QUFBQSxlQUFRLEtBQUtDLElBQWI7QUFBQSxPQUFULENBQXZCO0FBQ0FGLHFCQUFlRyxPQUFmLENBQXVCLGNBQWN0QixNQUFyQzs7QUFFQTtBQUNBO0FBQ0F1QixlQUFTQyxTQUFULENBQW1CQyxLQUFuQixDQUF5QkMsSUFBekIsQ0FBOEJSLFFBQVFSLEtBQXRDLEVBQTZDUSxPQUE3QyxFQUFzREMsY0FBdEQ7QUFDRDtBQUNELFFBQUk7QUFDRjtBQUNBO0FBQ0E7QUFDQSxVQUFJUCxXQUFXLENBQWY7QUFDQSxVQUFNZSxVQUNKLGNBQWMzQixPQUFPYSxPQUFQLENBQWUsS0FBZixFQUFzQjtBQUFBLGVBQU1GLEtBQUtDLFVBQUwsQ0FBTjtBQUFBLE9BQXRCLENBRGhCO0FBRUEsWUFBTSxJQUFJVixLQUFKLENBQVV5QixPQUFWLENBQU47QUFDRCxLQVJELENBUUUsT0FBT0MsQ0FBUCxFQUFVLENBQUU7QUFDZixHQWpDRDtBQWtDRDs7a0JBRWNaLG1COzs7Ozs7Ozs7Ozs7O0FDL0NmOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7O0FBVEE7Ozs7OztBQWdCQSxJQUFJYSxVQUFVYiw2QkFBZDs7QUFFQSxJQUFJakIsSUFBSixFQUFhO0FBQ1g4QixZQUFVLGlCQUFTMUIsU0FBVCxFQUFvQkgsTUFBcEIsRUFBcUM7QUFDN0MsUUFBSUcsU0FBSixFQUFlO0FBQ2I7QUFDRDtBQUNELFFBQU0yQix5QkFBeUJDLCtCQUFxQkQsc0JBQXBEO0FBQ0EsUUFBTUUsUUFBUUYsdUJBQXVCRyxnQkFBdkIsRUFBZDtBQUNBOztBQU42QyxzQ0FBTnRCLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQU83Q0ssb0RBQW9CLEtBQXBCLEVBQTJCaEIsU0FBUyxJQUFwQyxTQUE2Q1csSUFBN0MsR0FBbURxQixLQUFuRDtBQUNELEdBUkQ7QUFTRDs7a0JBRWNILE87Ozs7Ozs7Ozs7OztRQ1VDSyxxQixHQUFBQSxxQjtBQXhDaEI7Ozs7Ozs7OztBQVNPLElBQU1DLG9EQUFzQnBDLElBQTVCOztBQUVQO0FBQ08sSUFBTXFDLG9FQUE4QixLQUFwQzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLDhGQUEyQ3RDLElBQWpEOztBQUVQO0FBQ0E7QUFDTyxJQUFNdUMsNEdBQWtEdkMsSUFBeEQ7O0FBRVA7QUFDTyxJQUFNd0Msd0VBQWdDLEtBQXRDOztBQUVQO0FBQ08sSUFBTUMsb0RBQXNCQyxJQUE1Qjs7QUFFUDtBQUNPLElBQU1DLDBEQUF5QkQsSUFBL0I7O0FBRVA7QUFDTyxJQUFNRSxzRUFBK0IsS0FBckMsQyxDQUE0Qzs7QUFFbkQ7QUFDTyxJQUFNQyw4REFBMkIsS0FBakM7O0FBRVA7QUFDTyxTQUFTVixxQkFBVCxHQUFpQztBQUN0QyxRQUFNLElBQUloQyxLQUFKLENBQVUsa0JBQVYsQ0FBTjtBQUNEOztBQUVEO0FBQ0E7QUFDTyxJQUFNMkMsc0VBQStCLEtBQXJDOztBQUVQO0FBQ0E7QUFDTyxJQUFNQywwRUFBaUMsS0FBdkM7O0FBRUEsSUFBTUMsb0ZBQXNDLEtBQTVDLEM7Ozs7Ozs7Ozs7OztBQ3RCQSxJQUFNQyxnREFBb0IsQ0FBMUIsQyxDQTlCUDs7Ozs7Ozs7O0FBK0JPLElBQU1DLDBDQUFpQixDQUF2QjtBQUNBLElBQU1DLDBEQUF5QixDQUEvQixDLENBQWtDO0FBQ2xDLElBQU1DLDhCQUFXLENBQWpCLEMsQ0FBb0I7QUFDcEIsSUFBTUMsa0NBQWEsQ0FBbkIsQyxDQUFzQjtBQUN0QixJQUFNQyx3Q0FBZ0IsQ0FBdEI7QUFDQSxJQUFNQyw4QkFBVyxDQUFqQjtBQUNBLElBQU1DLDhCQUFXLENBQWpCO0FBQ0EsSUFBTUMsc0JBQU8sQ0FBYjtBQUNBLElBQU1DLDRDQUFrQixDQUF4QjtBQUNBLElBQU1DLDRDQUFrQixFQUF4QjtBQUNBLElBQU1DLGtDQUFhLEVBQW5CO0FBQ0EsSUFBTUMsOEJBQVcsRUFBakI7QUFDQSxJQUFNQyxnREFBb0IsRUFBMUI7QUFDQSxJQUFNQyx3Q0FBZ0IsRUFBdEI7QUFDQSxJQUFNQyxvREFBc0IsRUFBNUI7QUFDQSxJQUFNQyx3Q0FBZ0IsRUFBdEI7QUFDQSxJQUFNQyw4REFBMkIsRUFBakM7QUFDQSxJQUFNQyxvRUFBOEIsRUFBcEMsQzs7Ozs7Ozs7Ozs7Ozs4UUNoRFA7Ozs7Ozs7OztBQVdBOzs7O0FBQ0E7O0FBYUE7Ozs7QUFFQSxTQUFTQyxjQUFULENBQ0VDLFNBREYsRUFFRUMsU0FGRixFQUdFQyxXQUhGLEVBSVU7QUFDUixNQUFNQyxlQUFlRixVQUFVRyxXQUFWLElBQXlCSCxVQUFVdkQsSUFBbkMsSUFBMkMsRUFBaEU7QUFDQSxTQUNHc0QsU0FBRCxDQUFpQkksV0FBakIsS0FDQ0QsaUJBQWlCLEVBQWpCLEdBQXlCRCxXQUF6QixTQUF3Q0MsWUFBeEMsU0FBMERELFdBRDNELENBREY7QUFJRDs7QUFFRCxTQUFTRyxnQkFBVCxDQUEwQkMsSUFBMUIsRUFBc0Q7QUFDcEQsTUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFJM0UsSUFBSixFQUFhO0FBQ1gsUUFBSSxPQUFRMkUsSUFBRCxDQUFZQyxHQUFuQixLQUEyQixRQUEvQixFQUF5QztBQUN2Qyx5Q0FDRSxLQURGLEVBRUUsMERBQ0Usc0RBSEo7QUFLRDtBQUNGO0FBQ0QsTUFBSSxPQUFPRCxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCLFdBQU9BLEtBQUtGLFdBQUwsSUFBb0JFLEtBQUs1RCxJQUF6QixJQUFpQyxJQUF4QztBQUNEO0FBQ0QsTUFBSSxPQUFPNEQsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixXQUFPQSxJQUFQO0FBQ0Q7QUFDRCxVQUFRQSxJQUFSO0FBQ0UsU0FBS0Usd0NBQUw7QUFDRSxhQUFPLGdCQUFQO0FBQ0YsU0FBS0MsaUNBQUw7QUFDRSxhQUFPLFVBQVA7QUFDRixTQUFLQywrQkFBTDtBQUNFLGFBQU8sUUFBUDtBQUNGLFNBQUtDLGlDQUFMO0FBQ0U7QUFDRixTQUFLQyxvQ0FBTDtBQUNFLGFBQU8sWUFBUDtBQUNGLFNBQUtDLGlDQUFMO0FBQ0UsYUFBTyxVQUFQO0FBWko7QUFjQSxNQUFJLFFBQU9QLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBcEIsRUFBOEI7QUFDNUIsWUFBUUEsS0FBS1EsUUFBYjtBQUNFLFdBQUtDLGdDQUFMO0FBQ0UsZUFBTyxrQkFBUDtBQUNGLFdBQUtDLGlDQUFMO0FBQ0UsZUFBTyxrQkFBUDtBQUNGLFdBQUtDLG9DQUFMO0FBQ0UsZUFBT2xCLGVBQWVPLElBQWYsRUFBcUJBLEtBQUtZLE1BQTFCLEVBQWtDLFlBQWxDLENBQVA7QUFDRixXQUFLQyw2QkFBTDtBQUNFLGVBQU9kLGlCQUFpQkMsS0FBS0EsSUFBdEIsQ0FBUDtBQUNGLFdBQUtjLDZCQUFMO0FBQXNCO0FBQ3BCLGNBQU1DLFdBQWtDZixJQUF4QztBQUNBLGNBQU1nQixtQkFBbUIscURBQTRCRCxRQUE1QixDQUF6QjtBQUNBLGNBQUlDLGdCQUFKLEVBQXNCO0FBQ3BCLG1CQUFPakIsaUJBQWlCaUIsZ0JBQWpCLENBQVA7QUFDRDtBQUNGO0FBZkg7QUFpQkQ7QUFDRCxTQUFPLElBQVA7QUFDRDs7a0JBRWNqQixnQjs7Ozs7Ozs7Ozs7Ozs7O1FDM0NDa0IsYSxHQUFBQSxhO0FBcERoQjs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBLElBQU1DLFlBQVksT0FBT0MsTUFBUCxLQUFrQixVQUFsQixJQUFnQ0EsT0FBT0MsR0FBekQ7O0FBRU8sSUFBTUMsa0RBQXFCSCxZQUM5QkMsT0FBT0MsR0FBUCxDQUFXLGVBQVgsQ0FEOEIsR0FFOUIsTUFGRztBQUdBLElBQU1oQixnREFBb0JjLFlBQzdCQyxPQUFPQyxHQUFQLENBQVcsY0FBWCxDQUQ2QixHQUU3QixNQUZHO0FBR0EsSUFBTWpCLG9EQUFzQmUsWUFDL0JDLE9BQU9DLEdBQVAsQ0FBVyxnQkFBWCxDQUQrQixHQUUvQixNQUZHO0FBR0EsSUFBTWQsMERBQXlCWSxZQUNsQ0MsT0FBT0MsR0FBUCxDQUFXLG1CQUFYLENBRGtDLEdBRWxDLE1BRkc7QUFHQSxJQUFNZixvREFBc0JhLFlBQy9CQyxPQUFPQyxHQUFQLENBQVcsZ0JBQVgsQ0FEK0IsR0FFL0IsTUFGRztBQUdBLElBQU1WLG9EQUFzQlEsWUFDL0JDLE9BQU9DLEdBQVAsQ0FBVyxnQkFBWCxDQUQrQixHQUUvQixNQUZHO0FBR0EsSUFBTVgsa0RBQXFCUyxZQUM5QkMsT0FBT0MsR0FBUCxDQUFXLGVBQVgsQ0FEOEIsR0FFOUIsTUFGRztBQUdBLElBQU1FLHdEQUF3QkosWUFDakNDLE9BQU9DLEdBQVAsQ0FBVyxrQkFBWCxDQURpQyxHQUVqQyxNQUZHO0FBR0EsSUFBTWxCLGtFQUE2QmdCLFlBQ3RDQyxPQUFPQyxHQUFQLENBQVcsdUJBQVgsQ0FEc0MsR0FFdEMsTUFGRztBQUdBLElBQU1ULDBEQUF5Qk8sWUFDbENDLE9BQU9DLEdBQVAsQ0FBVyxtQkFBWCxDQURrQyxHQUVsQyxNQUZHO0FBR0EsSUFBTWIsb0RBQXNCVyxZQUMvQkMsT0FBT0MsR0FBUCxDQUFXLGdCQUFYLENBRCtCLEdBRS9CLE1BRkc7QUFHQSxJQUFNUCw0Q0FBa0JLLFlBQVlDLE9BQU9DLEdBQVAsQ0FBVyxZQUFYLENBQVosR0FBdUMsTUFBL0Q7QUFDQSxJQUFNTiw0Q0FBa0JJLFlBQVlDLE9BQU9DLEdBQVAsQ0FBVyxZQUFYLENBQVosR0FBdUMsTUFBL0Q7O0FBRVAsSUFBTUcsd0JBQXdCLE9BQU9KLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0NBLE9BQU9LLFFBQXJFO0FBQ0EsSUFBTUMsdUJBQXVCLFlBQTdCOztBQUVPLFNBQVNSLGFBQVQsQ0FBdUJTLGFBQXZCLEVBQWlFO0FBQ3RFLE1BQUlBLGtCQUFrQixJQUFsQixJQUEwQixRQUFPQSxhQUFQLHlDQUFPQSxhQUFQLE9BQXlCLFFBQXZELEVBQWlFO0FBQy9ELFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBTUMsZ0JBQ0hKLHlCQUF5QkcsY0FBY0gscUJBQWQsQ0FBMUIsSUFDQUcsY0FBY0Qsb0JBQWQsQ0FGRjtBQUdBLE1BQUksT0FBT0UsYUFBUCxLQUF5QixVQUE3QixFQUF5QztBQUN2QyxXQUFPQSxhQUFQO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7O1FDZGVDLDJCLEdBQUFBLDJCO1FBYUFDLG1DLEdBQUFBLG1DO1FBYUFDLHlCLEdBQUFBLHlCO1FBWUFDLGlCLEdBQUFBLGlCO1FBUUFDLGUsR0FBQUEsZTtRQVFBQyxlLEdBQUFBLGU7O0FBNUZoQjs7OztBQUNBOztBQVFBOzs7O0FBQ0E7Ozs7OztBQUdBLElBQU03RSx5QkFBeUJDLCtCQUFxQkQsc0JBQXBELEMsQ0F4QkE7Ozs7Ozs7OztBQTRCQSxTQUFTOEUsYUFBVCxDQUF1QkMsS0FBdkIsRUFBNkM7QUFDM0MsVUFBUUEsTUFBTWxDLEdBQWQ7QUFDRSxTQUFLeEIsdUJBQUw7QUFDQSxTQUFLQyx5QkFBTDtBQUNBLFNBQUtFLHVCQUFMO0FBQ0EsU0FBS0MsdUJBQUw7QUFDQSxTQUFLRyw4QkFBTDtBQUNBLFNBQUtELDhCQUFMO0FBQ0UsYUFBTyxFQUFQO0FBQ0Y7QUFDRSxVQUFNcUQsUUFBUUQsTUFBTUUsV0FBcEI7QUFDQSxVQUFNQyxTQUFTSCxNQUFNSSxZQUFyQjtBQUNBLFVBQU1uRyxPQUFPLGdDQUFpQitGLE1BQU1uQyxJQUF2QixDQUFiO0FBQ0EsVUFBSXdDLFlBQVksSUFBaEI7QUFDQSxVQUFJSixLQUFKLEVBQVc7QUFDVEksb0JBQVksZ0NBQWlCSixNQUFNcEMsSUFBdkIsQ0FBWjtBQUNEO0FBQ0QsYUFBTyxzQ0FBdUI1RCxJQUF2QixFQUE2QmtHLE1BQTdCLEVBQXFDRSxTQUFyQyxDQUFQO0FBaEJKO0FBa0JEOztBQUVNLFNBQVNaLDJCQUFULENBQXFDYSxjQUFyQyxFQUFvRTtBQUN6RSxNQUFJQyxPQUFPLEVBQVg7QUFDQSxNQUFJQyxPQUFPRixjQUFYO0FBQ0EsS0FBRztBQUNEQyxZQUFRUixjQUFjUyxJQUFkLENBQVI7QUFDQUEsV0FBT0EsS0FBS0MsTUFBWjtBQUNELEdBSEQsUUFHU0QsSUFIVDtBQUlBLFNBQU9ELElBQVA7QUFDRDs7QUFFTSxJQUFJRyw0QkFBd0IsSUFBNUI7QUFDQSxJQUFJQyx3QkFBK0IsSUFBbkM7O0FBRUEsU0FBU2pCLG1DQUFULEdBQThEO0FBQ25FLE1BQUl4RyxJQUFKLEVBQWE7QUFDWCxRQUFJd0gsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixhQUFPLElBQVA7QUFDRDtBQUNELFFBQU1ULFFBQVFTLFFBQVFSLFdBQXRCO0FBQ0EsUUFBSUQsVUFBVSxJQUFWLElBQWtCLE9BQU9BLEtBQVAsS0FBaUIsV0FBdkMsRUFBb0Q7QUFDbEQsYUFBTyxnQ0FBaUJBLE1BQU1wQyxJQUF2QixDQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVNLFNBQVM4Qix5QkFBVCxHQUE2QztBQUNsRCxNQUFJekcsSUFBSixFQUFhO0FBQ1gsUUFBSXdILFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsYUFBTyxFQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsV0FBT2pCLDRCQUE0QmlCLE9BQTVCLENBQVA7QUFDRDtBQUNELFNBQU8sRUFBUDtBQUNEOztBQUVNLFNBQVNkLGlCQUFULEdBQTZCO0FBQ2xDLE1BQUkxRyxJQUFKLEVBQWE7QUFDWCtCLDJCQUF1QjJGLGVBQXZCLEdBQXlDLElBQXpDO0FBQ0EsWUEvQk9GLE9BK0JQLGFBQVUsSUFBVjtBQUNBLFlBL0JPQyxLQStCUCxXQUFRLElBQVI7QUFDRDtBQUNGOztBQUVNLFNBQVNkLGVBQVQsQ0FBeUJHLEtBQXpCLEVBQXVDO0FBQzVDLE1BQUk5RyxJQUFKLEVBQWE7QUFDWCtCLDJCQUF1QjJGLGVBQXZCLEdBQXlDakIseUJBQXpDO0FBQ0EsWUF2Q09lLE9BdUNQLGFBQVVWLEtBQVY7QUFDQSxZQXZDT1csS0F1Q1AsV0FBUSxJQUFSO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTYixlQUFULENBQXlCZSxjQUF6QixFQUFnRTtBQUNyRSxNQUFJM0gsSUFBSixFQUFhO0FBQ1gsWUE3Q095SCxLQTZDUCxXQUFRRSxjQUFSO0FBQ0Q7QUFDRixDOzs7Ozs7Ozs7Ozs7OztBQ2hHRDtBQUNPLElBQU1DLFdBQVcsa0JBQVgsbUJBQThCLENBQXBDLEMsQ0FaUDs7Ozs7Ozs7O0FBYU8sSUFBTUMsZ0JBQWdCLGFBQWhCLHdCQUE4QixDQUFwQzs7QUFFUDtBQUNPLElBQU1DLFlBQVksaUJBQVosb0JBQThCLENBQXBDO0FBQ0EsSUFBTUMsU0FBUyxvQkFBVCxpQkFBOEIsQ0FBcEM7QUFDQSxJQUFNQyxxQkFBcUIsUUFBckIsNkJBQThCLENBQXBDO0FBQ0EsSUFBTUMsV0FBVyxrQkFBWCxtQkFBOEIsQ0FBcEM7QUFDQSxJQUFNQyxlQUFlLGNBQWYsdUJBQThCLEVBQXBDO0FBQ0EsSUFBTUMsV0FBVyxrQkFBWCxtQkFBOEIsRUFBcEM7QUFDQSxJQUFNQyxhQUFhLGdCQUFiLHFCQUE4QixFQUFwQztBQUNBLElBQU1DLE1BQU0sdUJBQU4sY0FBOEIsR0FBcEM7QUFDQSxJQUFNQyxXQUFXLGtCQUFYLG1CQUE4QixHQUFwQztBQUNBLElBQU1DLFVBQVUsbUJBQVYsa0JBQThCLEdBQXBDOztBQUVQO0FBQ08sSUFBTUMsc0JBQXNCLE9BQXRCLDhCQUE4QixHQUFwQzs7QUFFUDtBQUNPLElBQU1DLGlCQUFpQixZQUFqQix5QkFBOEIsSUFBcEM7O0FBRUEsSUFBTUMsYUFBYSxnQkFBYixxQkFBOEIsSUFBcEM7QUFDQSxJQUFNQyxnQkFBZ0IsYUFBaEIsd0JBQThCLElBQXBDLEM7Ozs7Ozs7Ozs7Ozs7UUNiU0Msa0IsR0FBQUEsa0I7UUFLQUMsa0IsR0FBQUEsa0I7UUF5QkFDLHNCLEdBQUFBLHNCO1FBd0JBQyw0QixHQUFBQSw0Qjs7QUFsRWhCOzs7Ozs7QUFJTyxJQUFNQywwQkFBUyxDQUFmLEMsQ0FiUDs7Ozs7Ozs7O0FBY08sSUFBTUMsd0JBQVEsQ0FBZDtBQUNBLElBQU1DLHNCQUFPQywyQkFBYjs7QUFFUCxJQUFNQyxZQUFZLEVBQWxCO0FBQ0EsSUFBTUMsc0JBQXNCRiw4QkFBd0IsQ0FBcEQ7O0FBRUE7QUFDTyxTQUFTUCxrQkFBVCxDQUE0QlUsRUFBNUIsRUFBd0Q7QUFDN0Q7QUFDQSxTQUFPRCx1QkFBd0JDLEtBQUtGLFNBQU4sR0FBbUIsQ0FBMUMsQ0FBUDtBQUNEOztBQUVNLFNBQVNQLGtCQUFULENBQTRCVSxjQUE1QixFQUFvRTtBQUN6RSxTQUFPLENBQUNGLHNCQUFzQkUsY0FBdkIsSUFBeUNILFNBQWhEO0FBQ0Q7O0FBRUQsU0FBU0ksT0FBVCxDQUFpQkMsR0FBakIsRUFBOEJDLFNBQTlCLEVBQXlEO0FBQ3ZELFNBQU8sQ0FBQyxDQUFFRCxNQUFNQyxTQUFQLEdBQW9CLENBQXJCLElBQTBCLENBQTNCLElBQWdDQSxTQUF2QztBQUNEOztBQUVELFNBQVNDLHVCQUFULENBQ0VDLFdBREYsRUFFRUMsY0FGRixFQUdFQyxZQUhGLEVBSWtCO0FBQ2hCLFNBQ0VULHNCQUNBRyxRQUNFSCxzQkFBc0JPLFdBQXRCLEdBQW9DQyxpQkFBaUJULFNBRHZELEVBRUVVLGVBQWVWLFNBRmpCLENBRkY7QUFPRDs7QUFFTSxJQUFNVyw0REFBMEIsSUFBaEM7QUFDQSxJQUFNQyw0REFBMEIsR0FBaEM7O0FBRUEsU0FBU2xCLHNCQUFULENBQ0xjLFdBREssRUFFVztBQUNoQixTQUFPRCx3QkFDTEMsV0FESyxFQUVMRyx1QkFGSyxFQUdMQyx1QkFISyxDQUFQO0FBS0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1DLDhEQUEyQmpLLEtBQU9BLEdBQUcsR0FBVixHQUFnQixHQUFqRDtBQUNBLElBQU1rSyw4REFBMkIsR0FBakM7O0FBRUEsU0FBU25CLDRCQUFULENBQXNDYSxXQUF0QyxFQUFtRTtBQUN4RSxTQUFPRCx3QkFDTEMsV0FESyxFQUVMSyx3QkFGSyxFQUdMQyx3QkFISyxDQUFQO0FBS0QsQzs7Ozs7Ozs7Ozs7OztBQzFFRDs7OztBQUNBOzs7Ozs7QUFSQTs7Ozs7OztBQVVBLElBQU1sSSx1QkFDSm1JLGdCQUFNQyxrREFEUjs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrQkFFZUMsOEI7Ozs7Ozs7Ozs7Ozs7OztBQ0RmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFaQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7OztBQUNBOzs7Ozs7QUFWQTs7Ozs7OztBQU9BOztBQUtBLElBQU1DLGtCQUFrQixFQUF4Qjs7QUFFQTs7OztBQUlBLElBQU1DLGlCQUFpQjtBQUNyQjVGLFFBQU0sSUFEZTtBQUVyQjZGLFVBQVEsSUFGYTtBQUdyQjtBQUNBQyxpQkFBZSx5QkFBVztBQUN4QixXQUFPLElBQVA7QUFDRCxHQU5vQjtBQU9yQkMsY0FBWSxJQVBTO0FBUXJCQyxXQUFTLElBUlk7QUFTckJDLGNBQVksSUFUUztBQVVyQkMsYUFBVyxtQkFBU0MsS0FBVCxFQUFnQjtBQUN6QixXQUFPQSxNQUFNRCxTQUFOLElBQW1CRSxLQUFLQyxHQUFMLEVBQTFCO0FBQ0QsR0Fab0I7QUFhckJDLG9CQUFrQixJQWJHO0FBY3JCQyxhQUFXO0FBZFUsQ0FBdkI7O0FBaUJBLFNBQVNDLHVCQUFULEdBQW1DO0FBQ2pDLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVNDLHdCQUFULEdBQW9DO0FBQ2xDLFNBQU8sS0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsU0FBU0MsY0FBVCxDQUNFQyxjQURGLEVBRUVDLFVBRkYsRUFHRUMsV0FIRixFQUlFQyxpQkFKRixFQUtFO0FBQ0EsTUFBSXpMLElBQUosRUFBYTtBQUNYO0FBQ0EsV0FBTyxLQUFLd0wsV0FBWjtBQUNBLFdBQU8sS0FBS0UsY0FBWjtBQUNBLFdBQU8sS0FBS0MsZUFBWjtBQUNBLFdBQU8sS0FBS0Msa0JBQVo7QUFDQSxXQUFPLEtBQUtDLG9CQUFaO0FBQ0Q7O0FBRUQsT0FBS1AsY0FBTCxHQUFzQkEsY0FBdEI7QUFDQSxPQUFLUSxXQUFMLEdBQW1CUCxVQUFuQjtBQUNBLE9BQUtDLFdBQUwsR0FBbUJBLFdBQW5COztBQUVBLE1BQU1PLFlBQVksS0FBS0MsV0FBTCxDQUFpQkQsU0FBbkM7QUFDQSxPQUFLLElBQU1FLFFBQVgsSUFBdUJGLFNBQXZCLEVBQWtDO0FBQ2hDLFFBQUksQ0FBQ0EsVUFBVUcsY0FBVixDQUF5QkQsUUFBekIsQ0FBTCxFQUF5QztBQUN2QztBQUNEO0FBQ0QsUUFBSWpNLElBQUosRUFBYTtBQUNYLGFBQU8sS0FBS2lNLFFBQUwsQ0FBUCxDQURXLENBQ1k7QUFDeEI7QUFDRCxRQUFNRSxZQUFZSixVQUFVRSxRQUFWLENBQWxCO0FBQ0EsUUFBSUUsU0FBSixFQUFlO0FBQ2IsV0FBS0YsUUFBTCxJQUFpQkUsVUFBVVgsV0FBVixDQUFqQjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUlTLGFBQWEsUUFBakIsRUFBMkI7QUFDekIsYUFBS3pCLE1BQUwsR0FBY2lCLGlCQUFkO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS1EsUUFBTCxJQUFpQlQsWUFBWVMsUUFBWixDQUFqQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFNaEIsbUJBQ0pPLFlBQVlQLGdCQUFaLElBQWdDLElBQWhDLEdBQ0lPLFlBQVlQLGdCQURoQixHQUVJTyxZQUFZWSxXQUFaLEtBQTRCLEtBSGxDO0FBSUEsTUFBSW5CLGdCQUFKLEVBQXNCO0FBQ3BCLFNBQUtXLGtCQUFMLEdBQTBCVCx1QkFBMUI7QUFDRCxHQUZELE1BRU87QUFDTCxTQUFLUyxrQkFBTCxHQUEwQlIsd0JBQTFCO0FBQ0Q7QUFDRCxPQUFLUyxvQkFBTCxHQUE0QlQsd0JBQTVCO0FBQ0EsU0FBTyxJQUFQO0FBQ0Q7O0FBRURpQixPQUFPQyxNQUFQLENBQWNqQixlQUFlNUosU0FBN0IsRUFBd0M7QUFDdENpSyxrQkFBZ0IsMEJBQVc7QUFDekIsU0FBS1QsZ0JBQUwsR0FBd0IsSUFBeEI7QUFDQSxRQUFNSCxRQUFRLEtBQUtVLFdBQW5CO0FBQ0EsUUFBSSxDQUFDVixLQUFMLEVBQVk7QUFDVjtBQUNEOztBQUVELFFBQUlBLE1BQU1ZLGNBQVYsRUFBMEI7QUFDeEJaLFlBQU1ZLGNBQU47QUFDRCxLQUZELE1BRU8sSUFBSSxPQUFPWixNQUFNc0IsV0FBYixLQUE2QixTQUFqQyxFQUE0QztBQUNqRHRCLFlBQU1zQixXQUFOLEdBQW9CLEtBQXBCO0FBQ0Q7QUFDRCxTQUFLUixrQkFBTCxHQUEwQlQsdUJBQTFCO0FBQ0QsR0FkcUM7O0FBZ0J0Q1EsbUJBQWlCLDJCQUFXO0FBQzFCLFFBQU1iLFFBQVEsS0FBS1UsV0FBbkI7QUFDQSxRQUFJLENBQUNWLEtBQUwsRUFBWTtBQUNWO0FBQ0Q7O0FBRUQsUUFBSUEsTUFBTWEsZUFBVixFQUEyQjtBQUN6QmIsWUFBTWEsZUFBTjtBQUNELEtBRkQsTUFFTyxJQUFJLE9BQU9iLE1BQU15QixZQUFiLEtBQThCLFNBQWxDLEVBQTZDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXpCLFlBQU15QixZQUFOLEdBQXFCLElBQXJCO0FBQ0Q7O0FBRUQsU0FBS1Ysb0JBQUwsR0FBNEJWLHVCQUE1QjtBQUNELEdBbENxQzs7QUFvQ3RDOzs7OztBQUtBcUIsV0FBUyxtQkFBVztBQUNsQixTQUFLQyxZQUFMLEdBQW9CdEIsdUJBQXBCO0FBQ0QsR0EzQ3FDOztBQTZDdEM7Ozs7O0FBS0FzQixnQkFBY3JCLHdCQWxEd0I7O0FBb0R0Qzs7O0FBR0FzQixjQUFZLHNCQUFXO0FBQ3JCLFFBQU1YLFlBQVksS0FBS0MsV0FBTCxDQUFpQkQsU0FBbkM7QUFDQSxTQUFLLElBQU1FLFFBQVgsSUFBdUJGLFNBQXZCLEVBQWtDO0FBQ2hDLFVBQUkvTCxJQUFKLEVBQWE7QUFDWHFNLGVBQU9NLGNBQVAsQ0FDRSxJQURGLEVBRUVWLFFBRkYsRUFHRVcsbUNBQW1DWCxRQUFuQyxFQUE2Q0YsVUFBVUUsUUFBVixDQUE3QyxDQUhGO0FBS0QsT0FORCxNQU1PO0FBQ0wsYUFBS0EsUUFBTCxJQUFpQixJQUFqQjtBQUNEO0FBQ0Y7QUFDRCxTQUFLWCxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsU0FBS1EsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtOLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxTQUFLSSxrQkFBTCxHQUEwQlIsd0JBQTFCO0FBQ0EsU0FBS1Msb0JBQUwsR0FBNEJULHdCQUE1QjtBQUNBLFNBQUt5QixrQkFBTCxHQUEwQixJQUExQjtBQUNBLFNBQUtDLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsUUFBSTlNLElBQUosRUFBYTtBQUNYcU0sYUFBT00sY0FBUCxDQUNFLElBREYsRUFFRSxhQUZGLEVBR0VDLG1DQUFtQyxhQUFuQyxFQUFrRCxJQUFsRCxDQUhGO0FBS0FQLGFBQU9NLGNBQVAsQ0FDRSxJQURGLEVBRUUsb0JBRkYsRUFHRUMsbUNBQ0Usb0JBREYsRUFFRXhCLHdCQUZGLENBSEY7QUFRQWlCLGFBQU9NLGNBQVAsQ0FDRSxJQURGLEVBRUUsc0JBRkYsRUFHRUMsbUNBQ0Usc0JBREYsRUFFRXhCLHdCQUZGLENBSEY7QUFRQWlCLGFBQU9NLGNBQVAsQ0FDRSxJQURGLEVBRUUsZ0JBRkYsRUFHRUMsbUNBQW1DLGdCQUFuQyxFQUFxRCxZQUFNLENBQUUsQ0FBN0QsQ0FIRjtBQUtBUCxhQUFPTSxjQUFQLENBQ0UsSUFERixFQUVFLGlCQUZGLEVBR0VDLG1DQUFtQyxpQkFBbkMsRUFBc0QsWUFBTSxDQUFFLENBQTlELENBSEY7QUFLRDtBQUNGO0FBNUdxQyxDQUF4Qzs7QUErR0F2QixlQUFlVSxTQUFmLEdBQTJCeEIsY0FBM0I7O0FBRUE7OztBQUdBYyxlQUFlMEIsTUFBZixHQUF3QixVQUFTaEIsU0FBVCxFQUFvQjtBQUMxQyxNQUFNaUIsUUFBUSxJQUFkOztBQUVBLE1BQU1DLElBQUksU0FBSkEsQ0FBSSxHQUFXLENBQUUsQ0FBdkI7QUFDQUEsSUFBRXhMLFNBQUYsR0FBY3VMLE1BQU12TCxTQUFwQjtBQUNBLE1BQU1BLFlBQVksSUFBSXdMLENBQUosRUFBbEI7O0FBRUEsV0FBU0MsS0FBVCxHQUFpQjtBQUNmLFdBQU9GLE1BQU10TCxLQUFOLENBQVksSUFBWixFQUFrQnlMLFNBQWxCLENBQVA7QUFDRDtBQUNEZCxTQUFPQyxNQUFQLENBQWM3SyxTQUFkLEVBQXlCeUwsTUFBTXpMLFNBQS9CO0FBQ0F5TCxRQUFNekwsU0FBTixHQUFrQkEsU0FBbEI7QUFDQXlMLFFBQU16TCxTQUFOLENBQWdCdUssV0FBaEIsR0FBOEJrQixLQUE5Qjs7QUFFQUEsUUFBTW5CLFNBQU4sR0FBa0JNLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCVSxNQUFNakIsU0FBeEIsRUFBbUNBLFNBQW5DLENBQWxCO0FBQ0FtQixRQUFNSCxNQUFOLEdBQWVDLE1BQU1ELE1BQXJCO0FBQ0FLLG9CQUFrQkYsS0FBbEI7O0FBRUEsU0FBT0EsS0FBUDtBQUNELENBbkJEOztBQXFCQUUsa0JBQWtCL0IsY0FBbEI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTdUIsa0NBQVQsQ0FBNENYLFFBQTVDLEVBQXNEb0IsTUFBdEQsRUFBOEQ7QUFDNUQsTUFBTUMsYUFBYSxPQUFPRCxNQUFQLEtBQWtCLFVBQXJDO0FBQ0EsU0FBTztBQUNMRSxrQkFBYyxJQURUO0FBRUxDLFNBQUtBLEdBRkE7QUFHTEMsU0FBS0E7QUFIQSxHQUFQOztBQU1BLFdBQVNELEdBQVQsQ0FBYUUsR0FBYixFQUFrQjtBQUNoQixRQUFNQyxTQUFTTCxhQUFhLG9CQUFiLEdBQW9DLHNCQUFuRDtBQUNBTSxTQUFLRCxNQUFMLEVBQWEsNkJBQWI7QUFDQSxXQUFPRCxHQUFQO0FBQ0Q7O0FBRUQsV0FBU0QsR0FBVCxHQUFlO0FBQ2IsUUFBTUUsU0FBU0wsYUFDWCxzQkFEVyxHQUVYLHdCQUZKO0FBR0EsUUFBTU8sU0FBU1AsYUFDWCwwQkFEVyxHQUVYLHFCQUZKO0FBR0FNLFNBQUtELE1BQUwsRUFBYUUsTUFBYjtBQUNBLFdBQU9SLE1BQVA7QUFDRDs7QUFFRCxXQUFTTyxJQUFULENBQWNELE1BQWQsRUFBc0JFLE1BQXRCLEVBQThCO0FBQzVCLFFBQU1DLG1CQUFtQixLQUF6QjtBQUNBLHVDQUNFQSxnQkFERixFQUVFLG9GQUNFLDhEQURGLEdBRUUsNkVBRkYsR0FHRSw2REFMSixFQU1FSCxNQU5GLEVBT0UxQixRQVBGLEVBUUU0QixNQVJGO0FBVUQ7QUFDRjs7QUFFRCxTQUFTRSxjQUFULENBQXdCekMsY0FBeEIsRUFBd0NDLFVBQXhDLEVBQW9EQyxXQUFwRCxFQUFpRXdDLFVBQWpFLEVBQTZFO0FBQzNFLE1BQU1DLG1CQUFtQixJQUF6QjtBQUNBLE1BQUlBLGlCQUFpQkMsU0FBakIsQ0FBMkJoTixNQUEvQixFQUF1QztBQUNyQyxRQUFNaU4sV0FBV0YsaUJBQWlCQyxTQUFqQixDQUEyQkUsR0FBM0IsRUFBakI7QUFDQUgscUJBQWlCdE0sSUFBakIsQ0FDRXdNLFFBREYsRUFFRTdDLGNBRkYsRUFHRUMsVUFIRixFQUlFQyxXQUpGLEVBS0V3QyxVQUxGO0FBT0EsV0FBT0csUUFBUDtBQUNEO0FBQ0QsU0FBTyxJQUFJRixnQkFBSixDQUNMM0MsY0FESyxFQUVMQyxVQUZLLEVBR0xDLFdBSEssRUFJTHdDLFVBSkssQ0FBUDtBQU1EOztBQUVELFNBQVNLLGtCQUFULENBQTRCdkQsS0FBNUIsRUFBbUM7QUFDakMsTUFBTW1ELG1CQUFtQixJQUF6QjtBQUNBLDJCQUNFbkQsaUJBQWlCbUQsZ0JBRG5CLEVBRUUsc0VBRkY7QUFJQW5ELFFBQU00QixVQUFOO0FBQ0EsTUFBSXVCLGlCQUFpQkMsU0FBakIsQ0FBMkJoTixNQUEzQixHQUFvQ29KLGVBQXhDLEVBQXlEO0FBQ3ZEMkQscUJBQWlCQyxTQUFqQixDQUEyQkksSUFBM0IsQ0FBZ0N4RCxLQUFoQztBQUNEO0FBQ0Y7O0FBRUQsU0FBU3NDLGlCQUFULENBQTJCYSxnQkFBM0IsRUFBNkM7QUFDM0NBLG1CQUFpQkMsU0FBakIsR0FBNkIsRUFBN0I7QUFDQUQsbUJBQWlCTSxTQUFqQixHQUE2QlIsY0FBN0I7QUFDQUUsbUJBQWlCTyxPQUFqQixHQUEyQkgsa0JBQTNCO0FBQ0Q7O2tCQUVjaEQsYzs7Ozs7Ozs7Ozs7O0FDeFVSLElBQU1vRCxnQ0FBWSxDQUFsQixDLENBVlA7Ozs7Ozs7O0FBV08sSUFBTUMsMENBQWlCLENBQXZCO0FBQ0EsSUFBTUMsa0NBQWEsQ0FBbkI7QUFDQSxJQUFNQyxvQ0FBYyxDQUFwQixDOzs7Ozs7Ozs7Ozs7O1FDdUtTQyxlLEdBQUFBLGU7O0FBektoQjs7QUFJQTs7Ozs7O0FBRUE7Ozs7Ozs7QUFPTyxJQUFNQyxnQ0FBWSwyREFBa0MsT0FBbEMsQ0FBbEIsQyxDQXhCUDs7Ozs7Ozs7O0FBeUJPLElBQU1DLGdEQUFvQiwyREFDL0IsMENBQTJCLGNBQTNCLENBRCtCLENBQTFCO0FBR0EsSUFBTUMsNERBQTBCLDJEQUNyQywwQ0FBMkIsb0JBQTNCLENBRHFDLENBQWhDO0FBR0EsSUFBTUMsb0RBQXNCLDJEQUNqQywwQ0FBMkIsZ0JBQTNCLENBRGlDLENBQTVCO0FBR0EsSUFBTUMsOEJBQVcsMkRBQWtDLE1BQWxDLENBQWpCO0FBQ0EsSUFBTUMsc0NBQWUsMkRBQWtDLFNBQWxDLENBQXJCO0FBQ0EsSUFBTUMsc0RBQXVCLDJEQUNsQyxnQkFEa0MsQ0FBN0I7QUFHQSxJQUFNQyxrQ0FBYSwyREFBa0MsUUFBbEMsQ0FBbkI7QUFDQSxJQUFNQyxrQ0FBYSwyREFBa0MsUUFBbEMsQ0FBbkI7QUFDQSxJQUFNQyxnQ0FBWSwyREFBa0MsT0FBbEMsQ0FBbEI7QUFDQSxJQUFNQyxnQ0FBWSwyREFBa0MsT0FBbEMsQ0FBbEI7QUFDQSxJQUFNQyxvREFBc0IsMkRBQ2pDLGdCQURpQyxDQUE1QjtBQUdBLElBQU1DLHdEQUF3QiwyREFDbkMsa0JBRG1DLENBQTlCO0FBR0EsSUFBTUMsMERBQXlCLDJEQUNwQyxtQkFEb0MsQ0FBL0I7QUFHQSxJQUFNQyw4Q0FBbUIsMkRBQzlCLGFBRDhCLENBQXpCO0FBR0EsSUFBTUMsOEJBQVcsMkRBQWtDLE1BQWxDLENBQWpCO0FBQ0EsSUFBTUMsNEJBQVUsMkRBQWtDLEtBQWxDLENBQWhCO0FBQ0EsSUFBTUMsOENBQW1CLDJEQUFrQyxVQUFsQyxDQUF6QjtBQUNBLElBQU1DLHdDQUFnQiwyREFBa0MsVUFBbEMsQ0FBdEI7QUFDQSxJQUFNQyw4QkFBVywyREFBa0MsTUFBbEMsQ0FBakI7QUFDQSxJQUFNQyxzQ0FBZSwyREFBa0MsU0FBbEMsQ0FBckI7QUFDQSxJQUFNQywwQ0FBaUIsMkRBQWtDLFdBQWxDLENBQXZCO0FBQ0EsSUFBTUMsd0NBQWdCLDJEQUFrQyxVQUFsQyxDQUF0QjtBQUNBLElBQU1DLDBDQUFpQiwyREFBa0MsV0FBbEMsQ0FBdkI7QUFDQSxJQUFNQyx3Q0FBZ0IsMkRBQWtDLFVBQWxDLENBQXRCO0FBQ0EsSUFBTUMsMENBQWlCLDJEQUFrQyxXQUFsQyxDQUF2QjtBQUNBLElBQU1DLDhCQUFXLDJEQUFrQyxNQUFsQyxDQUFqQjtBQUNBLElBQU1DLG9EQUFzQiwyREFDakMsZ0JBRGlDLENBQTVCO0FBR0EsSUFBTUMsb0NBQWMsMkRBQWtDLFNBQWxDLENBQXBCO0FBQ0EsSUFBTUMsd0NBQWdCLDJEQUFrQyxXQUFsQyxDQUF0QjtBQUNBLElBQU1DLGdDQUFZLDJEQUFrQyxPQUFsQyxDQUFsQjtBQUNBLElBQU1DLGdDQUFZLDJEQUFrQyxPQUFsQyxDQUFsQjtBQUNBLElBQU1DLGdDQUFZLDJEQUFrQyxPQUFsQyxDQUFsQjtBQUNBLElBQU1DLDREQUEwQiwyREFDckMsbUJBRHFDLENBQWhDO0FBR0EsSUFBTUMsZ0NBQVksMkRBQWtDLE9BQWxDLENBQWxCO0FBQ0EsSUFBTUMsb0NBQWMsMkRBQWtDLFNBQWxDLENBQXBCO0FBQ0EsSUFBTUMsc0NBQWUsMkRBQWtDLFNBQWxDLENBQXJCO0FBQ0EsSUFBTUMsd0NBQWdCLDJEQUFrQyxVQUFsQyxDQUF0QjtBQUNBLElBQU1DLGtDQUFhLDJEQUFrQyxPQUFsQyxDQUFuQjtBQUNBLElBQU1DLDhCQUFXLDJEQUFrQyxNQUFsQyxDQUFqQjtBQUNBLElBQU1DLDBDQUFpQiwyREFBa0MsV0FBbEMsQ0FBdkI7QUFDQSxJQUFNQyw0Q0FBa0IsMkRBQWtDLFlBQWxDLENBQXhCO0FBQ0EsSUFBTUMsb0RBQXNCLDJEQUNqQyxnQkFEaUMsQ0FBNUI7QUFHQSxJQUFNQyw4REFBMkIsMkRBQ3RDLG9CQURzQyxDQUFqQztBQUdBLElBQU1DLDBDQUFpQiwyREFBa0MsV0FBbEMsQ0FBdkI7QUFDQSxJQUFNQywwQ0FBaUIsMkRBQWtDLFdBQWxDLENBQXZCO0FBQ0EsSUFBTUMsd0NBQWdCLDJEQUFrQyxVQUFsQyxDQUF0QjtBQUNBLElBQU1DLDBDQUFpQiwyREFBa0MsV0FBbEMsQ0FBdkI7QUFDQSxJQUFNQyxzQ0FBZSwyREFBa0MsU0FBbEMsQ0FBckI7QUFDQSxJQUFNQyxnQ0FBWSwyREFBa0MsT0FBbEMsQ0FBbEI7QUFDQSxJQUFNQyxnQ0FBWSwyREFBa0MsT0FBbEMsQ0FBbEI7QUFDQSxJQUFNQyw4QkFBVywyREFBa0MsTUFBbEMsQ0FBakI7QUFDQSxJQUFNQyxvQ0FBYywyREFBa0MsU0FBbEMsQ0FBcEI7QUFDQSxJQUFNQyxrREFBcUIsMkRBQ2hDLGVBRGdDLENBQTNCO0FBR0EsSUFBTUMsOENBQW1CLDJEQUM5QixhQUQ4QixDQUF6QjtBQUdBLElBQU1DLGdEQUFvQiwyREFDL0IsY0FEK0IsQ0FBMUI7QUFHQSxJQUFNQyxnREFBb0IsMkRBQy9CLGNBRCtCLENBQTFCO0FBR0EsSUFBTUMsOENBQW1CLDJEQUM5QixhQUQ4QixDQUF6QjtBQUdBLElBQU1DLDRDQUFrQiwyREFBa0MsWUFBbEMsQ0FBeEI7QUFDQSxJQUFNQyw4Q0FBbUIsMkRBQzlCLGFBRDhCLENBQXpCO0FBR0EsSUFBTUMsMENBQWlCLDJEQUFrQyxXQUFsQyxDQUF2QjtBQUNBLElBQU1DLHNDQUFlLDJEQUFrQyxVQUFsQyxDQUFyQjtBQUNBLElBQU1DLDRDQUFrQiwyREFBa0MsWUFBbEMsQ0FBeEI7QUFDQSxJQUFNQyxnQ0FBWSwyREFBa0MsT0FBbEMsQ0FBbEI7QUFDQSxJQUFNQyxrQ0FBYSwyREFBa0MsUUFBbEMsQ0FBbkI7QUFDQSxJQUFNQyxrQ0FBYSwyREFBa0MsUUFBbEMsQ0FBbkI7QUFDQSxJQUFNQyxvQ0FBYywyREFBa0MsU0FBbEMsQ0FBcEI7QUFDQSxJQUFNQyxzREFBdUIsMkRBQ2xDLGlCQURrQyxDQUE3QjtBQUdBLElBQU1DLG9DQUFjLDJEQUFrQyxTQUFsQyxDQUFwQjtBQUNBLElBQU1DLGtDQUFhLDJEQUFrQyxRQUFsQyxDQUFuQjtBQUNBLElBQU1DLG9DQUFjLDJEQUFrQyxTQUFsQyxDQUFwQjtBQUNBLElBQU1DLDBDQUFpQiwyREFBa0MsV0FBbEMsQ0FBdkI7QUFDQSxJQUFNQyw0Q0FBa0IsMkRBQWtDLFlBQWxDLENBQXhCO0FBQ0EsSUFBTUMsa0NBQWEsMkRBQWtDLFFBQWxDLENBQW5CO0FBQ0EsSUFBTUMsOENBQW1CLDJEQUM5QixhQUQ4QixDQUF6QjtBQUdBLElBQU1DLHdDQUFnQiwyREFBa0MsVUFBbEMsQ0FBdEI7QUFDQSxJQUFNQywwQ0FBaUIsMkRBQWtDLFdBQWxDLENBQXZCO0FBQ0EsSUFBTUMsNENBQWtCLDJEQUFrQyxZQUFsQyxDQUF4QjtBQUNBLElBQU1DLGtEQUFxQiwyREFDaEMsMENBQTJCLGVBQTNCLENBRGdDLENBQTNCO0FBR0EsSUFBTUMsZ0RBQW9CLDJEQUMvQixjQUQrQixDQUExQjtBQUdBLElBQU1DLG9DQUFjLDJEQUFrQyxTQUFsQyxDQUFwQjtBQUNBLElBQU1DLGdDQUFZLDJEQUFrQyxPQUFsQyxDQUFsQjs7QUFFUDtBQUNBO0FBQ0E7QUFDTyxJQUFNQyw0Q0FBa0IsQ0FDN0JsRixTQUQ2QixFQUU3QkssWUFGNkIsRUFHN0JDLG9CQUg2QixFQUk3QnFCLG1CQUo2QixFQUs3QkMsV0FMNkIsRUFNN0JDLGFBTjZCLEVBTzdCQyxTQVA2QixFQVE3QkMsU0FSNkIsRUFTN0JVLGVBVDZCLEVBVTdCQyxtQkFWNkIsRUFXN0JGLGNBWDZCLEVBWTdCVSxTQVo2QixFQWE3QkMsUUFiNkIsRUFjN0JDLFdBZDZCLEVBZTdCUyxZQWY2QixFQWdCN0JDLGVBaEI2QixFQWlCN0JHLFVBakI2QixFQWtCN0JDLFdBbEI2QixFQW1CN0JFLFdBbkI2QixFQW9CN0JFLFdBcEI2QixFQXFCN0JFLGVBckI2QixFQXNCN0JPLGlCQXRCNkIsRUF1QjdCQyxXQXZCNkIsQ0FBeEI7O0FBMEJBLFNBQVNqRixlQUFULENBQXlCb0YsWUFBekIsRUFBcUU7QUFDMUUsU0FBTywyREFBa0NBLFlBQWxDLENBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUN0TEQ7Ozs7Ozs7OztBQVNBOzs7O0FBSU8sSUFBTUMsc0NBQWUsQ0FBckI7QUFDQSxJQUFNQyxnQ0FBWSxDQUFsQjtBQUNBLElBQU1DLHNDQUFlLENBQXJCO0FBQ0EsSUFBTUMsd0NBQWdCLENBQXRCO0FBQ0EsSUFBTUMsMERBQXlCLEVBQS9CLEM7Ozs7Ozs7Ozs7OztRQ0RTQyxpQixHQUFBQSxpQjtRQVFBQywwQixHQUFBQSwwQjtRQTRCQUMsbUIsR0FBQUEsbUI7UUFnQkFDLG1CLEdBQUFBLG1CO1FBWUFDLDRCLEdBQUFBLDRCO1FBSUFDLGdCLEdBQUFBLGdCOztBQTdFaEI7O0FBQ0E7Ozs7OztBQVJBOzs7Ozs7O0FBVUEsSUFBTUMsWUFBWUMsS0FBS0MsTUFBTCxHQUNmQyxRQURlLENBQ04sRUFETSxFQUVmQyxLQUZlLENBRVQsQ0FGUyxDQUFsQjtBQUdBLElBQU1DLHNCQUFzQiw2QkFBNkJMLFNBQXpEO0FBQ0EsSUFBTU0sMkJBQTJCLDBCQUEwQk4sU0FBM0Q7O0FBRU8sU0FBU04saUJBQVQsQ0FBMkJhLFFBQTNCLEVBQXFDOU4sSUFBckMsRUFBMkM7QUFDaERBLE9BQUs0TixtQkFBTCxJQUE0QkUsUUFBNUI7QUFDRDs7QUFFRDs7OztBQUlPLFNBQVNaLDBCQUFULENBQW9DbE4sSUFBcEMsRUFBMEM7QUFDL0MsTUFBSUEsS0FBSzROLG1CQUFMLENBQUosRUFBK0I7QUFDN0IsV0FBTzVOLEtBQUs0TixtQkFBTCxDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxDQUFDNU4sS0FBSzROLG1CQUFMLENBQVIsRUFBbUM7QUFDakMsUUFBSTVOLEtBQUsrTixVQUFULEVBQXFCO0FBQ25CL04sYUFBT0EsS0FBSytOLFVBQVo7QUFDRCxLQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJQyxPQUFPaE8sS0FBSzROLG1CQUFMLENBQVg7QUFDQSxNQUFJSSxLQUFLMVEsR0FBTCxLQUFhdEIsNEJBQWIsSUFBOEJnUyxLQUFLMVEsR0FBTCxLQUFhckIsdUJBQS9DLEVBQXlEO0FBQ3ZEO0FBQ0EsV0FBTytSLElBQVA7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQUlPLFNBQVNiLG1CQUFULENBQTZCbk4sSUFBN0IsRUFBbUM7QUFDeEMsTUFBTWdPLE9BQU9oTyxLQUFLNE4sbUJBQUwsQ0FBYjtBQUNBLE1BQUlJLElBQUosRUFBVTtBQUNSLFFBQUlBLEtBQUsxUSxHQUFMLEtBQWF0Qiw0QkFBYixJQUE4QmdTLEtBQUsxUSxHQUFMLEtBQWFyQix1QkFBL0MsRUFBeUQ7QUFDdkQsYUFBTytSLElBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJTyxTQUFTWixtQkFBVCxDQUE2QlksSUFBN0IsRUFBbUM7QUFDeEMsTUFBSUEsS0FBSzFRLEdBQUwsS0FBYXRCLDRCQUFiLElBQThCZ1MsS0FBSzFRLEdBQUwsS0FBYXJCLHVCQUEvQyxFQUF5RDtBQUN2RDtBQUNBO0FBQ0EsV0FBTytSLEtBQUtDLFNBQVo7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsMkJBQVUsS0FBVixFQUFpQix3Q0FBakI7QUFDRDs7QUFFTSxTQUFTWiw0QkFBVCxDQUFzQ3JOLElBQXRDLEVBQTRDO0FBQ2pELFNBQU9BLEtBQUs2Tix3QkFBTCxLQUFrQyxJQUF6QztBQUNEOztBQUVNLFNBQVNQLGdCQUFULENBQTBCdE4sSUFBMUIsRUFBZ0NrTyxLQUFoQyxFQUF1QztBQUM1Q2xPLE9BQUs2Tix3QkFBTCxJQUFpQ0ssS0FBakM7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUN0RkQ7Ozs7Ozs7OztBQVNPLElBQU1DLGdDQUFxQixDQUFDLEVBQ2pDLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFDQUEsT0FBT0MsUUFEUCxJQUVBRCxPQUFPQyxRQUFQLENBQWdCQyxhQUhpQixDQUE1QixDOzs7Ozs7Ozs7Ozs7O1FDa0pTQyxpQixHQUFBQSxpQjtRQXFDQUMsWSxHQUFBQSxZO1FBMkJBQyxhLEdBQUFBLGE7UUEyRUFDLHFCLEdBQUFBLHFCO1FBeUhBQyxrQixHQUFBQSxrQjtRQWdLQUMsbUMsR0FBQUEsbUM7UUFJQUMsa0MsR0FBQUEsa0M7UUFJQUMsaUIsR0FBQUEsaUI7O0FBOWVoQjs7QUFDQTs7QUFJQTs7QUFDQTs7QUFFQTs7QUFLQTs7QUFFQTs7OztBQUNBOzs7Ozs7QUF6R0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWtETyxJQUFNQyxvQ0FBYyxDQUFwQjtBQUNBLElBQU1DLHNDQUFlLENBQXJCO0FBQ0EsSUFBTUMsb0NBQWMsQ0FBcEI7QUFDQSxJQUFNQyx3Q0FBZ0IsQ0FBdEI7O0FBRVA7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsaUJBQWlCLEtBQXJCOztBQUVBLElBQUlDLGtDQUFKO0FBQ0EsSUFBSUMsaUNBQUo7QUFDTyxJQUFJQyw4RUFBSjtBQUNQLElBQUk1VyxJQUFKLEVBQWE7QUFDWDBXLDhCQUE0QixLQUE1QjtBQUNBQyw2QkFBMkIsSUFBM0I7QUFDQSxVQUpTQyw2QkFJVCxtQ0FBZ0MseUNBQU07QUFDcENELCtCQUEyQixJQUEzQjtBQUNELEdBRkQ7QUFHRDs7QUFFTSxTQUFTZCxpQkFBVCxDQUFrQ2dCLFNBQWxDLEVBQXdFO0FBQzdFLE1BQU1DLFFBQTRCO0FBQ2hDRCx3QkFEZ0M7QUFFaENFLGlCQUFhLElBRm1CO0FBR2hDQyxnQkFBWSxJQUhvQjtBQUloQ0MseUJBQXFCLElBSlc7QUFLaENDLHdCQUFvQixJQUxZO0FBTWhDQyxpQkFBYSxJQU5tQjtBQU9oQ0MsZ0JBQVksSUFQb0I7QUFRaENDLHlCQUFxQixJQVJXO0FBU2hDQyx3QkFBb0I7QUFUWSxHQUFsQztBQVdBLFNBQU9SLEtBQVA7QUFDRDs7QUFFRCxTQUFTUyxnQkFBVCxDQUNFQyxZQURGLEVBRXNCO0FBQ3BCLE1BQU1WLFFBQTRCO0FBQ2hDRCxlQUFXVyxhQUFhWCxTQURRO0FBRWhDRSxpQkFBYVMsYUFBYVQsV0FGTTtBQUdoQ0MsZ0JBQVlRLGFBQWFSLFVBSE87O0FBS2hDO0FBQ0E7QUFDQUMseUJBQXFCLElBUFc7QUFRaENDLHdCQUFvQixJQVJZOztBQVVoQ0MsaUJBQWEsSUFWbUI7QUFXaENDLGdCQUFZLElBWG9COztBQWFoQ0MseUJBQXFCLElBYlc7QUFjaENDLHdCQUFvQjtBQWRZLEdBQWxDO0FBZ0JBLFNBQU9SLEtBQVA7QUFDRDs7QUFFTSxTQUFTaEIsWUFBVCxDQUFzQnZNLGNBQXRCLEVBQWlFO0FBQ3RFLFNBQU87QUFDTEEsb0JBQWdCQSxjQURYOztBQUdMM0UsU0FBS3lSLFdBSEE7QUFJTG9CLGFBQVMsSUFKSjtBQUtMQyxjQUFVLElBTEw7O0FBT0xDLFVBQU0sSUFQRDtBQVFMQyxnQkFBWTtBQVJQLEdBQVA7QUFVRDs7QUFFRCxTQUFTQyxtQkFBVCxDQUNFZixLQURGLEVBRUVnQixNQUZGLEVBR0U7QUFDQTtBQUNBLE1BQUloQixNQUFNRSxVQUFOLEtBQXFCLElBQXpCLEVBQStCO0FBQzdCO0FBQ0FGLFVBQU1DLFdBQU4sR0FBb0JELE1BQU1FLFVBQU4sR0FBbUJjLE1BQXZDO0FBQ0QsR0FIRCxNQUdPO0FBQ0xoQixVQUFNRSxVQUFOLENBQWlCVyxJQUFqQixHQUF3QkcsTUFBeEI7QUFDQWhCLFVBQU1FLFVBQU4sR0FBbUJjLE1BQW5CO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTL0IsYUFBVCxDQUE4QmpQLEtBQTlCLEVBQTRDZ1IsTUFBNUMsRUFBbUU7QUFDeEU7QUFDQSxNQUFNQyxZQUFZalIsTUFBTWlSLFNBQXhCO0FBQ0EsTUFBSUMsZUFBSjtBQUNBLE1BQUlDLGVBQUo7QUFDQSxNQUFJRixjQUFjLElBQWxCLEVBQXdCO0FBQ3RCO0FBQ0FDLGFBQVNsUixNQUFNb1IsV0FBZjtBQUNBRCxhQUFTLElBQVQ7QUFDQSxRQUFJRCxXQUFXLElBQWYsRUFBcUI7QUFDbkJBLGVBQVNsUixNQUFNb1IsV0FBTixHQUFvQnJDLGtCQUFrQi9PLE1BQU1xUixhQUF4QixDQUE3QjtBQUNEO0FBQ0YsR0FQRCxNQU9PO0FBQ0w7QUFDQUgsYUFBU2xSLE1BQU1vUixXQUFmO0FBQ0FELGFBQVNGLFVBQVVHLFdBQW5CO0FBQ0EsUUFBSUYsV0FBVyxJQUFmLEVBQXFCO0FBQ25CLFVBQUlDLFdBQVcsSUFBZixFQUFxQjtBQUNuQjtBQUNBRCxpQkFBU2xSLE1BQU1vUixXQUFOLEdBQW9CckMsa0JBQWtCL08sTUFBTXFSLGFBQXhCLENBQTdCO0FBQ0FGLGlCQUFTRixVQUFVRyxXQUFWLEdBQXdCckMsa0JBQy9Ca0MsVUFBVUksYUFEcUIsQ0FBakM7QUFHRCxPQU5ELE1BTU87QUFDTDtBQUNBSCxpQkFBU2xSLE1BQU1vUixXQUFOLEdBQW9CWCxpQkFBaUJVLE1BQWpCLENBQTdCO0FBQ0Q7QUFDRixLQVhELE1BV087QUFDTCxVQUFJQSxXQUFXLElBQWYsRUFBcUI7QUFDbkI7QUFDQUEsaUJBQVNGLFVBQVVHLFdBQVYsR0FBd0JYLGlCQUFpQlMsTUFBakIsQ0FBakM7QUFDRCxPQUhELE1BR087QUFDTDtBQUNEO0FBQ0Y7QUFDRjtBQUNELE1BQUlDLFdBQVcsSUFBWCxJQUFtQkQsV0FBV0MsTUFBbEMsRUFBMEM7QUFDeEM7QUFDQUosd0JBQW9CRyxNQUFwQixFQUE0QkYsTUFBNUI7QUFDRCxHQUhELE1BR087QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFJRSxPQUFPaEIsVUFBUCxLQUFzQixJQUF0QixJQUE4QmlCLE9BQU9qQixVQUFQLEtBQXNCLElBQXhELEVBQThEO0FBQzVEO0FBQ0FhLDBCQUFvQkcsTUFBcEIsRUFBNEJGLE1BQTVCO0FBQ0FELDBCQUFvQkksTUFBcEIsRUFBNEJILE1BQTVCO0FBQ0QsS0FKRCxNQUlPO0FBQ0w7QUFDQTtBQUNBRCwwQkFBb0JHLE1BQXBCLEVBQTRCRixNQUE1QjtBQUNBO0FBQ0FHLGFBQU9qQixVQUFQLEdBQW9CYyxNQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSTlYLElBQUosRUFBYTtBQUNYLFFBQ0U4RyxNQUFNbEMsR0FBTixLQUFjMUIsNkJBQWQsS0FDQ3lULDZCQUE2QnFCLE1BQTdCLElBQ0VDLFdBQVcsSUFBWCxJQUFtQnRCLDZCQUE2QnNCLE1BRm5ELEtBR0EsQ0FBQ3ZCLHlCQUpILEVBS0U7QUFDQSx5Q0FDRSxLQURGLEVBRUUsc0VBQ0UsbUVBREYsR0FFRSxpRUFGRixHQUdFLFdBTEo7QUFPQUEsa0NBQTRCLElBQTVCO0FBQ0Q7QUFDRjtBQUNGOztBQUVNLFNBQVNWLHFCQUFULENBQ0w1TyxjQURLLEVBRUwwUSxNQUZLLEVBR0w7QUFDQTtBQUNBO0FBQ0EsTUFBSU0sc0JBQXNCaFIsZUFBZThRLFdBQXpDO0FBQ0EsTUFBSUUsd0JBQXdCLElBQTVCLEVBQWtDO0FBQ2hDQSwwQkFBc0JoUixlQUFlOFEsV0FBZixHQUE2QnJDLGtCQUNqRHpPLGVBQWUrUSxhQURrQyxDQUFuRDtBQUdELEdBSkQsTUFJTztBQUNMO0FBQ0E7QUFDQTtBQUNBQywwQkFBc0JDLGtDQUNwQmpSLGNBRG9CLEVBRXBCZ1IsbUJBRm9CLENBQXRCO0FBSUQ7O0FBRUQ7QUFDQSxNQUFJQSxvQkFBb0JsQixrQkFBcEIsS0FBMkMsSUFBL0MsRUFBcUQ7QUFDbkQ7QUFDQWtCLHdCQUFvQm5CLG1CQUFwQixHQUEwQ21CLG9CQUFvQmxCLGtCQUFwQixHQUF5Q1ksTUFBbkY7QUFDRCxHQUhELE1BR087QUFDTE0sd0JBQW9CbEIsa0JBQXBCLENBQXVDUyxJQUF2QyxHQUE4Q0csTUFBOUM7QUFDQU0sd0JBQW9CbEIsa0JBQXBCLEdBQXlDWSxNQUF6QztBQUNEO0FBQ0Y7O0FBRUQsU0FBU08saUNBQVQsQ0FDRWpSLGNBREYsRUFFRTBQLEtBRkYsRUFHc0I7QUFDcEIsTUFBTXRQLFVBQVVKLGVBQWUyUSxTQUEvQjtBQUNBLE1BQUl2USxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQSxRQUFJc1AsVUFBVXRQLFFBQVEwUSxXQUF0QixFQUFtQztBQUNqQ3BCLGNBQVExUCxlQUFlOFEsV0FBZixHQUE2QlgsaUJBQWlCVCxLQUFqQixDQUFyQztBQUNEO0FBQ0Y7QUFDRCxTQUFPQSxLQUFQO0FBQ0Q7O0FBRUQsU0FBU3dCLGtCQUFULENBQ0VsUixjQURGLEVBRUUwUCxLQUZGLEVBR0VnQixNQUhGLEVBSUVTLFNBSkYsRUFLRUMsU0FMRixFQU1FckssUUFORixFQU9PO0FBQ0wsVUFBUTJKLE9BQU9sVCxHQUFmO0FBQ0UsU0FBSzBSLFlBQUw7QUFBbUI7QUFDakIsWUFBTW1CLFdBQVVLLE9BQU9MLE9BQXZCO0FBQ0EsWUFBSSxPQUFPQSxRQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2pDO0FBQ0EsY0FBSXpYLElBQUosRUFBYTtBQUNYO0FBQ0EsZ0JBQ0VxQyxrREFDQ0MsK0RBQ0M4RSxlQUFlcVIsSUFBZixHQUFzQjlKLDJCQUgxQixFQUlFO0FBQ0E4SSx1QkFBUTlWLElBQVIsQ0FBYXdNLFFBQWIsRUFBdUJvSyxTQUF2QixFQUFrQ0MsU0FBbEM7QUFDRDtBQUNGO0FBQ0QsY0FBTUUsWUFBWWpCLFNBQVE5VixJQUFSLENBQWF3TSxRQUFiLEVBQXVCb0ssU0FBdkIsRUFBa0NDLFNBQWxDLENBQWxCO0FBQ0EsY0FBSXhZLElBQUosRUFBYTtBQUNYO0FBQ0Q7QUFDRCxpQkFBTzBZLFNBQVA7QUFDRDtBQUNEO0FBQ0EsZUFBT2pCLFFBQVA7QUFDRDtBQUNELFNBQUtqQixhQUFMO0FBQW9CO0FBQ2xCcFAsdUJBQWV1UixTQUFmLEdBQ0d2UixlQUFldVIsU0FBZixHQUEyQixDQUFDaFEsa0NBQTdCLEdBQThDUCwrQkFEaEQ7QUFFRDtBQUNEO0FBQ0EsU0FBS2lPLFdBQUw7QUFBa0I7QUFDaEIsWUFBTW9CLFlBQVVLLE9BQU9MLE9BQXZCO0FBQ0EsWUFBSW1CLHFCQUFKO0FBQ0EsWUFBSSxPQUFPbkIsU0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQztBQUNBLGNBQUl6WCxJQUFKLEVBQWE7QUFDWDtBQUNBLGdCQUNFcUMsa0RBQ0NDLCtEQUNDOEUsZUFBZXFSLElBQWYsR0FBc0I5SiwyQkFIMUIsRUFJRTtBQUNBOEksd0JBQVE5VixJQUFSLENBQWF3TSxRQUFiLEVBQXVCb0ssU0FBdkIsRUFBa0NDLFNBQWxDO0FBQ0Q7QUFDRjtBQUNESSx5QkFBZW5CLFVBQVE5VixJQUFSLENBQWF3TSxRQUFiLEVBQXVCb0ssU0FBdkIsRUFBa0NDLFNBQWxDLENBQWY7QUFDQSxjQUFJeFksSUFBSixFQUFhO0FBQ1g7QUFDRDtBQUNGLFNBaEJELE1BZ0JPO0FBQ0w7QUFDQTRZLHlCQUFlbkIsU0FBZjtBQUNEO0FBQ0QsWUFBSW1CLGlCQUFpQixJQUFqQixJQUF5QkEsaUJBQWlCMVksU0FBOUMsRUFBeUQ7QUFDdkQ7QUFDQSxpQkFBT3FZLFNBQVA7QUFDRDtBQUNEO0FBQ0EsZUFBT2xNLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCaU0sU0FBbEIsRUFBNkJLLFlBQTdCLENBQVA7QUFDRDtBQUNELFNBQUtyQyxXQUFMO0FBQWtCO0FBQ2hCRSx5QkFBaUIsSUFBakI7QUFDQSxlQUFPOEIsU0FBUDtBQUNEO0FBOURIO0FBZ0VBLFNBQU9BLFNBQVA7QUFDRDs7QUFFTSxTQUFTdEMsa0JBQVQsQ0FDTDdPLGNBREssRUFFTDBQLEtBRkssRUFHTHRCLEtBSEssRUFJTHJILFFBSkssRUFLTDBLLG9CQUxLLEVBTUM7QUFDTnBDLG1CQUFpQixLQUFqQjs7QUFFQUssVUFBUXVCLGtDQUFrQ2pSLGNBQWxDLEVBQWtEMFAsS0FBbEQsQ0FBUjs7QUFFQSxNQUFJOVcsSUFBSixFQUFhO0FBQ1gyVywrQkFBMkJHLEtBQTNCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJZ0MsZUFBZWhDLE1BQU1ELFNBQXpCO0FBQ0EsTUFBSWtDLGlCQUFpQixJQUFyQjtBQUNBLE1BQUlDLG9CQUFvQmhRLGdDQUF4Qjs7QUFFQTtBQUNBLE1BQUk4TyxTQUFTaEIsTUFBTUMsV0FBbkI7QUFDQSxNQUFJa0MsY0FBY0gsWUFBbEI7QUFDQSxTQUFPaEIsV0FBVyxJQUFsQixFQUF3QjtBQUN0QixRQUFNb0IsdUJBQXVCcEIsT0FBT3ZPLGNBQXBDO0FBQ0EsUUFBSTJQLHVCQUF1Qkwsb0JBQTNCLEVBQWlEO0FBQy9DO0FBQ0EsVUFBSUUsbUJBQW1CLElBQXZCLEVBQTZCO0FBQzNCO0FBQ0E7QUFDQUEseUJBQWlCakIsTUFBakI7QUFDQTtBQUNBO0FBQ0FnQix1QkFBZUcsV0FBZjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFVBQUlELG9CQUFvQkUsb0JBQXhCLEVBQThDO0FBQzVDRiw0QkFBb0JFLG9CQUFwQjtBQUNEO0FBQ0YsS0FmRCxNQWVPO0FBQ0w7QUFDQTtBQUNBRCxvQkFBY1gsbUJBQ1psUixjQURZLEVBRVowUCxLQUZZLEVBR1pnQixNQUhZLEVBSVptQixXQUpZLEVBS1p6RCxLQUxZLEVBTVpySCxRQU5ZLENBQWQ7QUFRQSxVQUFNdUosWUFBV0ksT0FBT0osUUFBeEI7QUFDQSxVQUFJQSxjQUFhLElBQWpCLEVBQXVCO0FBQ3JCdFEsdUJBQWV1UixTQUFmLElBQTRCeFEsNkJBQTVCO0FBQ0E7QUFDQTJQLGVBQU9GLFVBQVAsR0FBb0IsSUFBcEI7QUFDQSxZQUFJZCxNQUFNTSxVQUFOLEtBQXFCLElBQXpCLEVBQStCO0FBQzdCTixnQkFBTUssV0FBTixHQUFvQkwsTUFBTU0sVUFBTixHQUFtQlUsTUFBdkM7QUFDRCxTQUZELE1BRU87QUFDTGhCLGdCQUFNTSxVQUFOLENBQWlCUSxVQUFqQixHQUE4QkUsTUFBOUI7QUFDQWhCLGdCQUFNTSxVQUFOLEdBQW1CVSxNQUFuQjtBQUNEO0FBQ0Y7QUFDRjtBQUNEO0FBQ0FBLGFBQVNBLE9BQU9ILElBQWhCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJd0IseUJBQXlCLElBQTdCO0FBQ0FyQixXQUFTaEIsTUFBTUcsbUJBQWY7QUFDQSxTQUFPYSxXQUFXLElBQWxCLEVBQXdCO0FBQ3RCLFFBQU1vQix3QkFBdUJwQixPQUFPdk8sY0FBcEM7QUFDQSxRQUFJMlAsd0JBQXVCTCxvQkFBM0IsRUFBaUQ7QUFDL0M7QUFDQSxVQUFJTSwyQkFBMkIsSUFBL0IsRUFBcUM7QUFDbkM7QUFDQTtBQUNBQSxpQ0FBeUJyQixNQUF6QjtBQUNBO0FBQ0E7QUFDQSxZQUFJaUIsbUJBQW1CLElBQXZCLEVBQTZCO0FBQzNCRCx5QkFBZUcsV0FBZjtBQUNEO0FBQ0Y7QUFDRDtBQUNBO0FBQ0EsVUFBSUQsb0JBQW9CRSxxQkFBeEIsRUFBOEM7QUFDNUNGLDRCQUFvQkUscUJBQXBCO0FBQ0Q7QUFDRixLQWpCRCxNQWlCTztBQUNMO0FBQ0E7QUFDQUQsb0JBQWNYLG1CQUNabFIsY0FEWSxFQUVaMFAsS0FGWSxFQUdaZ0IsTUFIWSxFQUlabUIsV0FKWSxFQUtaekQsS0FMWSxFQU1ackgsUUFOWSxDQUFkO0FBUUEsVUFBTXVKLGFBQVdJLE9BQU9KLFFBQXhCO0FBQ0EsVUFBSUEsZUFBYSxJQUFqQixFQUF1QjtBQUNyQnRRLHVCQUFldVIsU0FBZixJQUE0QnhRLDZCQUE1QjtBQUNBO0FBQ0EyUCxlQUFPRixVQUFQLEdBQW9CLElBQXBCO0FBQ0EsWUFBSWQsTUFBTVEsa0JBQU4sS0FBNkIsSUFBakMsRUFBdUM7QUFDckNSLGdCQUFNTyxtQkFBTixHQUE0QlAsTUFBTVEsa0JBQU4sR0FBMkJRLE1BQXZEO0FBQ0QsU0FGRCxNQUVPO0FBQ0xoQixnQkFBTVEsa0JBQU4sQ0FBeUJNLFVBQXpCLEdBQXNDRSxNQUF0QztBQUNBaEIsZ0JBQU1RLGtCQUFOLEdBQTJCUSxNQUEzQjtBQUNEO0FBQ0Y7QUFDRjtBQUNEQSxhQUFTQSxPQUFPSCxJQUFoQjtBQUNEOztBQUVELE1BQUlvQixtQkFBbUIsSUFBdkIsRUFBNkI7QUFDM0JqQyxVQUFNRSxVQUFOLEdBQW1CLElBQW5CO0FBQ0Q7QUFDRCxNQUFJbUMsMkJBQTJCLElBQS9CLEVBQXFDO0FBQ25DckMsVUFBTUksa0JBQU4sR0FBMkIsSUFBM0I7QUFDRCxHQUZELE1BRU87QUFDTDlQLG1CQUFldVIsU0FBZixJQUE0QnhRLDZCQUE1QjtBQUNEO0FBQ0QsTUFBSTRRLG1CQUFtQixJQUFuQixJQUEyQkksMkJBQTJCLElBQTFELEVBQWdFO0FBQzlEO0FBQ0E7QUFDQUwsbUJBQWVHLFdBQWY7QUFDRDs7QUFFRG5DLFFBQU1ELFNBQU4sR0FBa0JpQyxZQUFsQjtBQUNBaEMsUUFBTUMsV0FBTixHQUFvQmdDLGNBQXBCO0FBQ0FqQyxRQUFNRyxtQkFBTixHQUE0QmtDLHNCQUE1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBL1IsaUJBQWVtQyxjQUFmLEdBQWdDeVAsaUJBQWhDO0FBQ0E1UixpQkFBZStRLGFBQWYsR0FBK0JjLFdBQS9COztBQUVBLE1BQUlqWixJQUFKLEVBQWE7QUFDWDJXLCtCQUEyQixJQUEzQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3lDLFlBQVQsQ0FBc0IxQixRQUF0QixFQUFnQzJCLE9BQWhDLEVBQXlDO0FBQ3ZDLDJCQUNFLE9BQU8zQixRQUFQLEtBQW9CLFVBRHRCLEVBRUUsdUVBQ0UsY0FISixFQUlFQSxRQUpGO0FBTUFBLFdBQVMvVixJQUFULENBQWMwWCxPQUFkO0FBQ0Q7O0FBRU0sU0FBU25ELG1DQUFULEdBQStDO0FBQ3BETyxtQkFBaUIsS0FBakI7QUFDRDs7QUFFTSxTQUFTTixrQ0FBVCxHQUF1RDtBQUM1RCxTQUFPTSxjQUFQO0FBQ0Q7O0FBRU0sU0FBU0wsaUJBQVQsQ0FDTGtELFlBREssRUFFTEMsYUFGSyxFQUdMcEwsUUFISyxFQUlMMEssb0JBSkssRUFLQztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSVUsY0FBY3RDLG1CQUFkLEtBQXNDLElBQTFDLEVBQWdEO0FBQzlDO0FBQ0EsUUFBSXNDLGNBQWN2QyxVQUFkLEtBQTZCLElBQWpDLEVBQXVDO0FBQ3JDdUMsb0JBQWN2QyxVQUFkLENBQXlCVyxJQUF6QixHQUFnQzRCLGNBQWN0QyxtQkFBOUM7QUFDQXNDLG9CQUFjdkMsVUFBZCxHQUEyQnVDLGNBQWNyQyxrQkFBekM7QUFDRDtBQUNEO0FBQ0FxQyxrQkFBY3RDLG1CQUFkLEdBQW9Dc0MsY0FBY3JDLGtCQUFkLEdBQW1DLElBQXZFO0FBQ0Q7O0FBRUQ7QUFDQXNDLHNCQUFvQkQsY0FBY3BDLFdBQWxDLEVBQStDaEosUUFBL0M7QUFDQW9MLGdCQUFjcEMsV0FBZCxHQUE0Qm9DLGNBQWNuQyxVQUFkLEdBQTJCLElBQXZEOztBQUVBb0Msc0JBQW9CRCxjQUFjbEMsbUJBQWxDLEVBQXVEbEosUUFBdkQ7QUFDQW9MLGdCQUFjbEMsbUJBQWQsR0FBb0NrQyxjQUFjakMsa0JBQWQsR0FBbUMsSUFBdkU7QUFDRDs7QUFFRCxTQUFTa0MsbUJBQVQsQ0FDRUMsTUFERixFQUVFdEwsUUFGRixFQUdRO0FBQ04sU0FBT3NMLFdBQVcsSUFBbEIsRUFBd0I7QUFDdEIsUUFBTS9CLGFBQVcrQixPQUFPL0IsUUFBeEI7QUFDQSxRQUFJQSxlQUFhLElBQWpCLEVBQXVCO0FBQ3JCK0IsYUFBTy9CLFFBQVAsR0FBa0IsSUFBbEI7QUFDQTBCLG1CQUFhMUIsVUFBYixFQUF1QnZKLFFBQXZCO0FBQ0Q7QUFDRHNMLGFBQVNBLE9BQU83QixVQUFoQjtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7O1FDbGpCZThCLHVCLEdBQUFBLHVCO1FBV0FDLCtCLEdBQUFBLCtCO1FBTUFDLDhCLEdBQUFBLDhCO1FBTUFDLFksR0FBQUEsWTtRQWtDQUMsVyxHQUFBQSxXO1FBYUFDLG9CLEdBQUFBLG9CO1FBeURBQyxzQixHQUFBQSxzQjtRQXlIQUMsb0IsR0FBQUEsb0I7UUFxQkFDLFcsR0FBQUEsVzs7QUFqVGhCOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFNQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFLQTs7QUFDQTs7QUFDQTs7OztBQTdDQTs7Ozs7Ozs7O0FBK0NBLElBQU1DLGNBQWtDLG1DQUFhLElBQWIsQ0FBeEM7O0FBRUEsSUFBSUMsc0JBQUo7QUFDQSxJQUFJcGEsSUFBSixFQUFhO0FBQ1g7QUFDQW9hLGtCQUFnQixFQUFoQjtBQUNEOztBQUVELElBQUlDLDBCQUF3QyxJQUE1QztBQUNBLElBQUlDLHdCQUF5RCxJQUE3RDtBQUNBLElBQUlDLGlDQUEyRCxJQUEvRDs7QUFFQSxJQUFJQywrQkFBd0MsS0FBNUM7O0FBRU8sU0FBU2QsdUJBQVQsR0FBeUM7QUFDOUM7QUFDQTtBQUNBVyw0QkFBMEIsSUFBMUI7QUFDQUMsMEJBQXdCLElBQXhCO0FBQ0FDLG1DQUFpQyxJQUFqQztBQUNBLE1BQUl2YSxJQUFKLEVBQWE7QUFDWHdhLG1DQUErQixLQUEvQjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU2IsK0JBQVQsR0FBaUQ7QUFDdEQsTUFBSTNaLElBQUosRUFBYTtBQUNYd2EsbUNBQStCLElBQS9CO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTWiw4QkFBVCxHQUFnRDtBQUNyRCxNQUFJNVosSUFBSixFQUFhO0FBQ1h3YSxtQ0FBK0IsS0FBL0I7QUFDRDtBQUNGOztBQUVNLFNBQVNYLFlBQVQsQ0FBeUJZLGFBQXpCLEVBQStDQyxTQUEvQyxFQUFtRTtBQUN4RSxNQUFNckIsVUFBMkJvQixjQUFjOVYsSUFBZCxDQUFtQmdXLFFBQXBEOztBQUVBLE1BQUlDLHVDQUFKLEVBQXVCO0FBQ3JCLCtCQUFLVCxXQUFMLEVBQWtCZCxRQUFRd0IsYUFBMUIsRUFBeUNKLGFBQXpDOztBQUVBcEIsWUFBUXdCLGFBQVIsR0FBd0JILFNBQXhCO0FBQ0EsUUFBSTFhLElBQUosRUFBYTtBQUNYLHlDQUNFcVosUUFBUXlCLGdCQUFSLEtBQTZCNWEsU0FBN0IsSUFDRW1aLFFBQVF5QixnQkFBUixLQUE2QixJQUQvQixJQUVFekIsUUFBUXlCLGdCQUFSLEtBQTZCVixhQUhqQyxFQUlFLDREQUNFLHVEQUxKO0FBT0FmLGNBQVF5QixnQkFBUixHQUEyQlYsYUFBM0I7QUFDRDtBQUNGLEdBZEQsTUFjTztBQUNMLCtCQUFLRCxXQUFMLEVBQWtCZCxRQUFRMEIsY0FBMUIsRUFBMENOLGFBQTFDOztBQUVBcEIsWUFBUTBCLGNBQVIsR0FBeUJMLFNBQXpCO0FBQ0EsUUFBSTFhLElBQUosRUFBYTtBQUNYLHlDQUNFcVosUUFBUTJCLGlCQUFSLEtBQThCOWEsU0FBOUIsSUFDRW1aLFFBQVEyQixpQkFBUixLQUE4QixJQURoQyxJQUVFM0IsUUFBUTJCLGlCQUFSLEtBQThCWixhQUhsQyxFQUlFLDREQUNFLHVEQUxKO0FBT0FmLGNBQVEyQixpQkFBUixHQUE0QlosYUFBNUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBU04sV0FBVCxDQUFxQlcsYUFBckIsRUFBaUQ7QUFDdEQsTUFBTVEsZUFBZWQsWUFBWTNTLE9BQWpDOztBQUVBLDRCQUFJMlMsV0FBSixFQUFpQk0sYUFBakI7O0FBRUEsTUFBTXBCLFVBQTZCb0IsY0FBYzlWLElBQWQsQ0FBbUJnVyxRQUF0RDtBQUNBLE1BQUlDLHVDQUFKLEVBQXVCO0FBQ3JCdkIsWUFBUXdCLGFBQVIsR0FBd0JJLFlBQXhCO0FBQ0QsR0FGRCxNQUVPO0FBQ0w1QixZQUFRMEIsY0FBUixHQUF5QkUsWUFBekI7QUFDRDtBQUNGOztBQUVNLFNBQVNsQixvQkFBVCxDQUNMVixPQURLLEVBRUw2QixRQUZLLEVBR0xDLFFBSEssRUFJTDtBQUNBLE1BQUksd0JBQUdBLFFBQUgsRUFBYUQsUUFBYixDQUFKLEVBQTRCO0FBQzFCO0FBQ0EsV0FBTyxDQUFQO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsUUFBTUUsY0FDSixPQUFPL0IsUUFBUWdDLHFCQUFmLEtBQXlDLFVBQXpDLEdBQ0loQyxRQUFRZ0MscUJBQVIsQ0FBOEJGLFFBQTlCLEVBQXdDRCxRQUF4QyxDQURKLEdBRUkvUiwyQkFITjs7QUFLQSxRQUFJbkosSUFBSixFQUFhO0FBQ1gsNkJBQ0UsQ0FBQ29iLGNBQWNqUywyQkFBZixNQUEwQ2lTLFdBRDVDLEVBRUUsNkRBQ0Usc0NBSEosRUFJRUEsV0FKRjtBQU1EO0FBQ0QsV0FBT0EsY0FBYyxDQUFyQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0Usd0JBQVQsQ0FDRUMsTUFERixFQUVFMUMsb0JBRkYsRUFHRTtBQUNBO0FBQ0E7QUFDQSxNQUFJdlIsT0FBT2lVLE1BQVg7QUFDQSxTQUFPalUsU0FBUyxJQUFoQixFQUFzQjtBQUNwQixRQUFJeVEsWUFBWXpRLEtBQUt5USxTQUFyQjtBQUNBLFFBQUl6USxLQUFLa1UsbUJBQUwsR0FBMkIzQyxvQkFBL0IsRUFBcUQ7QUFDbkR2UixXQUFLa1UsbUJBQUwsR0FBMkIzQyxvQkFBM0I7QUFDQSxVQUNFZCxjQUFjLElBQWQsSUFDQUEsVUFBVXlELG1CQUFWLEdBQWdDM0Msb0JBRmxDLEVBR0U7QUFDQWQsa0JBQVV5RCxtQkFBVixHQUFnQzNDLG9CQUFoQztBQUNEO0FBQ0YsS0FSRCxNQVFPLElBQ0xkLGNBQWMsSUFBZCxJQUNBQSxVQUFVeUQsbUJBQVYsR0FBZ0MzQyxvQkFGM0IsRUFHTDtBQUNBZCxnQkFBVXlELG1CQUFWLEdBQWdDM0Msb0JBQWhDO0FBQ0QsS0FMTSxNQUtBO0FBQ0w7QUFDQTtBQUNBO0FBQ0Q7QUFDRHZSLFdBQU9BLEtBQUtDLE1BQVo7QUFDRDtBQUNGOztBQUVNLFNBQVN5UyxzQkFBVCxDQUNMNVMsY0FESyxFQUVMaVMsT0FGSyxFQUdMK0IsV0FISyxFQUlMdkMsb0JBSkssRUFLQztBQUNOLE1BQUkvUixRQUFRTSxlQUFlcVUsS0FBM0I7QUFDQSxNQUFJM1UsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCO0FBQ0FBLFVBQU1TLE1BQU4sR0FBZUgsY0FBZjtBQUNEO0FBQ0QsU0FBT04sVUFBVSxJQUFqQixFQUF1QjtBQUNyQixRQUFJNFUsa0JBQUo7O0FBRUE7QUFDQSxRQUFNQyxPQUFPN1UsTUFBTThVLG1CQUFuQjtBQUNBLFFBQUlELFNBQVMsSUFBYixFQUFtQjtBQUNqQkQsa0JBQVk1VSxNQUFNMlUsS0FBbEI7O0FBRUEsVUFBSUksYUFBYUYsS0FBS0csS0FBdEI7QUFDQSxhQUFPRCxlQUFlLElBQXRCLEVBQTRCO0FBQzFCO0FBQ0EsWUFDRUEsV0FBV3hDLE9BQVgsS0FBdUJBLE9BQXZCLElBQ0EsQ0FBQ3dDLFdBQVdFLFlBQVgsR0FBMEJYLFdBQTNCLE1BQTRDLENBRjlDLEVBR0U7QUFDQTs7QUFFQSxjQUFJdFUsTUFBTWxDLEdBQU4sS0FBYzFCLDZCQUFsQixFQUFrQztBQUNoQztBQUNBLGdCQUFNNFUsU0FBUyxvQ0FBYWUsb0JBQWIsQ0FBZjtBQUNBZixtQkFBT2xULEdBQVAsR0FBYTJSLDZCQUFiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBY3pQLEtBQWQsRUFBcUJnUixNQUFyQjtBQUNEOztBQUVELGNBQUloUixNQUFNeUMsY0FBTixHQUF1QnNQLG9CQUEzQixFQUFpRDtBQUMvQy9SLGtCQUFNeUMsY0FBTixHQUF1QnNQLG9CQUF2QjtBQUNEO0FBQ0QsY0FBSWQsWUFBWWpSLE1BQU1pUixTQUF0QjtBQUNBLGNBQ0VBLGNBQWMsSUFBZCxJQUNBQSxVQUFVeE8sY0FBVixHQUEyQnNQLG9CQUY3QixFQUdFO0FBQ0FkLHNCQUFVeE8sY0FBVixHQUEyQnNQLG9CQUEzQjtBQUNEOztBQUVEeUMsbUNBQXlCeFUsTUFBTVMsTUFBL0IsRUFBdUNzUixvQkFBdkM7O0FBRUE7QUFDQSxjQUFJOEMsS0FBS3BTLGNBQUwsR0FBc0JzUCxvQkFBMUIsRUFBZ0Q7QUFDOUM4QyxpQkFBS3BTLGNBQUwsR0FBc0JzUCxvQkFBdEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDRDtBQUNEZ0QscUJBQWFBLFdBQVdsRSxJQUF4QjtBQUNEO0FBQ0YsS0EvQ0QsTUErQ08sSUFBSTdRLE1BQU1sQyxHQUFOLEtBQWNqQiw4QkFBbEIsRUFBbUM7QUFDeEM7QUFDQStYLGtCQUFZNVUsTUFBTW5DLElBQU4sS0FBZXlDLGVBQWV6QyxJQUE5QixHQUFxQyxJQUFyQyxHQUE0Q21DLE1BQU0yVSxLQUE5RDtBQUNELEtBSE0sTUFHQSxJQUNMN1ksbURBQ0FrRSxNQUFNbEMsR0FBTixLQUFjVCwwQ0FGVCxFQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSTJDLE1BQU15QyxjQUFOLEdBQXVCc1Asb0JBQTNCLEVBQWlEO0FBQy9DL1IsY0FBTXlDLGNBQU4sR0FBdUJzUCxvQkFBdkI7QUFDRDtBQUNELFVBQUlkLGFBQVlqUixNQUFNaVIsU0FBdEI7QUFDQSxVQUNFQSxlQUFjLElBQWQsSUFDQUEsV0FBVXhPLGNBQVYsR0FBMkJzUCxvQkFGN0IsRUFHRTtBQUNBZCxtQkFBVXhPLGNBQVYsR0FBMkJzUCxvQkFBM0I7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0F5QywrQkFBeUJ4VSxLQUF6QixFQUFnQytSLG9CQUFoQztBQUNBNkMsa0JBQVk1VSxNQUFNa1YsT0FBbEI7QUFDRCxLQXZCTSxNQXVCQTtBQUNMO0FBQ0FOLGtCQUFZNVUsTUFBTTJVLEtBQWxCO0FBQ0Q7O0FBRUQsUUFBSUMsY0FBYyxJQUFsQixFQUF3QjtBQUN0QjtBQUNBQSxnQkFBVW5VLE1BQVYsR0FBbUJULEtBQW5CO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQTRVLGtCQUFZNVUsS0FBWjtBQUNBLGFBQU80VSxjQUFjLElBQXJCLEVBQTJCO0FBQ3pCLFlBQUlBLGNBQWN0VSxjQUFsQixFQUFrQztBQUNoQztBQUNBc1Usc0JBQVksSUFBWjtBQUNBO0FBQ0Q7QUFDRCxZQUFJTSxVQUFVTixVQUFVTSxPQUF4QjtBQUNBLFlBQUlBLFlBQVksSUFBaEIsRUFBc0I7QUFDcEI7QUFDQUEsa0JBQVF6VSxNQUFSLEdBQWlCbVUsVUFBVW5VLE1BQTNCO0FBQ0FtVSxzQkFBWU0sT0FBWjtBQUNBO0FBQ0Q7QUFDRDtBQUNBTixvQkFBWUEsVUFBVW5VLE1BQXRCO0FBQ0Q7QUFDRjtBQUNEVCxZQUFRNFUsU0FBUjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU3pCLG9CQUFULENBQ0w3UyxjQURLLEVBRUx5UixvQkFGSyxFQUdDO0FBQ053Qiw0QkFBMEJqVCxjQUExQjtBQUNBa1QsMEJBQXdCLElBQXhCO0FBQ0FDLG1DQUFpQyxJQUFqQzs7QUFFQSxNQUFNMEIsc0JBQXNCN1UsZUFBZXdVLG1CQUEzQztBQUNBLE1BQ0VLLHdCQUF3QixJQUF4QixJQUNBQSxvQkFBb0IxUyxjQUFwQixJQUFzQ3NQLG9CQUZ4QyxFQUdFO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0F6UixpQkFBZXdVLG1CQUFmLEdBQXFDLElBQXJDO0FBQ0Q7O0FBRU0sU0FBUzFCLFdBQVQsQ0FDTGIsT0FESyxFQUVMMEMsWUFGSyxFQUdGO0FBQ0gsTUFBSS9iLElBQUosRUFBYTtBQUNYO0FBQ0E7QUFDQSwyQkFDRSxDQUFDd2EsNEJBREgsRUFFRSx3REFDRSxnRkFERixHQUVFLGlGQUZGLEdBR0UsOENBTEo7QUFPRDs7QUFFRCxNQUFJRCxtQ0FBbUNsQixPQUF2QyxFQUFnRDtBQUM5QztBQUNELEdBRkQsTUFFTyxJQUFJMEMsaUJBQWlCLEtBQWpCLElBQTBCQSxpQkFBaUIsQ0FBL0MsRUFBa0Q7QUFDdkQ7QUFDRCxHQUZNLE1BRUE7QUFDTCxRQUFJRyw2QkFBSixDQURLLENBQ3FCO0FBQzFCLFFBQ0UsT0FBT0gsWUFBUCxLQUF3QixRQUF4QixJQUNBQSxpQkFBaUI1UywyQkFGbkIsRUFHRTtBQUNBO0FBQ0FvUix1Q0FBbUNsQixPQUFuQztBQUNBNkMsNkJBQXVCL1MsMkJBQXZCO0FBQ0QsS0FQRCxNQU9PO0FBQ0wrUyw2QkFBdUJILFlBQXZCO0FBQ0Q7O0FBRUQsUUFBSUksY0FBYztBQUNoQjlDLGVBQVdBLE9BREs7QUFFaEIwQyxvQkFBY0csb0JBRkU7QUFHaEJ2RSxZQUFNO0FBSFUsS0FBbEI7O0FBTUEsUUFBSTJDLDBCQUEwQixJQUE5QixFQUFvQztBQUNsQywrQkFDRUQsNEJBQTRCLElBRDlCLEVBRUUsd0RBQ0UsZ0ZBREYsR0FFRSxpRkFGRixHQUdFLDhDQUxKOztBQVFBO0FBQ0FDLDhCQUF3QjZCLFdBQXhCO0FBQ0E5Qiw4QkFBd0J1QixtQkFBeEIsR0FBOEM7QUFDNUNFLGVBQU9LLFdBRHFDO0FBRTVDNVMsd0JBQWdCUDtBQUY0QixPQUE5QztBQUlELEtBZkQsTUFlTztBQUNMO0FBQ0FzUiw4QkFBd0JBLHNCQUFzQjNDLElBQXRCLEdBQTZCd0UsV0FBckQ7QUFDRDtBQUNGO0FBQ0QsU0FBT3ZCLDBDQUFvQnZCLFFBQVF3QixhQUE1QixHQUE0Q3hCLFFBQVEwQixjQUEzRDtBQUNELEM7Ozs7Ozs7Ozs7OztRQ3BSZXFCLDRCLEdBQUFBLDRCO1FBSUFDLHNDLEdBQUFBLHNDO1FBSUFDLDhCLEdBQUFBLDhCO1FBSUFDLDBCLEdBQUFBLDBCOztBQXZIaEI7O0FBS0E7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUFJQTs7OztBQUlBLFNBQVNDLGVBQVQsQ0FBeUJsSCxJQUF6QixFQUErQnhLLEtBQS9CLEVBQXNDMlIsZ0JBQXRDLEVBQTJFO0FBQ3pFLE1BQU1DLG1CQUNKNVIsTUFBTVEsY0FBTixDQUFxQnFSLHVCQUFyQixDQUE2Q0YsZ0JBQTdDLENBREY7QUFFQSxTQUFPLGlDQUFZbkgsSUFBWixFQUFrQm9ILGdCQUFsQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTs7Ozs7O0FBeENBOzs7Ozs7O0FBOENBLFNBQVNFLCtCQUFULENBQXlDdEgsSUFBekMsRUFBK0M3TixLQUEvQyxFQUFzRHFELEtBQXRELEVBQTZEO0FBQzNELE1BQUk5SyxJQUFKLEVBQWE7QUFDWCx1Q0FBb0JzVixJQUFwQixFQUEwQixtQ0FBMUI7QUFDRDtBQUNELE1BQU11SCxXQUFXTCxnQkFBZ0JsSCxJQUFoQixFQUFzQnhLLEtBQXRCLEVBQTZCckQsS0FBN0IsQ0FBakI7QUFDQSxNQUFJb1YsUUFBSixFQUFjO0FBQ1ovUixVQUFNK0Isa0JBQU4sR0FBMkIsOEJBQ3pCL0IsTUFBTStCLGtCQURtQixFQUV6QmdRLFFBRnlCLENBQTNCO0FBSUEvUixVQUFNZ0Msa0JBQU4sR0FBMkIsOEJBQWVoQyxNQUFNZ0Msa0JBQXJCLEVBQXlDd0ksSUFBekMsQ0FBM0I7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O0FBT0EsU0FBU3dILGtDQUFULENBQTRDaFMsS0FBNUMsRUFBbUQ7QUFDakQsTUFBSUEsU0FBU0EsTUFBTVEsY0FBTixDQUFxQnFSLHVCQUFsQyxFQUEyRDtBQUN6RCw4Q0FBaUI3UixNQUFNZ0IsV0FBdkIsRUFBb0M4USwrQkFBcEMsRUFBcUU5UixLQUFyRTtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFNBQVNpUyw0Q0FBVCxDQUFzRGpTLEtBQXRELEVBQTZEO0FBQzNELE1BQUlBLFNBQVNBLE1BQU1RLGNBQU4sQ0FBcUJxUix1QkFBbEMsRUFBMkQ7QUFDekQsUUFBTXBSLGFBQWFULE1BQU1nQixXQUF6QjtBQUNBLFFBQU1rUixhQUFhelIsYUFBYSwyQ0FBa0JBLFVBQWxCLENBQWIsR0FBNkMsSUFBaEU7QUFDQSw4Q0FBaUJ5UixVQUFqQixFQUE2QkosK0JBQTdCLEVBQThEOVIsS0FBOUQ7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFNBQVNtUyxvQkFBVCxDQUE4QjNILElBQTlCLEVBQW9DNEgsZ0JBQXBDLEVBQXNEcFMsS0FBdEQsRUFBNkQ7QUFDM0QsTUFBSXdLLFFBQVF4SyxLQUFSLElBQWlCQSxNQUFNUSxjQUFOLENBQXFCb1IsZ0JBQTFDLEVBQTREO0FBQzFELFFBQU1BLG1CQUFtQjVSLE1BQU1RLGNBQU4sQ0FBcUJvUixnQkFBOUM7QUFDQSxRQUFNRyxXQUFXLGlDQUFZdkgsSUFBWixFQUFrQm9ILGdCQUFsQixDQUFqQjtBQUNBLFFBQUlHLFFBQUosRUFBYztBQUNaL1IsWUFBTStCLGtCQUFOLEdBQTJCLDhCQUN6Qi9CLE1BQU0rQixrQkFEbUIsRUFFekJnUSxRQUZ5QixDQUEzQjtBQUlBL1IsWUFBTWdDLGtCQUFOLEdBQTJCLDhCQUFlaEMsTUFBTWdDLGtCQUFyQixFQUF5Q3dJLElBQXpDLENBQTNCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7OztBQUtBLFNBQVM2SCxnQ0FBVCxDQUEwQ3JTLEtBQTFDLEVBQWlEO0FBQy9DLE1BQUlBLFNBQVNBLE1BQU1RLGNBQU4sQ0FBcUJvUixnQkFBbEMsRUFBb0Q7QUFDbERPLHlCQUFxQm5TLE1BQU1nQixXQUEzQixFQUF3QyxJQUF4QyxFQUE4Q2hCLEtBQTlDO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTc1IsNEJBQVQsQ0FBc0NnQixNQUF0QyxFQUE4QztBQUNuRCxvQ0FBbUJBLE1BQW5CLEVBQTJCTixrQ0FBM0I7QUFDRDs7QUFFTSxTQUFTVCxzQ0FBVCxDQUFnRGUsTUFBaEQsRUFBd0Q7QUFDN0Qsb0NBQW1CQSxNQUFuQixFQUEyQkwsNENBQTNCO0FBQ0Q7O0FBRU0sU0FBU1QsOEJBQVQsQ0FBd0NlLEtBQXhDLEVBQStDQyxLQUEvQyxFQUFzREMsSUFBdEQsRUFBNERDLEVBQTVELEVBQWdFO0FBQ3JFLDhDQUFtQkQsSUFBbkIsRUFBeUJDLEVBQXpCLEVBQTZCUCxvQkFBN0IsRUFBbURJLEtBQW5ELEVBQTBEQyxLQUExRDtBQUNEOztBQUVNLFNBQVNmLDBCQUFULENBQW9DYSxNQUFwQyxFQUE0QztBQUNqRCxvQ0FBbUJBLE1BQW5CLEVBQTJCRCxnQ0FBM0I7QUFDRCxDOzs7Ozs7Ozs7Ozs7OztrUUNoSUQ7Ozs7Ozs7OztBQVlBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxJQUFJTSwwQ0FBSjs7QUFFQSxJQUFJemQsSUFBSixFQUFhO0FBQ1h5ZCxzQ0FBb0MsRUFBcEM7QUFDRDs7QUFFTSxJQUFNQyxrREFBcUIsRUFBM0I7QUFDUCxJQUFJMWQsSUFBSixFQUFhO0FBQ1hxTSxTQUFPc1IsTUFBUCxDQUFjRCxrQkFBZDtBQUNEOztBQUVEO0FBQ0EsSUFBSUUscUJBQTBDLG1DQUFhRixrQkFBYixDQUE5QztBQUNBO0FBQ0EsSUFBSUcsNEJBQWtELG1DQUFhLEtBQWIsQ0FBdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQyxrQkFBMEJKLGtCQUE5Qjs7QUFFQSxTQUFTSyxrQkFBVCxDQUNFM1csY0FERixFQUVFNFcsU0FGRixFQUdFQywyQkFIRixFQUlVO0FBQ1IsTUFBSUEsK0JBQStCQyxrQkFBa0JGLFNBQWxCLENBQW5DLEVBQWlFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBT0YsZUFBUDtBQUNEO0FBQ0QsU0FBT0YsbUJBQW1CcFcsT0FBMUI7QUFDRDs7QUFFRCxTQUFTMlcsWUFBVCxDQUNFL1csY0FERixFQUVFZ1gsZUFGRixFQUdFQyxhQUhGLEVBSVE7QUFDTixNQUFNbFEsV0FBVy9HLGVBQWVtTyxTQUFoQztBQUNBcEgsV0FBU21RLDJDQUFULEdBQXVERixlQUF2RDtBQUNBalEsV0FBU29RLHlDQUFULEdBQXFERixhQUFyRDtBQUNEOztBQUVELFNBQVNHLGdCQUFULENBQ0VwWCxjQURGLEVBRUVnWCxlQUZGLEVBR1U7QUFDUixNQUFNelosT0FBT3lDLGVBQWV6QyxJQUE1QjtBQUNBLE1BQU04WixlQUFlOVosS0FBSzhaLFlBQTFCO0FBQ0EsTUFBSSxDQUFDQSxZQUFMLEVBQW1CO0FBQ2pCLFdBQU9mLGtCQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTXZQLFdBQVcvRyxlQUFlbU8sU0FBaEM7QUFDQSxNQUNFcEgsWUFDQUEsU0FBU21RLDJDQUFULEtBQXlERixlQUYzRCxFQUdFO0FBQ0EsV0FBT2pRLFNBQVNvUSx5Q0FBaEI7QUFDRDs7QUFFRCxNQUFNbEYsVUFBVSxFQUFoQjtBQUNBLE9BQUssSUFBSXFGLEdBQVQsSUFBZ0JELFlBQWhCLEVBQThCO0FBQzVCcEYsWUFBUXFGLEdBQVIsSUFBZU4sZ0JBQWdCTSxHQUFoQixDQUFmO0FBQ0Q7O0FBRUQsTUFBSTFlLElBQUosRUFBYTtBQUNYLFFBQU1lLE9BQU8sZ0NBQWlCNEQsSUFBakIsS0FBMEIsU0FBdkM7QUFDQSxrQ0FDRThaLFlBREYsRUFFRXBGLE9BRkYsRUFHRSxTQUhGLEVBSUV0WSxJQUpGLEVBS0UwRiw0Q0FMRjtBQU9EOztBQUVEO0FBQ0E7QUFDQSxNQUFJMEgsUUFBSixFQUFjO0FBQ1pnUSxpQkFBYS9XLGNBQWIsRUFBNkJnWCxlQUE3QixFQUE4Qy9FLE9BQTlDO0FBQ0Q7O0FBRUQsU0FBT0EsT0FBUDtBQUNEOztBQUVELFNBQVNzRixpQkFBVCxHQUFzQztBQUNwQyxTQUFPZCwwQkFBMEJyVyxPQUFqQztBQUNEOztBQUVELFNBQVMwVyxpQkFBVCxDQUEyQnZaLElBQTNCLEVBQW9EO0FBQ2xELE1BQU1pYSxvQkFBb0JqYSxLQUFLaWEsaUJBQS9CO0FBQ0EsU0FBT0Esc0JBQXNCLElBQXRCLElBQThCQSxzQkFBc0IxZSxTQUEzRDtBQUNEOztBQUVELFNBQVMyZSxVQUFULENBQW9CL1gsS0FBcEIsRUFBd0M7QUFDdEMsNEJBQUkrVyx5QkFBSixFQUErQi9XLEtBQS9CO0FBQ0EsNEJBQUk4VyxrQkFBSixFQUF3QjlXLEtBQXhCO0FBQ0Q7O0FBRUQsU0FBU2dZLHdCQUFULENBQWtDaFksS0FBbEMsRUFBc0Q7QUFDcEQsNEJBQUkrVyx5QkFBSixFQUErQi9XLEtBQS9CO0FBQ0EsNEJBQUk4VyxrQkFBSixFQUF3QjlXLEtBQXhCO0FBQ0Q7O0FBRUQsU0FBU2lZLHlCQUFULENBQ0VqWSxLQURGLEVBRUV1UyxPQUZGLEVBR0UyRixTQUhGLEVBSVE7QUFDTiwyQkFDRXBCLG1CQUFtQnBXLE9BQW5CLEtBQStCa1csa0JBRGpDLEVBRUUsd0NBQ0Usc0VBSEo7O0FBTUEsNkJBQUtFLGtCQUFMLEVBQXlCdkUsT0FBekIsRUFBa0N2UyxLQUFsQztBQUNBLDZCQUFLK1cseUJBQUwsRUFBZ0NtQixTQUFoQyxFQUEyQ2xZLEtBQTNDO0FBQ0Q7O0FBRUQsU0FBU21ZLG1CQUFULENBQ0VuWSxLQURGLEVBRUVuQyxJQUZGLEVBR0V1YSxhQUhGLEVBSVU7QUFDUixNQUFNL1EsV0FBV3JILE1BQU15TyxTQUF2QjtBQUNBLE1BQU1xSixvQkFBb0JqYSxLQUFLaWEsaUJBQS9COztBQUVBO0FBQ0E7QUFDQSxNQUFJLE9BQU96USxTQUFTZ1IsZUFBaEIsS0FBb0MsVUFBeEMsRUFBb0Q7QUFDbEQsUUFBSW5mLElBQUosRUFBYTtBQUNYLFVBQU1vZixnQkFBZ0IsZ0NBQWlCemEsSUFBakIsS0FBMEIsU0FBaEQ7O0FBRUEsVUFBSSxDQUFDOFksa0NBQWtDMkIsYUFBbEMsQ0FBTCxFQUF1RDtBQUNyRDNCLDBDQUFrQzJCLGFBQWxDLElBQW1ELElBQW5EO0FBQ0EsMkNBQ0UsS0FERixFQUVFLGdGQUNFLDJFQURGLEdBRUUsNEJBSkosRUFLRUEsYUFMRixFQU1FQSxhQU5GO0FBUUQ7QUFDRjtBQUNELFdBQU9GLGFBQVA7QUFDRDs7QUFFRCxNQUFJRyxxQkFBSjtBQUNBLE1BQUlyZixJQUFKLEVBQWE7QUFDWCw0Q0FBZ0IsaUJBQWhCO0FBQ0Q7QUFDRCw0Q0FBZ0I4RyxLQUFoQixFQUF1QixpQkFBdkI7QUFDQXVZLGlCQUFlbFIsU0FBU2dSLGVBQVQsRUFBZjtBQUNBO0FBQ0EsTUFBSW5mLElBQUosRUFBYTtBQUNYLDRDQUFnQixJQUFoQjtBQUNEO0FBQ0QsT0FBSyxJQUFJc2YsVUFBVCxJQUF1QkQsWUFBdkIsRUFBcUM7QUFDbkMsNkJBQ0VDLGNBQWNWLGlCQURoQixFQUVFLHFFQUZGLEVBR0UsZ0NBQWlCamEsSUFBakIsS0FBMEIsU0FINUIsRUFJRTJhLFVBSkY7QUFNRDtBQUNELE1BQUl0ZixJQUFKLEVBQWE7QUFDWCxRQUFNZSxPQUFPLGdDQUFpQjRELElBQWpCLEtBQTBCLFNBQXZDO0FBQ0Esa0NBQ0VpYSxpQkFERixFQUVFUyxZQUZGLEVBR0UsZUFIRixFQUlFdGUsSUFKRjtBQUtFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTBGLGdEQVZGO0FBWUQ7O0FBRUQsc0JBQVd5WSxhQUFYLEVBQTZCRyxZQUE3QjtBQUNEOztBQUVELFNBQVNFLG1CQUFULENBQTZCblksY0FBN0IsRUFBNkQ7QUFDM0QsTUFBTStHLFdBQVcvRyxlQUFlbU8sU0FBaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNaUssNkJBQ0hyUixZQUFZQSxTQUFTc1IseUNBQXRCLElBQ0EvQixrQkFGRjs7QUFJQTtBQUNBO0FBQ0FJLG9CQUFrQkYsbUJBQW1CcFcsT0FBckM7QUFDQSw2QkFBS29XLGtCQUFMLEVBQXlCNEIsMEJBQXpCLEVBQXFEcFksY0FBckQ7QUFDQSw2QkFDRXlXLHlCQURGLEVBRUVBLDBCQUEwQnJXLE9BRjVCLEVBR0VKLGNBSEY7O0FBTUEsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBU3NZLHlCQUFULENBQ0V0WSxjQURGLEVBRUV6QyxJQUZGLEVBR0VxYSxTQUhGLEVBSVE7QUFDTixNQUFNN1EsV0FBVy9HLGVBQWVtTyxTQUFoQztBQUNBLDJCQUNFcEgsUUFERixFQUVFLGlEQUNFLHNFQUhKOztBQU1BLE1BQUk2USxTQUFKLEVBQWU7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFNVyxnQkFBZ0JWLG9CQUNwQjdYLGNBRG9CLEVBRXBCekMsSUFGb0IsRUFHcEJtWixlQUhvQixDQUF0QjtBQUtBM1AsYUFBU3NSLHlDQUFULEdBQXFERSxhQUFyRDs7QUFFQTtBQUNBO0FBQ0EsOEJBQUk5Qix5QkFBSixFQUErQnpXLGNBQS9CO0FBQ0EsOEJBQUl3VyxrQkFBSixFQUF3QnhXLGNBQXhCO0FBQ0E7QUFDQSwrQkFBS3dXLGtCQUFMLEVBQXlCK0IsYUFBekIsRUFBd0N2WSxjQUF4QztBQUNBLCtCQUFLeVcseUJBQUwsRUFBZ0NtQixTQUFoQyxFQUEyQzVYLGNBQTNDO0FBQ0QsR0FsQkQsTUFrQk87QUFDTCw4QkFBSXlXLHlCQUFKLEVBQStCelcsY0FBL0I7QUFDQSwrQkFBS3lXLHlCQUFMLEVBQWdDbUIsU0FBaEMsRUFBMkM1WCxjQUEzQztBQUNEO0FBQ0Y7O0FBRUQsU0FBU3dZLDBCQUFULENBQW9DOVksS0FBcEMsRUFBMEQ7QUFDeEQ7QUFDQTtBQUNBLDJCQUNFLGdDQUFlQSxLQUFmLEtBQXlCQSxNQUFNbEMsR0FBTixLQUFjMUIsNkJBRHpDLEVBRUUsOERBQ0Usc0VBSEo7O0FBTUEsTUFBSW9FLE9BQU9SLEtBQVg7QUFDQSxLQUFHO0FBQ0QsWUFBUVEsS0FBSzFDLEdBQWI7QUFDRSxXQUFLeEIsdUJBQUw7QUFDRSxlQUFPa0UsS0FBS2lPLFNBQUwsQ0FBZThELE9BQXRCO0FBQ0YsV0FBS25XLDZCQUFMO0FBQXFCO0FBQ25CLGNBQU04YSxZQUFZMVcsS0FBSzNDLElBQXZCO0FBQ0EsY0FBSXVaLGtCQUFrQkYsU0FBbEIsQ0FBSixFQUFrQztBQUNoQyxtQkFBTzFXLEtBQUtpTyxTQUFMLENBQWVrSyx5Q0FBdEI7QUFDRDtBQUNEO0FBQ0Q7QUFUSDtBQVdBblksV0FBT0EsS0FBS0MsTUFBWjtBQUNELEdBYkQsUUFhU0QsU0FBUyxJQWJsQjtBQWNBLDJCQUNFLEtBREYsRUFFRSwrQ0FDRSxzRUFISjtBQUtEOztRQUdDeVcsa0IsR0FBQUEsa0I7UUFDQUksWSxHQUFBQSxZO1FBQ0FLLGdCLEdBQUFBLGdCO1FBQ0FHLGlCLEdBQUFBLGlCO1FBQ0FFLFUsR0FBQUEsVTtRQUNBQyx3QixHQUFBQSx3QjtRQUNBQyx5QixHQUFBQSx5QjtRQUNBRSxtQixHQUFBQSxtQjtRQUNBZixpQixHQUFBQSxpQjtRQUNBcUIsbUIsR0FBQUEsbUI7UUFDQUcseUIsR0FBQUEseUI7UUFDQUUsMEIsR0FBQUEsMEI7Ozs7Ozs7QUMzVEY7Ozs7Ozs7OztBQVNhOztBQUViOztBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0FDLE9BQU9DLE9BQVAsR0FBaUIzVixnQkFBTTRWLE9BQU4sSUFBaUI1VixlQUFsQyxDOzs7Ozs7O0FDaEJBOzs7Ozs7Ozs7QUFTYTs7Ozs7Ozs7QUFFYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7Ozs7Ozs7Ozs7Ozs7OFFDWkE7Ozs7Ozs7O1FBNkhnQjZWLFcsR0FBQUEsVztRQTREQUMsZ0IsR0FBQUEsZ0I7UUEwQkFDLHlCLEdBQUFBLHlCOztBQTNNaEI7O0FBQ0E7Ozs7QUFFQTs7QUFLQTs7QUFJQTs7OztBQUNBOzs7Ozs7QUFRQTs7OztBQUlBLElBQUlDLGFBQWtFLElBQXRFOztBQUVBOzs7Ozs7QUFNQSxJQUFNQyw4QkFBOEIsU0FBOUJBLDJCQUE4QixDQUFTdFYsS0FBVCxFQUFxQztBQUN2RSxNQUFJQSxLQUFKLEVBQVc7QUFDVCxvREFBeUJBLEtBQXpCOztBQUVBLFFBQUksQ0FBQ0EsTUFBTTJCLFlBQU4sRUFBTCxFQUEyQjtBQUN6QjNCLFlBQU1rQixXQUFOLENBQWtCd0MsT0FBbEIsQ0FBMEIxRCxLQUExQjtBQUNEO0FBQ0Y7QUFDRixDQVJEO0FBU0EsSUFBTXVWLHNDQUFzQyxTQUF0Q0EsbUNBQXNDLENBQVM1ZixDQUFULEVBQVk7QUFDdEQsU0FBTzJmLDRCQUE0QjNmLENBQTVCLENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVM2ZixhQUFULENBQXVCMWIsR0FBdkIsRUFBNEI7QUFDMUIsU0FDRUEsUUFBUSxRQUFSLElBQ0FBLFFBQVEsT0FEUixJQUVBQSxRQUFRLFFBRlIsSUFHQUEsUUFBUSxVQUpWO0FBTUQ7O0FBRUQsU0FBUzJiLHVCQUFULENBQWlDeGYsSUFBakMsRUFBdUM0RCxJQUF2QyxFQUE2QzZRLEtBQTdDLEVBQW9EO0FBQ2xELFVBQVF6VSxJQUFSO0FBQ0UsU0FBSyxTQUFMO0FBQ0EsU0FBSyxnQkFBTDtBQUNBLFNBQUssZUFBTDtBQUNBLFNBQUssc0JBQUw7QUFDQSxTQUFLLGFBQUw7QUFDQSxTQUFLLG9CQUFMO0FBQ0EsU0FBSyxhQUFMO0FBQ0EsU0FBSyxvQkFBTDtBQUNBLFNBQUssV0FBTDtBQUNBLFNBQUssa0JBQUw7QUFDRSxhQUFPLENBQUMsRUFBRXlVLE1BQU1nTCxRQUFOLElBQWtCRixjQUFjM2IsSUFBZCxDQUFwQixDQUFSO0FBQ0Y7QUFDRSxhQUFPLEtBQVA7QUFiSjtBQWVEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7O0FBR08sSUFBTThiLGdDQUFZO0FBQ3ZCOzs7O0FBSUFDLHFFQUx1Qjs7QUFPdkI7OztBQUdBQztBQVZ1QixDQUFsQjs7QUFhUDs7Ozs7QUFLTyxTQUFTWCxXQUFULENBQXFCMUssSUFBckIsRUFBa0NvSCxnQkFBbEMsRUFBNEQ7QUFDakUsTUFBSUcsaUJBQUo7O0FBRUE7QUFDQTtBQUNBLE1BQU10SCxZQUFZRCxLQUFLQyxTQUF2QjtBQUNBLE1BQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUNkO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFNQyxRQUFRLG9EQUE2QkQsU0FBN0IsQ0FBZDtBQUNBLE1BQUksQ0FBQ0MsS0FBTCxFQUFZO0FBQ1Y7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNEcUgsYUFBV3JILE1BQU1rSCxnQkFBTixDQUFYO0FBQ0EsTUFBSTZELHdCQUF3QjdELGdCQUF4QixFQUEwQ3BILEtBQUszUSxJQUEvQyxFQUFxRDZRLEtBQXJELENBQUosRUFBaUU7QUFDL0QsV0FBTyxJQUFQO0FBQ0Q7QUFDRCwyQkFDRSxDQUFDcUgsUUFBRCxJQUFhLE9BQU9BLFFBQVAsS0FBb0IsVUFEbkMsRUFFRSw0RUFGRixFQUdFSCxnQkFIRixTQUlTRyxRQUpULHlDQUlTQSxRQUpUO0FBTUEsU0FBT0EsUUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBUytELGFBQVQsQ0FDRTNNLFlBREYsRUFFRTFJLFVBRkYsRUFHRUMsV0FIRixFQUlFQyxpQkFKRixFQUsyRDtBQUN6RCxNQUFJMlIsU0FBUyxJQUFiO0FBQ0EsT0FBSyxJQUFJeUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJQyw2QkFBUTVmLE1BQTVCLEVBQW9DMmYsR0FBcEMsRUFBeUM7QUFDdkM7QUFDQSxRQUFNRSxpQkFBK0NELDZCQUFRRCxDQUFSLENBQXJEO0FBQ0EsUUFBSUUsY0FBSixFQUFvQjtBQUNsQixVQUFNQyxrQkFBa0JELGVBQWVILGFBQWYsQ0FDdEIzTSxZQURzQixFQUV0QjFJLFVBRnNCLEVBR3RCQyxXQUhzQixFQUl0QkMsaUJBSnNCLENBQXhCO0FBTUEsVUFBSXVWLGVBQUosRUFBcUI7QUFDbkI1RCxpQkFBUyw4QkFBZUEsTUFBZixFQUF1QjRELGVBQXZCLENBQVQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPNUQsTUFBUDtBQUNEOztBQUVNLFNBQVM2QyxnQkFBVCxDQUNMN0MsTUFESyxFQUVMO0FBQ0EsTUFBSUEsV0FBVyxJQUFmLEVBQXFCO0FBQ25CK0MsaUJBQWEsOEJBQWVBLFVBQWYsRUFBMkIvQyxNQUEzQixDQUFiO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQU02RCx1QkFBdUJkLFVBQTdCO0FBQ0FBLGVBQWEsSUFBYjs7QUFFQSxNQUFJLENBQUNjLG9CQUFMLEVBQTJCO0FBQ3pCO0FBQ0Q7O0FBRUQsb0NBQW1CQSxvQkFBbkIsRUFBeUNaLG1DQUF6QztBQUNBLDJCQUNFLENBQUNGLFVBREgsRUFFRSwyRUFDRSxnRUFISjtBQUtBO0FBQ0E7QUFDRDs7QUFFTSxTQUFTRCx5QkFBVCxDQUNMak0sWUFESyxFQUVMMUksVUFGSyxFQUdMQyxXQUhLLEVBSUxDLGlCQUpLLEVBS0w7QUFDQSxNQUFNMlIsU0FBU3dELGNBQ2IzTSxZQURhLEVBRWIxSSxVQUZhLEVBR2JDLFdBSGEsRUFJYkMsaUJBSmEsQ0FBZjtBQU1Bd1UsbUJBQWlCN0MsTUFBakI7QUFDRCxDOzs7Ozs7Ozs7Ozs7O1FDM0Jlc0Qsc0IsR0FBQUEsc0I7UUF1QkFDLHdCLEdBQUFBLHdCOztBQTVNaEI7Ozs7OztBQUtBOzs7QUFHQSxJQUFJTyxtQkFBcUMsSUFBekM7O0FBRUE7OztBQTFCQTs7Ozs7Ozs7O0FBNkJBLElBQU1DLGlCQUFpQyxFQUF2Qzs7QUFFQTs7Ozs7QUFLQSxTQUFTQyx1QkFBVCxHQUF5QztBQUN2QyxNQUFJLENBQUNGLGdCQUFMLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDRDtBQUNELE9BQUssSUFBTUcsVUFBWCxJQUF5QkYsY0FBekIsRUFBeUM7QUFDdkMsUUFBTUcsZUFBZUgsZUFBZUUsVUFBZixDQUFyQjtBQUNBLFFBQU1FLGNBQWNMLGlCQUFpQk0sT0FBakIsQ0FBeUJILFVBQXpCLENBQXBCO0FBQ0EsNkJBQ0VFLGNBQWMsQ0FBQyxDQURqQixFQUVFLDJFQUNFLDRCQUhKLEVBSUVGLFVBSkY7QUFNQSxRQUFJUCxRQUFRUyxXQUFSLENBQUosRUFBMEI7QUFDeEI7QUFDRDtBQUNELDZCQUNFRCxhQUFhVixhQURmLEVBRUUsMEVBQ0UsNEJBSEosRUFJRVMsVUFKRjtBQU1BUCxZQUFRUyxXQUFSLElBQXVCRCxZQUF2QjtBQUNBLFFBQU1HLGtCQUFrQkgsYUFBYUksVUFBckM7QUFDQSxTQUFLLElBQU1DLFNBQVgsSUFBd0JGLGVBQXhCLEVBQXlDO0FBQ3ZDLCtCQUNFRyxzQkFDRUgsZ0JBQWdCRSxTQUFoQixDQURGLEVBRUVMLFlBRkYsRUFHRUssU0FIRixDQURGLEVBTUUsb0VBTkYsRUFPRUEsU0FQRixFQVFFTixVQVJGO0FBVUQ7QUFDRjtBQUNGOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNPLHFCQUFULENBQ0V0VyxjQURGLEVBRUVnVyxZQUZGLEVBR0VLLFNBSEYsRUFJVztBQUNULDJCQUNFLENBQUNFLHlCQUF5QjNWLGNBQXpCLENBQXdDeVYsU0FBeEMsQ0FESCxFQUVFLHdFQUNFLG1CQUhKLEVBSUVBLFNBSkY7QUFNQUUsMkJBQXlCRixTQUF6QixJQUFzQ3JXLGNBQXRDOztBQUVBLE1BQU1xUiwwQkFBMEJyUixlQUFlcVIsdUJBQS9DO0FBQ0EsTUFBSUEsdUJBQUosRUFBNkI7QUFDM0IsU0FBSyxJQUFNbUYsU0FBWCxJQUF3Qm5GLHVCQUF4QixFQUFpRDtBQUMvQyxVQUFJQSx3QkFBd0J6USxjQUF4QixDQUF1QzRWLFNBQXZDLENBQUosRUFBdUQ7QUFDckQsWUFBTUMseUJBQXlCcEYsd0JBQXdCbUYsU0FBeEIsQ0FBL0I7QUFDQUUsZ0NBQ0VELHNCQURGLEVBRUVULFlBRkYsRUFHRUssU0FIRjtBQUtEO0FBQ0Y7QUFDRCxXQUFPLElBQVA7QUFDRCxHQVpELE1BWU8sSUFBSXJXLGVBQWVvUixnQkFBbkIsRUFBcUM7QUFDMUNzRiw0QkFDRTFXLGVBQWVvUixnQkFEakIsRUFFRTRFLFlBRkYsRUFHRUssU0FIRjtBQUtBLFdBQU8sSUFBUDtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTSyx1QkFBVCxDQUNFdEYsZ0JBREYsRUFFRTRFLFlBRkYsRUFHRUssU0FIRixFQUlRO0FBQ04sMkJBQ0UsQ0FBQ00sd0JBQXdCdkYsZ0JBQXhCLENBREgsRUFFRSx3RUFDRSwwQkFISixFQUlFQSxnQkFKRjtBQU1BdUYsMEJBQXdCdkYsZ0JBQXhCLElBQTRDNEUsWUFBNUM7QUFDQVksK0JBQTZCeEYsZ0JBQTdCLElBQ0U0RSxhQUFhSSxVQUFiLENBQXdCQyxTQUF4QixFQUFtQ1EsWUFEckM7O0FBR0EsTUFBSW5pQixJQUFKLEVBQWE7QUFDWCxRQUFNb2lCLGlCQUFpQjFGLGlCQUFpQjJGLFdBQWpCLEVBQXZCO0FBQ0FDLDhCQUEwQkYsY0FBMUIsSUFBNEMxRixnQkFBNUM7O0FBRUEsUUFBSUEscUJBQXFCLGVBQXpCLEVBQTBDO0FBQ3hDNEYsZ0NBQTBCQyxVQUExQixHQUF1QzdGLGdCQUF2QztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7OztBQUdPLElBQU1vRSw0QkFBVSxFQUFoQjs7QUFFUDs7O0FBR08sSUFBTWUsOERBQTJCLEVBQWpDOztBQUVQOzs7QUFHTyxJQUFNSSw0REFBMEIsRUFBaEM7O0FBRVA7OztBQUdPLElBQU1DLHNFQUErQixFQUFyQzs7QUFFUDs7Ozs7O0FBTU8sSUFBTUksZ0VBQTRCdGlCLEtBQU9BLEdBQUcsRUFBVixHQUFnQixJQUFsRDtBQUNQOztBQUVBOzs7Ozs7Ozs7QUFTTyxTQUFTMGdCLHNCQUFULENBQ0w4Qix3QkFESyxFQUVDO0FBQ04sMkJBQ0UsQ0FBQ3RCLGdCQURILEVBRUUsd0VBQ0Usa0VBSEo7QUFLQTtBQUNBQSxxQkFBbUJ1QixNQUFNaGhCLFNBQU4sQ0FBZ0J3VCxLQUFoQixDQUFzQnRULElBQXRCLENBQTJCNmdCLHdCQUEzQixDQUFuQjtBQUNBcEI7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVPLFNBQVNULHdCQUFULENBQ0wrQixzQkFESyxFQUVDO0FBQ04sTUFBSUMsa0JBQWtCLEtBQXRCO0FBQ0EsT0FBSyxJQUFNdEIsVUFBWCxJQUF5QnFCLHNCQUF6QixFQUFpRDtBQUMvQyxRQUFJLENBQUNBLHVCQUF1QnhXLGNBQXZCLENBQXNDbVYsVUFBdEMsQ0FBTCxFQUF3RDtBQUN0RDtBQUNEO0FBQ0QsUUFBTUMsZUFBZW9CLHVCQUF1QnJCLFVBQXZCLENBQXJCO0FBQ0EsUUFDRSxDQUFDRixlQUFlalYsY0FBZixDQUE4Qm1WLFVBQTlCLENBQUQsSUFDQUYsZUFBZUUsVUFBZixNQUErQkMsWUFGakMsRUFHRTtBQUNBLCtCQUNFLENBQUNILGVBQWVFLFVBQWYsQ0FESCxFQUVFLG9FQUNFLDRCQUhKLEVBSUVBLFVBSkY7QUFNQUYscUJBQWVFLFVBQWYsSUFBNkJDLFlBQTdCO0FBQ0FxQix3QkFBa0IsSUFBbEI7QUFDRDtBQUNGO0FBQ0QsTUFBSUEsZUFBSixFQUFxQjtBQUNuQnZCO0FBQ0Q7QUFDRixDOzs7Ozs7Ozs7Ozs7Ozs7OzhRQ3RQRDs7Ozs7Ozs7O1FBd0VnQndCLG1CLEdBQUFBLG1CO1FBa0JBQyxxQixHQUFBQSxxQjtRQXFCQUMsZ0MsR0FBQUEsZ0M7UUE4QkFDLHFCLEdBQUFBLHFCO1FBcUNBQyxlLEdBQUFBLGU7O0FBektoQjs7Ozs7O0FBSUE7QUFDQTtBQUNPLElBQU1DLDhCQUFXLENBQWpCOztBQUVQO0FBQ0E7QUFDTyxJQUFNQywwQkFBUyxDQUFmOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUMsZ0RBQW9CLENBQTFCOztBQUVQO0FBQ0E7QUFDQTtBQUNPLElBQU1DLDRCQUFVLENBQWhCOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUMsa0RBQXFCLENBQTNCOztBQUVQO0FBQ0E7QUFDTyxJQUFNQyw0QkFBVSxDQUFoQjs7QUFFUDtBQUNBO0FBQ08sSUFBTUMsOENBQW1CLENBQXpCOztBQVdQO0FBQ08sSUFBTUMsZ0VBQ1gsK0tBREs7QUFFUDtBQUNPLElBQU1DLG9EQUNYRCw0QkFBNEIsOENBRHZCOztBQUdBLElBQU1FLGdEQUFvQixjQUExQjtBQUNBLElBQU1DLG9EQUFzQixnQkFBNUI7QUFDQSxJQUFNQyxrRUFBNkIsSUFBSUMsTUFBSixDQUN4QyxPQUFPTCx5QkFBUCxHQUFtQyxJQUFuQyxHQUEwQ0MsbUJBQTFDLEdBQWdFLEtBRHhCLENBQW5DOztBQUlQLElBQU12WCxpQkFBaUJHLE9BQU81SyxTQUFQLENBQWlCeUssY0FBeEM7QUFDQSxJQUFNNFgsNEJBQTRCLEVBQWxDO0FBQ0EsSUFBTUMsOEJBQThCLEVBQXBDOztBQUVPLFNBQVNuQixtQkFBVCxDQUE2Qm9CLGFBQTdCLEVBQTZEO0FBQ2xFLE1BQUk5WCxlQUFldkssSUFBZixDQUFvQm9pQiwyQkFBcEIsRUFBaURDLGFBQWpELENBQUosRUFBcUU7QUFDbkUsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFJOVgsZUFBZXZLLElBQWYsQ0FBb0JtaUIseUJBQXBCLEVBQStDRSxhQUEvQyxDQUFKLEVBQW1FO0FBQ2pFLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSUosMkJBQTJCSyxJQUEzQixDQUFnQ0QsYUFBaEMsQ0FBSixFQUFvRDtBQUNsREQsZ0NBQTRCQyxhQUE1QixJQUE2QyxJQUE3QztBQUNBLFdBQU8sSUFBUDtBQUNEO0FBQ0RGLDRCQUEwQkUsYUFBMUIsSUFBMkMsSUFBM0M7QUFDQSxNQUFJaGtCLElBQUosRUFBYTtBQUNYLDJCQUFRLEtBQVIsRUFBZSw4QkFBZixFQUErQ2drQixhQUEvQztBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRU0sU0FBU25CLHFCQUFULENBQ0w5aEIsSUFESyxFQUVMbWpCLFlBRkssRUFHTEMsb0JBSEssRUFJSTtBQUNULE1BQUlELGlCQUFpQixJQUFyQixFQUEyQjtBQUN6QixXQUFPQSxhQUFhdmYsSUFBYixLQUFzQnNlLFFBQTdCO0FBQ0Q7QUFDRCxNQUFJa0Isb0JBQUosRUFBMEI7QUFDeEIsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUNFcGpCLEtBQUtHLE1BQUwsR0FBYyxDQUFkLEtBQ0NILEtBQUssQ0FBTCxNQUFZLEdBQVosSUFBbUJBLEtBQUssQ0FBTCxNQUFZLEdBRGhDLE1BRUNBLEtBQUssQ0FBTCxNQUFZLEdBQVosSUFBbUJBLEtBQUssQ0FBTCxNQUFZLEdBRmhDLENBREYsRUFJRTtBQUNBLFdBQU8sSUFBUDtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRU0sU0FBUytoQixnQ0FBVCxDQUNML2hCLElBREssRUFFTHFqQixLQUZLLEVBR0xGLFlBSEssRUFJTEMsb0JBSkssRUFLSTtBQUNULE1BQUlELGlCQUFpQixJQUFqQixJQUF5QkEsYUFBYXZmLElBQWIsS0FBc0JzZSxRQUFuRCxFQUE2RDtBQUMzRCxXQUFPLEtBQVA7QUFDRDtBQUNELGlCQUFlbUIsS0FBZix5Q0FBZUEsS0FBZjtBQUNFLFNBQUssVUFBTDtBQUNBO0FBQ0EsU0FBSyxRQUFMO0FBQWU7QUFDYixhQUFPLElBQVA7QUFDRixTQUFLLFNBQUw7QUFBZ0I7QUFDZCxZQUFJRCxvQkFBSixFQUEwQjtBQUN4QixpQkFBTyxLQUFQO0FBQ0Q7QUFDRCxZQUFJRCxpQkFBaUIsSUFBckIsRUFBMkI7QUFDekIsaUJBQU8sQ0FBQ0EsYUFBYUcsZUFBckI7QUFDRCxTQUZELE1BRU87QUFDTCxjQUFNQyxTQUFTdmpCLEtBQUtzaEIsV0FBTCxHQUFtQnBOLEtBQW5CLENBQXlCLENBQXpCLEVBQTRCLENBQTVCLENBQWY7QUFDQSxpQkFBT3FQLFdBQVcsT0FBWCxJQUFzQkEsV0FBVyxPQUF4QztBQUNEO0FBQ0Y7QUFDRDtBQUNFLGFBQU8sS0FBUDtBQWpCSjtBQW1CRDs7QUFFTSxTQUFTdkIscUJBQVQsQ0FDTGhpQixJQURLLEVBRUxxakIsS0FGSyxFQUdMRixZQUhLLEVBSUxDLG9CQUpLLEVBS0k7QUFDVCxNQUFJQyxVQUFVLElBQVYsSUFBa0IsT0FBT0EsS0FBUCxLQUFpQixXQUF2QyxFQUFvRDtBQUNsRCxXQUFPLElBQVA7QUFDRDtBQUNELE1BQ0V0QixpQ0FDRS9oQixJQURGLEVBRUVxakIsS0FGRixFQUdFRixZQUhGLEVBSUVDLG9CQUpGLENBREYsRUFPRTtBQUNBLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSUEsb0JBQUosRUFBMEI7QUFDeEIsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFJRCxpQkFBaUIsSUFBckIsRUFBMkI7QUFDekIsWUFBUUEsYUFBYXZmLElBQXJCO0FBQ0UsV0FBS3llLE9BQUw7QUFDRSxlQUFPLENBQUNnQixLQUFSO0FBQ0YsV0FBS2Ysa0JBQUw7QUFDRSxlQUFPZSxVQUFVLEtBQWpCO0FBQ0YsV0FBS2QsT0FBTDtBQUNFLGVBQU9pQixNQUFNSCxLQUFOLENBQVA7QUFDRixXQUFLYixnQkFBTDtBQUNFLGVBQU9nQixNQUFNSCxLQUFOLEtBQWlCQSxLQUFELEdBQWUsQ0FBdEM7QUFSSjtBQVVEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRU0sU0FBU3BCLGVBQVQsQ0FBeUJqaUIsSUFBekIsRUFBNEQ7QUFDakUsU0FBT3lqQixXQUFXdFksY0FBWCxDQUEwQm5MLElBQTFCLElBQWtDeWpCLFdBQVd6akIsSUFBWCxDQUFsQyxHQUFxRCxJQUE1RDtBQUNEOztBQUVELFNBQVMwakIsa0JBQVQsQ0FDRTFqQixJQURGLEVBRUU0RCxJQUZGLEVBR0UrZixlQUhGLEVBSUVWLGFBSkYsRUFLRVcsa0JBTEYsRUFNRTtBQUNBLE9BQUtOLGVBQUwsR0FDRTFmLFNBQVN3ZSxpQkFBVCxJQUNBeGUsU0FBU3llLE9BRFQsSUFFQXplLFNBQVMwZSxrQkFIWDtBQUlBLE9BQUtXLGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsT0FBS1csa0JBQUwsR0FBMEJBLGtCQUExQjtBQUNBLE9BQUtELGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsT0FBS0UsWUFBTCxHQUFvQjdqQixJQUFwQjtBQUNBLE9BQUs0RCxJQUFMLEdBQVlBLElBQVo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxJQUFNNmYsYUFBYSxFQUFuQjs7QUFFQTtBQUNBLENBQ0UsVUFERixFQUVFLHlCQUZGO0FBR0U7QUFDQTtBQUNBO0FBQ0EsY0FORixFQU9FLGdCQVBGLEVBUUUsV0FSRixFQVNFLGdDQVRGLEVBVUUsMEJBVkYsRUFXRSxPQVhGLEVBWUVLLE9BWkYsQ0FZVSxnQkFBUTtBQUNoQkwsYUFBV3pqQixJQUFYLElBQW1CLElBQUkwakIsa0JBQUosQ0FDakIxakIsSUFEaUIsRUFFakJraUIsUUFGaUIsRUFHakIsS0FIaUIsRUFHVjtBQUNQbGlCLE1BSmlCLEVBSVg7QUFDTixNQUxpQixDQUFuQjtBQU9ELENBcEJELENBa0JVO0FBbEJWOztBQXNCQTtBQUNBO0FBQ0EsQ0FDRSxDQUFDLGVBQUQsRUFBa0IsZ0JBQWxCLENBREYsRUFFRSxDQUFDLFdBQUQsRUFBYyxPQUFkLENBRkYsRUFHRSxDQUFDLFNBQUQsRUFBWSxLQUFaLENBSEYsRUFJRSxDQUFDLFdBQUQsRUFBYyxZQUFkLENBSkYsRUFLRThqQixPQUxGLENBS1UsZ0JBQTJCO0FBQUE7QUFBQSxNQUF6QjlqQixJQUF5QjtBQUFBLE1BQW5CaWpCLGFBQW1COztBQUNuQ1EsYUFBV3pqQixJQUFYLElBQW1CLElBQUkwakIsa0JBQUosQ0FDakIxakIsSUFEaUIsRUFFakJtaUIsTUFGaUIsRUFHakIsS0FIaUIsRUFHVjtBQUNQYyxlQUppQixFQUlGO0FBQ2YsTUFMaUIsQ0FBbkI7QUFPRCxDQWJELENBV1U7QUFYVjs7QUFlQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFELEVBQW9CLFdBQXBCLEVBQWlDLFlBQWpDLEVBQStDLE9BQS9DLEVBQXdEYSxPQUF4RCxDQUFnRSxnQkFBUTtBQUN0RUwsYUFBV3pqQixJQUFYLElBQW1CLElBQUkwakIsa0JBQUosQ0FDakIxakIsSUFEaUIsRUFFakJvaUIsaUJBRmlCLEVBR2pCLEtBSGlCLEVBR1Y7QUFDUHBpQixPQUFLc2hCLFdBQUwsRUFKaUIsRUFJRztBQUNwQixNQUxpQixDQUFuQjtBQU9ELENBUkQsQ0FNVTtBQU5WOztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FDRSxhQURGLEVBRUUsMkJBRkYsRUFHRSxXQUhGLEVBSUUsZUFKRixFQUtFd0MsT0FMRixDQUtVLGdCQUFRO0FBQ2hCTCxhQUFXempCLElBQVgsSUFBbUIsSUFBSTBqQixrQkFBSixDQUNqQjFqQixJQURpQixFQUVqQm9pQixpQkFGaUIsRUFHakIsS0FIaUIsRUFHVjtBQUNQcGlCLE1BSmlCLEVBSVg7QUFDTixNQUxpQixDQUFuQjtBQU9ELENBYkQsQ0FXVTtBQVhWOztBQWVBO0FBQ0EsQ0FDRSxpQkFERixFQUVFLE9BRkY7QUFHRTtBQUNBO0FBQ0EsV0FMRixFQU1FLFVBTkYsRUFPRSxVQVBGLEVBUUUsU0FSRixFQVNFLE9BVEYsRUFVRSxVQVZGLEVBV0UsZ0JBWEYsRUFZRSxRQVpGLEVBYUUsTUFiRixFQWNFLFVBZEYsRUFlRSxZQWZGLEVBZ0JFLE1BaEJGLEVBaUJFLGFBakJGLEVBa0JFLFVBbEJGLEVBbUJFLFVBbkJGLEVBb0JFLFVBcEJGLEVBcUJFLFFBckJGLEVBc0JFLFVBdEJGO0FBdUJFO0FBQ0EsV0F4QkYsRUF5QkU4akIsT0F6QkYsQ0F5QlUsZ0JBQVE7QUFDaEJMLGFBQVd6akIsSUFBWCxJQUFtQixJQUFJMGpCLGtCQUFKLENBQ2pCMWpCLElBRGlCLEVBRWpCcWlCLE9BRmlCLEVBR2pCLEtBSGlCLEVBR1Y7QUFDUHJpQixPQUFLc2hCLFdBQUwsRUFKaUIsRUFJRztBQUNwQixNQUxpQixDQUFuQjtBQU9ELENBakNELENBK0JVO0FBL0JWOztBQW1DQTtBQUNBO0FBQ0EsQ0FDRSxTQURGO0FBRUU7QUFDQTtBQUNBLFVBSkYsRUFLRSxPQUxGLEVBTUUsVUFORixFQVdFd0MsT0FYRixDQVdVLGdCQUFRO0FBQ2hCTCxhQUFXempCLElBQVgsSUFBbUIsSUFBSTBqQixrQkFBSixDQUNqQjFqQixJQURpQixFQUVqQnFpQixPQUZpQixFQUdqQixJQUhpQixFQUdYO0FBQ05yaUIsTUFKaUIsRUFJWDtBQUNOLE1BTGlCLENBQW5CO0FBT0QsQ0FuQkQsQ0FpQlU7QUFqQlY7O0FBcUJBO0FBQ0E7QUFDQSxDQUNFLFNBREYsRUFFRSxVQUZGLEVBT0U4akIsT0FQRixDQU9VLGdCQUFRO0FBQ2hCTCxhQUFXempCLElBQVgsSUFBbUIsSUFBSTBqQixrQkFBSixDQUNqQjFqQixJQURpQixFQUVqQnNpQixrQkFGaUIsRUFHakIsS0FIaUIsRUFHVjtBQUNQdGlCLE1BSmlCLEVBSVg7QUFDTixNQUxpQixDQUFuQjtBQU9ELENBZkQsQ0FhVTtBQWJWOztBQWlCQTtBQUNBLENBQ0UsTUFERixFQUVFLE1BRkYsRUFHRSxNQUhGLEVBSUUsTUFKRixFQVNFOGpCLE9BVEYsQ0FTVSxnQkFBUTtBQUNoQkwsYUFBV3pqQixJQUFYLElBQW1CLElBQUkwakIsa0JBQUosQ0FDakIxakIsSUFEaUIsRUFFakJ3aUIsZ0JBRmlCLEVBR2pCLEtBSGlCLEVBR1Y7QUFDUHhpQixNQUppQixFQUlYO0FBQ04sTUFMaUIsQ0FBbkI7QUFPRCxDQWpCRCxDQWVVO0FBZlY7O0FBbUJBO0FBQ0EsQ0FBQyxTQUFELEVBQVksT0FBWixFQUFxQjhqQixPQUFyQixDQUE2QixnQkFBUTtBQUNuQ0wsYUFBV3pqQixJQUFYLElBQW1CLElBQUkwakIsa0JBQUosQ0FDakIxakIsSUFEaUIsRUFFakJ1aUIsT0FGaUIsRUFHakIsS0FIaUIsRUFHVjtBQUNQdmlCLE9BQUtzaEIsV0FBTCxFQUppQixFQUlHO0FBQ3BCLE1BTGlCLENBQW5CO0FBT0QsQ0FSRCxDQU1VO0FBTlY7O0FBVUEsSUFBTXlDLFdBQVcsZ0JBQWpCO0FBQ0EsSUFBTUMsYUFBYSxTQUFiQSxVQUFhO0FBQUEsU0FBU0MsTUFBTSxDQUFOLEVBQVNDLFdBQVQsRUFBVDtBQUFBLENBQW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUNFLGVBREYsRUFFRSxvQkFGRixFQUdFLGFBSEYsRUFJRSxnQkFKRixFQUtFLFlBTEYsRUFNRSxXQU5GLEVBT0UsV0FQRixFQVFFLHFCQVJGLEVBU0UsNkJBVEYsRUFVRSxlQVZGLEVBV0UsaUJBWEYsRUFZRSxtQkFaRixFQWFFLG1CQWJGLEVBY0UsY0FkRixFQWVFLFdBZkYsRUFnQkUsYUFoQkYsRUFpQkUsZUFqQkYsRUFrQkUsYUFsQkYsRUFtQkUsV0FuQkYsRUFvQkUsa0JBcEJGLEVBcUJFLGNBckJGLEVBc0JFLFlBdEJGLEVBdUJFLGNBdkJGLEVBd0JFLGFBeEJGLEVBeUJFLFlBekJGLEVBMEJFLDhCQTFCRixFQTJCRSw0QkEzQkYsRUE0QkUsYUE1QkYsRUE2QkUsZ0JBN0JGLEVBOEJFLGlCQTlCRixFQStCRSxnQkEvQkYsRUFnQ0UsZ0JBaENGLEVBaUNFLFlBakNGLEVBa0NFLFlBbENGLEVBbUNFLGNBbkNGLEVBb0NFLG1CQXBDRixFQXFDRSxvQkFyQ0YsRUFzQ0UsYUF0Q0YsRUF1Q0UsVUF2Q0YsRUF3Q0UsZ0JBeENGLEVBeUNFLGtCQXpDRixFQTBDRSxpQkExQ0YsRUEyQ0UsWUEzQ0YsRUE0Q0UsY0E1Q0YsRUE2Q0Usd0JBN0NGLEVBOENFLHlCQTlDRixFQStDRSxrQkEvQ0YsRUFnREUsbUJBaERGLEVBaURFLGdCQWpERixFQWtERSxpQkFsREYsRUFtREUsbUJBbkRGLEVBb0RFLGdCQXBERixFQXFERSxjQXJERixFQXNERSxhQXRERixFQXVERSxpQkF2REYsRUF3REUsZ0JBeERGLEVBeURFLG9CQXpERixFQTBERSxxQkExREYsRUEyREUsY0EzREYsRUE0REUsZUE1REYsRUE2REUsY0E3REYsRUE4REUsY0E5REYsRUErREUsV0EvREYsRUFnRUUsZUFoRUYsRUFpRUUsZ0JBakVGLEVBa0VFLGVBbEVGLEVBbUVFLFlBbkVGLEVBb0VFLGVBcEVGLEVBcUVFLGVBckVGLEVBc0VFLGNBdEVGLEVBdUVFLGNBdkVGLEVBd0VFLGFBeEVGLEVBeUVFLFVBekVGLEVBOEVFSixPQTlFRixDQThFVSx5QkFBaUI7QUFDekIsTUFBTTlqQixPQUFPaWpCLGNBQWNsakIsT0FBZCxDQUFzQmdrQixRQUF0QixFQUFnQ0MsVUFBaEMsQ0FBYjtBQUNBUCxhQUFXempCLElBQVgsSUFBbUIsSUFBSTBqQixrQkFBSixDQUNqQjFqQixJQURpQixFQUVqQm1pQixNQUZpQixFQUdqQixLQUhpQixFQUdWO0FBQ1BjLGVBSmlCLEVBS2pCLElBTGlCLENBQW5CO0FBT0QsQ0F2RkQsQ0FxRlU7QUFyRlY7O0FBeUZBO0FBQ0EsQ0FDRSxlQURGLEVBRUUsZUFGRixFQUdFLFlBSEYsRUFJRSxZQUpGLEVBS0UsWUFMRixFQU1FLGFBTkYsRUFPRSxZQVBGLEVBWUVhLE9BWkYsQ0FZVSx5QkFBaUI7QUFDekIsTUFBTTlqQixPQUFPaWpCLGNBQWNsakIsT0FBZCxDQUFzQmdrQixRQUF0QixFQUFnQ0MsVUFBaEMsQ0FBYjtBQUNBUCxhQUFXempCLElBQVgsSUFBbUIsSUFBSTBqQixrQkFBSixDQUNqQjFqQixJQURpQixFQUVqQm1pQixNQUZpQixFQUdqQixLQUhpQixFQUdWO0FBQ1BjLGVBSmlCLEVBS2pCLDhCQUxpQixDQUFuQjtBQU9ELENBckJEOztBQXVCQTtBQUNBLENBQ0UsVUFERixFQUVFLFVBRkYsRUFHRSxXQUhGLEVBUUVhLE9BUkYsQ0FRVSx5QkFBaUI7QUFDekIsTUFBTTlqQixPQUFPaWpCLGNBQWNsakIsT0FBZCxDQUFzQmdrQixRQUF0QixFQUFnQ0MsVUFBaEMsQ0FBYjtBQUNBUCxhQUFXempCLElBQVgsSUFBbUIsSUFBSTBqQixrQkFBSixDQUNqQjFqQixJQURpQixFQUVqQm1pQixNQUZpQixFQUdqQixLQUhpQixFQUdWO0FBQ1BjLGVBSmlCLEVBS2pCLHNDQUxpQixDQUFuQjtBQU9ELENBakJEOztBQW1CQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQUQsRUFBYSxhQUFiLEVBQTRCYSxPQUE1QixDQUFvQyx5QkFBaUI7QUFDbkRMLGFBQVdSLGFBQVgsSUFBNEIsSUFBSVMsa0JBQUosQ0FDMUJULGFBRDBCLEVBRTFCZCxNQUYwQixFQUcxQixLQUgwQixFQUduQjtBQUNQYyxnQkFBYzNCLFdBQWQsRUFKMEIsRUFJRztBQUM3QixNQUwwQixDQUE1QjtBQU9ELENBUkQsQ0FNVTtBQU5WLEU7Ozs7Ozs7Ozs7Ozs7QUMzZ0JBOzs7O0FBQ0E7Ozs7OztBQVJBOzs7Ozs7O0FBVUEsSUFBSTZDLGtCQUFrQixDQUF0QjtBQUNBLElBQUlDLGtCQUFrQixDQUF0QjtBQUNBO0FBQ0EsSUFBSUMsaUJBQWlCLEtBQXJCO0FBQ0EsSUFBSUMsaUJBQWlCLEtBQXJCOztBQUVBOzs7O0FBSUEsSUFBTUMsc0JBQXNCQywyQkFBaUJ4WSxNQUFqQixDQUF3QjtBQUNsRHlZLFdBQVMsSUFEeUM7QUFFbERDLFdBQVMsSUFGeUM7QUFHbERDLFdBQVMsSUFIeUM7QUFJbERDLFdBQVMsSUFKeUM7QUFLbERDLFNBQU8sSUFMMkM7QUFNbERDLFNBQU8sSUFOMkM7QUFPbERDLFdBQVMsSUFQeUM7QUFRbERDLFlBQVUsSUFSd0M7QUFTbERDLFVBQVEsSUFUMEM7QUFVbERDLFdBQVMsSUFWeUM7QUFXbERDLG9CQUFrQkMsK0JBWGdDO0FBWWxEQyxVQUFRLElBWjBDO0FBYWxEQyxXQUFTLElBYnlDO0FBY2xEQyxpQkFBZSx1QkFBU3hiLEtBQVQsRUFBZ0I7QUFDN0IsV0FDRUEsTUFBTXdiLGFBQU4sS0FDQ3hiLE1BQU15YixXQUFOLEtBQXNCemIsTUFBTTBiLFVBQTVCLEdBQ0cxYixNQUFNMmIsU0FEVCxHQUVHM2IsTUFBTXliLFdBSFYsQ0FERjtBQU1ELEdBckJpRDtBQXNCbERHLGFBQVcsbUJBQVM1YixLQUFULEVBQWdCO0FBQ3pCLFFBQUksZUFBZUEsS0FBbkIsRUFBMEI7QUFDeEIsYUFBT0EsTUFBTTRiLFNBQWI7QUFDRDs7QUFFRCxRQUFNbEIsVUFBVU4sZUFBaEI7QUFDQUEsc0JBQWtCcGEsTUFBTTBhLE9BQXhCOztBQUVBLFFBQUksQ0FBQ0osY0FBTCxFQUFxQjtBQUNuQkEsdUJBQWlCLElBQWpCO0FBQ0EsYUFBTyxDQUFQO0FBQ0Q7O0FBRUQsV0FBT3RhLE1BQU1uRyxJQUFOLEtBQWUsV0FBZixHQUE2Qm1HLE1BQU0wYSxPQUFOLEdBQWdCQSxPQUE3QyxHQUF1RCxDQUE5RDtBQUNELEdBcENpRDtBQXFDbERtQixhQUFXLG1CQUFTN2IsS0FBVCxFQUFnQjtBQUN6QixRQUFJLGVBQWVBLEtBQW5CLEVBQTBCO0FBQ3hCLGFBQU9BLE1BQU02YixTQUFiO0FBQ0Q7O0FBRUQsUUFBTWxCLFVBQVVOLGVBQWhCO0FBQ0FBLHNCQUFrQnJhLE1BQU0yYSxPQUF4Qjs7QUFFQSxRQUFJLENBQUNKLGNBQUwsRUFBcUI7QUFDbkJBLHVCQUFpQixJQUFqQjtBQUNBLGFBQU8sQ0FBUDtBQUNEOztBQUVELFdBQU92YSxNQUFNbkcsSUFBTixLQUFlLFdBQWYsR0FBNkJtRyxNQUFNMmEsT0FBTixHQUFnQkEsT0FBN0MsR0FBdUQsQ0FBOUQ7QUFDRDtBQW5EaUQsQ0FBeEIsQ0FBNUI7O2tCQXNEZUgsbUI7Ozs7Ozs7Ozs7Ozs7QUNuRWY7Ozs7OztBQUVBLElBQU1DLG1CQUFtQmxhLHlCQUFlMEIsTUFBZixDQUFzQjtBQUM3QzZaLFFBQU0sSUFEdUM7QUFFN0NDLFVBQVE7QUFGcUMsQ0FBdEIsQ0FBekIsQyxDQVRBOzs7Ozs7O2tCQWNldEIsZ0I7Ozs7Ozs7Ozs7OztRQzhNQ3VCLFksR0FBQUEsWTtRQU1BQyxvQixHQUFBQSxvQjtRQWVBQyx5QixHQUFBQSx5QjtRQVNBQyx3QixHQUFBQSx3QjtRQWlCQUMsYyxHQUFBQSxjO1FBY0FDLGUsR0FBQUEsZTtRQVlBQyxhLEdBQUFBLGE7UUFlQUMsbUIsR0FBQUEsbUI7UUFvQkFDLGUsR0FBQUEsZTtRQWNBQyxjLEdBQUFBLGM7UUFnQkFDLGtCLEdBQUFBLGtCO1FBZUFDLGlCLEdBQUFBLGlCO1FBNkJBQyxnQixHQUFBQSxnQjtRQVlBQyxlLEdBQUFBLGU7UUFxQkFDLCtCLEdBQUFBLCtCO1FBVUFDLDhCLEdBQUFBLDhCO1FBZUFDLDJCLEdBQUFBLDJCO1FBVUFDLDBCLEdBQUFBLDBCO1FBZUFDLDBCLEdBQUFBLDBCO1FBVUFDLHlCLEdBQUFBLHlCOztBQXBlaEI7O0FBQ0E7Ozs7QUFDQTs7OztBQXdCQTtBQUNBO0FBdENBOzs7Ozs7Ozs7QUF1Q0EsSUFBTUMsYUFBYSxRQUFuQjtBQUNBLElBQU1DLGVBQWUsUUFBckI7QUFDQSxJQUFNQyxxQkFDSixPQUFPQyxXQUFQLEtBQXVCLFdBQXZCLElBQ0EsT0FBT0EsWUFBWUMsSUFBbkIsS0FBNEIsVUFENUIsSUFFQSxPQUFPRCxZQUFZRSxVQUFuQixLQUFrQyxVQUZsQyxJQUdBLE9BQU9GLFlBQVlHLE9BQW5CLEtBQStCLFVBSC9CLElBSUEsT0FBT0gsWUFBWUksYUFBbkIsS0FBcUMsVUFMdkM7O0FBT0E7QUFDQTtBQUNBLElBQUlDLGVBQTZCLElBQWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQyxlQUF3QyxJQUE1QztBQUNBLElBQUlDLG9CQUFrQyxJQUF0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLGVBQXdCLEtBQTVCO0FBQ0EsSUFBSUMsb0NBQTZDLEtBQWpEO0FBQ0EsSUFBSUMsbUNBQTRDLEtBQWhEO0FBQ0EsSUFBSUMsK0JBQXVDLENBQTNDO0FBQ0EsSUFBSUMsNkJBQXFDLENBQXpDO0FBQ0EsSUFBSUMsdUJBQWdDLEtBQXBDO0FBQ0E7QUFDQTtBQUNBLElBQU1DLHdCQUFxQyxJQUFJQyxHQUFKLEVBQTNDOztBQUVBLElBQU1DLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBQ0MsUUFBRCxFQUFzQjtBQUMzQyxTQUFVcEIsVUFBVixTQUF3Qm9CLFFBQXhCO0FBQ0QsQ0FGRDs7QUFJQSxJQUFNQyxjQUFjLFNBQWRBLFdBQWMsQ0FBQ0MsS0FBRCxFQUFnQjFuQixPQUFoQixFQUEyQztBQUM3RCxNQUFNd2lCLFNBQVN4aUIsVUFBYXFtQixZQUFiLFNBQWtDRCxVQUFsQyxNQUFmO0FBQ0EsTUFBTXVCLFNBQVMzbkIseUJBQXVCQSxPQUF2QixHQUFtQyxFQUFsRDtBQUNBLGNBQVV3aUIsTUFBVixHQUFtQmtGLEtBQW5CLEdBQTJCQyxNQUEzQjtBQUNELENBSkQ7O0FBTUEsSUFBTUMsWUFBWSxTQUFaQSxTQUFZLENBQUNKLFFBQUQsRUFBc0I7QUFDdENqQixjQUFZQyxJQUFaLENBQWlCZSxlQUFlQyxRQUFmLENBQWpCO0FBQ0QsQ0FGRDs7QUFJQSxJQUFNSyxZQUFZLFNBQVpBLFNBQVksQ0FBQ0wsUUFBRCxFQUFzQjtBQUN0Q2pCLGNBQVlFLFVBQVosQ0FBdUJjLGVBQWVDLFFBQWYsQ0FBdkI7QUFDRCxDQUZEOztBQUlBLElBQU1NLFVBQVUsU0FBVkEsT0FBVSxDQUFDSixLQUFELEVBQWdCRixRQUFoQixFQUFrQ3huQixPQUFsQyxFQUE2RDtBQUMzRSxNQUFNK25CLG9CQUFvQlIsZUFBZUMsUUFBZixDQUExQjtBQUNBLE1BQU1RLGlCQUFpQlAsWUFBWUMsS0FBWixFQUFtQjFuQixPQUFuQixDQUF2QjtBQUNBLE1BQUk7QUFDRnVtQixnQkFBWUcsT0FBWixDQUFvQnNCLGNBQXBCLEVBQW9DRCxpQkFBcEM7QUFDRCxHQUZELENBRUUsT0FBT0UsR0FBUCxFQUFZLENBSWI7QUFIQztBQUNBO0FBQ0E7O0FBRUY7QUFDQTFCLGNBQVlFLFVBQVosQ0FBdUJzQixpQkFBdkI7QUFDQXhCLGNBQVlJLGFBQVosQ0FBMEJxQixjQUExQjtBQUNELENBYkQ7O0FBZUEsSUFBTUUsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBQ1IsS0FBRCxFQUFnQlMsT0FBaEIsRUFBb0M7QUFDM0QsU0FBVVQsS0FBVixXQUFxQlMsT0FBckI7QUFDRCxDQUZEOztBQUlBLElBQU1DLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FDcEI5SyxhQURvQixFQUVwQitLLFNBRm9CLEVBR3BCMWlCLEtBSG9CLEVBSWpCO0FBQ0gsTUFBSUEsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCO0FBQ0EsV0FBVTJYLGFBQVYsV0FBNEIrSyxZQUFZLFFBQVosR0FBdUIsT0FBbkQ7QUFDRCxHQUhELE1BR087QUFDTDtBQUNBLFdBQVUvSyxhQUFWLFNBQTJCM1gsS0FBM0I7QUFDRDtBQUNGLENBWkQ7O0FBY0EsSUFBTTJpQixpQkFBaUIsU0FBakJBLGNBQWlCLENBQ3JCdGpCLEtBRHFCLEVBRXJCVyxLQUZxQixFQUdUO0FBQ1osTUFBTTJYLGdCQUFnQixnQ0FBaUJ0WSxNQUFNbkMsSUFBdkIsS0FBZ0MsU0FBdEQ7QUFDQSxNQUFNc2xCLFVBQVluakIsTUFBTXVqQixRQUF4QjtBQUNBLE1BQU1GLFlBQVlyakIsTUFBTWlSLFNBQU4sS0FBb0IsSUFBdEM7QUFDQSxNQUFNeVIsUUFBUVUsY0FBYzlLLGFBQWQsRUFBNkIrSyxTQUE3QixFQUF3QzFpQixLQUF4QyxDQUFkOztBQUVBLE1BQUlvaEIsZ0JBQWdCTSxzQkFBc0JtQixHQUF0QixDQUEwQmQsS0FBMUIsQ0FBcEIsRUFBc0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsV0FBTyxLQUFQO0FBQ0Q7QUFDREwsd0JBQXNCb0IsR0FBdEIsQ0FBMEJmLEtBQTFCOztBQUVBLE1BQU1GLFdBQVdVLGlCQUFpQlIsS0FBakIsRUFBd0JTLE9BQXhCLENBQWpCO0FBQ0FQLFlBQVVKLFFBQVY7QUFDQSxTQUFPLElBQVA7QUFDRCxDQXBCRDs7QUFzQkEsSUFBTWtCLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBQzFqQixLQUFELEVBQWVXLEtBQWYsRUFBa0Q7QUFDdkUsTUFBTTJYLGdCQUFnQixnQ0FBaUJ0WSxNQUFNbkMsSUFBdkIsS0FBZ0MsU0FBdEQ7QUFDQSxNQUFNc2xCLFVBQVluakIsTUFBTXVqQixRQUF4QjtBQUNBLE1BQU1GLFlBQVlyakIsTUFBTWlSLFNBQU4sS0FBb0IsSUFBdEM7QUFDQSxNQUFNeVIsUUFBUVUsY0FBYzlLLGFBQWQsRUFBNkIrSyxTQUE3QixFQUF3QzFpQixLQUF4QyxDQUFkO0FBQ0EsTUFBTTZoQixXQUFXVSxpQkFBaUJSLEtBQWpCLEVBQXdCUyxPQUF4QixDQUFqQjtBQUNBTixZQUFVTCxRQUFWO0FBQ0QsQ0FQRDs7QUFTQSxJQUFNbUIsZUFBZSxTQUFmQSxZQUFlLENBQ25CM2pCLEtBRG1CLEVBRW5CVyxLQUZtQixFQUduQjNGLE9BSG1CLEVBSWhCO0FBQ0gsTUFBTXNkLGdCQUFnQixnQ0FBaUJ0WSxNQUFNbkMsSUFBdkIsS0FBZ0MsU0FBdEQ7QUFDQSxNQUFNc2xCLFVBQVluakIsTUFBTXVqQixRQUF4QjtBQUNBLE1BQU1GLFlBQVlyakIsTUFBTWlSLFNBQU4sS0FBb0IsSUFBdEM7QUFDQSxNQUFNeVIsUUFBUVUsY0FBYzlLLGFBQWQsRUFBNkIrSyxTQUE3QixFQUF3QzFpQixLQUF4QyxDQUFkO0FBQ0EsTUFBTTZoQixXQUFXVSxpQkFBaUJSLEtBQWpCLEVBQXdCUyxPQUF4QixDQUFqQjtBQUNBTCxVQUFRSixLQUFSLEVBQWVGLFFBQWYsRUFBeUJ4bkIsT0FBekI7QUFDRCxDQVhEOztBQWFBLElBQU00b0Isb0JBQW9CLFNBQXBCQSxpQkFBb0IsQ0FBQzVqQixLQUFELEVBQTJCO0FBQ25EO0FBQ0E7QUFDQSxVQUFRQSxNQUFNbEMsR0FBZDtBQUNFLFNBQUt4Qix1QkFBTDtBQUNBLFNBQUtFLDRCQUFMO0FBQ0EsU0FBS0MsdUJBQUw7QUFDQSxTQUFLRix5QkFBTDtBQUNBLFNBQUtHLHVCQUFMO0FBQ0EsU0FBS0csOEJBQUw7QUFDQSxTQUFLRCw4QkFBTDtBQUNBLFNBQUtELG1CQUFMO0FBQ0UsYUFBTyxJQUFQO0FBQ0Y7QUFDRSxhQUFPLEtBQVA7QUFYSjtBQWFELENBaEJEOztBQWtCQSxJQUFNa25CLCtCQUErQixTQUEvQkEsNEJBQStCLEdBQU07QUFDekMsTUFBSWhDLGlCQUFpQixJQUFqQixJQUF5QkMsc0JBQXNCLElBQW5ELEVBQXlEO0FBQ3ZENEIsbUJBQWU1QixpQkFBZixFQUFrQ0QsWUFBbEM7QUFDRDtBQUNEQyxzQkFBb0IsSUFBcEI7QUFDQUQsaUJBQWUsSUFBZjtBQUNBSSxxQ0FBbUMsS0FBbkM7QUFDRCxDQVBEOztBQVNBLElBQU02QixjQUFjLFNBQWRBLFdBQWMsR0FBTTtBQUN4QjtBQUNBO0FBQ0EsTUFBSTlqQixRQUFRNGhCLFlBQVo7QUFDQSxTQUFPNWhCLEtBQVAsRUFBYztBQUNaLFFBQUlBLE1BQU0rakIsdUJBQVYsRUFBbUM7QUFDakNKLG1CQUFhM2pCLEtBQWIsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUI7QUFDRDtBQUNEQSxZQUFRQSxNQUFNUyxNQUFkO0FBQ0Q7QUFDRixDQVZEOztBQVlBLElBQU11akIsMEJBQTBCLFNBQTFCQSx1QkFBMEIsQ0FBQ2hrQixLQUFELEVBQWtCO0FBQ2hELE1BQUlBLE1BQU1TLE1BQU4sS0FBaUIsSUFBckIsRUFBMkI7QUFDekJ1akIsNEJBQXdCaGtCLE1BQU1TLE1BQTlCO0FBQ0Q7QUFDRCxNQUFJVCxNQUFNK2pCLHVCQUFWLEVBQW1DO0FBQ2pDVCxtQkFBZXRqQixLQUFmLEVBQXNCLElBQXRCO0FBQ0Q7QUFDRixDQVBEOztBQVNBLElBQU1pa0IsZUFBZSxTQUFmQSxZQUFlLEdBQU07QUFDekI7QUFDQSxNQUFJckMsaUJBQWlCLElBQXJCLEVBQTJCO0FBQ3pCb0MsNEJBQXdCcEMsWUFBeEI7QUFDRDtBQUNGLENBTEQ7O0FBT08sU0FBUzVCLFlBQVQsR0FBOEI7QUFDbkMsTUFBSTFrQixzQ0FBSixFQUF5QjtBQUN2QjZtQjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU2xDLG9CQUFULEdBQXNDO0FBQzNDLE1BQUkza0Isc0NBQUosRUFBeUI7QUFDdkIsUUFBSXltQixZQUFKLEVBQWtCO0FBQ2hCQywwQ0FBb0MsSUFBcEM7QUFDRDtBQUNELFFBQ0VILGlCQUFpQixJQUFqQixJQUNBQSxpQkFBaUIsb0JBRGpCLElBRUFBLGlCQUFpQiwyQkFIbkIsRUFJRTtBQUNBSSx5Q0FBbUMsSUFBbkM7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBUy9CLHlCQUFULEdBQTJDO0FBQ2hELE1BQUk1a0Isc0NBQUosRUFBeUI7QUFDdkIsUUFBSWdtQixzQkFBc0IsQ0FBQ2Msb0JBQTNCLEVBQWlEO0FBQy9DQSw2QkFBdUIsSUFBdkI7QUFDQVEsZ0JBQVUsaUNBQVY7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBU3pDLHdCQUFULENBQ0wrRCxTQURLLEVBRUx6aEIsY0FGSyxFQUdDO0FBQ04sTUFBSW5ILHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUlnbUIsa0JBQUosRUFBd0I7QUFDdEJjLDZCQUF1QixLQUF2QjtBQUNBLFVBQU1wbkIsVUFBVWtwQixZQUFZLGtDQUFaLEdBQWlELElBQWpFO0FBQ0FwQixzRUFDd0RyZ0IsY0FEeEQsV0FFRSxpQ0FGRixFQUdFekgsT0FIRjtBQUtEO0FBQ0Y7QUFDRjs7QUFFTSxTQUFTb2xCLGNBQVQsQ0FBd0JwZ0IsS0FBeEIsRUFBNEM7QUFDakQsTUFBSTFFLHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQ2dtQixrQkFBRCxJQUF1QnNDLGtCQUFrQjVqQixLQUFsQixDQUEzQixFQUFxRDtBQUNuRDtBQUNEO0FBQ0Q7QUFDQTRoQixtQkFBZTVoQixLQUFmO0FBQ0EsUUFBSSxDQUFDc2pCLGVBQWV0akIsS0FBZixFQUFzQixJQUF0QixDQUFMLEVBQWtDO0FBQ2hDO0FBQ0Q7QUFDREEsVUFBTStqQix1QkFBTixHQUFnQyxJQUFoQztBQUNEO0FBQ0Y7O0FBRU0sU0FBUzFELGVBQVQsQ0FBeUJyZ0IsS0FBekIsRUFBNkM7QUFDbEQsTUFBSTFFLHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQ2dtQixrQkFBRCxJQUF1QnNDLGtCQUFrQjVqQixLQUFsQixDQUEzQixFQUFxRDtBQUNuRDtBQUNEO0FBQ0Q7QUFDQTtBQUNBQSxVQUFNK2pCLHVCQUFOLEdBQWdDLEtBQWhDO0FBQ0FMLG1CQUFlMWpCLEtBQWYsRUFBc0IsSUFBdEI7QUFDRDtBQUNGOztBQUVNLFNBQVNzZ0IsYUFBVCxDQUF1QnRnQixLQUF2QixFQUEyQztBQUNoRCxNQUFJMUUsc0NBQUosRUFBeUI7QUFDdkIsUUFBSSxDQUFDZ21CLGtCQUFELElBQXVCc0Msa0JBQWtCNWpCLEtBQWxCLENBQTNCLEVBQXFEO0FBQ25EO0FBQ0Q7QUFDRDtBQUNBNGhCLG1CQUFlNWhCLE1BQU1TLE1BQXJCO0FBQ0EsUUFBSSxDQUFDVCxNQUFNK2pCLHVCQUFYLEVBQW9DO0FBQ2xDO0FBQ0Q7QUFDRC9qQixVQUFNK2pCLHVCQUFOLEdBQWdDLEtBQWhDO0FBQ0FKLGlCQUFhM2pCLEtBQWIsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUI7QUFDRDtBQUNGOztBQUVNLFNBQVN1Z0IsbUJBQVQsQ0FBNkJ2Z0IsS0FBN0IsRUFBaUQ7QUFDdEQsTUFBSTFFLHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQ2dtQixrQkFBRCxJQUF1QnNDLGtCQUFrQjVqQixLQUFsQixDQUEzQixFQUFxRDtBQUNuRDtBQUNEO0FBQ0Q7QUFDQTRoQixtQkFBZTVoQixNQUFNUyxNQUFyQjtBQUNBLFFBQUksQ0FBQ1QsTUFBTStqQix1QkFBWCxFQUFvQztBQUNsQztBQUNEO0FBQ0QvakIsVUFBTStqQix1QkFBTixHQUFnQyxLQUFoQztBQUNBLFFBQU0vb0IsVUFDSmdGLE1BQU1sQyxHQUFOLEtBQWNkLGdDQUFkLElBQ0FnRCxNQUFNbEMsR0FBTixLQUFjVCwwQ0FEZCxHQUVJLHlCQUZKLEdBR0ksZ0RBSk47QUFLQXNtQixpQkFBYTNqQixLQUFiLEVBQW9CLElBQXBCLEVBQTBCaEYsT0FBMUI7QUFDRDtBQUNGOztBQUVNLFNBQVN3bEIsZUFBVCxDQUF5QnhnQixLQUF6QixFQUF1Q1csS0FBdkMsRUFBc0U7QUFDM0UsTUFBSXJGLHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQ2dtQixrQkFBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0R1QztBQUNBLFFBQUksQ0FBQ1AsZUFBZXRqQixLQUFmLEVBQXNCVyxLQUF0QixDQUFMLEVBQW1DO0FBQ2pDO0FBQ0Q7QUFDRG1oQix3QkFBb0I5aEIsS0FBcEI7QUFDQTZoQixtQkFBZWxoQixLQUFmO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTOGYsY0FBVCxHQUFnQztBQUNyQyxNQUFJbmxCLHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQ2dtQixrQkFBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0QsUUFBSU8saUJBQWlCLElBQWpCLElBQXlCQyxzQkFBc0IsSUFBbkQsRUFBeUQ7QUFDdkQsVUFBTTltQixVQUFVaW5CLG1DQUNaLDhCQURZLEdBRVosSUFGSjtBQUdBMEIsbUJBQWE3QixpQkFBYixFQUFnQ0QsWUFBaEMsRUFBOEM3bUIsT0FBOUM7QUFDRDtBQUNENm1CLG1CQUFlLElBQWY7QUFDQUMsd0JBQW9CLElBQXBCO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTcEIsa0JBQVQsQ0FBNEJ5RCxjQUE1QixFQUFnRTtBQUNyRSxNQUFJN29CLHNDQUFKLEVBQXlCO0FBQ3ZCc21CLG1CQUFldUMsY0FBZjtBQUNBLFFBQUksQ0FBQzdDLGtCQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7QUFDRFksbUNBQStCLENBQS9CO0FBQ0E7QUFDQTtBQUNBVSxjQUFVLDZCQUFWO0FBQ0E7QUFDQXFCO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTdEQsaUJBQVQsQ0FDTHlELGFBREssRUFFTEMsZUFGSyxFQUdDO0FBQ04sTUFBSS9vQixzQ0FBSixFQUF5QjtBQUN2QixRQUFJLENBQUNnbUIsa0JBQUwsRUFBeUI7QUFDdkI7QUFDRDtBQUNELFFBQUl0bUIsVUFBVSxJQUFkO0FBQ0EsUUFBSW9wQixrQkFBa0IsSUFBdEIsRUFBNEI7QUFDMUIsVUFBSUEsY0FBY3RtQixHQUFkLEtBQXNCeEIsdUJBQTFCLEVBQW9DO0FBQ2xDdEIsa0JBQVUsb0RBQVY7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFNc2QsZ0JBQWdCLGdDQUFpQjhMLGNBQWN2bUIsSUFBL0IsS0FBd0MsU0FBOUQ7QUFDQTdDLG9DQUEwQnNkLGFBQTFCO0FBQ0Q7QUFDRixLQVBELE1BT08sSUFBSTRKLCtCQUErQixDQUFuQyxFQUFzQztBQUMzQ2xuQixnQkFBVSw4QkFBVjtBQUNEO0FBQ0RrbkIsbUNBQStCLENBQS9CO0FBQ0EsUUFBSVEsUUFBUTJCLGtCQUNSLDZDQURRLEdBRVIsc0NBRko7QUFHQTtBQUNBUDtBQUNBaEIsWUFBUUosS0FBUixFQUFlLDZCQUFmLEVBQThDMW5CLE9BQTlDO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTNGxCLGdCQUFULEdBQWtDO0FBQ3ZDLE1BQUl0bEIsc0NBQUosRUFBeUI7QUFDdkIsUUFBSSxDQUFDZ21CLGtCQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7QUFDRFMsbUJBQWUsSUFBZjtBQUNBQyx3Q0FBb0MsS0FBcEM7QUFDQUssMEJBQXNCaUMsS0FBdEI7QUFDQTFCLGNBQVUsc0JBQVY7QUFDRDtBQUNGOztBQUVNLFNBQVMvQixlQUFULEdBQWlDO0FBQ3RDLE1BQUl2bEIsc0NBQUosRUFBeUI7QUFDdkIsUUFBSSxDQUFDZ21CLGtCQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7O0FBRUQsUUFBSXRtQixVQUFVLElBQWQ7QUFDQSxRQUFJZ25CLGlDQUFKLEVBQXVDO0FBQ3JDaG5CLGdCQUFVLDZDQUFWO0FBQ0QsS0FGRCxNQUVPLElBQUlrbkIsK0JBQStCLENBQW5DLEVBQXNDO0FBQzNDbG5CLGdCQUFVLGdEQUFWO0FBQ0Q7QUFDRGduQix3Q0FBb0MsS0FBcEM7QUFDQUU7QUFDQUgsbUJBQWUsS0FBZjtBQUNBTSwwQkFBc0JpQyxLQUF0Qjs7QUFFQXhCLFlBQVEsc0JBQVIsRUFBZ0Msc0JBQWhDLEVBQXdEOW5CLE9BQXhEO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTOGxCLCtCQUFULEdBQWlEO0FBQ3RELE1BQUl4bEIsc0NBQUosRUFBeUI7QUFDdkIsUUFBSSxDQUFDZ21CLGtCQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7QUFDRGEsaUNBQTZCLENBQTdCO0FBQ0FTLGNBQVUsK0JBQVY7QUFDRDtBQUNGOztBQUVNLFNBQVM3Qiw4QkFBVCxHQUFnRDtBQUNyRCxNQUFJemxCLHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQ2dtQixrQkFBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0QsUUFBTWlELFFBQVFwQywwQkFBZDtBQUNBQSxpQ0FBNkIsQ0FBN0I7QUFDQVcsK0NBQ21DeUIsS0FEbkMsY0FFRSwrQkFGRixFQUdFLElBSEY7QUFLRDtBQUNGOztBQUVNLFNBQVN2RCwyQkFBVCxHQUE2QztBQUNsRCxNQUFJMWxCLHNDQUFKLEVBQXlCO0FBQ3ZCLFFBQUksQ0FBQ2dtQixrQkFBTCxFQUF5QjtBQUN2QjtBQUNEO0FBQ0RhLGlDQUE2QixDQUE3QjtBQUNBUyxjQUFVLDJCQUFWO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTM0IsMEJBQVQsR0FBNEM7QUFDakQsTUFBSTNsQixzQ0FBSixFQUF5QjtBQUN2QixRQUFJLENBQUNnbUIsa0JBQUwsRUFBeUI7QUFDdkI7QUFDRDtBQUNELFFBQU1pRCxRQUFRcEMsMEJBQWQ7QUFDQUEsaUNBQTZCLENBQTdCO0FBQ0FXLDJDQUMrQnlCLEtBRC9CLGNBRUUsMkJBRkYsRUFHRSxJQUhGO0FBS0Q7QUFDRjs7QUFFTSxTQUFTckQsMEJBQVQsR0FBNEM7QUFDakQsTUFBSTVsQixzQ0FBSixFQUF5QjtBQUN2QixRQUFJLENBQUNnbUIsa0JBQUwsRUFBeUI7QUFDdkI7QUFDRDtBQUNEYSxpQ0FBNkIsQ0FBN0I7QUFDQVMsY0FBVSw2QkFBVjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU3pCLHlCQUFULEdBQTJDO0FBQ2hELE1BQUk3bEIsc0NBQUosRUFBeUI7QUFDdkIsUUFBSSxDQUFDZ21CLGtCQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7QUFDRCxRQUFNaUQsUUFBUXBDLDBCQUFkO0FBQ0FBLGlDQUE2QixDQUE3QjtBQUNBVyw2Q0FDaUN5QixLQURqQyxjQUVFLDZCQUZGLEVBR0UsSUFIRjtBQUtEO0FBQ0YsQzs7Ozs7Ozs7Ozs7Ozs4UUM1ZkQ7Ozs7Ozs7OztRQWlVZ0JDLHlCLEdBQUFBLHlCO1FBUUFDLHVCLEdBQUFBLHVCO1FBZ0JBQyxvQixHQUFBQSxvQjtRQTJFQUMsbUIsR0FBQUEsbUI7UUFhQUMsMkIsR0FBQUEsMkI7UUEwR0FDLHNCLEdBQUFBLHNCO1FBMkJBQyx1QixHQUFBQSx1QjtRQTBEQUMsdUIsR0FBQUEsdUI7UUFpQkFDLG1CLEdBQUFBLG1CO1FBVUFDLHNDLEdBQUFBLHNDO1FBUUFDLHFCLEdBQUFBLHFCO1FBaUJBQywwQixHQUFBQSwwQjs7QUFscEJoQjs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBa0JBOzs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBTUE7Ozs7QUFhQSxJQUFJQywwQkFBSjs7QUFFQSxJQUFJbHNCLElBQUosRUFBYTtBQUNYa3NCLHNCQUFvQixLQUFwQjtBQUNBLE1BQUk7QUFDRixRQUFNQyxzQkFBc0I5ZixPQUFPK2YsaUJBQVAsQ0FBeUIsRUFBekIsQ0FBNUI7QUFDQSxRQUFNQyxVQUFVLElBQUlDLEdBQUosQ0FBUSxDQUFDLENBQUNILG1CQUFELEVBQXNCLElBQXRCLENBQUQsQ0FBUixDQUFoQjtBQUNBLFFBQU1JLFVBQVUsSUFBSW5ELEdBQUosQ0FBUSxDQUFDK0MsbUJBQUQsQ0FBUixDQUFoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxZQUFRN2UsR0FBUixDQUFZLENBQVosRUFBZSxDQUFmO0FBQ0ErZSxZQUFRaEMsR0FBUixDQUFZLENBQVo7QUFDRCxHQVRELENBU0UsT0FBTzlwQixDQUFQLEVBQVU7QUFDVjtBQUNBeXJCLHdCQUFvQixJQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTs7O0FBNkhBLElBQUlNLHFCQUFKOztBQUVBLElBQUl4c0IsSUFBSixFQUFhO0FBQ1h3c0IsaUJBQWUsQ0FBZjtBQUNEOztBQUVELFNBQVNDLFNBQVQsQ0FDRTduQixHQURGLEVBRUU4bkIsWUFGRixFQUdFaE8sR0FIRixFQUlFakcsSUFKRixFQUtFO0FBQ0E7QUFDQSxPQUFLN1QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBSzhaLEdBQUwsR0FBV0EsR0FBWDtBQUNBLE9BQUtpTyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsT0FBS2hvQixJQUFMLEdBQVksSUFBWjtBQUNBLE9BQUs0USxTQUFMLEdBQWlCLElBQWpCOztBQUVBO0FBQ0EsT0FBS2hPLE1BQUwsR0FBYyxJQUFkO0FBQ0EsT0FBS2tVLEtBQUwsR0FBYSxJQUFiO0FBQ0EsT0FBS08sT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLNFEsS0FBTCxHQUFhLENBQWI7O0FBRUEsT0FBS0MsR0FBTCxHQUFXLElBQVg7O0FBRUEsT0FBS0gsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxPQUFLSSxhQUFMLEdBQXFCLElBQXJCO0FBQ0EsT0FBSzVVLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxPQUFLQyxhQUFMLEdBQXFCLElBQXJCO0FBQ0EsT0FBS3lELG1CQUFMLEdBQTJCLElBQTNCOztBQUVBLE9BQUtuRCxJQUFMLEdBQVlBLElBQVo7O0FBRUE7QUFDQSxPQUFLRSxTQUFMLEdBQWlCL1EsNkJBQWpCO0FBQ0EsT0FBS2dRLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUEsT0FBS1QsV0FBTCxHQUFtQixJQUFuQjtBQUNBLE9BQUtDLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUEsT0FBSzdOLGNBQUwsR0FBc0JQLGdDQUF0QjtBQUNBLE9BQUt3UyxtQkFBTCxHQUEyQnhTLGdDQUEzQjs7QUFFQSxPQUFLK08sU0FBTCxHQUFpQixJQUFqQjs7QUFFQSxNQUFJdFYsc0NBQUosRUFBeUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBS3NxQixjQUFMLEdBQXNCQyxPQUFPQyxHQUE3QjtBQUNBLFNBQUtDLGVBQUwsR0FBdUJGLE9BQU9DLEdBQTlCO0FBQ0EsU0FBS0UsZ0JBQUwsR0FBd0JILE9BQU9DLEdBQS9CO0FBQ0EsU0FBS0csZ0JBQUwsR0FBd0JKLE9BQU9DLEdBQS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQUtGLGNBQUwsR0FBc0IsQ0FBdEI7QUFDQSxTQUFLRyxlQUFMLEdBQXVCLENBQUMsQ0FBeEI7QUFDQSxTQUFLQyxnQkFBTCxHQUF3QixDQUF4QjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLENBQXhCO0FBQ0Q7O0FBRUQsTUFBSXB0QixJQUFKLEVBQWE7QUFDWCxTQUFLcXFCLFFBQUwsR0FBZ0JtQyxjQUFoQjtBQUNBLFNBQUt0bEIsWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUtGLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxTQUFLNmpCLHVCQUFMLEdBQStCLEtBQS9CO0FBQ0EsUUFBSSxDQUFDcUIsaUJBQUQsSUFBc0IsT0FBTzdmLE9BQU8rZixpQkFBZCxLQUFvQyxVQUE5RCxFQUEwRTtBQUN4RS9mLGFBQU8rZixpQkFBUCxDQUF5QixJQUF6QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1pQixjQUFjLFNBQWRBLFdBQWMsQ0FDbEJ6b0IsR0FEa0IsRUFFbEI4bkIsWUFGa0IsRUFHbEJoTyxHQUhrQixFQUlsQmpHLElBSmtCLEVBS1g7QUFDUDtBQUNBLFNBQU8sSUFBSWdVLFNBQUosQ0FBYzduQixHQUFkLEVBQW1COG5CLFlBQW5CLEVBQWlDaE8sR0FBakMsRUFBc0NqRyxJQUF0QyxDQUFQO0FBQ0QsQ0FSRDs7QUFVQSxTQUFTNlUsZUFBVCxDQUF5QnRQLFNBQXpCLEVBQThDO0FBQzVDLE1BQU12YyxZQUFZdWMsVUFBVXZjLFNBQTVCO0FBQ0EsU0FBTyxDQUFDLEVBQUVBLGFBQWFBLFVBQVU4ckIsZ0JBQXpCLENBQVI7QUFDRDs7QUFFTSxTQUFTakMseUJBQVQsQ0FBbUMzbUIsSUFBbkMsRUFBOEM7QUFDbkQsU0FDRSxPQUFPQSxJQUFQLEtBQWdCLFVBQWhCLElBQ0EsQ0FBQzJvQixnQkFBZ0Izb0IsSUFBaEIsQ0FERCxJQUVBQSxLQUFLNm9CLFlBQUwsS0FBc0J0dEIsU0FIeEI7QUFLRDs7QUFFTSxTQUFTcXJCLHVCQUFULENBQWlDdk4sU0FBakMsRUFBK0Q7QUFDcEUsTUFBSSxPQUFPQSxTQUFQLEtBQXFCLFVBQXpCLEVBQXFDO0FBQ25DLFdBQU9zUCxnQkFBZ0J0UCxTQUFoQixJQUE2QjlhLDZCQUE3QixHQUE4Q0QsZ0NBQXJEO0FBQ0QsR0FGRCxNQUVPLElBQUkrYSxjQUFjOWQsU0FBZCxJQUEyQjhkLGNBQWMsSUFBN0MsRUFBbUQ7QUFDeEQsUUFBTTdZLFdBQVc2WSxVQUFVN1ksUUFBM0I7QUFDQSxRQUFJQSxhQUFhRyxvQ0FBakIsRUFBeUM7QUFDdkMsYUFBTzFCLHlCQUFQO0FBQ0Q7QUFDRCxRQUFJdUIsYUFBYUssNkJBQWpCLEVBQWtDO0FBQ2hDLGFBQU96Qiw0QkFBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPWixxQ0FBUDtBQUNEOztBQUVEO0FBQ08sU0FBU3FvQixvQkFBVCxDQUNMaGtCLE9BREssRUFFTGtsQixZQUZLLEVBR0xuakIsY0FISyxFQUlFO0FBQ1AsTUFBSW5DLGlCQUFpQkksUUFBUXVRLFNBQTdCO0FBQ0EsTUFBSTNRLG1CQUFtQixJQUF2QixFQUE2QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLHFCQUFpQmltQixZQUNmN2xCLFFBQVE1QyxHQURPLEVBRWY4bkIsWUFGZSxFQUdmbGxCLFFBQVFrWCxHQUhPLEVBSWZsWCxRQUFRaVIsSUFKTyxDQUFqQjtBQU1BclIsbUJBQWV1bEIsV0FBZixHQUE2Qm5sQixRQUFRbWxCLFdBQXJDO0FBQ0F2bEIsbUJBQWV6QyxJQUFmLEdBQXNCNkMsUUFBUTdDLElBQTlCO0FBQ0F5QyxtQkFBZW1PLFNBQWYsR0FBMkIvTixRQUFRK04sU0FBbkM7O0FBRUEsUUFBSXZWLElBQUosRUFBYTtBQUNYO0FBQ0FvSCxxQkFBZWlqQixRQUFmLEdBQTBCN2lCLFFBQVE2aUIsUUFBbEM7QUFDQWpqQixxQkFBZUYsWUFBZixHQUE4Qk0sUUFBUU4sWUFBdEM7QUFDQUUscUJBQWVKLFdBQWYsR0FBNkJRLFFBQVFSLFdBQXJDO0FBQ0Q7O0FBRURJLG1CQUFlMlEsU0FBZixHQUEyQnZRLE9BQTNCO0FBQ0FBLFlBQVF1USxTQUFSLEdBQW9CM1EsY0FBcEI7QUFDRCxHQXpCRCxNQXlCTztBQUNMQSxtQkFBZXNsQixZQUFmLEdBQThCQSxZQUE5Qjs7QUFFQTtBQUNBO0FBQ0F0bEIsbUJBQWV1UixTQUFmLEdBQTJCL1EsNkJBQTNCOztBQUVBO0FBQ0FSLG1CQUFld1EsVUFBZixHQUE0QixJQUE1QjtBQUNBeFEsbUJBQWUrUCxXQUFmLEdBQTZCLElBQTdCO0FBQ0EvUCxtQkFBZWdRLFVBQWYsR0FBNEIsSUFBNUI7O0FBRUEsUUFBSTNVLHNDQUFKLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EyRSxxQkFBZTJsQixjQUFmLEdBQWdDLENBQWhDO0FBQ0EzbEIscUJBQWU4bEIsZUFBZixHQUFpQyxDQUFDLENBQWxDO0FBQ0Q7QUFDRjs7QUFFRDlsQixpQkFBZW9VLG1CQUFmLEdBQXFDaFUsUUFBUWdVLG1CQUE3QztBQUNBcFUsaUJBQWVtQyxjQUFmLEdBQWdDL0IsUUFBUStCLGNBQXhDOztBQUVBbkMsaUJBQWVxVSxLQUFmLEdBQXVCalUsUUFBUWlVLEtBQS9CO0FBQ0FyVSxpQkFBZTBsQixhQUFmLEdBQStCdGxCLFFBQVFzbEIsYUFBdkM7QUFDQTFsQixpQkFBZStRLGFBQWYsR0FBK0IzUSxRQUFRMlEsYUFBdkM7QUFDQS9RLGlCQUFlOFEsV0FBZixHQUE2QjFRLFFBQVEwUSxXQUFyQztBQUNBOVEsaUJBQWV3VSxtQkFBZixHQUFxQ3BVLFFBQVFvVSxtQkFBN0M7O0FBRUE7QUFDQXhVLGlCQUFlNFUsT0FBZixHQUF5QnhVLFFBQVF3VSxPQUFqQztBQUNBNVUsaUJBQWV3bEIsS0FBZixHQUF1QnBsQixRQUFRb2xCLEtBQS9CO0FBQ0F4bEIsaUJBQWV5bEIsR0FBZixHQUFxQnJsQixRQUFRcWxCLEdBQTdCOztBQUVBLE1BQUlwcUIsc0NBQUosRUFBeUI7QUFDdkIyRSxtQkFBZStsQixnQkFBZixHQUFrQzNsQixRQUFRMmxCLGdCQUExQztBQUNBL2xCLG1CQUFlZ21CLGdCQUFmLEdBQWtDNWxCLFFBQVE0bEIsZ0JBQTFDO0FBQ0Q7O0FBRUQsU0FBT2htQixjQUFQO0FBQ0Q7O0FBRU0sU0FBU3FrQixtQkFBVCxDQUE2QmdDLFlBQTdCLEVBQTJEO0FBQ2hFLE1BQUloVixPQUFPZ1YsZUFBZS9lLGtDQUFpQkMsMkJBQWhDLEdBQTZDRiwwQkFBeEQ7O0FBRUEsTUFBSWhNLDBDQUF1QmlyQix5Q0FBM0IsRUFBOEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0FqVixZQUFRN0osNEJBQVI7QUFDRDs7QUFFRCxTQUFPeWUsWUFBWWpxQix1QkFBWixFQUFzQixJQUF0QixFQUE0QixJQUE1QixFQUFrQ3FWLElBQWxDLENBQVA7QUFDRDs7QUFFTSxTQUFTaVQsMkJBQVQsQ0FDTC9tQixJQURLLEVBQ007QUFDWCtaLEdBRkssRUFHTGdPLFlBSEssRUFJTDNsQixLQUpLLEVBS0wwUixJQUxLLEVBTUxsUCxjQU5LLEVBT0U7QUFDUCxNQUFJekMsY0FBSjs7QUFFQSxNQUFJNm1CLFdBQVd4cUIscUNBQWY7QUFDQTtBQUNBLE1BQUl5cUIsZUFBZWpwQixJQUFuQjtBQUNBLE1BQUksT0FBT0EsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUM5QixRQUFJMm9CLGdCQUFnQjNvQixJQUFoQixDQUFKLEVBQTJCO0FBQ3pCZ3BCLGlCQUFXenFCLDZCQUFYO0FBQ0Q7QUFDRixHQUpELE1BSU8sSUFBSSxPQUFPeUIsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUNuQ2dwQixlQUFXcnFCLDRCQUFYO0FBQ0QsR0FGTSxNQUVBO0FBQ0x1cUIsWUFBUSxRQUFRbHBCLElBQVI7QUFDTixXQUFLRyxpQ0FBTDtBQUNFLGVBQU84bUIsd0JBQ0xjLGFBQWFvQixRQURSLEVBRUxyVixJQUZLLEVBR0xsUCxjQUhLLEVBSUxtVixHQUpLLENBQVA7QUFNRixXQUFLN1osd0NBQUw7QUFDRSxlQUFPa3BCLG9CQUNMckIsWUFESyxFQUVMalUsT0FBTy9KLCtCQUFQLEdBQXdCQywyQkFGbkIsRUFHTHBGLGNBSEssRUFJTG1WLEdBSkssQ0FBUDtBQU1GLFdBQUt6WixvQ0FBTDtBQUNFLGVBQU84b0Isb0JBQ0xyQixZQURLLEVBRUxqVSxPQUFPOUosMkJBRkYsRUFHTHBGLGNBSEssRUFJTG1WLEdBSkssQ0FBUDtBQU1GLFdBQUsxWixpQ0FBTDtBQUNFLGVBQU9ncEIsd0JBQXdCdEIsWUFBeEIsRUFBc0NqVSxJQUF0QyxFQUE0Q2xQLGNBQTVDLEVBQTREbVYsR0FBNUQsQ0FBUDtBQUNGLFdBQUt4WixpQ0FBTDtBQUNFLGVBQU8ybUIsd0JBQXdCYSxZQUF4QixFQUFzQ2pVLElBQXRDLEVBQTRDbFAsY0FBNUMsRUFBNERtVixHQUE1RCxDQUFQO0FBQ0Y7QUFBUztBQUNQLGNBQUksUUFBTy9aLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEJBLFNBQVMsSUFBekMsRUFBK0M7QUFDN0Msb0JBQVFBLEtBQUtRLFFBQWI7QUFDRSxtQkFBS0UsaUNBQUw7QUFDRXNvQiwyQkFBV2hxQiw4QkFBWDtBQUNBLHNCQUFNa3FCLE1BQU47QUFDRixtQkFBS3pvQixnQ0FBTDtBQUNFO0FBQ0F1b0IsMkJBQVdqcUIsOEJBQVg7QUFDQSxzQkFBTW1xQixNQUFOO0FBQ0YsbUJBQUt2b0Isb0NBQUw7QUFDRXFvQiwyQkFBVy9wQix5QkFBWDtBQUNBLHNCQUFNaXFCLE1BQU47QUFDRixtQkFBS3JvQiw2QkFBTDtBQUNFbW9CLDJCQUFXNXBCLDRCQUFYO0FBQ0Esc0JBQU04cEIsTUFBTjtBQUNGLG1CQUFLcG9CLDZCQUFMO0FBQ0Vrb0IsMkJBQVcxcEIsNEJBQVg7QUFDQTJwQiwrQkFBZSxJQUFmO0FBQ0Esc0JBQU1DLE1BQU47QUFqQko7QUFtQkQ7QUFDRCxjQUFJeG1CLE9BQU8sRUFBWDtBQUNBLGNBQUlySCxJQUFKLEVBQWE7QUFDWCxnQkFDRTJFLFNBQVN6RSxTQUFULElBQ0MsUUFBT3lFLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFDQ0EsU0FBUyxJQURWLElBRUMwSCxPQUFPNGhCLElBQVAsQ0FBWXRwQixJQUFaLEVBQWtCekQsTUFBbEIsS0FBNkIsQ0FKakMsRUFLRTtBQUNBbUcsc0JBQ0UsK0RBQ0EsMERBREEsR0FFQSxnQkFIRjtBQUlEO0FBQ0QsZ0JBQU1GLFlBQVlKLFFBQVEsZ0NBQWlCQSxNQUFNcEMsSUFBdkIsQ0FBUixHQUF1QyxJQUF6RDtBQUNBLGdCQUFJd0MsU0FBSixFQUFlO0FBQ2JFLHNCQUFRLHFDQUFxQ0YsU0FBckMsR0FBaUQsSUFBekQ7QUFDRDtBQUNGO0FBQ0QsbUNBQ0UsS0FERixFQUVFLDhEQUNFLDZEQURGLEdBRUUsZ0JBSkosRUFLRXhDLFFBQVEsSUFBUixHQUFlQSxJQUFmLFVBQTZCQSxJQUE3Qix5Q0FBNkJBLElBQTdCLENBTEYsRUFNRTBDLElBTkY7QUFRRDtBQTFFSztBQTRFVDs7QUFFRFAsVUFBUXVtQixZQUFZTSxRQUFaLEVBQXNCakIsWUFBdEIsRUFBb0NoTyxHQUFwQyxFQUF5Q2pHLElBQXpDLENBQVI7QUFDQTNSLFFBQU02bEIsV0FBTixHQUFvQmhvQixJQUFwQjtBQUNBbUMsUUFBTW5DLElBQU4sR0FBYWlwQixZQUFiO0FBQ0E5bUIsUUFBTXlDLGNBQU4sR0FBdUJBLGNBQXZCOztBQUVBLFNBQU96QyxLQUFQO0FBQ0Q7O0FBRU0sU0FBUzZrQixzQkFBVCxDQUNMdUMsT0FESyxFQUVMelYsSUFGSyxFQUdMbFAsY0FISyxFQUlFO0FBQ1AsTUFBSXhDLFFBQVEsSUFBWjtBQUNBLE1BQUkvRyxJQUFKLEVBQWE7QUFDWCtHLFlBQVFtbkIsUUFBUUMsTUFBaEI7QUFDRDtBQUNELE1BQU14cEIsT0FBT3VwQixRQUFRdnBCLElBQXJCO0FBQ0EsTUFBTStaLE1BQU13UCxRQUFReFAsR0FBcEI7QUFDQSxNQUFNZ08sZUFBZXdCLFFBQVExWSxLQUE3QjtBQUNBLE1BQU0xTyxRQUFRNGtCLDRCQUNaL21CLElBRFksRUFFWitaLEdBRlksRUFHWmdPLFlBSFksRUFJWjNsQixLQUpZLEVBS1owUixJQUxZLEVBTVpsUCxjQU5ZLENBQWQ7QUFRQSxNQUFJdkosSUFBSixFQUFhO0FBQ1g4RyxVQUFNSSxZQUFOLEdBQXFCZ25CLFFBQVFFLE9BQTdCO0FBQ0F0bkIsVUFBTUUsV0FBTixHQUFvQmtuQixRQUFRQyxNQUE1QjtBQUNEO0FBQ0QsU0FBT3JuQixLQUFQO0FBQ0Q7O0FBRU0sU0FBUzhrQix1QkFBVCxDQUNMeUMsUUFESyxFQUVMNVYsSUFGSyxFQUdMbFAsY0FISyxFQUlMbVYsR0FKSyxFQUtFO0FBQ1AsTUFBTTVYLFFBQVF1bUIsWUFBWTdwQix1QkFBWixFQUFzQjZxQixRQUF0QixFQUFnQzNQLEdBQWhDLEVBQXFDakcsSUFBckMsQ0FBZDtBQUNBM1IsUUFBTXlDLGNBQU4sR0FBdUJBLGNBQXZCO0FBQ0EsU0FBT3pDLEtBQVA7QUFDRDs7QUFFRCxTQUFTa25CLHVCQUFULENBQ0V0QixZQURGLEVBRUVqVSxJQUZGLEVBR0VsUCxjQUhGLEVBSUVtVixHQUpGLEVBS1M7QUFDUCxNQUFJMWUsSUFBSixFQUFhO0FBQ1gsUUFDRSxPQUFPMHNCLGFBQWE0QixFQUFwQixLQUEyQixRQUEzQixJQUNBLE9BQU81QixhQUFhNkIsUUFBcEIsS0FBaUMsVUFGbkMsRUFHRTtBQUNBLHlDQUNFLEtBREYsRUFFRSx1RUFGRjtBQUlEO0FBQ0Y7O0FBRUQsTUFBTXpuQixRQUFRdW1CLFlBQVl4cEIsdUJBQVosRUFBc0I2b0IsWUFBdEIsRUFBb0NoTyxHQUFwQyxFQUF5Q2pHLE9BQU83Siw0QkFBaEQsQ0FBZDtBQUNBO0FBQ0E5SCxRQUFNNmxCLFdBQU4sR0FBb0IzbkIsaUNBQXBCO0FBQ0E4QixRQUFNbkMsSUFBTixHQUFhSyxpQ0FBYjtBQUNBOEIsUUFBTXlDLGNBQU4sR0FBdUJBLGNBQXZCOztBQUVBLFNBQU96QyxLQUFQO0FBQ0Q7O0FBRUQsU0FBU2luQixtQkFBVCxDQUNFckIsWUFERixFQUVFalUsSUFGRixFQUdFbFAsY0FIRixFQUlFbVYsR0FKRixFQUtTO0FBQ1AsTUFBTTVYLFFBQVF1bUIsWUFBWTVwQixtQkFBWixFQUFrQmlwQixZQUFsQixFQUFnQ2hPLEdBQWhDLEVBQXFDakcsSUFBckMsQ0FBZDs7QUFFQTtBQUNBLE1BQU05VCxPQUNKLENBQUM4VCxPQUFPL0osK0JBQVIsTUFBNEJELDBCQUE1QixHQUNJeEosb0NBREosR0FFSUosd0NBSE47QUFJQWlDLFFBQU02bEIsV0FBTixHQUFvQmhvQixJQUFwQjtBQUNBbUMsUUFBTW5DLElBQU4sR0FBYUEsSUFBYjs7QUFFQW1DLFFBQU15QyxjQUFOLEdBQXVCQSxjQUF2QjtBQUNBLFNBQU96QyxLQUFQO0FBQ0Q7O0FBRU0sU0FBUytrQix1QkFBVCxDQUNMYSxZQURLLEVBRUxqVSxJQUZLLEVBR0xsUCxjQUhLLEVBSUxtVixHQUpLLEVBS0w7QUFDQSxNQUFNNVgsUUFBUXVtQixZQUFZdnBCLGdDQUFaLEVBQStCNG9CLFlBQS9CLEVBQTZDaE8sR0FBN0MsRUFBa0RqRyxJQUFsRCxDQUFkOztBQUVBO0FBQ0EsTUFBTTlULE9BQU9PLGlDQUFiO0FBQ0E0QixRQUFNNmxCLFdBQU4sR0FBb0Job0IsSUFBcEI7QUFDQW1DLFFBQU1uQyxJQUFOLEdBQWFBLElBQWI7O0FBRUFtQyxRQUFNeUMsY0FBTixHQUF1QkEsY0FBdkI7QUFDQSxTQUFPekMsS0FBUDtBQUNEOztBQUVNLFNBQVNnbEIsbUJBQVQsQ0FDTDBDLE9BREssRUFFTC9WLElBRkssRUFHTGxQLGNBSEssRUFJRTtBQUNQLE1BQU16QyxRQUFRdW1CLFlBQVk5cEIsdUJBQVosRUFBc0JpckIsT0FBdEIsRUFBK0IsSUFBL0IsRUFBcUMvVixJQUFyQyxDQUFkO0FBQ0EzUixRQUFNeUMsY0FBTixHQUF1QkEsY0FBdkI7QUFDQSxTQUFPekMsS0FBUDtBQUNEOztBQUVNLFNBQVNpbEIsc0NBQVQsR0FBeUQ7QUFDOUQsTUFBTWpsQixRQUFRdW1CLFlBQVkvcEIsNEJBQVosRUFBMkIsSUFBM0IsRUFBaUMsSUFBakMsRUFBdUNtTCwwQkFBdkMsQ0FBZDtBQUNBO0FBQ0EzSCxRQUFNNmxCLFdBQU4sR0FBb0IsU0FBcEI7QUFDQTdsQixRQUFNbkMsSUFBTixHQUFhLFNBQWI7QUFDQSxTQUFPbUMsS0FBUDtBQUNEOztBQUVNLFNBQVNrbEIscUJBQVQsQ0FDTHlDLE1BREssRUFFTGhXLElBRkssRUFHTGxQLGNBSEssRUFJRTtBQUNQLE1BQU1takIsZUFBZStCLE9BQU9YLFFBQVAsS0FBb0IsSUFBcEIsR0FBMkJXLE9BQU9YLFFBQWxDLEdBQTZDLEVBQWxFO0FBQ0EsTUFBTWhuQixRQUFRdW1CLFlBQVlocUIseUJBQVosRUFBd0JxcEIsWUFBeEIsRUFBc0MrQixPQUFPL1AsR0FBN0MsRUFBa0RqRyxJQUFsRCxDQUFkO0FBQ0EzUixRQUFNeUMsY0FBTixHQUF1QkEsY0FBdkI7QUFDQXpDLFFBQU15TyxTQUFOLEdBQWtCO0FBQ2hCbVosbUJBQWVELE9BQU9DLGFBRE47QUFFaEJDLHFCQUFpQixJQUZELEVBRU87QUFDdkJDLG9CQUFnQkgsT0FBT0c7QUFIUCxHQUFsQjtBQUtBLFNBQU85bkIsS0FBUDtBQUNEOztBQUVEO0FBQ08sU0FBU21sQiwwQkFBVCxDQUNMemhCLE1BREssRUFFTHZELE1BRkssRUFHRTtBQUNQLE1BQUl1RCxXQUFXLElBQWYsRUFBcUI7QUFDbkI7QUFDQTtBQUNBQSxhQUFTNmlCLFlBQVlscUIscUNBQVosRUFBb0MsSUFBcEMsRUFBMEMsSUFBMUMsRUFBZ0RzTCwwQkFBaEQsQ0FBVDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUFqRSxTQUFPNUYsR0FBUCxHQUFhcUMsT0FBT3JDLEdBQXBCO0FBQ0E0RixTQUFPa1UsR0FBUCxHQUFhelgsT0FBT3lYLEdBQXBCO0FBQ0FsVSxTQUFPbWlCLFdBQVAsR0FBcUIxbEIsT0FBTzBsQixXQUE1QjtBQUNBbmlCLFNBQU83RixJQUFQLEdBQWNzQyxPQUFPdEMsSUFBckI7QUFDQTZGLFNBQU8rSyxTQUFQLEdBQW1CdE8sT0FBT3NPLFNBQTFCO0FBQ0EvSyxTQUFPakQsTUFBUCxHQUFnQk4sT0FBT00sTUFBdkI7QUFDQWlELFNBQU9pUixLQUFQLEdBQWV4VSxPQUFPd1UsS0FBdEI7QUFDQWpSLFNBQU93UixPQUFQLEdBQWlCL1UsT0FBTytVLE9BQXhCO0FBQ0F4UixTQUFPb2lCLEtBQVAsR0FBZTNsQixPQUFPMmxCLEtBQXRCO0FBQ0FwaUIsU0FBT3FpQixHQUFQLEdBQWE1bEIsT0FBTzRsQixHQUFwQjtBQUNBcmlCLFNBQU9raUIsWUFBUCxHQUFzQnpsQixPQUFPeWxCLFlBQTdCO0FBQ0FsaUIsU0FBT3NpQixhQUFQLEdBQXVCN2xCLE9BQU82bEIsYUFBOUI7QUFDQXRpQixTQUFPME4sV0FBUCxHQUFxQmpSLE9BQU9pUixXQUE1QjtBQUNBMU4sU0FBTzJOLGFBQVAsR0FBdUJsUixPQUFPa1IsYUFBOUI7QUFDQTNOLFNBQU9vUixtQkFBUCxHQUE2QjNVLE9BQU8yVSxtQkFBcEM7QUFDQXBSLFNBQU9pTyxJQUFQLEdBQWN4UixPQUFPd1IsSUFBckI7QUFDQWpPLFNBQU9tTyxTQUFQLEdBQW1CMVIsT0FBTzBSLFNBQTFCO0FBQ0FuTyxTQUFPb04sVUFBUCxHQUFvQjNRLE9BQU8yUSxVQUEzQjtBQUNBcE4sU0FBTzJNLFdBQVAsR0FBcUJsUSxPQUFPa1EsV0FBNUI7QUFDQTNNLFNBQU80TSxVQUFQLEdBQW9CblEsT0FBT21RLFVBQTNCO0FBQ0E1TSxTQUFPakIsY0FBUCxHQUF3QnRDLE9BQU9zQyxjQUEvQjtBQUNBaUIsU0FBT2dSLG1CQUFQLEdBQTZCdlUsT0FBT3VVLG1CQUFwQztBQUNBaFIsU0FBT3VOLFNBQVAsR0FBbUI5USxPQUFPOFEsU0FBMUI7QUFDQSxNQUFJdFYsc0NBQUosRUFBeUI7QUFDdkIrSCxXQUFPdWlCLGNBQVAsR0FBd0I5bEIsT0FBTzhsQixjQUEvQjtBQUNBdmlCLFdBQU8waUIsZUFBUCxHQUF5QmptQixPQUFPaW1CLGVBQWhDO0FBQ0ExaUIsV0FBTzJpQixnQkFBUCxHQUEwQmxtQixPQUFPa21CLGdCQUFqQztBQUNBM2lCLFdBQU80aUIsZ0JBQVAsR0FBMEJubUIsT0FBT21tQixnQkFBakM7QUFDRDtBQUNENWlCLFNBQU82ZixRQUFQLEdBQWtCcGpCLE9BQU9vakIsUUFBekI7QUFDQTdmLFNBQU90RCxZQUFQLEdBQXNCRCxPQUFPQyxZQUE3QjtBQUNBc0QsU0FBT3hELFdBQVAsR0FBcUJDLE9BQU9ELFdBQTVCO0FBQ0F3RCxTQUFPcWdCLHVCQUFQLEdBQWlDNWpCLE9BQU80akIsdUJBQXhDO0FBQ0EsU0FBT3JnQixNQUFQO0FBQ0QsQzs7Ozs7Ozs7Ozs7Ozs7OFFDdHRCRDs7Ozs7Ozs7O1FBcXlEZ0Jxa0IsK0IsR0FBQUEsK0I7O0FBdnhEaEI7O0FBS0E7O0FBVUE7O0FBS0E7Ozs7QUFDQTs7OztBQUNBOztBQWdCQTs7QUFhQTs7QUFRQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOztBQU1BOztBQWFBOztBQVVBOztBQW1CQTs7QUFDQTs7QUFDQTs7QUFTQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFLQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFLQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFPQTs7OztJQWlCT0Msc0IsR0FBNkM5c0IsOEIsQ0FBN0M4c0Isc0I7SUFBd0JDLGlCLEdBQXFCL3NCLDhCLENBQXJCK3NCLGlCOzs7QUFFL0IsSUFBSUMsb0NBQUo7QUFDQSxJQUFJQyxvQ0FBSjtBQUNBLElBQUlDLG1DQUFKO0FBQ0EsSUFBSUMsZ0NBQUo7O0FBRUEsSUFBSXhzQix5Q0FBSixFQUE0QjtBQUMxQjtBQUNBO0FBQ0EsMkJBQ0V5c0IsOEJBQXFCLElBQXJCLElBQTZCQSwyQkFBa0I1bkIsT0FBbEIsSUFBNkIsSUFENUQsRUFFRSx5R0FDRSw0RkFERixHQUVFLCtEQUZGLEdBR0UsNENBTEo7QUFPRDs7QUFFRCxJQUFJeEgsSUFBSixFQUFhO0FBQ1hndkIsZ0NBQThCLEtBQTlCO0FBQ0FDLGdDQUE4QixLQUE5QjtBQUNBLE1BQU1JLDBDQUEwQyxFQUFoRDs7QUFFQUgsK0JBQTZCLG9DQUFTcG9CLEtBQVQsRUFBdUJ3b0IsT0FBdkIsRUFBeUM7QUFDcEU7QUFDQTtBQUNBLFFBQU1sUSxnQkFBZ0IsZ0NBQWlCdFksTUFBTW5DLElBQXZCLEtBQWdDLGdCQUF0RDtBQUNBLFFBQUkwcUIsd0NBQXdDalEsYUFBeEMsQ0FBSixFQUE0RDtBQUMxRDtBQUNEO0FBQ0QsdUNBQ0UsS0FERixFQUVFLHdFQUNFLHFFQURGLEdBRUUsK0RBSkosRUFLRWtRLFVBQ0ksaUNBREosR0FFSSw4QkFQTixFQVFFLG9EQUE0QnhvQixLQUE1QixDQVJGO0FBVUF1b0IsNENBQXdDalEsYUFBeEMsSUFBeUQsSUFBekQ7QUFDRCxHQWxCRDs7QUFvQkErUCw0QkFBMEIsaUNBQVNoaEIsUUFBVCxFQUF5QztBQUNqRSxZQUFRb2hCLHdCQUFSO0FBQ0UsV0FBSyxpQkFBTDtBQUNFLFlBQUlOLDJCQUFKLEVBQWlDO0FBQy9CO0FBQ0Q7QUFDRCwyQ0FDRSxLQURGLEVBRUUsZ0VBRkY7QUFJQUEsc0NBQThCLElBQTlCO0FBQ0E7QUFDRixXQUFLLFFBQUw7QUFDRSxZQUFJRCwyQkFBSixFQUFpQztBQUMvQjtBQUNEO0FBQ0QsMkNBQ0UsS0FERixFQUVFLHVFQUNFLHlFQUhKO0FBS0FBLHNDQUE4QixJQUE5QjtBQUNBO0FBckJKO0FBdUJELEdBeEJEO0FBeUJEOztBQUVEO0FBQ0EsSUFBSVEsNEJBQW9DdG1CLGlDQUFPLENBQS9DOztBQUVBLElBQUl1bUIsWUFBcUIsS0FBekI7O0FBRUE7QUFDQSxJQUFJeEUsaUJBQStCLElBQW5DO0FBQ0EsSUFBSXlFLFdBQTZCLElBQWpDO0FBQ0E7QUFDQSxJQUFJQywyQkFBMkMzbUIsZ0NBQS9DO0FBQ0EsSUFBSTRtQiw4QkFBc0MsQ0FBQyxDQUEzQztBQUNBLElBQUlDLHFCQUE4QixLQUFsQzs7QUFFQTtBQUNBLElBQUlqWSxhQUEyQixJQUEvQjs7QUFFQSxJQUFJaVIsZUFBd0IsS0FBNUI7QUFDQSxJQUFJaUgsZ0NBQWtELElBQXREO0FBQ0EsSUFBSUMsOEJBQWlDLElBQXJDO0FBQ0EsSUFBSUMsd0JBQTJCLElBQS9COztBQUVBLElBQUlDLHlDQUE0RCxJQUFoRTs7QUFFQTtBQUNBLElBQUkvRSxnQkFBOEIsSUFBbEM7O0FBRUEsSUFBSWdGLHdDQUFKO0FBQ0EsSUFBSUMseUJBQUo7QUFDQSxJQUFJQyxrQ0FBSjtBQUNBLElBQUlDLG9DQUFKO0FBQ0EsSUFBSUMsNEJBQUo7QUFDQSxJQUFJQyw2QkFBSjtBQUNBLElBQUl2d0IsSUFBT0EsSUFBSXVDLGtFQUFmLEVBQWdFO0FBQzlEMnRCLG9DQUFrQyxJQUFsQztBQUNBRSw4QkFBNEIsSUFBNUI7QUFDQUMsZ0NBQThCLEtBQTlCO0FBQ0FDLHdCQUFzQixJQUF0QjtBQUNBSCxxQkFBbUIsMEJBQ2pCSyxnQkFEaUIsRUFFakJDLFdBRmlCLEVBR2pCQyxRQUhpQixFQUlkO0FBQ0gsUUFDRUQsZ0JBQWdCLElBQWhCLElBQ0EsUUFBT0EsV0FBUCx5Q0FBT0EsV0FBUCxPQUF1QixRQUR2QixJQUVBLE9BQU9BLFlBQVlFLElBQW5CLEtBQTRCLFVBSDlCLEVBSUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0EsUUFBSVQsb0NBQW9DLElBQXhDLEVBQThDO0FBQzVDO0FBQ0EseUNBQ0UsS0FERixFQUVFLCtFQUNFLHVCQUhKO0FBS0E7QUFDRDtBQUNELGdEQUNFTSxnQkFERixFQUVFTiwrQkFGRjs7QUFLQSxZQUFRTSxpQkFBaUI1ckIsR0FBekI7QUFDRSxXQUFLeEIsdUJBQUw7QUFDRSxxREFBaUJvdEIsZ0JBQWpCO0FBQ0EseURBQStCQSxnQkFBL0I7QUFDQTtBQUNGLFdBQUtsdEIsNEJBQUw7QUFDRSxtREFBZWt0QixnQkFBZjtBQUNBO0FBQ0YsV0FBS3R0Qiw2QkFBTDtBQUFxQjtBQUNuQixjQUFNOGEsWUFBWXdTLGlCQUFpQjdyQixJQUFuQztBQUNBLGNBQUksMENBQXdCcVosU0FBeEIsQ0FBSixFQUF3QztBQUN0QywrQ0FBaUJ3UyxnQkFBakI7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxXQUFLbnRCLHlCQUFMO0FBQ0UscURBQWlCbXRCLGdCQUFqQjtBQUNBO0FBQ0YsV0FBSzdzQiw4QkFBTDtBQUNFLCtDQUFZNnNCLGdCQUFaO0FBQ0E7QUFwQko7QUFzQkE7QUFDQUgsa0NBQThCLElBQTlCO0FBQ0FDLDBCQUFzQkcsV0FBdEI7QUFDQSxnREFBc0IsSUFBdEIsRUFBNEJHLFFBQTVCLEVBQXNDLElBQXRDLEVBQTRDRixRQUE1QztBQUNBTCxrQ0FBOEIsS0FBOUI7QUFDQUMsMEJBQXNCLElBQXRCO0FBQ0EsUUFBSSxzQ0FBSixFQUFzQjtBQUNwQixVQUFNTyxjQUFjLHdDQUFwQjtBQUNBLFVBQUlBLGVBQWUsSUFBZixJQUF1QkosZUFBZSxJQUExQyxFQUFnRDtBQUM5QyxZQUFJO0FBQ0Y7QUFDQTtBQUNBLGNBQUlJLFlBQVlDLGdCQUFoQixFQUFrQztBQUNoQztBQUNDTCx1QkFBRCxDQUFtQkssZ0JBQW5CLEdBQXNDLElBQXRDO0FBQ0Q7QUFDRixTQVBELENBT0UsT0FBT0MsS0FBUCxFQUFjO0FBQ2Q7QUFDRDtBQUNGO0FBQ0YsS0FkRCxNQWNPO0FBQ0w7QUFDQTtBQUNBOUYsdUJBQWlCdUYsZ0JBQWpCO0FBQ0Q7QUFDRixHQTlFRDtBQStFQUQseUJBQXVCLGdDQUFNO0FBQzNCLFVBQU1ELG1CQUFOO0FBQ0QsR0FGRDtBQUdEOztBQUVELFNBQVNVLFVBQVQsR0FBc0I7QUFDcEIsTUFBSS9GLG1CQUFtQixJQUF2QixFQUE2QjtBQUMzQixRQUFJZ0csa0JBQWtCaEcsZUFBZTFqQixNQUFyQztBQUNBLFdBQU8wcEIsb0JBQW9CLElBQTNCLEVBQWlDO0FBQy9CLHVEQUFzQkEsZUFBdEI7QUFDQUEsd0JBQWtCQSxnQkFBZ0IxcEIsTUFBbEM7QUFDRDtBQUNGOztBQUVELE1BQUl2SCxJQUFKLEVBQWE7QUFDWGt4QixzQ0FBd0JDLHNCQUF4QjtBQUNBO0FBQ0Q7O0FBRUR6QixhQUFXLElBQVg7QUFDQUMsNkJBQTJCM21CLGdDQUEzQjtBQUNBNG1CLGdDQUE4QixDQUFDLENBQS9CO0FBQ0FDLHVCQUFxQixLQUFyQjtBQUNBNUUsbUJBQWlCLElBQWpCO0FBQ0Q7O0FBRUQsU0FBU21HLG9CQUFULEdBQWdDO0FBQzlCLFNBQU94WixlQUFlLElBQXRCLEVBQTRCO0FBQzFCLFFBQUk1WCxJQUFKLEVBQWE7QUFDWCw4Q0FBZ0I0WCxVQUFoQjtBQUNEO0FBQ0Q7O0FBRUEsUUFBTWUsWUFBWWYsV0FBV2UsU0FBN0I7O0FBRUEsUUFBSUEsWUFBWXpRLGlDQUFoQixFQUE4QjtBQUM1Qix3REFBdUIwUCxVQUF2QjtBQUNEOztBQUVELFFBQUllLFlBQVl0USx3QkFBaEIsRUFBcUI7QUFDbkIsVUFBTWIsVUFBVW9RLFdBQVdHLFNBQTNCO0FBQ0EsVUFBSXZRLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsbURBQWdCQSxPQUFoQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJNnBCLG1CQUFtQjFZLGFBQWE3USxpQ0FBWUMsMkJBQVosR0FBcUJFLDZCQUFsQyxDQUF2QjtBQUNBLFlBQVFvcEIsZ0JBQVI7QUFDRSxXQUFLdnBCLDhCQUFMO0FBQWdCO0FBQ2QscURBQWdCOFAsVUFBaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLHFCQUFXZSxTQUFYLElBQXdCLENBQUM3USw4QkFBekI7QUFDQTtBQUNEO0FBQ0QsV0FBS0UsdUNBQUw7QUFBeUI7QUFDdkI7QUFDQSxxREFBZ0I0UCxVQUFoQjtBQUNBO0FBQ0E7QUFDQUEscUJBQVdlLFNBQVgsSUFBd0IsQ0FBQzdRLDhCQUF6Qjs7QUFFQTtBQUNBLGNBQU1OLFdBQVVvUSxXQUFXRyxTQUEzQjtBQUNBLGdEQUFXdlEsUUFBWCxFQUFvQm9RLFVBQXBCO0FBQ0E7QUFDRDtBQUNELFdBQUs3UCwyQkFBTDtBQUFhO0FBQ1gsY0FBTVAsWUFBVW9RLFdBQVdHLFNBQTNCO0FBQ0EsZ0RBQVd2USxTQUFYLEVBQW9Cb1EsVUFBcEI7QUFDQTtBQUNEO0FBQ0QsV0FBSzNQLDZCQUFMO0FBQWU7QUFDYixvREFBZTJQLFVBQWY7QUFDQTtBQUNEO0FBL0JIO0FBaUNBQSxpQkFBYUEsV0FBV0EsVUFBeEI7QUFDRDs7QUFFRCxNQUFJNVgsSUFBSixFQUFhO0FBQ1g7QUFDRDtBQUNGOztBQUVELFNBQVNzeEIsOEJBQVQsR0FBMEM7QUFDeEMsU0FBTzFaLGVBQWUsSUFBdEIsRUFBNEI7QUFDMUIsUUFBSTVYLElBQUosRUFBYTtBQUNYLDhDQUFnQjRYLFVBQWhCO0FBQ0Q7O0FBRUQsUUFBTWUsWUFBWWYsV0FBV2UsU0FBN0I7QUFDQSxRQUFJQSxZQUFZclEsNkJBQWhCLEVBQTBCO0FBQ3hCO0FBQ0EsVUFBTWQsVUFBVW9RLFdBQVdHLFNBQTNCO0FBQ0EsZ0VBQStCdlEsT0FBL0IsRUFBd0NvUSxVQUF4QztBQUNEOztBQUVEQSxpQkFBYUEsV0FBV0EsVUFBeEI7QUFDRDs7QUFFRCxNQUFJNVgsSUFBSixFQUFhO0FBQ1g7QUFDRDtBQUNGOztBQUVELFNBQVN1eEIsbUJBQVQsQ0FDRUMsWUFERixFQUVFQyx1QkFGRixFQUdFO0FBQ0EsTUFBSXp4QixJQUFKLEVBQWE7QUFDWGt4QixzQ0FBd0JRLG1DQUF4QjtBQUNBUixzQ0FBd0JTLHlCQUF4Qjs7QUFFQSxRQUFJbnZCLGdEQUFKLEVBQW1DO0FBQ2pDMHVCLHdDQUF3QlUsK0JBQXhCO0FBQ0Q7QUFDRjtBQUNELFNBQU9oYSxlQUFlLElBQXRCLEVBQTRCO0FBQzFCLFFBQUk1WCxJQUFKLEVBQWE7QUFDWCw4Q0FBZ0I0WCxVQUFoQjtBQUNEO0FBQ0QsUUFBTWUsWUFBWWYsV0FBV2UsU0FBN0I7O0FBRUEsUUFBSUEsYUFBYTVRLDhCQUFTSSw2QkFBdEIsQ0FBSixFQUFxQztBQUNuQztBQUNBLFVBQU1YLFVBQVVvUSxXQUFXRyxTQUEzQjtBQUNBLGtEQUNFeVosWUFERixFQUVFaHFCLE9BRkYsRUFHRW9RLFVBSEYsRUFJRTZaLHVCQUpGO0FBTUQ7O0FBRUQsUUFBSTlZLFlBQVl0USx3QkFBaEIsRUFBcUI7QUFDbkI7QUFDQSxpREFBZ0J1UCxVQUFoQjtBQUNEOztBQUVELFFBQUllLFlBQVlwUSw0QkFBaEIsRUFBeUI7QUFDdkJ1bkIsc0NBQWdDMEIsWUFBaEM7QUFDRDs7QUFFRDVaLGlCQUFhQSxXQUFXQSxVQUF4QjtBQUNEO0FBQ0QsTUFBSTVYLElBQUosRUFBYTtBQUNYO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNnhCLG9CQUFULENBQThCQyxJQUE5QixFQUErQzNhLFdBQS9DLEVBQXlFO0FBQ3ZFMlksa0NBQWdDLElBQWhDO0FBQ0FDLGdDQUE4QixJQUE5QjtBQUNBQywwQkFBd0IsSUFBeEI7O0FBRUE7QUFDQSxNQUFNK0Isc0JBQXNCQyxXQUE1QjtBQUNBQSxnQkFBYyxJQUFkOztBQUVBLE1BQUl2WSxTQUFTdEMsV0FBYjtBQUNBLEtBQUc7QUFDRCxRQUFJblgsSUFBSixFQUFhO0FBQ1gsOENBQWdCeVosTUFBaEI7QUFDRDs7QUFFRCxRQUFJQSxPQUFPZCxTQUFQLEdBQW1CcFEsNEJBQXZCLEVBQWdDO0FBQzlCLFVBQUkwcEIsV0FBVyxLQUFmO0FBQ0EsVUFBSXR4QixjQUFKO0FBQ0EsVUFBSVgsSUFBSixFQUFhO0FBQ1gsb0RBQXNCLElBQXRCLEVBQTRCa3lCLDhDQUE1QixFQUFzRCxJQUF0RCxFQUE0RHpZLE1BQTVEO0FBQ0EsWUFBSSxzQ0FBSixFQUFzQjtBQUNwQndZLHFCQUFXLElBQVg7QUFDQXR4QixrQkFBUSx3Q0FBUjtBQUNEO0FBQ0YsT0FORCxNQU1PO0FBQ0wsWUFBSTtBQUNGLDhEQUF5QjhZLE1BQXpCO0FBQ0QsU0FGRCxDQUVFLE9BQU9oWixDQUFQLEVBQVU7QUFDVnd4QixxQkFBVyxJQUFYO0FBQ0F0eEIsa0JBQVFGLENBQVI7QUFDRDtBQUNGO0FBQ0QsVUFBSXd4QixRQUFKLEVBQWM7QUFDWkUsZ0NBQXdCMVksTUFBeEIsRUFBZ0M5WSxLQUFoQztBQUNEO0FBQ0Y7QUFDRDhZLGFBQVNBLE9BQU83QixVQUFoQjtBQUNELEdBM0JELFFBMkJTNkIsV0FBVyxJQTNCcEI7QUE0QkEsTUFBSXpaLElBQUosRUFBYTtBQUNYO0FBQ0Q7O0FBRURneUIsZ0JBQWNELG1CQUFkOztBQUVBO0FBQ0EsTUFBTUsscUJBQXFCTixLQUFLdm9CLGNBQWhDO0FBQ0EsTUFBSTZvQix1QkFBdUJwcEIsZ0NBQTNCLEVBQW1DO0FBQ2pDcXBCLGdCQUFZUCxJQUFaLEVBQWtCTSxrQkFBbEI7QUFDRDtBQUNEO0FBQ0EsTUFBSSxDQUFDRSxpQkFBRCxJQUFzQixDQUFDTixXQUEzQixFQUF3QztBQUN0Q087QUFDRDtBQUNGOztBQUVELFNBQVNDLGtDQUFULENBQTRDcmtCLFFBQTVDLEVBQXNFO0FBQ3BFLFNBQ0U4aEIsMkNBQTJDLElBQTNDLElBQ0FBLHVDQUF1QzNGLEdBQXZDLENBQTJDbmMsUUFBM0MsQ0FGRjtBQUlEOztBQUVELFNBQVNza0IsK0JBQVQsQ0FBeUN0a0IsUUFBekMsRUFBMEQ7QUFDeEQsTUFBSThoQiwyQ0FBMkMsSUFBL0MsRUFBcUQ7QUFDbkRBLDZDQUF5QyxJQUFJN0csR0FBSixDQUFRLENBQUNqYixRQUFELENBQVIsQ0FBekM7QUFDRCxHQUZELE1BRU87QUFDTDhoQiwyQ0FBdUMxRixHQUF2QyxDQUEyQ3BjLFFBQTNDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTdWtCLG1CQUFULEdBQStCO0FBQzdCLE1BQUkzQyxnQ0FBZ0MsSUFBcEMsRUFBMEM7QUFDeEMsb0RBQXFCQSwyQkFBckI7QUFDRDtBQUNELE1BQUlDLDBCQUEwQixJQUE5QixFQUFvQztBQUNsQztBQUNBO0FBQ0FBO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTMkMsVUFBVCxDQUFvQmIsSUFBcEIsRUFBcUN4WSxZQUFyQyxFQUFnRTtBQUM5RG1XLGNBQVksSUFBWjtBQUNBNUcsaUJBQWUsSUFBZjtBQUNBOztBQUVBLDJCQUNFaUosS0FBS3RxQixPQUFMLEtBQWlCOFIsWUFEbkIsRUFFRSxtRUFDRSxvRUFERixHQUVFLGlDQUpKO0FBTUEsTUFBTW1ZLDBCQUEwQkssS0FBS2MsMkJBQXJDO0FBQ0EsMkJBQ0VuQiw0QkFBNEJ6b0IsZ0NBRDlCLEVBRUUsd0VBQ0UscUNBSEo7QUFLQThvQixPQUFLYywyQkFBTCxHQUFtQzVwQixnQ0FBbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTZwQixtQ0FBbUN2WixhQUFhL1AsY0FBdEQ7QUFDQSxNQUFNdXBCLGtDQUFrQ3haLGFBQWFrQyxtQkFBckQ7QUFDQSxNQUFNdVgsb0NBQ0pELGtDQUFrQ0QsZ0NBQWxDLEdBQ0lDLCtCQURKLEdBRUlELGdDQUhOO0FBSUEsOERBQTRCZixJQUE1QixFQUFrQ2lCLGlDQUFsQzs7QUFFQSxNQUFJQyxtQkFBc0MsSUFBMUM7QUFDQSxNQUFJcndCLHlDQUFKLEVBQTRCO0FBQzFCO0FBQ0E7QUFDQXF3Qix1QkFBbUI1RCwyQkFBa0I1bkIsT0FBckM7QUFDQTRuQiwrQkFBa0I1bkIsT0FBbEIsR0FBNEJzcUIsS0FBS21CLG9CQUFqQztBQUNEOztBQUVEO0FBQ0FsRSxvQkFBa0J2bkIsT0FBbEIsR0FBNEIsSUFBNUI7O0FBRUEsTUFBSTJQLG9CQUFKO0FBQ0EsTUFBSW1DLGFBQWFYLFNBQWIsR0FBeUI5USxrQ0FBN0IsRUFBNEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJeVIsYUFBYWxDLFVBQWIsS0FBNEIsSUFBaEMsRUFBc0M7QUFDcENrQyxtQkFBYWxDLFVBQWIsQ0FBd0JRLFVBQXhCLEdBQXFDMEIsWUFBckM7QUFDQW5DLG9CQUFjbUMsYUFBYW5DLFdBQTNCO0FBQ0QsS0FIRCxNQUdPO0FBQ0xBLG9CQUFjbUMsWUFBZDtBQUNEO0FBQ0YsR0FYRCxNQVdPO0FBQ0w7QUFDQW5DLGtCQUFjbUMsYUFBYW5DLFdBQTNCO0FBQ0Q7O0FBRUQsOENBQWlCMmEsS0FBS3BELGFBQXRCOztBQUVBO0FBQ0E5VyxlQUFhVCxXQUFiO0FBQ0E7QUFDQSxTQUFPUyxlQUFlLElBQXRCLEVBQTRCO0FBQzFCLFFBQUlxYSxXQUFXLEtBQWY7QUFDQSxRQUFJdHhCLGNBQUo7QUFDQSxRQUFJWCxJQUFKLEVBQWE7QUFDWCxrREFBc0IsSUFBdEIsRUFBNEJzeEIsOEJBQTVCLEVBQTRELElBQTVEO0FBQ0EsVUFBSSxzQ0FBSixFQUFzQjtBQUNwQlcsbUJBQVcsSUFBWDtBQUNBdHhCLGdCQUFRLHdDQUFSO0FBQ0Q7QUFDRixLQU5ELE1BTU87QUFDTCxVQUFJO0FBQ0Yyd0I7QUFDRCxPQUZELENBRUUsT0FBTzd3QixDQUFQLEVBQVU7QUFDVnd4QixtQkFBVyxJQUFYO0FBQ0F0eEIsZ0JBQVFGLENBQVI7QUFDRDtBQUNGO0FBQ0QsUUFBSXd4QixRQUFKLEVBQWM7QUFDWiwrQkFDRXJhLGVBQWUsSUFEakIsRUFFRSxtRUFDRSxpQ0FISjtBQUtBdWEsOEJBQXdCdmEsVUFBeEIsRUFBb0NqWCxLQUFwQztBQUNBO0FBQ0EsVUFBSWlYLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkJBLHFCQUFhQSxXQUFXQSxVQUF4QjtBQUNEO0FBQ0Y7QUFDRjtBQUNEOztBQUVBLE1BQUluVixzQ0FBSixFQUF5QjtBQUN2QjtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQW1WLGVBQWFULFdBQWI7QUFDQTtBQUNBLFNBQU9TLGVBQWUsSUFBdEIsRUFBNEI7QUFDMUIsUUFBSXFhLFlBQVcsS0FBZjtBQUNBLFFBQUl0eEIsZUFBSjtBQUNBLFFBQUlYLElBQUosRUFBYTtBQUNYLGtEQUFzQixJQUF0QixFQUE0Qm94QixvQkFBNUIsRUFBa0QsSUFBbEQ7QUFDQSxVQUFJLHNDQUFKLEVBQXNCO0FBQ3BCYSxvQkFBVyxJQUFYO0FBQ0F0eEIsaUJBQVEsd0NBQVI7QUFDRDtBQUNGLEtBTkQsTUFNTztBQUNMLFVBQUk7QUFDRnl3QjtBQUNELE9BRkQsQ0FFRSxPQUFPM3dCLENBQVAsRUFBVTtBQUNWd3hCLG9CQUFXLElBQVg7QUFDQXR4QixpQkFBUUYsQ0FBUjtBQUNEO0FBQ0Y7QUFDRCxRQUFJd3hCLFNBQUosRUFBYztBQUNaLCtCQUNFcmEsZUFBZSxJQURqQixFQUVFLG1FQUNFLGlDQUhKO0FBS0F1YSw4QkFBd0J2YSxVQUF4QixFQUFvQ2pYLE1BQXBDO0FBQ0E7QUFDQSxVQUFJaVgsZUFBZSxJQUFuQixFQUF5QjtBQUN2QkEscUJBQWFBLFdBQVdBLFVBQXhCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7O0FBRUEsOENBQWlCa2EsS0FBS3BELGFBQXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FvRCxPQUFLdHFCLE9BQUwsR0FBZThSLFlBQWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTFCLGVBQWFULFdBQWI7QUFDQTtBQUNBLFNBQU9TLGVBQWUsSUFBdEIsRUFBNEI7QUFDMUIsUUFBSXFhLGFBQVcsS0FBZjtBQUNBLFFBQUl0eEIsZ0JBQUo7QUFDQSxRQUFJWCxJQUFKLEVBQWE7QUFDWCxrREFDRSxJQURGLEVBRUV1eEIsbUJBRkYsRUFHRSxJQUhGLEVBSUVPLElBSkYsRUFLRUwsdUJBTEY7QUFPQSxVQUFJLHNDQUFKLEVBQXNCO0FBQ3BCUSxxQkFBVyxJQUFYO0FBQ0F0eEIsa0JBQVEsd0NBQVI7QUFDRDtBQUNGLEtBWkQsTUFZTztBQUNMLFVBQUk7QUFDRjR3Qiw0QkFBb0JPLElBQXBCLEVBQTBCTCx1QkFBMUI7QUFDRCxPQUZELENBRUUsT0FBT2h4QixDQUFQLEVBQVU7QUFDVnd4QixxQkFBVyxJQUFYO0FBQ0F0eEIsa0JBQVFGLENBQVI7QUFDRDtBQUNGO0FBQ0QsUUFBSXd4QixVQUFKLEVBQWM7QUFDWiwrQkFDRXJhLGVBQWUsSUFEakIsRUFFRSxtRUFDRSxpQ0FISjtBQUtBdWEsOEJBQXdCdmEsVUFBeEIsRUFBb0NqWCxPQUFwQztBQUNBLFVBQUlpWCxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSxxQkFBYUEsV0FBV0EsVUFBeEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSVQsZ0JBQWdCLElBQWhCLElBQXdCMlksa0NBQWtDLElBQTlELEVBQW9FO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSXBZLFdBQVdtYSxxQkFBcUJxQixJQUFyQixDQUEwQixJQUExQixFQUFnQ3BCLElBQWhDLEVBQXNDM2EsV0FBdEMsQ0FBZjtBQUNBLFFBQUl4VSx5Q0FBSixFQUE0QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQStVLGlCQUFXLDRCQUF1QkEsUUFBdkIsQ0FBWDtBQUNEO0FBQ0RxWSxrQ0FBOEIseUNBQWdCb0Qsa0NBQWhCLEVBQWdDLFlBQU07QUFDbEUsYUFBTyxrREFBdUJ6YixRQUF2QixDQUFQO0FBQ0QsS0FGNkIsQ0FBOUI7QUFHQXNZLDRCQUF3QnRZLFFBQXhCO0FBQ0Q7O0FBRURtUixpQkFBZSxLQUFmO0FBQ0E0RyxjQUFZLEtBQVo7QUFDQTtBQUNBO0FBQ0EsNENBQWFuVyxhQUFhL0QsU0FBMUI7QUFDQSxNQUFJdlYsSUFBT0EsSUFBSW96QixvQ0FBMEJDLFNBQXpDLEVBQW9EO0FBQ2xERCx3Q0FBMEJDLFNBQTFCLENBQW9DQyxZQUFwQyxDQUFpRGhhLFlBQWpEO0FBQ0Q7O0FBRUQsTUFBTWlhLGtDQUFrQ2phLGFBQWEvUCxjQUFyRDtBQUNBLE1BQU1pcUIsaUNBQWlDbGEsYUFBYWtDLG1CQUFwRDtBQUNBLE1BQU1pWSxtQ0FDSkQsaUNBQWlDRCwrQkFBakMsR0FDSUMsOEJBREosR0FFSUQsK0JBSE47QUFJQSxNQUFJRSxxQ0FBcUN6cUIsZ0NBQXpDLEVBQWlEO0FBQy9DO0FBQ0E7QUFDQWluQiw2Q0FBeUMsSUFBekM7QUFDRDtBQUNEeUQsV0FBUzVCLElBQVQsRUFBZTJCLGdDQUFmOztBQUVBLE1BQUk5d0IseUNBQUosRUFBNEI7QUFDMUJ5c0IsK0JBQWtCNW5CLE9BQWxCLEdBQTRCd3JCLGdCQUE1Qjs7QUFFQSxRQUFJVyxtQkFBSjs7QUFFQSxRQUFJO0FBQ0ZBLG1CQUFhQyx5QkFBZ0Jwc0IsT0FBN0I7QUFDQSxVQUFJbXNCLGVBQWUsSUFBZixJQUF1QjdCLEtBQUttQixvQkFBTCxDQUEwQlksSUFBMUIsR0FBaUMsQ0FBNUQsRUFBK0Q7QUFDN0QsWUFBTUMsV0FBV0MsZ0JBQ2Z0Qyx1QkFEZSxFQUVmSyxLQUFLa0MsbUJBRlUsQ0FBakI7QUFJQUwsbUJBQVdNLGFBQVgsQ0FBeUJuQyxLQUFLbUIsb0JBQTlCLEVBQW9EYSxRQUFwRDtBQUNEO0FBQ0YsS0FURCxDQVNFLE9BQU9uekIsS0FBUCxFQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQUksQ0FBQ3V6QixpQkFBTCxFQUF3QjtBQUN0QkEsNEJBQW9CLElBQXBCO0FBQ0FDLHlCQUFpQnh6QixLQUFqQjtBQUNEO0FBQ0YsS0FoQkQsU0FnQlU7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFNeXpCLHdCQUF3QnRDLEtBQUtzQyxxQkFBbkM7QUFDQUEsNEJBQXNCdlAsT0FBdEIsQ0FDRSxVQUFDd1AscUJBQUQsRUFBd0JDLHVCQUF4QixFQUFvRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFJQSwwQkFBMEJiLGdDQUE5QixFQUFnRTtBQUM5RFcsZ0NBQXNCRyxNQUF0QixDQUE2QkQsdUJBQTdCOztBQUVBRCxnQ0FBc0J4UCxPQUF0QixDQUE4Qix1QkFBZTtBQUMzQzJQLHdCQUFZQyxPQUFaOztBQUVBLGdCQUFJZCxlQUFlLElBQWYsSUFBdUJhLFlBQVlDLE9BQVosS0FBd0IsQ0FBbkQsRUFBc0Q7QUFDcEQsa0JBQUk7QUFDRmQsMkJBQVdlLG1DQUFYLENBQStDRixXQUEvQztBQUNELGVBRkQsQ0FFRSxPQUFPN3pCLEtBQVAsRUFBYztBQUNkO0FBQ0E7QUFDQSxvQkFBSSxDQUFDdXpCLGlCQUFMLEVBQXdCO0FBQ3RCQSxzQ0FBb0IsSUFBcEI7QUFDQUMsbUNBQWlCeHpCLEtBQWpCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsV0FmRDtBQWdCRDtBQUNGLE9BekJIO0FBMkJEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTZzBCLHdCQUFULENBQ0V2dEIsY0FERixFQUVFd3RCLFVBRkYsRUFHRTtBQUNBLE1BQUlBLGVBQWUzckIsK0JBQWYsSUFBd0I3QixlQUFlb1UsbUJBQWYsS0FBdUN2UywrQkFBbkUsRUFBMEU7QUFDeEU7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsTUFBSTRyQix5QkFBeUI3ckIsZ0NBQTdCOztBQUVBO0FBQ0EsTUFBSXZHLDBDQUF1QjJFLGVBQWVxUixJQUFmLEdBQXNCN0osNEJBQWpELEVBQThEO0FBQzVEO0FBQ0E7QUFDQSxRQUFJbWUsaUJBQWlCM2xCLGVBQWUybEIsY0FBcEM7QUFDQSxRQUFJSyxtQkFBbUJobUIsZUFBZStsQixnQkFBdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNMkgsOEJBQ0oxdEIsZUFBZTJRLFNBQWYsS0FBNkIsSUFBN0IsSUFDQTNRLGVBQWVxVSxLQUFmLEtBQXlCclUsZUFBZTJRLFNBQWYsQ0FBeUIwRCxLQUZwRDs7QUFJQSxRQUFJQSxRQUFRclUsZUFBZXFVLEtBQTNCO0FBQ0EsV0FBT0EsVUFBVSxJQUFqQixFQUF1QjtBQUNyQixVQUFNc1osNEJBQTRCdFosTUFBTWxTLGNBQXhDO0FBQ0EsVUFBTXlyQiwyQkFBMkJ2WixNQUFNRCxtQkFBdkM7QUFDQSxVQUFJdVosNEJBQTRCRixzQkFBaEMsRUFBd0Q7QUFDdERBLGlDQUF5QkUseUJBQXpCO0FBQ0Q7QUFDRCxVQUFJQywyQkFBMkJILHNCQUEvQixFQUF1RDtBQUNyREEsaUNBQXlCRyx3QkFBekI7QUFDRDtBQUNELFVBQUlGLDJCQUFKLEVBQWlDO0FBQy9CL0gsMEJBQWtCdFIsTUFBTXNSLGNBQXhCO0FBQ0Q7QUFDREssMEJBQW9CM1IsTUFBTTJSLGdCQUExQjtBQUNBM1IsY0FBUUEsTUFBTU8sT0FBZDtBQUNEO0FBQ0Q1VSxtQkFBZTJsQixjQUFmLEdBQWdDQSxjQUFoQztBQUNBM2xCLG1CQUFlZ21CLGdCQUFmLEdBQWtDQSxnQkFBbEM7QUFDRCxHQW5DRCxNQW1DTztBQUNMLFFBQUkzUixTQUFRclUsZUFBZXFVLEtBQTNCO0FBQ0EsV0FBT0EsV0FBVSxJQUFqQixFQUF1QjtBQUNyQixVQUFNc1osNkJBQTRCdFosT0FBTWxTLGNBQXhDO0FBQ0EsVUFBTXlyQiw0QkFBMkJ2WixPQUFNRCxtQkFBdkM7QUFDQSxVQUFJdVosNkJBQTRCRixzQkFBaEMsRUFBd0Q7QUFDdERBLGlDQUF5QkUsMEJBQXpCO0FBQ0Q7QUFDRCxVQUFJQyw0QkFBMkJILHNCQUEvQixFQUF1RDtBQUNyREEsaUNBQXlCRyx5QkFBekI7QUFDRDtBQUNEdlosZUFBUUEsT0FBTU8sT0FBZDtBQUNEO0FBQ0Y7O0FBRUQ1VSxpQkFBZW9VLG1CQUFmLEdBQXFDcVosc0JBQXJDO0FBQ0Q7O0FBRUQsU0FBU0ksa0JBQVQsQ0FBNEI3dEIsY0FBNUIsRUFBaUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsU0FBTyxJQUFQLEVBQWE7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU1JLFVBQVVKLGVBQWUyUSxTQUEvQjtBQUNBLFFBQUkvWCxJQUFKLEVBQWE7QUFDWCw4Q0FBZ0JvSCxjQUFoQjtBQUNEOztBQUVELFFBQU04dEIsY0FBYzl0QixlQUFlRyxNQUFuQztBQUNBLFFBQU00dEIsZUFBZS90QixlQUFlNFUsT0FBcEM7O0FBRUEsUUFBSSxDQUFDNVUsZUFBZXVSLFNBQWYsR0FBMkJqUSwrQkFBNUIsTUFBNENkLDZCQUFoRCxFQUEwRDtBQUN4RCxVQUFJNUgsSUFBT0EsSUFBSXVDLGtFQUFmLEVBQWdFO0FBQzlEO0FBQ0E2dEIsb0NBQTRCLEtBQTVCO0FBQ0Q7QUFDRDtBQUNBO0FBQ0FuRix1QkFBaUI3akIsY0FBakI7QUFDQSxVQUFJM0Usc0NBQUosRUFBeUI7QUFDdkIsWUFBSTJFLGVBQWVxUixJQUFmLEdBQXNCN0osNEJBQTFCLEVBQXVDO0FBQ3JDLHNEQUFtQnhILGNBQW5CO0FBQ0Q7QUFDRDZqQix5QkFBaUIsMENBQ2Z6akIsT0FEZSxFQUVmSixjQUZlLEVBR2Z1b0Isd0JBSGUsQ0FBakI7QUFLQSxZQUFJdm9CLGVBQWVxUixJQUFmLEdBQXNCN0osNEJBQTFCLEVBQXVDO0FBQ3JDO0FBQ0EsNEVBQXlDeEgsY0FBekMsRUFBeUQsS0FBekQ7QUFDRDtBQUNGLE9BYkQsTUFhTztBQUNMNmpCLHlCQUFpQiwwQ0FDZnpqQixPQURlLEVBRWZKLGNBRmUsRUFHZnVvQix3QkFIZSxDQUFqQjtBQUtEO0FBQ0QsVUFBSTN2QixJQUFPQSxJQUFJdUMsa0VBQWYsRUFBZ0U7QUFDOUQ7QUFDQTZ0QixvQ0FBNEIsSUFBNUI7QUFDRDtBQUNELDhDQUFjaHBCLGNBQWQ7QUFDQXV0QiwrQkFBeUJ2dEIsY0FBekIsRUFBeUN1b0Isd0JBQXpDO0FBQ0EsVUFBSTN2QixJQUFKLEVBQWE7QUFDWDtBQUNEOztBQUVELFVBQUlpckIsbUJBQW1CLElBQXZCLEVBQTZCO0FBQzNCO0FBQ0EsZUFBT0EsY0FBUDtBQUNEOztBQUVELFVBQ0VpSyxnQkFBZ0IsSUFBaEI7QUFDQTtBQUNBLE9BQUNBLFlBQVl2YyxTQUFaLEdBQXdCalEsK0JBQXpCLE1BQXlDZCw2QkFIM0MsRUFJRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUlzdEIsWUFBWS9kLFdBQVosS0FBNEIsSUFBaEMsRUFBc0M7QUFDcEMrZCxzQkFBWS9kLFdBQVosR0FBMEIvUCxlQUFlK1AsV0FBekM7QUFDRDtBQUNELFlBQUkvUCxlQUFlZ1EsVUFBZixLQUE4QixJQUFsQyxFQUF3QztBQUN0QyxjQUFJOGQsWUFBWTlkLFVBQVosS0FBMkIsSUFBL0IsRUFBcUM7QUFDbkM4ZCx3QkFBWTlkLFVBQVosQ0FBdUJRLFVBQXZCLEdBQW9DeFEsZUFBZStQLFdBQW5EO0FBQ0Q7QUFDRCtkLHNCQUFZOWQsVUFBWixHQUF5QmhRLGVBQWVnUSxVQUF4QztBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQU11QixZQUFZdlIsZUFBZXVSLFNBQWpDO0FBQ0E7QUFDQTtBQUNBLFlBQUlBLFlBQVk5USxrQ0FBaEIsRUFBK0I7QUFDN0IsY0FBSXF0QixZQUFZOWQsVUFBWixLQUEyQixJQUEvQixFQUFxQztBQUNuQzhkLHdCQUFZOWQsVUFBWixDQUF1QlEsVUFBdkIsR0FBb0N4USxjQUFwQztBQUNELFdBRkQsTUFFTztBQUNMOHRCLHdCQUFZL2QsV0FBWixHQUEwQi9QLGNBQTFCO0FBQ0Q7QUFDRDh0QixzQkFBWTlkLFVBQVosR0FBeUJoUSxjQUF6QjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXBILElBQU9BLElBQUlvekIsb0NBQTBCQyxTQUF6QyxFQUFvRDtBQUNsREQsNENBQTBCQyxTQUExQixDQUFvQytCLGNBQXBDLENBQW1EaHVCLGNBQW5EO0FBQ0Q7O0FBRUQsVUFBSSt0QixpQkFBaUIsSUFBckIsRUFBMkI7QUFDekI7QUFDQSxlQUFPQSxZQUFQO0FBQ0QsT0FIRCxNQUdPLElBQUlELGdCQUFnQixJQUFwQixFQUEwQjtBQUMvQjtBQUNBOXRCLHlCQUFpQjh0QixXQUFqQjtBQUNBO0FBQ0QsT0FKTSxNQUlBO0FBQ0w7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNGLEtBL0ZELE1BK0ZPO0FBQ0wsVUFBSXp5QiwwQ0FBdUIyRSxlQUFlcVIsSUFBZixHQUFzQjdKLDRCQUFqRCxFQUE4RDtBQUM1RDtBQUNBLDBFQUF5Q3hILGNBQXpDLEVBQXlELEtBQXpEOztBQUVBO0FBQ0EsWUFBSTJsQixpQkFBaUIzbEIsZUFBZTJsQixjQUFwQztBQUNBLFlBQUl0UixRQUFRclUsZUFBZXFVLEtBQTNCO0FBQ0EsZUFBT0EsVUFBVSxJQUFqQixFQUF1QjtBQUNyQnNSLDRCQUFrQnRSLE1BQU1zUixjQUF4QjtBQUNBdFIsa0JBQVFBLE1BQU1PLE9BQWQ7QUFDRDtBQUNENVUsdUJBQWUybEIsY0FBZixHQUFnQ0EsY0FBaEM7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFNcFYsT0FBTyxzQ0FBV3ZRLGNBQVgsRUFBMkJ1b0Isd0JBQTNCLENBQWI7QUFDQTtBQUNBLFVBQUl2b0IsZUFBZXVSLFNBQWYsR0FBMkJ2USwrQkFBL0IsRUFBMkM7QUFDekM7QUFDQSxzREFBb0JoQixjQUFwQjtBQUNELE9BSEQsTUFHTztBQUNMLGdEQUFjQSxjQUFkO0FBQ0Q7O0FBRUQsVUFBSXBILElBQUosRUFBYTtBQUNYO0FBQ0Q7O0FBRUQsVUFBSTJYLFNBQVMsSUFBYixFQUFtQjtBQUNqQixnREFBY3ZRLGNBQWQ7QUFDQSxZQUFJcEgsSUFBT0EsSUFBSW96QixvQ0FBMEJDLFNBQXpDLEVBQW9EO0FBQ2xERCw4Q0FBMEJDLFNBQTFCLENBQW9DK0IsY0FBcEMsQ0FBbURodUIsY0FBbkQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBdVEsYUFBS2dCLFNBQUwsSUFBa0JsUSxtQ0FBbEI7QUFDQSxlQUFPa1AsSUFBUDtBQUNEOztBQUVELFVBQUl1ZCxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEI7QUFDQUEsb0JBQVkvZCxXQUFaLEdBQTBCK2QsWUFBWTlkLFVBQVosR0FBeUIsSUFBbkQ7QUFDQThkLG9CQUFZdmMsU0FBWixJQUF5QmpRLCtCQUF6QjtBQUNEOztBQUVELFVBQUkxSSxJQUFPQSxJQUFJb3pCLG9DQUEwQkMsU0FBekMsRUFBb0Q7QUFDbERELDRDQUEwQkMsU0FBMUIsQ0FBb0MrQixjQUFwQyxDQUFtRGh1QixjQUFuRDtBQUNEOztBQUVELFVBQUkrdEIsaUJBQWlCLElBQXJCLEVBQTJCO0FBQ3pCO0FBQ0EsZUFBT0EsWUFBUDtBQUNELE9BSEQsTUFHTyxJQUFJRCxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDL0I7QUFDQTl0Qix5QkFBaUI4dEIsV0FBakI7QUFDQTtBQUNELE9BSk0sTUFJQTtBQUNMLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTRyxpQkFBVCxDQUEyQmp1QixjQUEzQixFQUFnRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1JLFVBQVVKLGVBQWUyUSxTQUEvQjs7QUFFQTtBQUNBLDJDQUFlM1EsY0FBZjtBQUNBLE1BQUlwSCxJQUFKLEVBQWE7QUFDWCw0Q0FBZ0JvSCxjQUFoQjtBQUNEOztBQUVELE1BQUlwSCxJQUFPQSxJQUFJdUMsa0VBQWYsRUFBZ0U7QUFDOUQydEIsc0NBQWtDLDRDQUNoQ0EsK0JBRGdDLEVBRWhDOW9CLGNBRmdDLENBQWxDO0FBSUQ7O0FBRUQsTUFBSXVRLGFBQUo7QUFDQSxNQUFJbFYsc0NBQUosRUFBeUI7QUFDdkIsUUFBSTJFLGVBQWVxUixJQUFmLEdBQXNCN0osNEJBQTFCLEVBQXVDO0FBQ3JDLGtEQUFtQnhILGNBQW5CO0FBQ0Q7O0FBRUR1USxXQUFPLG9DQUFVblEsT0FBVixFQUFtQkosY0FBbkIsRUFBbUN1b0Isd0JBQW5DLENBQVA7QUFDQXZvQixtQkFBZTBsQixhQUFmLEdBQStCMWxCLGVBQWVzbEIsWUFBOUM7O0FBRUEsUUFBSXRsQixlQUFlcVIsSUFBZixHQUFzQjdKLDRCQUExQixFQUF1QztBQUNyQztBQUNBLHdFQUF5Q3hILGNBQXpDLEVBQXlELElBQXpEO0FBQ0Q7QUFDRixHQVpELE1BWU87QUFDTHVRLFdBQU8sb0NBQVVuUSxPQUFWLEVBQW1CSixjQUFuQixFQUFtQ3VvQix3QkFBbkMsQ0FBUDtBQUNBdm9CLG1CQUFlMGxCLGFBQWYsR0FBK0IxbEIsZUFBZXNsQixZQUE5QztBQUNEOztBQUVELE1BQUkxc0IsSUFBSixFQUFhO0FBQ1g7QUFDQSxRQUFJcXdCLDJCQUFKLEVBQWlDO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0FFO0FBQ0Q7QUFDRjtBQUNELE1BQUl2d0IsSUFBT0EsSUFBSW96QixvQ0FBMEJDLFNBQXpDLEVBQW9EO0FBQ2xERCx3Q0FBMEJDLFNBQTFCLENBQW9DaUMsV0FBcEMsQ0FBZ0RsdUIsY0FBaEQ7QUFDRDs7QUFFRCxNQUFJdVEsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCO0FBQ0FBLFdBQU9zZCxtQkFBbUI3dEIsY0FBbkIsQ0FBUDtBQUNEOztBQUVEMm5CLG9CQUFrQnZuQixPQUFsQixHQUE0QixJQUE1Qjs7QUFFQSxTQUFPbVEsSUFBUDtBQUNEOztBQUVELFNBQVNpWixRQUFULENBQWtCRixRQUFsQixFQUE0QjtBQUMxQixNQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNiO0FBQ0EsV0FBT3pGLG1CQUFtQixJQUExQixFQUFnQztBQUM5QkEsdUJBQWlCb0ssa0JBQWtCcEssY0FBbEIsQ0FBakI7QUFDRDtBQUNGLEdBTEQsTUFLTztBQUNMO0FBQ0EsV0FBT0EsbUJBQW1CLElBQW5CLElBQTJCLENBQUNzSyx1QkFBbkMsRUFBNEQ7QUFDMUR0Syx1QkFBaUJvSyxrQkFBa0JwSyxjQUFsQixDQUFqQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTdUssVUFBVCxDQUFvQjFELElBQXBCLEVBQXFDcEIsUUFBckMsRUFBOEQ7QUFDNUQsMkJBQ0UsQ0FBQ2pCLFNBREgsRUFFRSxvRUFDRSwwQ0FISjs7QUFNQWlEOztBQUVBakQsY0FBWSxJQUFaO0FBQ0EsTUFBTWdHLHFCQUFxQjNHLHVCQUF1QnRuQixPQUFsRDtBQUNBc25CLHlCQUF1QnRuQixPQUF2QixHQUFpQ2t1QixzQ0FBakM7O0FBRUEsTUFBTW5zQixpQkFBaUJ1b0IsS0FBSzZELDBCQUE1Qjs7QUFFQTtBQUNBO0FBQ0EsTUFDRXBzQixtQkFBbUJvbUIsd0JBQW5CLElBQ0FtQyxTQUFTcEMsUUFEVCxJQUVBekUsbUJBQW1CLElBSHJCLEVBSUU7QUFDQTtBQUNBK0Y7QUFDQXRCLGVBQVdvQyxJQUFYO0FBQ0FuQywrQkFBMkJwbUIsY0FBM0I7QUFDQTBoQixxQkFBaUIsc0NBQ2Z5RSxTQUFTbG9CLE9BRE0sRUFFZixJQUZlLEVBR2Ztb0Isd0JBSGUsQ0FBakI7QUFLQW1DLFNBQUtjLDJCQUFMLEdBQW1DNXBCLGdDQUFuQzs7QUFFQSxRQUFJckcseUNBQUosRUFBNEI7QUFDMUI7QUFDQTtBQUVBLFVBQU1pekIsZUFBaUMsSUFBSXhNLEdBQUosRUFBdkM7QUFDQTBJLFdBQUtzQyxxQkFBTCxDQUEyQnZQLE9BQTNCLENBQ0UsVUFBQ3dQLHFCQUFELEVBQXdCQyx1QkFBeEIsRUFBb0Q7QUFDbEQsWUFBSUEsMkJBQTJCL3FCLGNBQS9CLEVBQStDO0FBQzdDOHFCLGdDQUFzQnhQLE9BQXRCLENBQThCO0FBQUEsbUJBQzVCK1EsYUFBYXJMLEdBQWIsQ0FBaUJpSyxXQUFqQixDQUQ0QjtBQUFBLFdBQTlCO0FBR0Q7QUFDRixPQVBIOztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0ExQyxXQUFLbUIsb0JBQUwsR0FBNEIyQyxZQUE1Qjs7QUFFQSxVQUFJQSxhQUFhL0IsSUFBYixHQUFvQixDQUF4QixFQUEyQjtBQUN6QixZQUFNRixhQUFhQyx5QkFBZ0Jwc0IsT0FBbkM7QUFDQSxZQUFJbXNCLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkIsY0FBTUcsV0FBV0MsZ0JBQ2Z4cUIsY0FEZSxFQUVmdW9CLEtBQUtrQyxtQkFGVSxDQUFqQjtBQUlBLGNBQUk7QUFDRkwsdUJBQVdrQyxhQUFYLENBQXlCRCxZQUF6QixFQUF1QzlCLFFBQXZDO0FBQ0QsV0FGRCxDQUVFLE9BQU9uekIsS0FBUCxFQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksQ0FBQ3V6QixpQkFBTCxFQUF3QjtBQUN0QkEsa0NBQW9CLElBQXBCO0FBQ0FDLCtCQUFpQnh6QixLQUFqQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJcXlCLG1CQUFzQyxJQUExQztBQUNBLE1BQUlyd0IseUNBQUosRUFBNEI7QUFDMUI7QUFDQTtBQUNBcXdCLHVCQUFtQjVELDJCQUFrQjVuQixPQUFyQztBQUNBNG5CLCtCQUFrQjVuQixPQUFsQixHQUE0QnNxQixLQUFLbUIsb0JBQWpDO0FBQ0Q7O0FBRUQsTUFBSTZDLFdBQVcsS0FBZjs7QUFFQSwrQ0FBbUI3SyxjQUFuQjs7QUFFQSxLQUFHO0FBQ0QsUUFBSTtBQUNGMkYsZUFBU0YsUUFBVDtBQUNELEtBRkQsQ0FFRSxPQUFPRCxXQUFQLEVBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQUlzRixrQkFBSjtBQUNBLFVBQUkvMUIsSUFBT0EsSUFBSXVDLGtFQUFmLEVBQWdFO0FBQzlEd3pCLG9CQUFZM0YseUJBQVo7QUFDQUEsb0NBQTRCLElBQTVCO0FBQ0Q7O0FBRUQsVUFBSW5GLG1CQUFtQixJQUF2QixFQUE2QjtBQUMzQjtBQUNBNkssbUJBQVcsSUFBWDtBQUNBRSx3QkFBZ0J2RixXQUFoQjtBQUNELE9BSkQsTUFJTztBQUNMLFlBQUlodUIsMENBQXVCd29CLGVBQWV4UyxJQUFmLEdBQXNCN0osNEJBQWpELEVBQThEO0FBQzVEO0FBQ0E7QUFDQSw0RUFBeUNxYyxjQUF6QyxFQUF5RCxJQUF6RDtBQUNEOztBQUVELFlBQUlqckIsSUFBSixFQUFhO0FBQ1g7QUFDQTtBQUNBLGNBQUM0VywrQ0FBRDtBQUNEOztBQUVELFlBQUk1VyxJQUFPQSxJQUFJdUMsa0VBQWYsRUFBZ0U7QUFDOUQsY0FBSXd6QixTQUFKLEVBQWU7QUFDYixnQkFBTXZGLG1CQUEwQnZGLGNBQWhDO0FBQ0FrRiw2QkFBaUJLLGdCQUFqQixFQUFtQ0MsV0FBbkMsRUFBZ0RDLFFBQWhEO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxpQ0FDRXpGLG1CQUFtQixJQURyQixFQUVFLHFEQUNFLDJEQURGLEdBRUUsNkNBSko7O0FBT0EsWUFBTWdMLGNBQXFCaEwsY0FBM0I7QUFDQSxZQUFJaUssY0FBY2UsWUFBWTF1QixNQUE5QjtBQUNBLFlBQUkydEIsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBWSxxQkFBVyxJQUFYO0FBQ0FFLDBCQUFnQnZGLFdBQWhCO0FBQ0QsU0FURCxNQVNPO0FBQ0wsb0RBQ0VxQixJQURGLEVBRUVvRCxXQUZGLEVBR0VlLFdBSEYsRUFJRXhGLFdBSkYsRUFLRWQsd0JBTEY7QUFPQTFFLDJCQUFpQmdLLG1CQUFtQmdCLFdBQW5CLENBQWpCO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRDtBQUNELEdBMUVELFFBMEVTLElBMUVUOztBQTRFQSxNQUFJdHpCLHlDQUFKLEVBQTRCO0FBQzFCO0FBQ0F5c0IsK0JBQWtCNW5CLE9BQWxCLEdBQTRCd3JCLGdCQUE1QjtBQUNEOztBQUVEO0FBQ0F2RCxjQUFZLEtBQVo7QUFDQVgseUJBQXVCdG5CLE9BQXZCLEdBQWlDaXVCLGtCQUFqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFJSyxRQUFKLEVBQWM7QUFDWixRQUFNM0ssbUJBQWtCLEtBQXhCO0FBQ0EsZ0RBQWtCRCxhQUFsQixFQUFpQ0MsZ0JBQWpDO0FBQ0FELG9CQUFnQixJQUFoQjtBQUNBO0FBQ0EsUUFBSWxyQixJQUFKLEVBQWE7QUFDWDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EwdkIsZUFBVyxJQUFYO0FBQ0F3RyxZQUFRcEUsSUFBUjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSTdHLG1CQUFtQixJQUF2QixFQUE2QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU1FLG9CQUFrQixLQUF4QjtBQUNBLGdEQUFrQkQsYUFBbEIsRUFBaUNDLGlCQUFqQztBQUNBRCxvQkFBZ0IsSUFBaEI7QUFDQWlMLFlBQVFyRSxJQUFSO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLE1BQU0zRyxrQkFBa0IsSUFBeEI7QUFDQSw4Q0FBa0JELGFBQWxCLEVBQWlDQyxlQUFqQztBQUNBLE1BQU1pTCxxQkFBcUJ0RSxLQUFLdHFCLE9BQUwsQ0FBYXVRLFNBQXhDO0FBQ0EsMkJBQ0VxZSx1QkFBdUIsSUFEekIsRUFFRSx3RUFDRSxpREFISjs7QUFNQTtBQUNBO0FBQ0E7QUFDQTFHLGFBQVcsSUFBWDtBQUNBeEUsa0JBQWdCLElBQWhCOztBQUVBLE1BQUkyRSxrQkFBSixFQUF3QjtBQUN0QjtBQUNBLFFBQUkscURBQXFCaUMsSUFBckIsRUFBMkJ2b0IsY0FBM0IsQ0FBSixFQUFnRDtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQTJCdW9CLElBQTNCLEVBQWlDdm9CLGNBQWpDO0FBQ0EsVUFBTThzQiwwQkFBMEI5c0IsY0FBaEM7QUFDQSxVQUFNNm9CLHFCQUFxQk4sS0FBS3ZvQixjQUFoQztBQUNBK3NCLGdCQUNFeEUsSUFERixFQUVFc0Usa0JBRkYsRUFHRUMsdUJBSEYsRUFJRWpFLGtCQUpGLEVBS0UsQ0FBQyxDQUxILENBS007QUFMTjtBQU9BO0FBQ0QsS0FqQkQsTUFpQk87QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUNOLEtBQUtHLFFBQU4sSUFDQXZCLFFBTkssRUFPTDtBQUNBb0IsV0FBS0csUUFBTCxHQUFnQixJQUFoQjtBQUNBLFVBQU1vRSwyQkFBMkJ2RSxLQUFLNkQsMEJBQUwsR0FBa0Nwc0IsY0FBbkU7QUFDQSxVQUFNNm9CLHNCQUFzQk4sS0FBS3ZvQixjQUFMLEdBQXNCTCw4QkFBbEQ7QUFDQW90QixnQkFDRXhFLElBREYsRUFFRXNFLGtCQUZGLEVBR0VDLHdCQUhGLEVBSUVqRSxtQkFKRixFQUtFLENBQUMsQ0FMSCxDQUtNO0FBTE47QUFPQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSTFCLFlBQVlkLGdDQUFnQyxDQUFDLENBQWpELEVBQW9EO0FBQ2xEO0FBQ0EsUUFBTXlHLDRCQUEwQjlzQixjQUFoQztBQUNBLCtEQUEyQnVvQixJQUEzQixFQUFpQ3VFLHlCQUFqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFNRSx5QkFBeUIscUVBQzdCekUsSUFENkIsRUFFN0J2b0IsY0FGNkIsQ0FBL0I7QUFJQSxRQUFNaXRCLDJCQUEyQixrREFBbUJELHNCQUFuQixDQUFqQztBQUNBLFFBQUlDLDJCQUEyQjVHLDJCQUEvQixFQUE0RDtBQUMxREEsb0NBQThCNEcsd0JBQTlCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNQyxnQkFBZ0Isa0RBQW1CQyxvQkFBbkIsQ0FBdEI7QUFDQSxRQUFJQyxpQkFBaUIvRyw4QkFBOEI2RyxhQUFuRDtBQUNBRSxxQkFBaUJBLGlCQUFpQixDQUFqQixHQUFxQixDQUFyQixHQUF5QkEsY0FBMUM7O0FBRUE7O0FBRUEsUUFBTXZFLHVCQUFxQk4sS0FBS3ZvQixjQUFoQztBQUNBK3NCLGNBQ0V4RSxJQURGLEVBRUVzRSxrQkFGRixFQUdFQyx5QkFIRixFQUlFakUsb0JBSkYsRUFLRXVFLGNBTEY7QUFPQTtBQUNEOztBQUVEO0FBQ0FDLGFBQVc5RSxJQUFYLEVBQWlCc0Usa0JBQWpCLEVBQXFDN3NCLGNBQXJDO0FBQ0Q7O0FBRUQsU0FBUzRvQix1QkFBVCxDQUFpQzhELFdBQWpDLEVBQXFEN1IsS0FBckQsRUFBbUU7QUFDakUsTUFBTTdhLGlCQUFpQkwsOEJBQXZCO0FBQ0EsTUFBSXBDLFFBQVFtdkIsWUFBWTF1QixNQUF4QjtBQUNBLFNBQU9ULFVBQVUsSUFBakIsRUFBdUI7QUFDckIsWUFBUUEsTUFBTWxDLEdBQWQ7QUFDRSxXQUFLMUIsNkJBQUw7QUFDRSxZQUFNMnpCLE9BQU8vdkIsTUFBTW5DLElBQW5CO0FBQ0EsWUFBTXdKLFdBQVdySCxNQUFNeU8sU0FBdkI7QUFDQSxZQUNFLE9BQU9zaEIsS0FBS0Msd0JBQVosS0FBeUMsVUFBekMsSUFDQyxPQUFPM29CLFNBQVM0b0IsaUJBQWhCLEtBQXNDLFVBQXRDLElBQ0MsQ0FBQ3ZFLG1DQUFtQ3JrQixRQUFuQyxDQUhMLEVBSUU7QUFDQSxjQUFNNm9CLFlBQVksNkNBQW9CNVMsS0FBcEIsRUFBMkI2UixXQUEzQixDQUFsQjtBQUNBLGNBQU1uZSxTQUFTLGtEQUNiaFIsS0FEYSxFQUVia3dCLFNBRmEsRUFHYnp0QixjQUhhLENBQWY7QUFLQSwrQ0FBY3pDLEtBQWQsRUFBcUJnUixNQUFyQjtBQUNBbWYsdUJBQWFud0IsS0FBYixFQUFvQnlDLGNBQXBCO0FBQ0E7QUFDRDtBQUNEO0FBQ0YsV0FBS25HLHVCQUFMO0FBQWU7QUFDYixjQUFNNHpCLGFBQVksNkNBQW9CNVMsS0FBcEIsRUFBMkI2UixXQUEzQixDQUFsQjtBQUNBLGNBQU1uZSxVQUFTLGlEQUFzQmhSLEtBQXRCLEVBQTZCa3dCLFVBQTdCLEVBQXdDenRCLGNBQXhDLENBQWY7QUFDQSwrQ0FBY3pDLEtBQWQsRUFBcUJnUixPQUFyQjtBQUNBbWYsdUJBQWFud0IsS0FBYixFQUFvQnlDLGNBQXBCO0FBQ0E7QUFDRDtBQTFCSDtBQTRCQXpDLFlBQVFBLE1BQU1TLE1BQWQ7QUFDRDs7QUFFRCxNQUFJMHVCLFlBQVlyeEIsR0FBWixLQUFvQnhCLHVCQUF4QixFQUFrQztBQUNoQztBQUNBO0FBQ0EsUUFBTTh6QixZQUFZakIsV0FBbEI7QUFDQSxRQUFNZSxjQUFZLDZDQUFvQjVTLEtBQXBCLEVBQTJCOFMsU0FBM0IsQ0FBbEI7QUFDQSxRQUFNcGYsV0FBUyxpREFBc0JvZixTQUF0QixFQUFpQ0YsV0FBakMsRUFBNEN6dEIsY0FBNUMsQ0FBZjtBQUNBLHlDQUFjMnRCLFNBQWQsRUFBeUJwZixRQUF6QjtBQUNBbWYsaUJBQWFDLFNBQWIsRUFBd0IzdEIsY0FBeEI7QUFDRDtBQUNGOztBQUVELFNBQVN3cUIsZUFBVCxDQUNFeHFCLGNBREYsRUFFRXlxQixtQkFGRixFQUdVO0FBQ1I7QUFDQSxTQUFPenFCLGlCQUFpQixJQUFqQixHQUF3QnlxQixtQkFBL0I7QUFDRDs7QUFFRDtBQUNBLFNBQVNtRCw0QkFBVCxHQUF3RDtBQUN0RCxNQUFNdnRCLGNBQWM4c0Isb0JBQXBCO0FBQ0EsTUFBSTdvQixTQUFTLHNEQUF1QmpFLFdBQXZCLENBQWI7QUFDQSxNQUFJaUUsVUFBVTJoQix5QkFBZCxFQUF5QztBQUN2QztBQUNBO0FBQ0E7QUFDQTNoQixhQUFTMmhCLDRCQUE0QixDQUFyQztBQUNEO0FBQ0RBLDhCQUE0QjNoQixNQUE1QjtBQUNBLFNBQU8yaEIseUJBQVA7QUFDRDs7QUFFRCxTQUFTNEgseUJBQVQsQ0FBbUN4dEIsV0FBbkMsRUFBZ0U5QyxLQUFoRSxFQUE4RTtBQUM1RSxNQUFNdXdCLGdCQUFnQixrREFBdEI7O0FBRUEsTUFBSTl0Qix1QkFBSjtBQUNBLE1BQUksQ0FBQ3pDLE1BQU0yUixJQUFOLEdBQWEvSiwrQkFBZCxNQUFrQ0QsMEJBQXRDLEVBQWlEO0FBQy9DO0FBQ0FsRixxQkFBaUJMLDhCQUFqQjtBQUNELEdBSEQsTUFHTyxJQUFJdW1CLGFBQWEsQ0FBQzVHLFlBQWxCLEVBQWdDO0FBQ3JDO0FBQ0F0ZixxQkFBaUJvbUIsd0JBQWpCO0FBQ0QsR0FITSxNQUdBO0FBQ0wsWUFBUTBILGFBQVI7QUFDRSxXQUFLQyxxQ0FBTDtBQUNFL3RCLHlCQUFpQkwsOEJBQWpCO0FBQ0E7QUFDRixXQUFLcXVCLHdDQUFMO0FBQ0VodUIseUJBQWlCLDREQUE2QkssV0FBN0IsQ0FBakI7QUFDQTtBQUNGLFdBQUt1cEIsa0NBQUw7QUFDRTtBQUNBNXBCLHlCQUFpQixzREFBdUJLLFdBQXZCLENBQWpCO0FBQ0E7QUFDRixXQUFLNHRCLCtCQUFMO0FBQ0EsV0FBS0MsZ0NBQUw7QUFDRWx1Qix5QkFBaUJOLCtCQUFqQjtBQUNBO0FBQ0Y7QUFDRSxpQ0FDRSxLQURGLEVBRUUscUVBQ0UsOEJBSEo7QUFoQko7O0FBdUJBO0FBQ0E7QUFDQSxRQUFJeW1CLGFBQWEsSUFBYixJQUFxQm5tQixtQkFBbUJvbUIsd0JBQTVDLEVBQXNFO0FBQ3BFcG1CLHdCQUFrQixDQUFsQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUNFOHRCLGtCQUFrQkUsd0NBQWxCLEtBQ0NHLG1EQUFtRDF1QixnQ0FBbkQsSUFDQ08saUJBQWlCbXVCLDhDQUZuQixDQURGLEVBSUU7QUFDQUEscURBQWlEbnVCLGNBQWpEO0FBQ0Q7O0FBRUQsU0FBT0EsY0FBUDtBQUNEOztBQUVELFNBQVNvdUIsZ0JBQVQsQ0FDRTdGLElBREYsRUFFRThGLGlCQUZGLEVBR0VDLGFBSEYsRUFJRTtBQUNBO0FBQ0EsTUFDRUQscUJBQXFCLENBQXJCLElBQ0FoSSw4QkFBOEJnSSxpQkFGaEMsRUFHRTtBQUNBaEksa0NBQThCZ0ksaUJBQTlCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTRSxjQUFULEdBQTBCO0FBQ3hCakksdUJBQXFCLElBQXJCO0FBQ0Q7O0FBRUQsU0FBU2tJLGlCQUFULENBQ0VqRyxJQURGLEVBRUVwc0IsUUFGRixFQUdFc3lCLFFBSEYsRUFJRTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUMsWUFBWW5HLEtBQUttRyxTQUF2QjtBQUNBLE1BQUlBLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBQSxjQUFVMUQsTUFBVixDQUFpQjd1QixRQUFqQjtBQUNEOztBQUVELE1BQUlncUIsYUFBYSxJQUFiLElBQXFCQyw2QkFBNkJxSSxRQUF0RCxFQUFnRTtBQUM5RDtBQUNBO0FBQ0F0SSxlQUFXLElBQVg7QUFDRCxHQUpELE1BSU87QUFDTDtBQUNBLFFBQUkseURBQXlCb0MsSUFBekIsRUFBK0JrRyxRQUEvQixDQUFKLEVBQThDO0FBQzVDO0FBQ0EsOERBQXdCbEcsSUFBeEIsRUFBOEJrRyxRQUE5QjtBQUNBLFVBQU01RixxQkFBcUJOLEtBQUt2b0IsY0FBaEM7QUFDQSxVQUFJNm9CLHVCQUF1QnBwQixnQ0FBM0IsRUFBbUM7QUFDakNxcEIsb0JBQVlQLElBQVosRUFBa0JNLGtCQUFsQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQVM4RixxQkFBVCxDQUErQkMsYUFBL0IsRUFBcUR6eUIsUUFBckQsRUFBeUU7QUFDdkU7QUFDQTtBQUNBO0FBR0EsTUFBSTB5QixtQkFBSjtBQUNBLE1BQUl4MUIsK0NBQUosRUFBa0M7QUFDaEMsWUFBUXUxQixjQUFjdnpCLEdBQXRCO0FBQ0UsV0FBS2QsZ0NBQUw7QUFDRXMwQixxQkFBYUQsY0FBYzVpQixTQUEzQjtBQUNBO0FBQ0YsV0FBS3BSLDBDQUFMO0FBQ0VpMEIscUJBQWFELGNBQWNoZ0IsYUFBM0I7QUFDQTtBQUNGO0FBQ0UsaUNBQ0UsS0FERixFQUVFLDRDQUNFLGtDQUhKO0FBUko7QUFjRCxHQWZELE1BZU87QUFDTGlnQixpQkFBYUQsY0FBYzVpQixTQUEzQjtBQUNEO0FBQ0QsTUFBSTZpQixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQUEsZUFBVzdELE1BQVgsQ0FBa0I3dUIsUUFBbEI7QUFDRDs7QUFFRCxNQUFNa0UsY0FBYzhzQixvQkFBcEI7QUFDQSxNQUFNMkIsWUFBWWpCLDBCQUEwQnh0QixXQUExQixFQUF1Q3V1QixhQUF2QyxDQUFsQjtBQUNBLE1BQU1yRyxPQUFPd0csbUJBQW1CSCxhQUFuQixFQUFrQ0UsU0FBbEMsQ0FBYjtBQUNBLE1BQUl2RyxTQUFTLElBQWIsRUFBbUI7QUFDakIsNkRBQXlCQSxJQUF6QixFQUErQnVHLFNBQS9CO0FBQ0EsUUFBTWpHLHFCQUFxQk4sS0FBS3ZvQixjQUFoQztBQUNBLFFBQUk2b0IsdUJBQXVCcHBCLGdDQUEzQixFQUFtQztBQUNqQ3FwQixrQkFBWVAsSUFBWixFQUFrQk0sa0JBQWxCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVNrRyxrQkFBVCxDQUE0Qnh4QixLQUE1QixFQUEwQ3lDLGNBQTFDLEVBQTRFO0FBQzFFOztBQUVBLE1BQUl2SixJQUFKLEVBQWE7QUFDWCxRQUFJOEcsTUFBTWxDLEdBQU4sS0FBYzFCLDZCQUFsQixFQUFrQztBQUNoQyxVQUFNaUwsV0FBV3JILE1BQU15TyxTQUF2QjtBQUNBNFosOEJBQXdCaGhCLFFBQXhCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLE1BQUlySCxNQUFNeUMsY0FBTixHQUF1QkEsY0FBM0IsRUFBMkM7QUFDekN6QyxVQUFNeUMsY0FBTixHQUF1QkEsY0FBdkI7QUFDRDtBQUNELE1BQUl3TyxZQUFZalIsTUFBTWlSLFNBQXRCO0FBQ0EsTUFBSUEsY0FBYyxJQUFkLElBQXNCQSxVQUFVeE8sY0FBVixHQUEyQkEsY0FBckQsRUFBcUU7QUFDbkV3TyxjQUFVeE8sY0FBVixHQUEyQkEsY0FBM0I7QUFDRDtBQUNEO0FBQ0EsTUFBSWpDLE9BQU9SLE1BQU1TLE1BQWpCO0FBQ0EsTUFBSXVxQixPQUFPLElBQVg7QUFDQSxNQUFJeHFCLFNBQVMsSUFBVCxJQUFpQlIsTUFBTWxDLEdBQU4sS0FBY3hCLHVCQUFuQyxFQUE2QztBQUMzQzB1QixXQUFPaHJCLE1BQU15TyxTQUFiO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT2pPLFNBQVMsSUFBaEIsRUFBc0I7QUFDcEJ5USxrQkFBWXpRLEtBQUt5USxTQUFqQjtBQUNBLFVBQUl6USxLQUFLa1UsbUJBQUwsR0FBMkJqUyxjQUEvQixFQUErQztBQUM3Q2pDLGFBQUtrVSxtQkFBTCxHQUEyQmpTLGNBQTNCO0FBQ0EsWUFDRXdPLGNBQWMsSUFBZCxJQUNBQSxVQUFVeUQsbUJBQVYsR0FBZ0NqUyxjQUZsQyxFQUdFO0FBQ0F3TyxvQkFBVXlELG1CQUFWLEdBQWdDalMsY0FBaEM7QUFDRDtBQUNGLE9BUkQsTUFRTyxJQUNMd08sY0FBYyxJQUFkLElBQ0FBLFVBQVV5RCxtQkFBVixHQUFnQ2pTLGNBRjNCLEVBR0w7QUFDQXdPLGtCQUFVeUQsbUJBQVYsR0FBZ0NqUyxjQUFoQztBQUNEO0FBQ0QsVUFBSWpDLEtBQUtDLE1BQUwsS0FBZ0IsSUFBaEIsSUFBd0JELEtBQUsxQyxHQUFMLEtBQWF4Qix1QkFBekMsRUFBbUQ7QUFDakQwdUIsZUFBT3hxQixLQUFLaU8sU0FBWjtBQUNBO0FBQ0Q7QUFDRGpPLGFBQU9BLEtBQUtDLE1BQVo7QUFDRDtBQUNGOztBQUVELE1BQUk1RSx5Q0FBSixFQUE0QjtBQUMxQixRQUFJbXZCLFNBQVMsSUFBYixFQUFtQjtBQUNqQixVQUFNOEQsZUFBZXhHLDJCQUFrQjVuQixPQUF2QztBQUNBLFVBQUlvdUIsYUFBYS9CLElBQWIsR0FBb0IsQ0FBeEIsRUFBMkI7QUFDekIsWUFBTU8sd0JBQXdCdEMsS0FBS3NDLHFCQUFuQztBQUNBLFlBQU1tRSxzQkFBc0JuRSxzQkFBc0IzbUIsR0FBdEIsQ0FBMEJsRSxjQUExQixDQUE1QjtBQUNBLFlBQUlndkIsdUJBQXVCLElBQTNCLEVBQWlDO0FBQy9CM0MsdUJBQWEvUSxPQUFiLENBQXFCLHVCQUFlO0FBQ2xDLGdCQUFJLENBQUMwVCxvQkFBb0JqTyxHQUFwQixDQUF3QmtLLFdBQXhCLENBQUwsRUFBMkM7QUFDekM7QUFDQUEsMEJBQVlDLE9BQVo7QUFDRDs7QUFFRDhELGdDQUFvQmhPLEdBQXBCLENBQXdCaUssV0FBeEI7QUFDRCxXQVBEO0FBUUQsU0FURCxNQVNPO0FBQ0xKLGdDQUFzQjVtQixHQUF0QixDQUEwQmpFLGNBQTFCLEVBQTBDLElBQUk2ZixHQUFKLENBQVF3TSxZQUFSLENBQTFDOztBQUVBO0FBQ0FBLHVCQUFhL1EsT0FBYixDQUFxQix1QkFBZTtBQUNsQzJQLHdCQUFZQyxPQUFaO0FBQ0QsV0FGRDtBQUdEOztBQUVELFlBQU1kLGFBQWFDLHlCQUFnQnBzQixPQUFuQztBQUNBLFlBQUltc0IsZUFBZSxJQUFuQixFQUF5QjtBQUN2QixjQUFNRyxXQUFXQyxnQkFDZnhxQixjQURlLEVBRWZ1b0IsS0FBS2tDLG1CQUZVLENBQWpCO0FBSUFMLHFCQUFXNkUsZUFBWCxDQUEyQjVDLFlBQTNCLEVBQXlDOUIsUUFBekM7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNELFNBQU9oQyxJQUFQO0FBQ0Q7O0FBRU0sU0FBU2pELCtCQUFULENBQXlDL25CLEtBQXpDLEVBQTZEO0FBQ2xFLE1BQUk5RyxJQUFKLEVBQWE7QUFDWCxRQUFJZ3lCLGdCQUFnQixLQUFoQixJQUF5Qk0sc0JBQXNCLEtBQW5ELEVBQTBEO0FBQ3hELHlDQUNFLEtBREYsRUFFRSxtRUFDRSx5RkFERixHQUVFLGVBRkYsR0FHRSx5Q0FIRixHQUlFLE9BSkYsR0FLRSxnQ0FMRixHQU1FLGtGQU5GLEdBT0Usd0RBUEYsR0FRRSxJQVZKLEVBV0UsZ0NBQWlCeHJCLE1BQU1uQyxJQUF2QixDQVhGLEVBWUUsb0RBQTRCbUMsS0FBNUIsQ0FaRjtBQWNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTbXdCLFlBQVQsQ0FBc0Jud0IsS0FBdEIsRUFBb0N5QyxjQUFwQyxFQUFvRTtBQUNsRSxNQUFNdW9CLE9BQU93RyxtQkFBbUJ4eEIsS0FBbkIsRUFBMEJ5QyxjQUExQixDQUFiO0FBQ0EsTUFBSXVvQixTQUFTLElBQWIsRUFBbUI7QUFDakIsUUFBSTl4QixJQUFKLEVBQWE7QUFDWCxjQUFROEcsTUFBTWxDLEdBQWQ7QUFDRSxhQUFLMUIsNkJBQUw7QUFDRWdzQixxQ0FBMkJwb0IsS0FBM0IsRUFBa0MsSUFBbEM7QUFDQTtBQUNGLGFBQUs3RCxnQ0FBTDtBQUNBLGFBQUtXLHlCQUFMO0FBQ0EsYUFBS0csNEJBQUw7QUFDQSxhQUFLQyxrQ0FBTDtBQUNFa3JCLHFDQUEyQnBvQixLQUEzQixFQUFrQyxLQUFsQztBQUNBO0FBVEo7QUFXRDtBQUNEO0FBQ0Q7O0FBRUQsTUFDRSxDQUFDMm9CLFNBQUQsSUFDQUUsNkJBQTZCM21CLGdDQUQ3QixJQUVBTyxpQkFBaUJvbUIsd0JBSG5CLEVBSUU7QUFDQTtBQUNBekUsb0JBQWdCcGtCLEtBQWhCO0FBQ0FrcUI7QUFDRDtBQUNELDJEQUF5QmMsSUFBekIsRUFBK0J2b0IsY0FBL0I7QUFDQTtBQUNFO0FBQ0E7QUFDQSxHQUFDa21CLFNBQUQsSUFDQTVHLFlBREE7QUFFQTtBQUNBNkcsZUFBYW9DLElBTmYsRUFPRTtBQUNBLFFBQU1NLHFCQUFxQk4sS0FBS3ZvQixjQUFoQztBQUNBOG9CLGdCQUFZUCxJQUFaLEVBQWtCTSxrQkFBbEI7QUFDRDtBQUNELE1BQUlxRyxvQkFBb0JDLG1CQUF4QixFQUE2QztBQUMzQztBQUNBRCx3QkFBb0IsQ0FBcEI7QUFDQSw2QkFDRSxLQURGLEVBRUUsMkRBQ0UsNkNBREYsR0FFRSwwREFGRixHQUdFLHlEQUxKO0FBT0Q7QUFDRjs7QUFFRCxTQUFTRSxXQUFULENBQ0VDLEVBREYsRUFFRXY0QixDQUZGLEVBR0VDLENBSEYsRUFJRUMsQ0FKRixFQUtFQyxDQUxGLEVBTUs7QUFDSCxTQUFPLHlDQUFnQjgyQixxQ0FBaEIsRUFBbUMsWUFBTTtBQUM5QyxXQUFPc0IsR0FBR3Y0QixDQUFILEVBQU1DLENBQU4sRUFBU0MsQ0FBVCxFQUFZQyxDQUFaLENBQVA7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFRDtBQUNBOztBQUVBO0FBQ0EsSUFBSXE0QixxQkFBdUMsSUFBM0M7QUFDQSxJQUFJQyxvQkFBc0MsSUFBMUM7O0FBRUEsSUFBSUMseUJBQXlDL3ZCLGdDQUE3QztBQUNBLElBQUlnd0IsbUJBQUo7QUFDQSxJQUFJaEgsY0FBdUIsS0FBM0I7QUFDQSxJQUFJaUgsa0JBQW9DLElBQXhDO0FBQ0EsSUFBSUMsNEJBQTRDbHdCLGdDQUFoRDtBQUNBLElBQUkwdUIsaURBQWlFMXVCLGdDQUFyRTtBQUNBLElBQUlrckIsb0JBQTZCLEtBQWpDO0FBQ0EsSUFBSUMsaUJBQStCLElBQW5DOztBQUVBLElBQUk3QixvQkFBNkIsS0FBakM7QUFDQSxJQUFJNkcsc0JBQStCLEtBQW5DOztBQUVBLElBQUlDLG1CQUF3QyxJQUE1Qzs7QUFFQSxJQUFJQyxzQkFBOEIsZ0NBQWxDO0FBQ0EsSUFBSUMsc0JBQXNDLGtEQUN4Q0QsbUJBRHdDLENBQTFDO0FBR0EsSUFBSUUsdUJBQXVDRCxtQkFBM0M7O0FBRUE7QUFDQSxJQUFNWixzQkFBc0IsRUFBNUI7QUFDQSxJQUFJRCxvQkFBNEIsQ0FBaEM7QUFDQSxJQUFJZSxtQ0FBcUQsSUFBekQ7O0FBRUEsU0FBU0MsNEJBQVQsR0FBd0M7QUFDdEMsTUFBTWhELGdCQUFnQixtQ0FBUTRDLG1CQUE5QjtBQUNBQyx3QkFBc0Isa0RBQW1CN0MsYUFBbkIsQ0FBdEI7QUFDRDs7QUFFRCxTQUFTaUQsa0NBQVQsQ0FDRTVILElBREYsRUFFRXZvQixjQUZGLEVBR0U7QUFDQSxNQUFJd3ZCLDJCQUEyQi92QixnQ0FBL0IsRUFBdUM7QUFDckM7QUFDQSxRQUFJTyxpQkFBaUJ3dkIsc0JBQXJCLEVBQTZDO0FBQzNDO0FBQ0E7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJQyxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQSwwREFBdUJBLFVBQXZCO0FBQ0Q7QUFDRjtBQUNEO0FBQ0QsR0FiRCxNQWFPO0FBQ0w7QUFDRDs7QUFFREQsMkJBQXlCeHZCLGNBQXpCO0FBQ0EsTUFBTW93QixZQUFZLG1DQUFRTixtQkFBMUI7QUFDQSxNQUFNTyxtQkFBbUIsa0RBQW1CcndCLGNBQW5CLENBQXpCO0FBQ0EsTUFBTXN3QixVQUFVRCxtQkFBbUJELFNBQW5DO0FBQ0FYLGVBQWEsb0RBQXlCYyxnQkFBekIsRUFBMkMsRUFBQ0QsZ0JBQUQsRUFBM0MsQ0FBYjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzNELE9BQVQsQ0FBaUJwRSxJQUFqQixFQUF1QjtBQUNyQkEsT0FBS3hZLFlBQUwsR0FBb0IsSUFBcEI7QUFDRDs7QUFFRCxTQUFTc2QsVUFBVCxDQUNFOUUsSUFERixFQUVFeFksWUFGRixFQUdFL1AsY0FIRixFQUlFO0FBQ0F1b0IsT0FBS2MsMkJBQUwsR0FBbUNycEIsY0FBbkM7QUFDQXVvQixPQUFLeFksWUFBTCxHQUFvQkEsWUFBcEI7QUFDRDs7QUFFRCxTQUFTZ2QsU0FBVCxDQUNFeEUsSUFERixFQUVFeFksWUFGRixFQUdFK2MsdUJBSEYsRUFJRWpFLGtCQUpGLEVBS0V1RSxjQUxGLEVBTVE7QUFDTjdFLE9BQUt2b0IsY0FBTCxHQUFzQjZvQixrQkFBdEI7QUFDQSxNQUFJdUUsbUJBQW1CLENBQW5CLElBQXdCLENBQUNwQix1QkFBN0IsRUFBc0Q7QUFDcEQ7QUFDQXpELFNBQUtjLDJCQUFMLEdBQW1DeUQsdUJBQW5DO0FBQ0F2RSxTQUFLeFksWUFBTCxHQUFvQkEsWUFBcEI7QUFDRCxHQUpELE1BSU8sSUFBSXFkLGlCQUFpQixDQUFyQixFQUF3QjtBQUM3QjtBQUNBN0UsU0FBS2lJLGFBQUwsR0FBcUIsMkNBQ25CQyxVQUFVOUcsSUFBVixDQUFlLElBQWYsRUFBcUJwQixJQUFyQixFQUEyQnhZLFlBQTNCLEVBQXlDK2MsdUJBQXpDLENBRG1CLEVBRW5CTSxjQUZtQixDQUFyQjtBQUlEO0FBQ0Y7O0FBRUQsU0FBU1IsT0FBVCxDQUFpQnJFLElBQWpCLEVBQXVCO0FBQ3JCQSxPQUFLeFksWUFBTCxHQUFvQixJQUFwQjtBQUNEOztBQUVELFNBQVMwZ0IsU0FBVCxDQUFtQmxJLElBQW5CLEVBQXlCeFksWUFBekIsRUFBdUMrYyx1QkFBdkMsRUFBZ0U7QUFDOUQ7QUFDQXZFLE9BQUtjLDJCQUFMLEdBQW1DeUQsdUJBQW5DO0FBQ0F2RSxPQUFLeFksWUFBTCxHQUFvQkEsWUFBcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQW1nQjtBQUNBRix5QkFBdUJELG1CQUF2QjtBQUNBVyxZQUFVbkksSUFBVixFQUFnQnVFLHVCQUFoQjtBQUNEOztBQUVELFNBQVMzQyxRQUFULENBQWtCNUIsSUFBbEIsRUFBd0J2b0IsY0FBeEIsRUFBd0M7QUFDdEN1b0IsT0FBS3ZvQixjQUFMLEdBQXNCQSxjQUF0QjtBQUNBdW9CLE9BQUt4WSxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7O0FBRUQsU0FBU29kLGtCQUFULEdBQThCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUkxRSxXQUFKLEVBQWlCO0FBQ2Y7QUFDQSxXQUFPdUgsb0JBQVA7QUFDRDtBQUNEO0FBQ0FXO0FBQ0EsTUFDRWhCLDhCQUE4Qmx3QixnQ0FBOUIsSUFDQWt3Qiw4QkFBOEJqd0IsK0JBRmhDLEVBR0U7QUFDQTtBQUNBO0FBQ0F3d0I7QUFDQUYsMkJBQXVCRCxtQkFBdkI7QUFDQSxXQUFPQyxvQkFBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9BLG9CQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQVNsSCxXQUFULENBQXFCUCxJQUFyQixFQUFzQ3ZvQixjQUF0QyxFQUFzRTtBQUNwRTR3QixvQkFBa0JySSxJQUFsQixFQUF3QnZvQixjQUF4QjtBQUNBLE1BQUl5b0IsV0FBSixFQUFpQjtBQUNmO0FBQ0E7QUFDQTtBQUNEOztBQUVELE1BQUlNLGlCQUFKLEVBQXVCO0FBQ3JCO0FBQ0EsUUFBSTZHLG1CQUFKLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQUYsd0JBQWtCbkgsSUFBbEI7QUFDQW9ILGtDQUE0Qmh3Qiw4QkFBNUI7QUFDQWt4Qix3QkFBa0J0SSxJQUFsQixFQUF3QjVvQiw4QkFBeEIsRUFBOEIsS0FBOUI7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJSyxtQkFBbUJMLDhCQUF2QixFQUE2QjtBQUMzQnFwQjtBQUNELEdBRkQsTUFFTztBQUNMbUgsdUNBQW1DNUgsSUFBbkMsRUFBeUN2b0IsY0FBekM7QUFDRDtBQUNGOztBQUVELFNBQVM0d0IsaUJBQVQsQ0FBMkJySSxJQUEzQixFQUE0Q3ZvQixjQUE1QyxFQUE0RTtBQUMxRTtBQUNBO0FBQ0EsTUFBSXVvQixLQUFLdUksaUJBQUwsS0FBMkIsSUFBL0IsRUFBcUM7QUFDbkM7QUFDQXZJLFNBQUt2b0IsY0FBTCxHQUFzQkEsY0FBdEI7QUFDQSxRQUFJdXZCLHNCQUFzQixJQUExQixFQUFnQztBQUM5QkQsMkJBQXFCQyxvQkFBb0JoSCxJQUF6QztBQUNBQSxXQUFLdUksaUJBQUwsR0FBeUJ2SSxJQUF6QjtBQUNELEtBSEQsTUFHTztBQUNMZ0gsd0JBQWtCdUIsaUJBQWxCLEdBQXNDdkksSUFBdEM7QUFDQWdILDBCQUFvQmhILElBQXBCO0FBQ0FnSCx3QkFBa0J1QixpQkFBbEIsR0FBc0N4QixrQkFBdEM7QUFDRDtBQUNGLEdBWEQsTUFXTztBQUNMO0FBQ0EsUUFBTXlCLDBCQUEwQnhJLEtBQUt2b0IsY0FBckM7QUFDQSxRQUFJQSxpQkFBaUIrd0IsdUJBQXJCLEVBQThDO0FBQzVDO0FBQ0F4SSxXQUFLdm9CLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVMyd0IsdUJBQVQsR0FBbUM7QUFDakMsTUFBSUssc0JBQXNCdnhCLGdDQUExQjtBQUNBLE1BQUl3eEIsc0JBQXNCLElBQTFCO0FBQ0EsTUFBSTFCLHNCQUFzQixJQUExQixFQUFnQztBQUM5QixRQUFJMkIsd0JBQXdCM0IsaUJBQTVCO0FBQ0EsUUFBSWhILE9BQU8rRyxrQkFBWDtBQUNBLFdBQU8vRyxTQUFTLElBQWhCLEVBQXNCO0FBQ3BCLFVBQU13SSwwQkFBMEJ4SSxLQUFLdm9CLGNBQXJDO0FBQ0EsVUFBSSt3Qiw0QkFBNEJ0eEIsZ0NBQWhDLEVBQXdDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUNFeXhCLDBCQUEwQixJQUExQixJQUFrQzNCLHNCQUFzQixJQUQxRCxFQUVFLGdFQUNFLGlEQUhKO0FBS0EsWUFBSWhILFNBQVNBLEtBQUt1SSxpQkFBbEIsRUFBcUM7QUFDbkM7QUFDQXZJLGVBQUt1SSxpQkFBTCxHQUF5QixJQUF6QjtBQUNBeEIsK0JBQXFCQyxvQkFBb0IsSUFBekM7QUFDQTtBQUNELFNBTEQsTUFLTyxJQUFJaEgsU0FBUytHLGtCQUFiLEVBQWlDO0FBQ3RDO0FBQ0EsY0FBTWxoQixPQUFPbWEsS0FBS3VJLGlCQUFsQjtBQUNBeEIsK0JBQXFCbGhCLElBQXJCO0FBQ0FtaEIsNEJBQWtCdUIsaUJBQWxCLEdBQXNDMWlCLElBQXRDO0FBQ0FtYSxlQUFLdUksaUJBQUwsR0FBeUIsSUFBekI7QUFDRCxTQU5NLE1BTUEsSUFBSXZJLFNBQVNnSCxpQkFBYixFQUFnQztBQUNyQztBQUNBQSw4QkFBb0IyQixxQkFBcEI7QUFDQTNCLDRCQUFrQnVCLGlCQUFsQixHQUFzQ3hCLGtCQUF0QztBQUNBL0csZUFBS3VJLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0E7QUFDRCxTQU5NLE1BTUE7QUFDTEksZ0NBQXNCSixpQkFBdEIsR0FBMEN2SSxLQUFLdUksaUJBQS9DO0FBQ0F2SSxlQUFLdUksaUJBQUwsR0FBeUIsSUFBekI7QUFDRDtBQUNEdkksZUFBTzJJLHNCQUFzQkosaUJBQTdCO0FBQ0QsT0FqQ0QsTUFpQ087QUFDTCxZQUFJQywwQkFBMEJDLG1CQUE5QixFQUFtRDtBQUNqRDtBQUNBQSxnQ0FBc0JELHVCQUF0QjtBQUNBRSxnQ0FBc0IxSSxJQUF0QjtBQUNEO0FBQ0QsWUFBSUEsU0FBU2dILGlCQUFiLEVBQWdDO0FBQzlCO0FBQ0Q7QUFDRCxZQUFJeUIsd0JBQXdCcnhCLDhCQUE1QixFQUFrQztBQUNoQztBQUNBO0FBQ0E7QUFDRDtBQUNEdXhCLGdDQUF3QjNJLElBQXhCO0FBQ0FBLGVBQU9BLEtBQUt1SSxpQkFBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRHBCLG9CQUFrQnVCLG1CQUFsQjtBQUNBdEIsOEJBQTRCcUIsbUJBQTVCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSUcsV0FBb0IsS0FBeEI7QUFDQSxTQUFTbkYscUJBQVQsR0FBaUM7QUFDL0IsTUFBSW1GLFFBQUosRUFBYztBQUNaLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSSx3Q0FBSixFQUFtQjtBQUNqQkEsZUFBVyxJQUFYO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFTWixnQkFBVCxHQUE0QjtBQUMxQixNQUFJO0FBQ0YsUUFBSSxDQUFDdkUsdUJBQUwsRUFBOEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUlzRCx1QkFBdUIsSUFBM0IsRUFBaUM7QUFDL0JZO0FBQ0EsWUFBSTNILE9BQWtCK0csa0JBQXRCO0FBQ0EsV0FBRztBQUNELG9FQUEwQi9HLElBQTFCLEVBQWdDd0gsbUJBQWhDO0FBQ0E7QUFDQXhILGlCQUFRQSxLQUFLdUksaUJBQWI7QUFDRCxTQUpELFFBSVN2SSxTQUFTK0csa0JBSmxCO0FBS0Q7QUFDRjtBQUNEOEIsZ0JBQVkzeEIsZ0NBQVosRUFBb0IsSUFBcEI7QUFDRCxHQWxCRCxTQWtCVTtBQUNSMHhCLGVBQVcsS0FBWDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU25JLGVBQVQsR0FBMkI7QUFDekJvSSxjQUFZenhCLDhCQUFaLEVBQWtCLEtBQWxCO0FBQ0Q7O0FBRUQsU0FBU3l4QixXQUFULENBQXFCQyxpQkFBckIsRUFBd0RsSyxRQUF4RCxFQUEyRTtBQUN6RTtBQUNBO0FBQ0F3Sjs7QUFFQSxNQUFJeEosUUFBSixFQUFjO0FBQ1orSTtBQUNBRiwyQkFBdUJELG1CQUF2Qjs7QUFFQSxRQUFJbDNCLHNDQUFKLEVBQXlCO0FBQ3ZCLFVBQU00b0IsWUFBWWtPLDRCQUE0QkksbUJBQTlDO0FBQ0EsVUFBTU8sVUFBVSxrREFBbUJYLHlCQUFuQixDQUFoQjtBQUNBLHlEQUF5QmxPLFNBQXpCLEVBQW9DNk8sT0FBcEM7QUFDRDs7QUFFRCxXQUNFWixvQkFBb0IsSUFBcEIsSUFDQUMsOEJBQThCbHdCLGdDQUQ5QixJQUVBNHhCLHFCQUFxQjFCLHlCQUZyQixJQUdBLEVBQUV3QixZQUFZcEIsc0JBQXNCSix5QkFBcEMsQ0FKRixFQUtFO0FBQ0FrQix3QkFDRW5CLGVBREYsRUFFRUMseUJBRkYsRUFHRUksc0JBQXNCSix5QkFIeEI7QUFLQWdCO0FBQ0FUO0FBQ0FGLDZCQUF1QkQsbUJBQXZCO0FBQ0Q7QUFDRixHQXpCRCxNQXlCTztBQUNMLFdBQ0VMLG9CQUFvQixJQUFwQixJQUNBQyw4QkFBOEJsd0IsZ0NBRDlCLElBRUE0eEIscUJBQXFCMUIseUJBSHZCLEVBSUU7QUFDQWtCLHdCQUFrQm5CLGVBQWxCLEVBQW1DQyx5QkFBbkMsRUFBOEQsS0FBOUQ7QUFDQWdCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBOztBQUVBO0FBQ0EsTUFBSXhKLFFBQUosRUFBYztBQUNacUksNkJBQXlCL3ZCLGdDQUF6QjtBQUNBZ3dCLGlCQUFhLElBQWI7QUFDRDtBQUNEO0FBQ0EsTUFBSUUsOEJBQThCbHdCLGdDQUFsQyxFQUEwQztBQUN4QzB3Qix1Q0FDSVQsZUFESixFQUVFQyx5QkFGRjtBQUlEOztBQUVEO0FBQ0EyQjtBQUNEOztBQUVELFNBQVNaLFNBQVQsQ0FBbUJuSSxJQUFuQixFQUFvQ3ZvQixjQUFwQyxFQUFvRTtBQUNsRSwyQkFDRSxDQUFDeW9CLFdBREgsRUFFRSx1RUFDRSwrREFISjtBQUtBO0FBQ0E7QUFDQTtBQUNBaUgsb0JBQWtCbkgsSUFBbEI7QUFDQW9ILDhCQUE0QjN2QixjQUE1QjtBQUNBNndCLG9CQUFrQnRJLElBQWxCLEVBQXdCdm9CLGNBQXhCLEVBQXdDLEtBQXhDO0FBQ0E7QUFDQWdwQjtBQUNEOztBQUVELFNBQVNzSSxlQUFULEdBQTJCO0FBQ3pCcEMsc0JBQW9CLENBQXBCO0FBQ0FlLHFDQUFtQyxJQUFuQzs7QUFFQSxNQUFJSixxQkFBcUIsSUFBekIsRUFBK0I7QUFDN0IsUUFBTTBCLFVBQVUxQixnQkFBaEI7QUFDQUEsdUJBQW1CLElBQW5CO0FBQ0EsU0FBSyxJQUFJdlksSUFBSSxDQUFiLEVBQWdCQSxJQUFJaWEsUUFBUTU1QixNQUE1QixFQUFvQzJmLEdBQXBDLEVBQXlDO0FBQ3ZDLFVBQU1rYSxRQUFRRCxRQUFRamEsQ0FBUixDQUFkO0FBQ0EsVUFBSTtBQUNGa2EsY0FBTUMsV0FBTjtBQUNELE9BRkQsQ0FFRSxPQUFPcjZCLEtBQVAsRUFBYztBQUNkLFlBQUksQ0FBQ3V6QixpQkFBTCxFQUF3QjtBQUN0QkEsOEJBQW9CLElBQXBCO0FBQ0FDLDJCQUFpQnh6QixLQUFqQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELE1BQUl1ekIsaUJBQUosRUFBdUI7QUFDckIsUUFBTXZ6QixRQUFRd3pCLGNBQWQ7QUFDQUEscUJBQWlCLElBQWpCO0FBQ0FELHdCQUFvQixLQUFwQjtBQUNBLFVBQU12ekIsS0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3k1QixpQkFBVCxDQUNFdEksSUFERixFQUVFdm9CLGNBRkYsRUFHRW1uQixRQUhGLEVBSUU7QUFDQSwyQkFDRSxDQUFDc0IsV0FESCxFQUVFLDJFQUNFLDBDQUhKOztBQU1BQSxnQkFBYyxJQUFkOztBQUVBO0FBQ0EsTUFBSSxDQUFDdEIsUUFBTCxFQUFlO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBSXBYLGVBQWV3WSxLQUFLeFksWUFBeEI7QUFDQSxRQUFJQSxpQkFBaUIsSUFBckIsRUFBMkI7QUFDekI7QUFDQTJoQixtQkFBYW5KLElBQWIsRUFBbUJ4WSxZQUFuQixFQUFpQy9QLGNBQWpDO0FBQ0QsS0FIRCxNQUdPO0FBQ0x1b0IsV0FBS3hZLFlBQUwsR0FBb0IsSUFBcEI7QUFDQTtBQUNBO0FBQ0EsVUFBTXlnQixnQkFBZ0JqSSxLQUFLaUksYUFBM0I7QUFDQSxVQUFJQSxrQkFBa0JtQiwrQkFBdEIsRUFBaUM7QUFDL0JwSixhQUFLaUksYUFBTCxHQUFxQm1CLCtCQUFyQjtBQUNBO0FBQ0EsaURBQWNuQixhQUFkO0FBQ0Q7QUFDRHZFLGlCQUFXMUQsSUFBWCxFQUFpQnBCLFFBQWpCO0FBQ0FwWCxxQkFBZXdZLEtBQUt4WSxZQUFwQjtBQUNBLFVBQUlBLGlCQUFpQixJQUFyQixFQUEyQjtBQUN6QjtBQUNBMmhCLHFCQUFhbkosSUFBYixFQUFtQnhZLFlBQW5CLEVBQWlDL1AsY0FBakM7QUFDRDtBQUNGO0FBQ0YsR0EzQkQsTUEyQk87QUFDTDtBQUNBLFFBQUkrUCxnQkFBZXdZLEtBQUt4WSxZQUF4QjtBQUNBLFFBQUlBLGtCQUFpQixJQUFyQixFQUEyQjtBQUN6QjtBQUNBMmhCLG1CQUFhbkosSUFBYixFQUFtQnhZLGFBQW5CLEVBQWlDL1AsY0FBakM7QUFDRCxLQUhELE1BR087QUFDTHVvQixXQUFLeFksWUFBTCxHQUFvQixJQUFwQjtBQUNBO0FBQ0E7QUFDQSxVQUFNeWdCLGlCQUFnQmpJLEtBQUtpSSxhQUEzQjtBQUNBLFVBQUlBLG1CQUFrQm1CLCtCQUF0QixFQUFpQztBQUMvQnBKLGFBQUtpSSxhQUFMLEdBQXFCbUIsK0JBQXJCO0FBQ0E7QUFDQSxpREFBY25CLGNBQWQ7QUFDRDtBQUNEdkUsaUJBQVcxRCxJQUFYLEVBQWlCcEIsUUFBakI7QUFDQXBYLHNCQUFld1ksS0FBS3hZLFlBQXBCO0FBQ0EsVUFBSUEsa0JBQWlCLElBQXJCLEVBQTJCO0FBQ3pCO0FBQ0E7QUFDQSxZQUFJLENBQUNpYyx1QkFBTCxFQUE4QjtBQUM1QjtBQUNBMEYsdUJBQWFuSixJQUFiLEVBQW1CeFksYUFBbkIsRUFBaUMvUCxjQUFqQztBQUNELFNBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQXVvQixlQUFLeFksWUFBTCxHQUFvQkEsYUFBcEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDBZLGdCQUFjLEtBQWQ7QUFDRDs7QUFFRCxTQUFTaUosWUFBVCxDQUNFbkosSUFERixFQUVFeFksWUFGRixFQUdFL1AsY0FIRixFQUlRO0FBQ047QUFDQSxNQUFNNHhCLGFBQWFySixLQUFLcUosVUFBeEI7QUFDQSxNQUFJQSxlQUFlLElBQWYsSUFBdUJBLFdBQVdDLGVBQVgsSUFBOEI3eEIsY0FBekQsRUFBeUU7QUFDdkUsUUFBSTZ2QixxQkFBcUIsSUFBekIsRUFBK0I7QUFDN0JBLHlCQUFtQixDQUFDK0IsVUFBRCxDQUFuQjtBQUNELEtBRkQsTUFFTztBQUNML0IsdUJBQWlCOXFCLElBQWpCLENBQXNCNnNCLFVBQXRCO0FBQ0Q7QUFDRCxRQUFJQSxXQUFXRSxNQUFmLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQXZKLFdBQUt4WSxZQUFMLEdBQW9CQSxZQUFwQjtBQUNBd1ksV0FBS3ZvQixjQUFMLEdBQXNCUCxnQ0FBdEI7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQThvQixPQUFLeFksWUFBTCxHQUFvQixJQUFwQjs7QUFFQTtBQUNBO0FBQ0EsTUFBSXdZLFNBQVMwSCxnQ0FBYixFQUErQztBQUM3QztBQUNBO0FBQ0FmO0FBQ0QsR0FKRCxNQUlPO0FBQ0w7QUFDQWUsdUNBQW1DMUgsSUFBbkM7QUFDQTJHLHdCQUFvQixDQUFwQjtBQUNEO0FBQ0QsMkNBQWdCbkIscUNBQWhCLEVBQW1DLFlBQU07QUFDdkMzRSxlQUFXYixJQUFYLEVBQWlCeFksWUFBakI7QUFDRCxHQUZEO0FBR0Q7O0FBRUQsU0FBUzBjLGVBQVQsQ0FBeUJyMUIsS0FBekIsRUFBdUM7QUFDckMsMkJBQ0VzNEIsb0JBQW9CLElBRHRCLEVBRUUsMEVBQ0UsOEJBSEo7QUFLQTtBQUNBO0FBQ0FBLGtCQUFnQjF2QixjQUFoQixHQUFpQ1AsZ0NBQWpDO0FBQ0EsTUFBSSxDQUFDa3JCLGlCQUFMLEVBQXdCO0FBQ3RCQSx3QkFBb0IsSUFBcEI7QUFDQUMscUJBQWlCeHpCLEtBQWpCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsU0FBUzI2QixjQUFULENBQThCMUMsRUFBOUIsRUFBK0N2NEIsQ0FBL0MsRUFBd0Q7QUFDdEQsTUFBTWs3Qiw0QkFBNEJqSixpQkFBbEM7QUFDQUEsc0JBQW9CLElBQXBCO0FBQ0EsTUFBSTtBQUNGLFdBQU9zRyxHQUFHdjRCLENBQUgsQ0FBUDtBQUNELEdBRkQsU0FFVTtBQUNSaXlCLHdCQUFvQmlKLHlCQUFwQjtBQUNBLFFBQUksQ0FBQ2pKLGlCQUFELElBQXNCLENBQUNOLFdBQTNCLEVBQXdDO0FBQ3RDTztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsU0FBU2lKLGdCQUFULENBQWdDNUMsRUFBaEMsRUFBaUR2NEIsQ0FBakQsRUFBMEQ7QUFDeEQsTUFBSWl5QixxQkFBcUIsQ0FBQzZHLG1CQUExQixFQUErQztBQUM3Q0EsMEJBQXNCLElBQXRCO0FBQ0EsUUFBSTtBQUNGLGFBQU9QLEdBQUd2NEIsQ0FBSCxDQUFQO0FBQ0QsS0FGRCxTQUVVO0FBQ1I4NEIsNEJBQXNCLEtBQXRCO0FBQ0Q7QUFDRjtBQUNELFNBQU9QLEdBQUd2NEIsQ0FBSCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQVNvN0IsU0FBVCxDQUF5QjdDLEVBQXpCLEVBQTBDdjRCLENBQTFDLEVBQW1EO0FBQ2pELDJCQUNFLENBQUMyeEIsV0FESCxFQUVFLHVFQUNFLHlDQUhKO0FBS0EsTUFBTXVKLDRCQUE0QmpKLGlCQUFsQztBQUNBQSxzQkFBb0IsSUFBcEI7QUFDQSxNQUFJO0FBQ0YsV0FBT3FHLFlBQVlDLEVBQVosRUFBZ0J2NEIsQ0FBaEIsQ0FBUDtBQUNELEdBRkQsU0FFVTtBQUNSaXlCLHdCQUFvQmlKLHlCQUFwQjtBQUNBaEo7QUFDRDtBQUNGOztBQUVELFNBQVNtSixrQkFBVCxDQUFxQzlDLEVBQXJDLEVBQXNEdjRCLENBQXRELEVBQTREQyxDQUE1RCxFQUFxRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQ0UsQ0FBQ2d5QixpQkFBRCxJQUNBLENBQUNOLFdBREQsSUFFQTBGLG1EQUFtRDF1QixnQ0FIckQsRUFJRTtBQUNBO0FBQ0EyeEIsZ0JBQVlqRCw4Q0FBWixFQUE0RCxLQUE1RDtBQUNBQSxxREFBaUQxdUIsZ0NBQWpEO0FBQ0Q7QUFDRCxNQUFNdXlCLDRCQUE0QmpKLGlCQUFsQztBQUNBQSxzQkFBb0IsSUFBcEI7QUFDQSxNQUFJO0FBQ0YsV0FBTyx5Q0FBZ0JpRix3Q0FBaEIsRUFBc0MsWUFBTTtBQUNqRCxhQUFPcUIsR0FBR3Y0QixDQUFILEVBQU1DLENBQU4sQ0FBUDtBQUNELEtBRk0sQ0FBUDtBQUdELEdBSkQsU0FJVTtBQUNSZ3lCLHdCQUFvQmlKLHlCQUFwQjtBQUNBLFFBQUksQ0FBQ2pKLGlCQUFELElBQXNCLENBQUNOLFdBQTNCLEVBQXdDO0FBQ3RDTztBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTb0osdUJBQVQsR0FBbUM7QUFDakMsTUFDRSxDQUFDM0osV0FBRCxJQUNBMEYsbURBQW1EMXVCLGdDQUZyRCxFQUdFO0FBQ0E7QUFDQTJ4QixnQkFBWWpELDhDQUFaLEVBQTRELEtBQTVEO0FBQ0FBLHFEQUFpRDF1QixnQ0FBakQ7QUFDRDtBQUNGOztBQUVELFNBQVM0eUIsZUFBVCxDQUF5QmhELEVBQXpCLEVBQWdEO0FBQzlDLE1BQU0yQyw0QkFBNEJqSixpQkFBbEM7QUFDQUEsc0JBQW9CLElBQXBCO0FBQ0EsTUFBSTtBQUNGcUcsZ0JBQVlDLEVBQVo7QUFDRCxHQUZELFNBRVU7QUFDUnRHLHdCQUFvQmlKLHlCQUFwQjtBQUNBLFFBQUksQ0FBQ2pKLGlCQUFELElBQXNCLENBQUNOLFdBQTNCLEVBQXdDO0FBQ3RDTztBQUNEO0FBQ0Y7QUFDRjs7UUFHQ21FLGtCLEdBQUFBLGtCO1FBQ0FVLHlCLEdBQUFBLHlCO1FBQ0FqRix1QixHQUFBQSx1QjtRQUNBNkQsZSxHQUFBQSxlO1FBQ0EyQixnQixHQUFBQSxnQjtRQUNBRyxjLEdBQUFBLGM7UUFDQUMsaUIsR0FBQUEsaUI7UUFDQUcscUIsR0FBQUEscUI7UUFDQXpGLCtCLEdBQUFBLCtCO1FBQ0FELGtDLEdBQUFBLGtDO1FBQ0F5RSxZLEdBQUFBLFk7UUFDQTVFLFcsR0FBQUEsVztRQUNBNEgsUyxHQUFBQSxTO1FBQ0FxQixjLEdBQUFBLGM7UUFDQUUsZ0IsR0FBQUEsZ0I7UUFDQUMsUyxHQUFBQSxTO1FBQ0FHLGUsR0FBQUEsZTtRQUNrQkMsZSxHQUFsQkMsd0I7UUFDQW5ELFcsR0FBQUEsVztRQUNBK0Msa0IsR0FBQUEsa0I7UUFDQUMsdUIsR0FBQUEsdUI7UUFDQXhFLDRCLEdBQUFBLDRCO1FBQ0F6RSxtQixHQUFBQSxtQjs7Ozs7Ozs7Ozs7O0FDN2lGRjs7Ozs7OztBQU9BOzs7Ozs7Ozs7Ozs7OztBQWNBLElBQUlxSixxQkFBcUIsOEJBQVcsQ0FBRSxDQUF0Qzs7QUFFQSxJQUFJLzdCLElBQUosRUFBYTtBQUNYLE1BQU1nOEIsZUFBZSxTQUFmQSxZQUFlLENBQVMvN0IsTUFBVCxFQUEwQjtBQUFBLHNDQUFOVyxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFDN0MsUUFBSUMsV0FBVyxDQUFmO0FBQ0EsUUFBTWUsVUFBVSxjQUFjM0IsT0FBT2EsT0FBUCxDQUFlLEtBQWYsRUFBc0I7QUFBQSxhQUFNRixLQUFLQyxVQUFMLENBQU47QUFBQSxLQUF0QixDQUE5QjtBQUNBLFFBQUksT0FBT00sT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNsQ0EsY0FBUXlNLElBQVIsQ0FBYWhNLE9BQWI7QUFDRDtBQUNELFFBQUk7QUFDRjtBQUNBO0FBQ0E7QUFDQSxZQUFNLElBQUl6QixLQUFKLENBQVV5QixPQUFWLENBQU47QUFDRCxLQUxELENBS0UsT0FBT0MsQ0FBUCxFQUFVLENBQUU7QUFDZixHQVpEOztBQWNBazZCLHVCQUFxQiw0QkFBUzM3QixTQUFULEVBQW9CSCxNQUFwQixFQUFxQztBQUN4RCxRQUFJQSxXQUFXQyxTQUFmLEVBQTBCO0FBQ3hCLFlBQU0sSUFBSUMsS0FBSixDQUNKLHlFQUNFLGtCQUZFLENBQU47QUFJRDtBQUNELFFBQUksQ0FBQ0MsU0FBTCxFQUFnQjtBQUFBLHlDQVBrQ1EsSUFPbEM7QUFQa0NBLFlBT2xDO0FBQUE7O0FBQ2RvN0IscUNBQWEvN0IsTUFBYixTQUF3QlcsSUFBeEI7QUFDRDtBQUNGLEdBVkQ7QUFXRDs7a0JBRWNtN0Isa0I7Ozs7Ozs7QUNuRGY7Ozs7Ozs7QUFPYTs7OztBQUViLElBQUlDLGVBQWUsd0JBQVcsQ0FBRSxDQUFoQzs7QUFFQSxJQUFJQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyxHQUFSLENBQTNCO0FBQ0EsTUFBSUMscUJBQXFCLEVBQXpCOztBQUVBTixpQkFBZSxzQkFBU08sSUFBVCxFQUFlO0FBQzVCLFFBQUkzNkIsVUFBVSxjQUFjMjZCLElBQTVCO0FBQ0EsUUFBSSxPQUFPcDdCLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbENBLGNBQVFSLEtBQVIsQ0FBY2lCLE9BQWQ7QUFDRDtBQUNELFFBQUk7QUFDRjtBQUNBO0FBQ0E7QUFDQSxZQUFNLElBQUl6QixLQUFKLENBQVV5QixPQUFWLENBQU47QUFDRCxLQUxELENBS0UsT0FBT0MsQ0FBUCxFQUFVLENBQUU7QUFDZixHQVhEO0FBWUQ7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0EsU0FBUzI2QixjQUFULENBQXdCQyxTQUF4QixFQUFtQ0MsTUFBbkMsRUFBMkNDLFFBQTNDLEVBQXFEdmQsYUFBckQsRUFBb0V3ZCxRQUFwRSxFQUE4RTtBQUM1RSxNQUFJWCxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsU0FBSyxJQUFJVSxZQUFULElBQXlCSixTQUF6QixFQUFvQztBQUNsQyxVQUFJQSxVQUFVdndCLGNBQVYsQ0FBeUIyd0IsWUFBekIsQ0FBSixFQUE0QztBQUMxQyxZQUFJbDhCLEtBQUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0Y7QUFDQTtBQUNBLGNBQUksT0FBTzg3QixVQUFVSSxZQUFWLENBQVAsS0FBbUMsVUFBdkMsRUFBbUQ7QUFDakQsZ0JBQUk5UyxNQUFNNXBCLE1BQ1IsQ0FBQ2lmLGlCQUFpQixhQUFsQixJQUFtQyxJQUFuQyxHQUEwQ3VkLFFBQTFDLEdBQXFELFNBQXJELEdBQWlFRSxZQUFqRSxHQUFnRixnQkFBaEYsR0FDQSw4RUFEQSxXQUN3RkosVUFBVUksWUFBVixDQUR4RixJQUNrSCxJQUYxRyxDQUFWO0FBSUE5UyxnQkFBSWhwQixJQUFKLEdBQVcscUJBQVg7QUFDQSxrQkFBTWdwQixHQUFOO0FBQ0Q7QUFDRHBwQixrQkFBUTg3QixVQUFVSSxZQUFWLEVBQXdCSCxNQUF4QixFQUFnQ0csWUFBaEMsRUFBOEN6ZCxhQUE5QyxFQUE2RHVkLFFBQTdELEVBQXVFLElBQXZFLEVBQTZFUCxvQkFBN0UsQ0FBUjtBQUNELFNBWkQsQ0FZRSxPQUFPVSxFQUFQLEVBQVc7QUFDWG44QixrQkFBUW04QixFQUFSO0FBQ0Q7QUFDRCxZQUFJbjhCLFNBQVMsRUFBRUEsaUJBQWlCUixLQUFuQixDQUFiLEVBQXdDO0FBQ3RDNjdCLHVCQUNFLENBQUM1YyxpQkFBaUIsYUFBbEIsSUFBbUMsMEJBQW5DLEdBQ0F1ZCxRQURBLEdBQ1csSUFEWCxHQUNrQkUsWUFEbEIsR0FDaUMsaUNBRGpDLEdBRUEsMkRBRkEsV0FFcUVsOEIsS0FGckUseUNBRXFFQSxLQUZyRSxLQUU2RSxJQUY3RSxHQUdBLGlFQUhBLEdBSUEsZ0VBSkEsR0FLQSxpQ0FORjtBQVNEO0FBQ0QsWUFBSUEsaUJBQWlCUixLQUFqQixJQUEwQixFQUFFUSxNQUFNaUIsT0FBTixJQUFpQjA2QixrQkFBbkIsQ0FBOUIsRUFBc0U7QUFDcEU7QUFDQTtBQUNBQSw2QkFBbUIzN0IsTUFBTWlCLE9BQXpCLElBQW9DLElBQXBDOztBQUVBLGNBQUlLLFFBQVEyNkIsV0FBV0EsVUFBWCxHQUF3QixFQUFwQzs7QUFFQVosdUJBQ0UsWUFBWVcsUUFBWixHQUF1QixTQUF2QixHQUFtQ2g4QixNQUFNaUIsT0FBekMsSUFBb0RLLFNBQVMsSUFBVCxHQUFnQkEsS0FBaEIsR0FBd0IsRUFBNUUsQ0FERjtBQUdEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ0ZCxPQUFPQyxPQUFQLEdBQWlCMGMsY0FBakIsQzs7Ozs7Ozs7Ozs7OztRQ2xEZ0JPLHFCLEdBQUFBLHFCO1FBMEJBQyx1QyxHQUFBQSx1QztRQWlDQUMsa0IsR0FBQUEsa0I7UUFTQUMsYyxHQUFBQSxjO1FBSUFDLGdCLEdBQUFBLGdCOztBQXZHaEI7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFaQTs7Ozs7Ozs7O0FBYUEsSUFBSUMsV0FBb0IsS0FBeEI7QUFDQSxJQUFJQyxjQUFxQixJQUF6Qjs7QUFFQTtBQUNBLElBQUlDLGtCQUEyQixLQUEvQjtBQUNBLElBQUlDLGVBQXNCLElBQTFCOztBQUVBLElBQU1DLFdBQVc7QUFDZkMsU0FEZSxtQkFDUDk4QixLQURPLEVBQ087QUFDcEJ5OEIsZUFBVyxJQUFYO0FBQ0FDLGtCQUFjMThCLEtBQWQ7QUFDRDtBQUpjLENBQWpCOztBQU9BOzs7Ozs7Ozs7Ozs7O0FBYU8sU0FBU284QixxQkFBVCxDQUNMaDhCLElBREssRUFFTDI4QixJQUZLLEVBR0xya0IsT0FISyxFQUlMaFosQ0FKSyxFQUtMQyxDQUxLLEVBTUxDLENBTkssRUFPTEMsQ0FQSyxFQVFMQyxDQVJLLEVBU0xDLENBVEssRUFVQztBQUNOMDhCLGFBQVcsS0FBWDtBQUNBQyxnQkFBYyxJQUFkO0FBQ0FNLHNDQUEwQmo4QixLQUExQixDQUFnQzg3QixRQUFoQyxFQUEwQ3J3QixTQUExQztBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVU8sU0FBUzZ2Qix1Q0FBVCxDQVNMajhCLElBVEssRUFVTDI4QixJQVZLLEVBV0xya0IsT0FYSyxFQVlMaFosQ0FaSyxFQWFMQyxDQWJLLEVBY0xDLENBZEssRUFlTEMsQ0FmSyxFQWdCTEMsQ0FoQkssRUFpQkxDLENBakJLLEVBa0JDO0FBQ05xOEIsd0JBQXNCcjdCLEtBQXRCLENBQTRCLElBQTVCLEVBQWtDeUwsU0FBbEM7QUFDQSxNQUFJaXdCLFFBQUosRUFBYztBQUNaLFFBQU16OEIsUUFBUXc4QixrQkFBZDtBQUNBLFFBQUksQ0FBQ0csZUFBTCxFQUFzQjtBQUNwQkEsd0JBQWtCLElBQWxCO0FBQ0FDLHFCQUFlNThCLEtBQWY7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7QUFJTyxTQUFTczhCLGtCQUFULEdBQThCO0FBQ25DLE1BQUlLLGVBQUosRUFBcUI7QUFDbkIsUUFBTTM4QixRQUFRNDhCLFlBQWQ7QUFDQUQsc0JBQWtCLEtBQWxCO0FBQ0FDLG1CQUFlLElBQWY7QUFDQSxVQUFNNThCLEtBQU47QUFDRDtBQUNGOztBQUVNLFNBQVN1OEIsY0FBVCxHQUEwQjtBQUMvQixTQUFPRSxRQUFQO0FBQ0Q7O0FBRU0sU0FBU0QsZ0JBQVQsR0FBNEI7QUFDakMsTUFBSUMsUUFBSixFQUFjO0FBQ1osUUFBTXo4QixRQUFRMDhCLFdBQWQ7QUFDQUQsZUFBVyxLQUFYO0FBQ0FDLGtCQUFjLElBQWQ7QUFDQSxXQUFPMThCLEtBQVA7QUFDRCxHQUxELE1BS087QUFDTCw2QkFDRSxLQURGLEVBRUUsdUVBQ0UsMkRBSEo7QUFLRDtBQUNGLEM7Ozs7Ozs7Ozs7Ozs7OztRQ3pHZXFVLFEsR0FBQUEsUTtRQUlBNG9CLGdCLEdBQUFBLGdCOzs7QUFQaEI7QUFDQTtBQUNBO0FBQ08sU0FBUzVvQixRQUFULENBQWtCb1AsS0FBbEIsRUFBZ0Q7QUFDckQsU0FBTyxLQUFNQSxLQUFiO0FBQ0QsQyxDQXRCRDs7Ozs7Ozs7O0FBd0JPLFNBQVN3WixnQkFBVCxDQUEwQnhaLEtBQTFCLEVBQXVEO0FBQzVELGlCQUFlQSxLQUFmLHlDQUFlQSxLQUFmO0FBQ0UsU0FBSyxTQUFMO0FBQ0EsU0FBSyxRQUFMO0FBQ0EsU0FBSyxRQUFMO0FBQ0EsU0FBSyxRQUFMO0FBQ0EsU0FBSyxXQUFMO0FBQ0UsYUFBT0EsS0FBUDtBQUNGO0FBQ0U7QUFDQSxhQUFPLEVBQVA7QUFUSjtBQVdELEM7Ozs7Ozs7QUNwQ0Q7Ozs7Ozs7OztBQVNhOzs7Ozs7OztBQUViO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHOzs7Ozs7Ozs7Ozs7UUNXZ0J5WixNLEdBQUFBLE07UUFJQXB3QixHLEdBQUFBLEc7UUFJQTZjLEcsR0FBQUEsRztRQUlBOWMsRyxHQUFBQSxHO0FBbENoQjs7Ozs7OztBQU9BOzs7Ozs7Ozs7O0FBVUE7Ozs7O0FBS08sU0FBU3F3QixNQUFULENBQWdCbmYsR0FBaEIsRUFBcUI7QUFDMUJBLE1BQUlvZixtQkFBSixHQUEwQjU5QixTQUExQjtBQUNEOztBQUVNLFNBQVN1TixHQUFULENBQWFpUixHQUFiLEVBQWtCO0FBQ3ZCLFNBQU9BLElBQUlvZixtQkFBWDtBQUNEOztBQUVNLFNBQVN4VCxHQUFULENBQWE1TCxHQUFiLEVBQWtCO0FBQ3ZCLFNBQU9BLElBQUlvZixtQkFBSixLQUE0QjU5QixTQUFuQztBQUNEOztBQUVNLFNBQVNzTixHQUFULENBQWFrUixHQUFiLEVBQWtCMEYsS0FBbEIsRUFBeUI7QUFDOUIxRixNQUFJb2YsbUJBQUosR0FBMEIxWixLQUExQjtBQUNELEM7Ozs7Ozs7Ozs7Ozs7O0FDekJEOzs7Ozs7QUFYQTs7Ozs7Ozs7O0FBaUJBLElBQU0yWixhQUF5QixFQUEvQjs7QUFFQSxJQUFJQyxtQkFBSjs7QUFFQSxJQUFJaCtCLElBQUosRUFBYTtBQUNYZytCLGVBQWEsRUFBYjtBQUNEOztBQUVELElBQUlwUixRQUFRLENBQUMsQ0FBYjs7QUFFQSxTQUFTcVIsWUFBVCxDQUF5QkMsWUFBekIsRUFBMEQ7QUFDeEQsU0FBTztBQUNMMTJCLGFBQVMwMkI7QUFESixHQUFQO0FBR0Q7O0FBRUQsU0FBU0MsT0FBVCxHQUE0QjtBQUMxQixTQUFPdlIsVUFBVSxDQUFDLENBQWxCO0FBQ0Q7O0FBRUQsU0FBU3hlLEdBQVQsQ0FBZ0Jnd0IsTUFBaEIsRUFBd0N0M0IsS0FBeEMsRUFBNEQ7QUFDMUQsTUFBSThsQixRQUFRLENBQVosRUFBZTtBQUNiLFFBQUk1c0IsSUFBSixFQUFhO0FBQ1gseUNBQW9CLEtBQXBCLEVBQTJCLGlCQUEzQjtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxNQUFJQSxJQUFKLEVBQWE7QUFDWCxRQUFJOEcsVUFBVWszQixXQUFXcFIsS0FBWCxDQUFkLEVBQWlDO0FBQy9CLHlDQUFvQixLQUFwQixFQUEyQiwwQkFBM0I7QUFDRDtBQUNGOztBQUVEd1IsU0FBTzUyQixPQUFQLEdBQWlCdTJCLFdBQVduUixLQUFYLENBQWpCOztBQUVBbVIsYUFBV25SLEtBQVgsSUFBb0IsSUFBcEI7O0FBRUEsTUFBSTVzQixJQUFKLEVBQWE7QUFDWGcrQixlQUFXcFIsS0FBWCxJQUFvQixJQUFwQjtBQUNEOztBQUVEQTtBQUNEOztBQUVELFNBQVN0ZSxJQUFULENBQWlCOHZCLE1BQWpCLEVBQXlDaGEsS0FBekMsRUFBbUR0ZCxLQUFuRCxFQUF1RTtBQUNyRThsQjs7QUFFQW1SLGFBQVduUixLQUFYLElBQW9Cd1IsT0FBTzUyQixPQUEzQjs7QUFFQSxNQUFJeEgsSUFBSixFQUFhO0FBQ1hnK0IsZUFBV3BSLEtBQVgsSUFBb0I5bEIsS0FBcEI7QUFDRDs7QUFFRHMzQixTQUFPNTJCLE9BQVAsR0FBaUI0YyxLQUFqQjtBQUNEOztBQUVELFNBQVNpYSxxQkFBVCxHQUFpQztBQUMvQixNQUFJcitCLElBQUosRUFBYTtBQUNYLFFBQUk0c0IsVUFBVSxDQUFDLENBQWYsRUFBa0I7QUFDaEIseUNBQ0UsS0FERixFQUVFLDREQUZGO0FBSUQ7QUFDRjtBQUNGOztBQUVELFNBQVMwUiw4QkFBVCxHQUEwQztBQUN4QyxNQUFJdCtCLElBQUosRUFBYTtBQUNYNHNCLFlBQVEsQ0FBQyxDQUFUO0FBQ0FtUixlQUFXNzhCLE1BQVgsR0FBb0IsQ0FBcEI7QUFDQTg4QixlQUFXOThCLE1BQVgsR0FBb0IsQ0FBcEI7QUFDRDtBQUNGOztRQUdDKzhCLFksR0FBQUEsWTtRQUNBRSxPLEdBQUFBLE87UUFDQS92QixHLEdBQUFBLEc7UUFDQUUsSSxHQUFBQSxJO1FBRUErdkIscUIsR0FBQUEscUI7UUFDQUMsOEIsR0FBQUEsOEI7Ozs7Ozs7Ozs7Ozs7UUM1RGNDLGUsR0FBQUEsZTtRQStDQUMsWSxHQUFBQSxZO1FBTUFDLGUsR0FBQUEsZTs7QUFqRmhCOzs7Ozs7QUFJQSxJQUFJQyxvQkFBb0IsSUFBeEIsQyxDQWhCQTs7Ozs7Ozs7O0FBaUJBLElBQUlDLHVCQUF1QixJQUEzQjtBQUNBLElBQUlDLGlCQUFpQixLQUFyQjs7QUFFQSxTQUFTQyxXQUFULENBQXFCakcsRUFBckIsRUFBeUI7QUFDdkIsU0FBTyxVQUFTa0csR0FBVCxFQUFjO0FBQ25CLFFBQUk7QUFDRixhQUFPbEcsR0FBR2tHLEdBQUgsQ0FBUDtBQUNELEtBRkQsQ0FFRSxPQUFPL1UsR0FBUCxFQUFZO0FBQ1osVUFBSS9wQixJQUFPQSxJQUFJLENBQUM0K0IsY0FBaEIsRUFBZ0M7QUFDOUJBLHlCQUFpQixJQUFqQjtBQUNBLDJDQUNFLEtBREYsRUFFRSx5Q0FGRixFQUdFN1UsR0FIRjtBQUtEO0FBQ0Y7QUFDRixHQWJEO0FBY0Q7O0FBRU0sSUFBTTJELGdEQUNYLE9BQU9xUiw4QkFBUCxLQUEwQyxXQURyQzs7QUFHQSxTQUFTUixlQUFULENBQXlCUyxTQUF6QixFQUFxRDtBQUMxRCxNQUFJLE9BQU9ELDhCQUFQLEtBQTBDLFdBQTlDLEVBQTJEO0FBQ3pEO0FBQ0EsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFNRSxPQUFPRiw4QkFBYjtBQUNBLE1BQUlFLEtBQUtDLFVBQVQsRUFBcUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFJLENBQUNELEtBQUtFLGFBQVYsRUFBeUI7QUFDdkIsUUFBSW4vQixJQUFKLEVBQWE7QUFDWCx5Q0FDRSxLQURGLEVBRUUsMEVBQ0UsbUVBREYsR0FFRSw4QkFKSjtBQU1EO0FBQ0Q7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNELE1BQUk7QUFDRixRQUFNby9CLGFBQWFILEtBQUtJLE1BQUwsQ0FBWUwsU0FBWixDQUFuQjtBQUNBO0FBQ0FOLHdCQUFvQkcsWUFBWTtBQUFBLGFBQzlCSSxLQUFLUCxpQkFBTCxDQUF1QlUsVUFBdkIsRUFBbUN0TixJQUFuQyxDQUQ4QjtBQUFBLEtBQVosQ0FBcEI7QUFHQTZNLDJCQUF1QkUsWUFBWTtBQUFBLGFBQ2pDSSxLQUFLTixvQkFBTCxDQUEwQlMsVUFBMUIsRUFBc0N0NEIsS0FBdEMsQ0FEaUM7QUFBQSxLQUFaLENBQXZCO0FBR0QsR0FURCxDQVNFLE9BQU9pakIsR0FBUCxFQUFZO0FBQ1o7QUFDQSxRQUFJL3BCLElBQUosRUFBYTtBQUNYLHlDQUNFLEtBREYsRUFFRSwwQ0FGRixFQUdFK3BCLEdBSEY7QUFLRDtBQUNGO0FBQ0Q7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTeVUsWUFBVCxDQUFzQjFNLElBQXRCLEVBQXVDO0FBQzVDLE1BQUksT0FBTzRNLGlCQUFQLEtBQTZCLFVBQWpDLEVBQTZDO0FBQzNDQSxzQkFBa0I1TSxJQUFsQjtBQUNEO0FBQ0Y7O0FBRU0sU0FBUzJNLGVBQVQsQ0FBeUIzM0IsS0FBekIsRUFBdUM7QUFDNUMsTUFBSSxPQUFPNjNCLG9CQUFQLEtBQWdDLFVBQXBDLEVBQWdEO0FBQzlDQSx5QkFBcUI3M0IsS0FBckI7QUFDRDtBQUNGLEM7Ozs7Ozs7Ozs7Ozs7OzhRQ2pHRDs7Ozs7Ozs7O1FBc0pnQnc0QixpQixHQUFBQSxpQjtRQTBxREFDLGdDLEdBQUFBLGdDOztBQWp6RGhCOzs7O0FBRUE7O0FBcUJBOztBQVVBOzs7O0FBQ0E7O0FBTUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBS0E7O0FBRUE7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBTUE7O0FBSUE7O0FBQ0E7O0FBT0E7O0FBQ0E7O0FBQ0E7O0FBU0E7O0FBTUE7O0FBUUE7O0FBSUE7Ozs7QUFRQSxJQUFNeFEsb0JBQW9CL3NCLCtCQUFxQitzQixpQkFBL0M7O0FBRUEsSUFBSXlRLG1CQUE0QixLQUFoQzs7QUFFQSxJQUFJQyw2QkFBSjtBQUNBLElBQUlDLG1EQUFKO0FBQ0EsSUFBSUMsdURBQUo7QUFDQSxJQUFJQyxpQ0FBSjtBQUNPLElBQUlDLDRFQUFKOztBQUVQLElBQUk3L0IsSUFBSixFQUFhO0FBQ1h5L0IseUJBQXVCLEVBQXZCO0FBQ0FDLCtDQUE2QyxFQUE3QztBQUNBQyxtREFBaUQsRUFBakQ7QUFDQUMsNkJBQTJCLEVBQTNCO0FBQ0EsVUFQU0MsNEJBT1Qsa0NBQStCLEtBQS9CO0FBQ0Q7O0FBRU0sU0FBU1AsaUJBQVQsQ0FDTDkzQixPQURLLEVBRUxKLGNBRkssRUFHTDA0QixZQUhLLEVBSUxqbkIsb0JBSkssRUFLTDtBQUNBLE1BQUlyUixZQUFZLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0FKLG1CQUFlcVUsS0FBZixHQUF1Qix1Q0FDckJyVSxjQURxQixFQUVyQixJQUZxQixFQUdyQjA0QixZQUhxQixFQUlyQmpuQixvQkFKcUIsQ0FBdkI7QUFNRCxHQVhELE1BV087QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBelIsbUJBQWVxVSxLQUFmLEdBQXVCLDJDQUNyQnJVLGNBRHFCLEVBRXJCSSxRQUFRaVUsS0FGYSxFQUdyQnFrQixZQUhxQixFQUlyQmpuQixvQkFKcUIsQ0FBdkI7QUFNRDtBQUNGOztBQUVELFNBQVNrbkIsK0JBQVQsQ0FDRXY0QixPQURGLEVBRUVKLGNBRkYsRUFHRTA0QixZQUhGLEVBSUVqbkIsb0JBSkYsRUFLRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXpSLGlCQUFlcVUsS0FBZixHQUF1QiwyQ0FDckJyVSxjQURxQixFQUVyQkksUUFBUWlVLEtBRmEsRUFHckIsSUFIcUIsRUFJckI1QyxvQkFKcUIsQ0FBdkI7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBelIsaUJBQWVxVSxLQUFmLEdBQXVCLDJDQUNyQnJVLGNBRHFCLEVBRXJCLElBRnFCLEVBR3JCMDRCLFlBSHFCLEVBSXJCam5CLG9CQUpxQixDQUF2QjtBQU1EOztBQUVELFNBQVNtbkIsZ0JBQVQsQ0FDRXg0QixPQURGLEVBRUVKLGNBRkYsRUFHRTRXLFNBSEYsRUFJRXhGLFNBSkYsRUFLRUssb0JBTEYsRUFNRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJN1ksSUFBSixFQUFhO0FBQ1gsUUFBSW9ILGVBQWV6QyxJQUFmLEtBQXdCeUMsZUFBZXVsQixXQUEzQyxFQUF3RDtBQUN0RDtBQUNBO0FBQ0EsVUFBTXNULGlCQUFpQmppQixVQUFVa2lCLFNBQWpDO0FBQ0EsVUFBSUQsY0FBSixFQUFvQjtBQUNsQixzQ0FDRUEsY0FERixFQUVFem5CLFNBRkYsRUFFYTtBQUNYLGNBSEYsRUFJRSxnQ0FBaUJ3RixTQUFqQixDQUpGLEVBS0V2WCw0Q0FMRjtBQU9EO0FBQ0Y7QUFDRjs7QUFFRCxNQUFNbEIsU0FBU3lZLFVBQVV6WSxNQUF6QjtBQUNBLE1BQU1zbkIsTUFBTXpsQixlQUFleWxCLEdBQTNCOztBQUVBO0FBQ0EsTUFBSWlULHFCQUFKO0FBQ0Esa0RBQXFCMTRCLGNBQXJCLEVBQXFDeVIsb0JBQXJDO0FBQ0EsTUFBSTdZLElBQUosRUFBYTtBQUNYK3VCLHNCQUFrQnZuQixPQUFsQixHQUE0QkosY0FBNUI7QUFDQSw0Q0FBZ0IsUUFBaEI7QUFDQTA0QixtQkFBZSxzQ0FDYnQ0QixPQURhLEVBRWJKLGNBRmEsRUFHYjdCLE1BSGEsRUFJYmlULFNBSmEsRUFLYnFVLEdBTGEsRUFNYmhVLG9CQU5hLENBQWY7QUFRQSxRQUNFeFcsa0RBQ0NDLCtEQUNDOEUsZUFBZXFSLElBQWYsR0FBc0I5SiwyQkFIMUIsRUFJRTtBQUNBO0FBQ0EsVUFBSXZILGVBQWUrUSxhQUFmLEtBQWlDLElBQXJDLEVBQTJDO0FBQ3pDMm5CLHVCQUFlLHNDQUNidDRCLE9BRGEsRUFFYkosY0FGYSxFQUdiN0IsTUFIYSxFQUliaVQsU0FKYSxFQUticVUsR0FMYSxFQU1iaFUsb0JBTmEsQ0FBZjtBQVFEO0FBQ0Y7QUFDRCw0Q0FBZ0IsSUFBaEI7QUFDRCxHQTdCRCxNQTZCTztBQUNMaW5CLG1CQUFlLHNDQUNidDRCLE9BRGEsRUFFYkosY0FGYSxFQUdiN0IsTUFIYSxFQUliaVQsU0FKYSxFQUticVUsR0FMYSxFQU1iaFUsb0JBTmEsQ0FBZjtBQVFEOztBQUVELE1BQUlyUixZQUFZLElBQVosSUFBb0IsQ0FBQ2c0QixnQkFBekIsRUFBMkM7QUFDekMsdUNBQWFoNEIsT0FBYixFQUFzQkosY0FBdEIsRUFBc0N5UixvQkFBdEM7QUFDQSxXQUFPc25CLDZCQUNMMzRCLE9BREssRUFFTEosY0FGSyxFQUdMeVIsb0JBSEssQ0FBUDtBQUtEOztBQUVEO0FBQ0F6UixpQkFBZXVSLFNBQWYsSUFBNEI5USxrQ0FBNUI7QUFDQXkzQixvQkFDRTkzQixPQURGLEVBRUVKLGNBRkYsRUFHRTA0QixZQUhGLEVBSUVqbkIsb0JBSkY7QUFNQSxTQUFPelIsZUFBZXFVLEtBQXRCO0FBQ0Q7O0FBRUQsU0FBUzJrQixtQkFBVCxDQUNFNTRCLE9BREYsRUFFRUosY0FGRixFQUdFNFcsU0FIRixFQUlFeEYsU0FKRixFQUtFVSxvQkFMRixFQU1FTCxvQkFORixFQU9nQjtBQUNkLE1BQUlyUixZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFFBQUk3QyxPQUFPcVosVUFBVXJaLElBQXJCO0FBQ0EsUUFDRSwyQ0FBMEJBLElBQTFCLEtBQ0FxWixVQUFVcWlCLE9BQVYsS0FBc0IsSUFEdEI7QUFFQTtBQUNBcmlCLGNBQVV3UCxZQUFWLEtBQTJCdHRCLFNBSjdCLEVBS0U7QUFDQTtBQUNBO0FBQ0E7QUFDQWtILHFCQUFleEMsR0FBZixHQUFxQlosa0NBQXJCO0FBQ0FvRCxxQkFBZXpDLElBQWYsR0FBc0JBLElBQXRCO0FBQ0EsVUFBSTNFLElBQUosRUFBYTtBQUNYc2dDLHVDQUErQmw1QixjQUEvQixFQUErQ3pDLElBQS9DO0FBQ0Q7QUFDRCxhQUFPNDdCLDBCQUNMLzRCLE9BREssRUFFTEosY0FGSyxFQUdMekMsSUFISyxFQUlMNlQsU0FKSyxFQUtMVSxvQkFMSyxFQU1MTCxvQkFOSyxDQUFQO0FBUUQ7QUFDRCxRQUFJN1ksSUFBSixFQUFhO0FBQ1gsVUFBTWlnQyxpQkFBaUJ0N0IsS0FBS3U3QixTQUE1QjtBQUNBLFVBQUlELGNBQUosRUFBb0I7QUFDbEI7QUFDQTtBQUNBLHNDQUNFQSxjQURGLEVBRUV6bkIsU0FGRixFQUVhO0FBQ1gsY0FIRixFQUlFLGdDQUFpQjdULElBQWpCLENBSkYsRUFLRThCLDRDQUxGO0FBT0Q7QUFDRjtBQUNELFFBQUlnVixRQUFRLDZDQUNWdUMsVUFBVXJaLElBREEsRUFFVixJQUZVLEVBR1Y2VCxTQUhVLEVBSVYsSUFKVSxFQUtWcFIsZUFBZXFSLElBTEwsRUFNVkksb0JBTlUsQ0FBWjtBQVFBNEMsVUFBTW9SLEdBQU4sR0FBWXpsQixlQUFleWxCLEdBQTNCO0FBQ0FwUixVQUFNbFUsTUFBTixHQUFlSCxjQUFmO0FBQ0FBLG1CQUFlcVUsS0FBZixHQUF1QkEsS0FBdkI7QUFDQSxXQUFPQSxLQUFQO0FBQ0Q7QUFDRCxNQUFJemIsSUFBSixFQUFhO0FBQ1gsUUFBTTJFLFFBQU9xWixVQUFVclosSUFBdkI7QUFDQSxRQUFNczdCLGtCQUFpQnQ3QixNQUFLdTdCLFNBQTVCO0FBQ0EsUUFBSUQsZUFBSixFQUFvQjtBQUNsQjtBQUNBO0FBQ0Esb0NBQ0VBLGVBREYsRUFFRXpuQixTQUZGLEVBRWE7QUFDWCxZQUhGLEVBSUUsZ0NBQWlCN1QsS0FBakIsQ0FKRixFQUtFOEIsNENBTEY7QUFPRDtBQUNGO0FBQ0QsTUFBSSs1QixlQUFpQmg1QixRQUFRaVUsS0FBN0IsQ0FwRWMsQ0FvRW9DO0FBQ2xELE1BQUl2Qyx1QkFBdUJMLG9CQUEzQixFQUFpRDtBQUMvQztBQUNBO0FBQ0EsUUFBTTRuQixZQUFZRCxhQUFhMVQsYUFBL0I7QUFDQTtBQUNBLFFBQUl1VCxVQUFVcmlCLFVBQVVxaUIsT0FBeEI7QUFDQUEsY0FBVUEsWUFBWSxJQUFaLEdBQW1CQSxPQUFuQixHQUE2Qkssc0JBQXZDO0FBQ0EsUUFBSUwsUUFBUUksU0FBUixFQUFtQmpvQixTQUFuQixLQUFpQ2hSLFFBQVFxbEIsR0FBUixLQUFnQnpsQixlQUFleWxCLEdBQXBFLEVBQXlFO0FBQ3ZFLGFBQU9zVCw2QkFDTDM0QixPQURLLEVBRUxKLGNBRkssRUFHTHlSLG9CQUhLLENBQVA7QUFLRDtBQUNGO0FBQ0Q7QUFDQXpSLGlCQUFldVIsU0FBZixJQUE0QjlRLGtDQUE1QjtBQUNBLE1BQUk4NEIsV0FBVyxzQ0FDYkgsWUFEYSxFQUViaG9CLFNBRmEsRUFHYkssb0JBSGEsQ0FBZjtBQUtBOG5CLFdBQVM5VCxHQUFULEdBQWV6bEIsZUFBZXlsQixHQUE5QjtBQUNBOFQsV0FBU3A1QixNQUFULEdBQWtCSCxjQUFsQjtBQUNBQSxpQkFBZXFVLEtBQWYsR0FBdUJrbEIsUUFBdkI7QUFDQSxTQUFPQSxRQUFQO0FBQ0Q7O0FBRUQsU0FBU0oseUJBQVQsQ0FDRS80QixPQURGLEVBRUVKLGNBRkYsRUFHRTRXLFNBSEYsRUFJRXhGLFNBSkYsRUFLRVUsb0JBTEYsRUFNRUwsb0JBTkYsRUFPZ0I7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsTUFBSTdZLElBQUosRUFBYTtBQUNYLFFBQUlvSCxlQUFlekMsSUFBZixLQUF3QnlDLGVBQWV1bEIsV0FBM0MsRUFBd0Q7QUFDdEQ7QUFDQTtBQUNBLFVBQUlpVSxnQkFBZ0J4NUIsZUFBZXVsQixXQUFuQztBQUNBLFVBQUlpVSxjQUFjejdCLFFBQWQsS0FBMkJNLDZCQUEvQixFQUFnRDtBQUM5QztBQUNBO0FBQ0E7QUFDQW03Qix3QkFBZ0IscURBQTRCQSxhQUE1QixDQUFoQjtBQUNEO0FBQ0QsVUFBTUMsaUJBQWlCRCxpQkFBa0JBLGFBQUQsQ0FBcUJWLFNBQTdEO0FBQ0EsVUFBSVcsY0FBSixFQUFvQjtBQUNsQixzQ0FDRUEsY0FERixFQUVFcm9CLFNBRkYsRUFFYTtBQUNYLGNBSEYsRUFJRSxnQ0FBaUJvb0IsYUFBakIsQ0FKRixFQUtFbjZCLDRDQUxGO0FBT0Q7QUFDRDtBQUNEO0FBQ0Y7QUFDRCxNQUFJZSxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFFBQU1pNUIsWUFBWWo1QixRQUFRc2xCLGFBQTFCO0FBQ0EsUUFDRSw0QkFBYTJULFNBQWIsRUFBd0Jqb0IsU0FBeEIsS0FDQWhSLFFBQVFxbEIsR0FBUixLQUFnQnpsQixlQUFleWxCLEdBRmpDLEVBR0U7QUFDQTJTLHlCQUFtQixLQUFuQjtBQUNBLFVBQUl0bUIsdUJBQXVCTCxvQkFBM0IsRUFBaUQ7QUFDL0MsZUFBT3NuQiw2QkFDTDM0QixPQURLLEVBRUxKLGNBRkssRUFHTHlSLG9CQUhLLENBQVA7QUFLRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPaW9CLHdCQUNMdDVCLE9BREssRUFFTEosY0FGSyxFQUdMNFcsU0FISyxFQUlMeEYsU0FKSyxFQUtMSyxvQkFMSyxDQUFQO0FBT0Q7O0FBRUQsU0FBU2tvQixjQUFULENBQ0V2NUIsT0FERixFQUVFSixjQUZGLEVBR0V5UixvQkFIRixFQUlFO0FBQ0EsTUFBTWluQixlQUFlMTRCLGVBQWVzbEIsWUFBcEM7QUFDQTRTLG9CQUNFOTNCLE9BREYsRUFFRUosY0FGRixFQUdFMDRCLFlBSEYsRUFJRWpuQixvQkFKRjtBQU1BLFNBQU96UixlQUFlcVUsS0FBdEI7QUFDRDs7QUFFRCxTQUFTdWxCLFVBQVQsQ0FDRXg1QixPQURGLEVBRUVKLGNBRkYsRUFHRXlSLG9CQUhGLEVBSUU7QUFDQSxNQUFNaW5CLGVBQWUxNEIsZUFBZXNsQixZQUFmLENBQTRCb0IsUUFBakQ7QUFDQXdSLG9CQUNFOTNCLE9BREYsRUFFRUosY0FGRixFQUdFMDRCLFlBSEYsRUFJRWpuQixvQkFKRjtBQU1BLFNBQU96UixlQUFlcVUsS0FBdEI7QUFDRDs7QUFFRCxTQUFTd2xCLGNBQVQsQ0FDRXo1QixPQURGLEVBRUVKLGNBRkYsRUFHRXlSLG9CQUhGLEVBSUU7QUFDQSxNQUFJcFcsc0NBQUosRUFBeUI7QUFDdkIyRSxtQkFBZXVSLFNBQWYsSUFBNEI1USwyQkFBNUI7QUFDRDtBQUNELE1BQU15USxZQUFZcFIsZUFBZXNsQixZQUFqQztBQUNBLE1BQU1vVCxlQUFldG5CLFVBQVVzVixRQUEvQjtBQUNBd1Isb0JBQ0U5M0IsT0FERixFQUVFSixjQUZGLEVBR0UwNEIsWUFIRixFQUlFam5CLG9CQUpGO0FBTUEsU0FBT3pSLGVBQWVxVSxLQUF0QjtBQUNEOztBQUVELFNBQVN5bEIsT0FBVCxDQUFpQjE1QixPQUFqQixFQUF3Q0osY0FBeEMsRUFBK0Q7QUFDN0QsTUFBTXlsQixNQUFNemxCLGVBQWV5bEIsR0FBM0I7QUFDQSxNQUNHcmxCLFlBQVksSUFBWixJQUFvQnFsQixRQUFRLElBQTdCLElBQ0NybEIsWUFBWSxJQUFaLElBQW9CQSxRQUFRcWxCLEdBQVIsS0FBZ0JBLEdBRnZDLEVBR0U7QUFDQTtBQUNBemxCLG1CQUFldVIsU0FBZixJQUE0QnRRLHdCQUE1QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3k0Qix1QkFBVCxDQUNFdDVCLE9BREYsRUFFRUosY0FGRixFQUdFNFcsU0FIRixFQUlFeEYsU0FKRixFQUtFSyxvQkFMRixFQU1FO0FBQ0EsTUFBSTdZLElBQUosRUFBYTtBQUNYLFFBQUlvSCxlQUFlekMsSUFBZixLQUF3QnlDLGVBQWV1bEIsV0FBM0MsRUFBd0Q7QUFDdEQ7QUFDQTtBQUNBLFVBQU1zVCxpQkFBaUJqaUIsVUFBVWtpQixTQUFqQztBQUNBLFVBQUlELGNBQUosRUFBb0I7QUFDbEIsc0NBQ0VBLGNBREYsRUFFRXpuQixTQUZGLEVBRWE7QUFDWCxjQUhGLEVBSUUsZ0NBQWlCd0YsU0FBakIsQ0FKRixFQUtFdlgsNENBTEY7QUFPRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBTTJYLGtCQUFrQiwyQ0FBbUJoWCxjQUFuQixFQUFtQzRXLFNBQW5DLEVBQThDLElBQTlDLENBQXhCO0FBQ0EsTUFBTTNFLFVBQVUseUNBQWlCalMsY0FBakIsRUFBaUNnWCxlQUFqQyxDQUFoQjs7QUFFQSxNQUFJMGhCLHFCQUFKO0FBQ0Esa0RBQXFCMTRCLGNBQXJCLEVBQXFDeVIsb0JBQXJDO0FBQ0EsTUFBSTdZLElBQUosRUFBYTtBQUNYK3VCLHNCQUFrQnZuQixPQUFsQixHQUE0QkosY0FBNUI7QUFDQSw0Q0FBZ0IsUUFBaEI7QUFDQTA0QixtQkFBZSxzQ0FDYnQ0QixPQURhLEVBRWJKLGNBRmEsRUFHYjRXLFNBSGEsRUFJYnhGLFNBSmEsRUFLYmEsT0FMYSxFQU1iUixvQkFOYSxDQUFmO0FBUUEsUUFDRXhXLGtEQUNDQywrREFDQzhFLGVBQWVxUixJQUFmLEdBQXNCOUosMkJBSDFCLEVBSUU7QUFDQTtBQUNBLFVBQUl2SCxlQUFlK1EsYUFBZixLQUFpQyxJQUFyQyxFQUEyQztBQUN6QzJuQix1QkFBZSxzQ0FDYnQ0QixPQURhLEVBRWJKLGNBRmEsRUFHYjRXLFNBSGEsRUFJYnhGLFNBSmEsRUFLYmEsT0FMYSxFQU1iUixvQkFOYSxDQUFmO0FBUUQ7QUFDRjtBQUNELDRDQUFnQixJQUFoQjtBQUNELEdBN0JELE1BNkJPO0FBQ0xpbkIsbUJBQWUsc0NBQ2J0NEIsT0FEYSxFQUViSixjQUZhLEVBR2I0VyxTQUhhLEVBSWJ4RixTQUphLEVBS2JhLE9BTGEsRUFNYlIsb0JBTmEsQ0FBZjtBQVFEOztBQUVELE1BQUlyUixZQUFZLElBQVosSUFBb0IsQ0FBQ2c0QixnQkFBekIsRUFBMkM7QUFDekMsdUNBQWFoNEIsT0FBYixFQUFzQkosY0FBdEIsRUFBc0N5UixvQkFBdEM7QUFDQSxXQUFPc25CLDZCQUNMMzRCLE9BREssRUFFTEosY0FGSyxFQUdMeVIsb0JBSEssQ0FBUDtBQUtEOztBQUVEO0FBQ0F6UixpQkFBZXVSLFNBQWYsSUFBNEI5USxrQ0FBNUI7QUFDQXkzQixvQkFDRTkzQixPQURGLEVBRUVKLGNBRkYsRUFHRTA0QixZQUhGLEVBSUVqbkIsb0JBSkY7QUFNQSxTQUFPelIsZUFBZXFVLEtBQXRCO0FBQ0Q7O0FBRUQsU0FBUzBsQixvQkFBVCxDQUNFMzVCLE9BREYsRUFFRUosY0FGRixFQUdFNFcsU0FIRixFQUlFeEYsU0FKRixFQUtFSyxvQkFMRixFQU1FO0FBQ0EsTUFBSTdZLElBQUosRUFBYTtBQUNYLFFBQUlvSCxlQUFlekMsSUFBZixLQUF3QnlDLGVBQWV1bEIsV0FBM0MsRUFBd0Q7QUFDdEQ7QUFDQTtBQUNBLFVBQU1zVCxpQkFBaUJqaUIsVUFBVWtpQixTQUFqQztBQUNBLFVBQUlELGNBQUosRUFBb0I7QUFDbEIsc0NBQ0VBLGNBREYsRUFFRXpuQixTQUZGLEVBRWE7QUFDWCxjQUhGLEVBSUUsZ0NBQWlCd0YsU0FBakIsQ0FKRixFQUtFdlgsNENBTEY7QUFPRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSTI2QixtQkFBSjtBQUNBLE1BQUksMENBQXdCcGpCLFNBQXhCLENBQUosRUFBd0M7QUFDdENvakIsaUJBQWEsSUFBYjtBQUNBLGdEQUEwQmg2QixjQUExQjtBQUNELEdBSEQsTUFHTztBQUNMZzZCLGlCQUFhLEtBQWI7QUFDRDtBQUNELGtEQUFxQmg2QixjQUFyQixFQUFxQ3lSLG9CQUFyQzs7QUFFQSxNQUFNMUssV0FBVy9HLGVBQWVtTyxTQUFoQztBQUNBLE1BQUk4ckIscUJBQUo7QUFDQSxNQUFJbHpCLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsUUFBSTNHLFlBQVksSUFBaEIsRUFBc0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsY0FBUXVRLFNBQVIsR0FBb0IsSUFBcEI7QUFDQTNRLHFCQUFlMlEsU0FBZixHQUEyQixJQUEzQjtBQUNBO0FBQ0EzUSxxQkFBZXVSLFNBQWYsSUFBNEI3USw4QkFBNUI7QUFDRDtBQUNEO0FBQ0EsMERBQ0VWLGNBREYsRUFFRTRXLFNBRkYsRUFHRXhGLFNBSEYsRUFJRUssb0JBSkY7QUFNQSxzREFDRXpSLGNBREYsRUFFRTRXLFNBRkYsRUFHRXhGLFNBSEYsRUFJRUssb0JBSkY7QUFNQXdvQixtQkFBZSxJQUFmO0FBQ0QsR0F6QkQsTUF5Qk8sSUFBSTc1QixZQUFZLElBQWhCLEVBQXNCO0FBQzNCO0FBQ0E2NUIsbUJBQWUsd0RBQ2JqNkIsY0FEYSxFQUViNFcsU0FGYSxFQUdieEYsU0FIYSxFQUliSyxvQkFKYSxDQUFmO0FBTUQsR0FSTSxNQVFBO0FBQ0x3b0IsbUJBQWUsbURBQ2I3NUIsT0FEYSxFQUViSixjQUZhLEVBR2I0VyxTQUhhLEVBSWJ4RixTQUphLEVBS2JLLG9CQUxhLENBQWY7QUFPRDtBQUNELE1BQU1vUyxpQkFBaUJxVyxxQkFDckI5NUIsT0FEcUIsRUFFckJKLGNBRnFCLEVBR3JCNFcsU0FIcUIsRUFJckJxakIsWUFKcUIsRUFLckJELFVBTHFCLEVBTXJCdm9CLG9CQU5xQixDQUF2QjtBQVFBLE1BQUk3WSxJQUFKLEVBQWE7QUFDWCxRQUFJc1YsT0FBT2xPLGVBQWVtTyxTQUExQjtBQUNBLFFBQUlELEtBQUtFLEtBQUwsS0FBZWdELFNBQW5CLEVBQThCO0FBQzVCLDZCQUNFcW5CLDRCQURGLEVBRUUsMkVBQ0UsdURBSEosRUFJRSxnQ0FBaUJ6NEIsZUFBZXpDLElBQWhDLEtBQXlDLGFBSjNDO0FBTUEsY0Fwa0JLazdCLDRCQW9rQkwsa0NBQStCLElBQS9CO0FBQ0Q7QUFDRjtBQUNELFNBQU81VSxjQUFQO0FBQ0Q7O0FBRUQsU0FBU3FXLG9CQUFULENBQ0U5NUIsT0FERixFQUVFSixjQUZGLEVBR0U0VyxTQUhGLEVBSUVxakIsWUFKRixFQUtFRCxVQUxGLEVBTUV2b0Isb0JBTkYsRUFPRTtBQUNBO0FBQ0Fxb0IsVUFBUTE1QixPQUFSLEVBQWlCSixjQUFqQjs7QUFFQSxNQUFNbTZCLGtCQUFrQixDQUFDbjZCLGVBQWV1UixTQUFmLEdBQTJCdlEsK0JBQTVCLE1BQTRDUiw2QkFBcEU7O0FBRUEsTUFBSSxDQUFDeTVCLFlBQUQsSUFBaUIsQ0FBQ0UsZUFBdEIsRUFBdUM7QUFDckM7QUFDQSxRQUFJSCxVQUFKLEVBQWdCO0FBQ2Qsd0RBQTBCaDZCLGNBQTFCLEVBQTBDNFcsU0FBMUMsRUFBcUQsS0FBckQ7QUFDRDs7QUFFRCxXQUFPbWlCLDZCQUNMMzRCLE9BREssRUFFTEosY0FGSyxFQUdMeVIsb0JBSEssQ0FBUDtBQUtEOztBQUVELE1BQU0xSyxXQUFXL0csZUFBZW1PLFNBQWhDOztBQUVBO0FBQ0F3WixvQkFBa0J2bkIsT0FBbEIsR0FBNEJKLGNBQTVCO0FBQ0EsTUFBSTA0QixxQkFBSjtBQUNBLE1BQ0V5QixtQkFDQSxPQUFPdmpCLFVBQVU4WSx3QkFBakIsS0FBOEMsVUFGaEQsRUFHRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWdKLG1CQUFlLElBQWY7O0FBRUEsUUFBSXI5QixzQ0FBSixFQUF5QjtBQUN2QiwwREFBMkIyRSxjQUEzQjtBQUNEO0FBQ0YsR0FkRCxNQWNPO0FBQ0wsUUFBSXBILElBQUosRUFBYTtBQUNYLDhDQUFnQixRQUFoQjtBQUNBOC9CLHFCQUFlM3hCLFNBQVM1SSxNQUFULEVBQWY7QUFDQSxVQUNFbEQsa0RBQ0NDLCtEQUNDOEUsZUFBZXFSLElBQWYsR0FBc0I5SiwyQkFIMUIsRUFJRTtBQUNBUixpQkFBUzVJLE1BQVQ7QUFDRDtBQUNELDhDQUFnQixJQUFoQjtBQUNELEtBWEQsTUFXTztBQUNMdTZCLHFCQUFlM3hCLFNBQVM1SSxNQUFULEVBQWY7QUFDRDtBQUNGOztBQUVEO0FBQ0E2QixpQkFBZXVSLFNBQWYsSUFBNEI5USxrQ0FBNUI7QUFDQSxNQUFJTCxZQUFZLElBQVosSUFBb0IrNUIsZUFBeEIsRUFBeUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQXhCLG9DQUNFdjRCLE9BREYsRUFFRUosY0FGRixFQUdFMDRCLFlBSEYsRUFJRWpuQixvQkFKRjtBQU1ELEdBWEQsTUFXTztBQUNMeW1CLHNCQUNFOTNCLE9BREYsRUFFRUosY0FGRixFQUdFMDRCLFlBSEYsRUFJRWpuQixvQkFKRjtBQU1EOztBQUVEO0FBQ0E7QUFDQXpSLGlCQUFlK1EsYUFBZixHQUErQmhLLFNBQVNxekIsS0FBeEM7O0FBRUE7QUFDQSxNQUFJSixVQUFKLEVBQWdCO0FBQ2Qsc0RBQTBCaDZCLGNBQTFCLEVBQTBDNFcsU0FBMUMsRUFBcUQsSUFBckQ7QUFDRDs7QUFFRCxTQUFPNVcsZUFBZXFVLEtBQXRCO0FBQ0Q7O0FBRUQsU0FBU2dtQixtQkFBVCxDQUE2QnI2QixjQUE3QixFQUE2QztBQUMzQyxNQUFNMHFCLE9BQVExcUIsZUFBZW1PLFNBQTdCO0FBQ0EsTUFBSXVjLEtBQUs0UCxjQUFULEVBQXlCO0FBQ3ZCLHNEQUNFdDZCLGNBREYsRUFFRTBxQixLQUFLNFAsY0FGUCxFQUdFNVAsS0FBSzRQLGNBQUwsS0FBd0I1UCxLQUFLelksT0FIL0I7QUFLRCxHQU5ELE1BTU8sSUFBSXlZLEtBQUt6WSxPQUFULEVBQWtCO0FBQ3ZCO0FBQ0Esc0RBQTBCalMsY0FBMUIsRUFBMEMwcUIsS0FBS3pZLE9BQS9DLEVBQXdELEtBQXhEO0FBQ0Q7QUFDRCxnREFBa0JqUyxjQUFsQixFQUFrQzBxQixLQUFLcEQsYUFBdkM7QUFDRDs7QUFFRCxTQUFTaVQsY0FBVCxDQUF3Qm42QixPQUF4QixFQUFpQ0osY0FBakMsRUFBaUR5UixvQkFBakQsRUFBdUU7QUFDckU0b0Isc0JBQW9CcjZCLGNBQXBCO0FBQ0EsTUFBTThRLGNBQWM5USxlQUFlOFEsV0FBbkM7QUFDQSwyQkFDRUEsZ0JBQWdCLElBRGxCLEVBRUUsc0VBQ0Usb0VBREYsR0FFRSxnQkFKSjtBQU1BLE1BQU1NLFlBQVlwUixlQUFlc2xCLFlBQWpDO0FBQ0EsTUFBTW5VLFlBQVluUixlQUFlK1EsYUFBakM7QUFDQSxNQUFNeXBCLGVBQWVycEIsY0FBYyxJQUFkLEdBQXFCQSxVQUFVMlYsT0FBL0IsR0FBeUMsSUFBOUQ7QUFDQSw0Q0FDRTltQixjQURGLEVBRUU4USxXQUZGLEVBR0VNLFNBSEYsRUFJRSxJQUpGLEVBS0VLLG9CQUxGO0FBT0EsTUFBTUgsWUFBWXRSLGVBQWUrUSxhQUFqQztBQUNBO0FBQ0E7QUFDQSxNQUFNMm5CLGVBQWVwbkIsVUFBVXdWLE9BQS9CO0FBQ0EsTUFBSTRSLGlCQUFpQjhCLFlBQXJCLEVBQW1DO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFdBQU96Qiw2QkFDTDM0QixPQURLLEVBRUxKLGNBRkssRUFHTHlSLG9CQUhLLENBQVA7QUFLRDtBQUNELE1BQU1pWixPQUFrQjFxQixlQUFlbU8sU0FBdkM7QUFDQSxNQUNFLENBQUMvTixZQUFZLElBQVosSUFBb0JBLFFBQVFpVSxLQUFSLEtBQWtCLElBQXZDLEtBQ0FxVyxLQUFLK1AsT0FETCxJQUVBLHFEQUFvQno2QixjQUFwQixDQUhGLEVBSUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxtQkFBZXVSLFNBQWYsSUFBNEI3USw4QkFBNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0FWLG1CQUFlcVUsS0FBZixHQUF1Qix1Q0FDckJyVSxjQURxQixFQUVyQixJQUZxQixFQUdyQjA0QixZQUhxQixFQUlyQmpuQixvQkFKcUIsQ0FBdkI7QUFNRCxHQXpCRCxNQXlCTztBQUNMO0FBQ0E7QUFDQXltQixzQkFDRTkzQixPQURGLEVBRUVKLGNBRkYsRUFHRTA0QixZQUhGLEVBSUVqbkIsb0JBSkY7QUFNQTtBQUNEO0FBQ0QsU0FBT3pSLGVBQWVxVSxLQUF0QjtBQUNEOztBQUVELFNBQVNxbUIsbUJBQVQsQ0FBNkJ0NkIsT0FBN0IsRUFBc0NKLGNBQXRDLEVBQXNEeVIsb0JBQXRELEVBQTRFO0FBQzFFLDhDQUFnQnpSLGNBQWhCOztBQUVBLE1BQUlJLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsc0VBQWlDSixjQUFqQztBQUNEOztBQUVELE1BQU16QyxPQUFPeUMsZUFBZXpDLElBQTVCO0FBQ0EsTUFBTTZULFlBQVlwUixlQUFlc2xCLFlBQWpDO0FBQ0EsTUFBTStULFlBQVlqNUIsWUFBWSxJQUFaLEdBQW1CQSxRQUFRc2xCLGFBQTNCLEdBQTJDLElBQTdEOztBQUVBLE1BQUlnVCxlQUFldG5CLFVBQVVzVixRQUE3QjtBQUNBLE1BQU1pVSxvQkFBb0IsZ0RBQXFCcDlCLElBQXJCLEVBQTJCNlQsU0FBM0IsQ0FBMUI7O0FBRUEsTUFBSXVwQixpQkFBSixFQUF1QjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBakMsbUJBQWUsSUFBZjtBQUNELEdBTkQsTUFNTyxJQUFJVyxjQUFjLElBQWQsSUFBc0IsZ0RBQXFCOTdCLElBQXJCLEVBQTJCODdCLFNBQTNCLENBQTFCLEVBQWlFO0FBQ3RFO0FBQ0E7QUFDQXI1QixtQkFBZXVSLFNBQWYsSUFBNEJ6USxpQ0FBNUI7QUFDRDs7QUFFRGc1QixVQUFRMTVCLE9BQVIsRUFBaUJKLGNBQWpCOztBQUVBO0FBQ0EsTUFDRXlSLHlCQUF5QjVQLCtCQUF6QixJQUNBN0IsZUFBZXFSLElBQWYsR0FBc0IvSiwrQkFEdEIsSUFFQSxxREFBMEIvSixJQUExQixFQUFnQzZULFNBQWhDLENBSEYsRUFJRTtBQUNBO0FBQ0FwUixtQkFBZW1DLGNBQWYsR0FBZ0NuQyxlQUFlb1UsbUJBQWYsR0FBcUN2UywrQkFBckU7QUFDQSxXQUFPLElBQVA7QUFDRDs7QUFFRHEyQixvQkFDRTkzQixPQURGLEVBRUVKLGNBRkYsRUFHRTA0QixZQUhGLEVBSUVqbkIsb0JBSkY7QUFNQSxTQUFPelIsZUFBZXFVLEtBQXRCO0FBQ0Q7O0FBRUQsU0FBU3VtQixjQUFULENBQXdCeDZCLE9BQXhCLEVBQWlDSixjQUFqQyxFQUFpRDtBQUMvQyxNQUFJSSxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLHNFQUFpQ0osY0FBakM7QUFDRDtBQUNEO0FBQ0E7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTNjZCLGtCQUFULENBQ0VDLFFBREYsRUFFRTk2QixjQUZGLEVBR0V1bEIsV0FIRixFQUlFelQsb0JBSkYsRUFLRUwsb0JBTEYsRUFNRTtBQUNBLE1BQUlxcEIsYUFBYSxJQUFqQixFQUF1QjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxhQUFTbnFCLFNBQVQsR0FBcUIsSUFBckI7QUFDQTNRLG1CQUFlMlEsU0FBZixHQUEyQixJQUEzQjtBQUNBO0FBQ0EzUSxtQkFBZXVSLFNBQWYsSUFBNEI3USw4QkFBNUI7QUFDRDs7QUFFRCxNQUFNME4sUUFBUXBPLGVBQWVzbEIsWUFBN0I7QUFDQTtBQUNBO0FBQ0EsNENBQWdCdGxCLGNBQWhCO0FBQ0EsTUFBSTRXLFlBQVksb0RBQXNCMk8sV0FBdEIsQ0FBaEI7QUFDQTtBQUNBdmxCLGlCQUFlekMsSUFBZixHQUFzQnFaLFNBQXRCO0FBQ0EsTUFBTW1rQixjQUFlLzZCLGVBQWV4QyxHQUFmLEdBQXFCLHlDQUF3Qm9aLFNBQXhCLENBQTFDO0FBQ0EsMkNBQWU1VyxjQUFmO0FBQ0EsTUFBTWc3QixnQkFBZ0Isa0RBQW9CcGtCLFNBQXBCLEVBQStCeEksS0FBL0IsQ0FBdEI7QUFDQSxNQUFJaUcsY0FBSjtBQUNBLFVBQVEwbUIsV0FBUjtBQUNFLFNBQUtsL0IsZ0NBQUw7QUFBd0I7QUFDdEIsWUFBSWpELElBQUosRUFBYTtBQUNYc2dDLHlDQUErQmw1QixjQUEvQixFQUErQzRXLFNBQS9DO0FBQ0Q7QUFDRHZDLGdCQUFRcWxCLHdCQUNOLElBRE0sRUFFTjE1QixjQUZNLEVBR040VyxTQUhNLEVBSU5va0IsYUFKTSxFQUtOdnBCLG9CQUxNLENBQVI7QUFPQTtBQUNEO0FBQ0QsU0FBSzNWLDZCQUFMO0FBQXFCO0FBQ25CdVksZ0JBQVEwbEIscUJBQ04sSUFETSxFQUVOLzVCLGNBRk0sRUFHTjRXLFNBSE0sRUFJTm9rQixhQUpNLEVBS052cEIsb0JBTE0sQ0FBUjtBQU9BO0FBQ0Q7QUFDRCxTQUFLalYseUJBQUw7QUFBaUI7QUFDZjZYLGdCQUFRdWtCLGlCQUNOLElBRE0sRUFFTjU0QixjQUZNLEVBR040VyxTQUhNLEVBSU5va0IsYUFKTSxFQUtOdnBCLG9CQUxNLENBQVI7QUFPQTtBQUNEO0FBQ0QsU0FBSzlVLDRCQUFMO0FBQW9CO0FBQ2xCLFlBQUkvRCxJQUFKLEVBQWE7QUFDWCxjQUFJb0gsZUFBZXpDLElBQWYsS0FBd0J5QyxlQUFldWxCLFdBQTNDLEVBQXdEO0FBQ3RELGdCQUFNa1UsaUJBQWlCN2lCLFVBQVVraUIsU0FBakM7QUFDQSxnQkFBSVcsY0FBSixFQUFvQjtBQUNsQiw0Q0FDRUEsY0FERixFQUVFdUIsYUFGRixFQUVpQjtBQUNmLG9CQUhGLEVBSUUsZ0NBQWlCcGtCLFNBQWpCLENBSkYsRUFLRXZYLDRDQUxGO0FBT0Q7QUFDRjtBQUNGO0FBQ0RnVixnQkFBUTJrQixvQkFDTixJQURNLEVBRU5oNUIsY0FGTSxFQUdONFcsU0FITSxFQUlOLGtEQUFvQkEsVUFBVXJaLElBQTlCLEVBQW9DeTlCLGFBQXBDLENBSk0sRUFJOEM7QUFDcERscEIsNEJBTE0sRUFNTkwsb0JBTk0sQ0FBUjtBQVFBO0FBQ0Q7QUFDRDtBQUFTO0FBQ1AsWUFBSXdwQixPQUFPLEVBQVg7QUFDQSxZQUFJcmlDLElBQUosRUFBYTtBQUNYLGNBQ0VnZSxjQUFjLElBQWQsSUFDQSxRQUFPQSxTQUFQLHlDQUFPQSxTQUFQLE9BQXFCLFFBRHJCLElBRUFBLFVBQVU3WSxRQUFWLEtBQXVCTSw2QkFIekIsRUFJRTtBQUNBNDhCLG1CQUFPLDJEQUFQO0FBQ0Q7QUFDRjtBQUNEO0FBQ0E7QUFDQTtBQUNBLGlDQUNFLEtBREYsRUFFRSx1RUFDRSwwREFISixFQUlFcmtCLFNBSkYsRUFLRXFrQixJQUxGO0FBT0Q7QUFoRkg7QUFrRkEsU0FBTzVtQixLQUFQO0FBQ0Q7O0FBRUQsU0FBUzZtQiw2QkFBVCxDQUNFSixRQURGLEVBRUU5NkIsY0FGRixFQUdFNFcsU0FIRixFQUlFeEYsU0FKRixFQUtFSyxvQkFMRixFQU1FO0FBQ0EsTUFBSXFwQixhQUFhLElBQWpCLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLGFBQVNucUIsU0FBVCxHQUFxQixJQUFyQjtBQUNBM1EsbUJBQWUyUSxTQUFmLEdBQTJCLElBQTNCO0FBQ0E7QUFDQTNRLG1CQUFldVIsU0FBZixJQUE0QjdRLDhCQUE1QjtBQUNEOztBQUVEO0FBQ0FWLGlCQUFleEMsR0FBZixHQUFxQjFCLDZCQUFyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFJaytCLG1CQUFKO0FBQ0EsTUFBSSwwQ0FBd0JwakIsU0FBeEIsQ0FBSixFQUF3QztBQUN0Q29qQixpQkFBYSxJQUFiO0FBQ0EsZ0RBQTBCaDZCLGNBQTFCO0FBQ0QsR0FIRCxNQUdPO0FBQ0xnNkIsaUJBQWEsS0FBYjtBQUNEO0FBQ0Qsa0RBQXFCaDZCLGNBQXJCLEVBQXFDeVIsb0JBQXJDOztBQUVBLHdEQUNFelIsY0FERixFQUVFNFcsU0FGRixFQUdFeEYsU0FIRixFQUlFSyxvQkFKRjtBQU1BLG9EQUNFelIsY0FERixFQUVFNFcsU0FGRixFQUdFeEYsU0FIRixFQUlFSyxvQkFKRjs7QUFPQSxTQUFPeW9CLHFCQUNMLElBREssRUFFTGw2QixjQUZLLEVBR0w0VyxTQUhLLEVBSUwsSUFKSyxFQUtMb2pCLFVBTEssRUFNTHZvQixvQkFOSyxDQUFQO0FBUUQ7O0FBRUQsU0FBUzBwQiwyQkFBVCxDQUNFTCxRQURGLEVBRUU5NkIsY0FGRixFQUdFNFcsU0FIRixFQUlFbkYsb0JBSkYsRUFLRTtBQUNBLE1BQUlxcEIsYUFBYSxJQUFqQixFQUF1QjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxhQUFTbnFCLFNBQVQsR0FBcUIsSUFBckI7QUFDQTNRLG1CQUFlMlEsU0FBZixHQUEyQixJQUEzQjtBQUNBO0FBQ0EzUSxtQkFBZXVSLFNBQWYsSUFBNEI3USw4QkFBNUI7QUFDRDs7QUFFRCxNQUFNME4sUUFBUXBPLGVBQWVzbEIsWUFBN0I7QUFDQSxNQUFNdE8sa0JBQWtCLDJDQUFtQmhYLGNBQW5CLEVBQW1DNFcsU0FBbkMsRUFBOEMsS0FBOUMsQ0FBeEI7QUFDQSxNQUFNM0UsVUFBVSx5Q0FBaUJqUyxjQUFqQixFQUFpQ2dYLGVBQWpDLENBQWhCOztBQUVBLGtEQUFxQmhYLGNBQXJCLEVBQXFDeVIsb0JBQXJDOztBQUVBLE1BQUl1TCxjQUFKOztBQUVBLE1BQUlwa0IsSUFBSixFQUFhO0FBQ1gsUUFDRWdlLFVBQVV2YyxTQUFWLElBQ0EsT0FBT3VjLFVBQVV2YyxTQUFWLENBQW9COEQsTUFBM0IsS0FBc0MsVUFGeEMsRUFHRTtBQUNBLFVBQU02WixnQkFBZ0IsZ0NBQWlCcEIsU0FBakIsS0FBK0IsU0FBckQ7O0FBRUEsVUFBSSxDQUFDeWhCLHFCQUFxQnJnQixhQUFyQixDQUFMLEVBQTBDO0FBQ3hDLDJDQUNFLEtBREYsRUFFRSwrRkFDRSw4RUFISixFQUlFQSxhQUpGLEVBS0VBLGFBTEY7QUFPQXFnQiw2QkFBcUJyZ0IsYUFBckIsSUFBc0MsSUFBdEM7QUFDRDtBQUNGOztBQUVELFFBQUloWSxlQUFlcVIsSUFBZixHQUFzQjlKLDJCQUExQixFQUFzQztBQUNwQ3VpQix3Q0FBd0JzUiwwQkFBeEIsQ0FBbURwN0IsY0FBbkQsRUFBbUUsSUFBbkU7QUFDRDs7QUFFRDJuQixzQkFBa0J2bkIsT0FBbEIsR0FBNEJKLGNBQTVCO0FBQ0FnZCxZQUFRLHNDQUNOLElBRE0sRUFFTmhkLGNBRk0sRUFHTjRXLFNBSE0sRUFJTnhJLEtBSk0sRUFLTjZELE9BTE0sRUFNTlIsb0JBTk0sQ0FBUjtBQVFELEdBaENELE1BZ0NPO0FBQ0x1TCxZQUFRLHNDQUNOLElBRE0sRUFFTmhkLGNBRk0sRUFHTjRXLFNBSE0sRUFJTnhJLEtBSk0sRUFLTjZELE9BTE0sRUFNTlIsb0JBTk0sQ0FBUjtBQVFEO0FBQ0Q7QUFDQXpSLGlCQUFldVIsU0FBZixJQUE0QjlRLGtDQUE1Qjs7QUFFQSxNQUNFLFFBQU91YyxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQWpCLElBQ0FBLFVBQVUsSUFEVixJQUVBLE9BQU9BLE1BQU03ZSxNQUFiLEtBQXdCLFVBRnhCLElBR0E2ZSxNQUFNamYsUUFBTixLQUFtQmpGLFNBSnJCLEVBS0U7QUFDQTtBQUNBa0gsbUJBQWV4QyxHQUFmLEdBQXFCMUIsNkJBQXJCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBSWsrQixhQUFhLEtBQWpCO0FBQ0EsUUFBSSwwQ0FBd0JwakIsU0FBeEIsQ0FBSixFQUF3QztBQUN0Q29qQixtQkFBYSxJQUFiO0FBQ0Esa0RBQTBCaDZCLGNBQTFCO0FBQ0QsS0FIRCxNQUdPO0FBQ0xnNkIsbUJBQWEsS0FBYjtBQUNEOztBQUVEaDZCLG1CQUFlK1EsYUFBZixHQUNFaU0sTUFBTW9kLEtBQU4sS0FBZ0IsSUFBaEIsSUFBd0JwZCxNQUFNb2QsS0FBTixLQUFnQnRoQyxTQUF4QyxHQUFvRGtrQixNQUFNb2QsS0FBMUQsR0FBa0UsSUFEcEU7O0FBR0EsUUFBTWlCLDJCQUEyQnprQixVQUFVeWtCLHdCQUEzQztBQUNBLFFBQUksT0FBT0Esd0JBQVAsS0FBb0MsVUFBeEMsRUFBb0Q7QUFDbEQsZ0VBQ0VyN0IsY0FERixFQUVFNFcsU0FGRixFQUdFeWtCLHdCQUhGLEVBSUVqdEIsS0FKRjtBQU1EOztBQUVELHNEQUFtQnBPLGNBQW5CLEVBQW1DZ2QsS0FBbkM7QUFDQSxzREFBbUJoZCxjQUFuQixFQUFtQzRXLFNBQW5DLEVBQThDeEksS0FBOUMsRUFBcURxRCxvQkFBckQ7QUFDQSxXQUFPeW9CLHFCQUNMLElBREssRUFFTGw2QixjQUZLLEVBR0w0VyxTQUhLLEVBSUwsSUFKSyxFQUtMb2pCLFVBTEssRUFNTHZvQixvQkFOSyxDQUFQO0FBUUQsR0E5Q0QsTUE4Q087QUFDTDtBQUNBelIsbUJBQWV4QyxHQUFmLEdBQXFCM0IsZ0NBQXJCO0FBQ0EsUUFBSWpELElBQUosRUFBYTtBQUNYLFVBQ0VxQyxrREFDQ0MsK0RBQ0M4RSxlQUFlcVIsSUFBZixHQUFzQjlKLDJCQUgxQixFQUlFO0FBQ0E7QUFDQSxZQUFJdkgsZUFBZStRLGFBQWYsS0FBaUMsSUFBckMsRUFBMkM7QUFDekNpTSxrQkFBUSxzQ0FDTixJQURNLEVBRU5oZCxjQUZNLEVBR040VyxTQUhNLEVBSU54SSxLQUpNLEVBS042RCxPQUxNLEVBTU5SLG9CQU5NLENBQVI7QUFRRDtBQUNGO0FBQ0Y7QUFDRHltQixzQkFBa0IsSUFBbEIsRUFBd0JsNEIsY0FBeEIsRUFBd0NnZCxLQUF4QyxFQUErQ3ZMLG9CQUEvQztBQUNBLFFBQUk3WSxJQUFKLEVBQWE7QUFDWHNnQyxxQ0FBK0JsNUIsY0FBL0IsRUFBK0M0VyxTQUEvQztBQUNEO0FBQ0QsV0FBTzVXLGVBQWVxVSxLQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUzZrQiw4QkFBVCxDQUF3Q2w1QixjQUF4QyxFQUErRDRXLFNBQS9ELEVBQStFO0FBQzdFLE1BQUlBLFNBQUosRUFBZTtBQUNiLHVDQUNFLENBQUNBLFVBQVVZLGlCQURiLEVBRUUsdUVBRkYsRUFHRVosVUFBVXZaLFdBQVYsSUFBeUJ1WixVQUFVamQsSUFBbkMsSUFBMkMsV0FIN0M7QUFLRDtBQUNELE1BQUlxRyxlQUFleWxCLEdBQWYsS0FBdUIsSUFBM0IsRUFBaUM7QUFDL0IsUUFBSXhsQixPQUFPLEVBQVg7QUFDQSxRQUFNRixZQUFZLDZEQUFsQjtBQUNBLFFBQUlBLFNBQUosRUFBZTtBQUNiRSxjQUFRLHFDQUFxQ0YsU0FBckMsR0FBaUQsSUFBekQ7QUFDRDs7QUFFRCxRQUFJdTdCLGFBQWF2N0IsYUFBYUMsZUFBZWlqQixRQUE1QixJQUF3QyxFQUF6RDtBQUNBLFFBQU1zWSxjQUFjdjdCLGVBQWVGLFlBQW5DO0FBQ0EsUUFBSXk3QixXQUFKLEVBQWlCO0FBQ2ZELG1CQUFhQyxZQUFZQyxRQUFaLEdBQXVCLEdBQXZCLEdBQTZCRCxZQUFZRSxVQUF0RDtBQUNEO0FBQ0QsUUFBSSxDQUFDakQseUJBQXlCOEMsVUFBekIsQ0FBTCxFQUEyQztBQUN6QzlDLCtCQUF5QjhDLFVBQXpCLElBQXVDLElBQXZDO0FBQ0EsNkJBQ0UsS0FERixFQUVFLCtDQUNFLHlDQURGLEdBRUUsMkNBSkosRUFLRXI3QixJQUxGO0FBT0Q7QUFDRjs7QUFFRCxNQUFJLE9BQU8yVyxVQUFVeWtCLHdCQUFqQixLQUE4QyxVQUFsRCxFQUE4RDtBQUM1RCxRQUFNcmpCLGdCQUFnQixnQ0FBaUJwQixTQUFqQixLQUErQixTQUFyRDs7QUFFQSxRQUFJLENBQUMyaEIsK0NBQStDdmdCLGFBQS9DLENBQUwsRUFBb0U7QUFDbEUseUNBQ0UsS0FERixFQUVFLGtFQUZGLEVBR0VBLGFBSEY7QUFLQXVnQixxREFBK0N2Z0IsYUFBL0MsSUFBZ0UsSUFBaEU7QUFDRDtBQUNGOztBQUVELE1BQ0UsUUFBT3BCLFVBQVU4a0IsV0FBakIsTUFBaUMsUUFBakMsSUFDQTlrQixVQUFVOGtCLFdBQVYsS0FBMEIsSUFGNUIsRUFHRTtBQUNBLFFBQU0xakIsaUJBQWdCLGdDQUFpQnBCLFNBQWpCLEtBQStCLFNBQXJEOztBQUVBLFFBQUksQ0FBQzBoQiwyQ0FBMkN0Z0IsY0FBM0MsQ0FBTCxFQUFnRTtBQUM5RCx5Q0FDRSxLQURGLEVBRUUscURBRkYsRUFHRUEsY0FIRjtBQUtBc2dCLGlEQUEyQ3RnQixjQUEzQyxJQUE0RCxJQUE1RDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTMmpCLHVCQUFULENBQ0V2N0IsT0FERixFQUVFSixjQUZGLEVBR0V5UixvQkFIRixFQUlFO0FBQ0EsTUFBTUosT0FBT3JSLGVBQWVxUixJQUE1QjtBQUNBLE1BQU1ELFlBQVlwUixlQUFlc2xCLFlBQWpDOztBQUVBO0FBQ0E7QUFDQSxNQUFJaFUsWUFBa0N0UixlQUFlK1EsYUFBckQ7O0FBRUEsTUFBSTZxQix1QkFBSjtBQUNBLE1BQUksQ0FBQzU3QixlQUFldVIsU0FBZixHQUEyQnZRLCtCQUE1QixNQUE0Q1IsNkJBQWhELEVBQTBEO0FBQ3hEO0FBQ0E4USxnQkFBWSxJQUFaO0FBQ0FzcUIscUJBQWlCLEtBQWpCO0FBQ0QsR0FKRCxNQUlPO0FBQ0w7QUFDQTtBQUNBdHFCLGdCQUFZO0FBQ1Z1cUIsa0JBQVl2cUIsY0FBYyxJQUFkLEdBQXFCQSxVQUFVdXFCLFVBQS9CLEdBQTRDajZCO0FBRDlDLEtBQVo7QUFHQWc2QixxQkFBaUIsSUFBakI7QUFDQTU3QixtQkFBZXVSLFNBQWYsSUFBNEIsQ0FBQ3ZRLCtCQUE3QjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFJcVQsY0FBSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSTlELGFBQUo7QUFDQSxNQUFJblEsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixRQUFJNUUsK0NBQUosRUFBa0M7QUFDaEM7QUFDQTtBQUNBLFVBQUk0VixVQUFVMHFCLFFBQVYsS0FBdUJoakMsU0FBM0IsRUFBc0M7QUFDcEMsMEVBQWlDa0gsY0FBakM7QUFDQTtBQUNBLFlBQUlBLGVBQWV4QyxHQUFmLEtBQXVCVCwwQ0FBM0IsRUFBd0Q7QUFDdEQsaUJBQU9nL0Isa0NBQ0wsSUFESyxFQUVMLzdCLGNBRkssRUFHTHlSLG9CQUhLLENBQVA7QUFLRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLFFBQUltcUIsY0FBSixFQUFvQjtBQUNsQjtBQUNBLFVBQU1JLHVCQUF1QjVxQixVQUFVMHFCLFFBQXZDO0FBQ0EsVUFBTUcsdUJBQXVCLHlDQUMzQixJQUQyQixFQUUzQjVxQixJQUYyQixFQUczQnpQLGdDQUgyQixFQUkzQixJQUoyQixDQUE3Qjs7QUFPQSxVQUFJLENBQUM1QixlQUFlcVIsSUFBZixHQUFzQi9KLCtCQUF2QixNQUEyQ0QsMEJBQS9DLEVBQTBEO0FBQ3hEO0FBRUEsWUFBTTYwQixrQkFBaUNsOEIsZUFBZStRLGFBQXREO0FBQ0EsWUFBTW9yQix5QkFDSkQsb0JBQW9CLElBQXBCLEdBQ0tsOEIsZUFBZXFVLEtBQWhCLENBQTRCQSxLQURoQyxHQUVLclUsZUFBZXFVLEtBSHRCO0FBSUE0bkIsNkJBQXFCNW5CLEtBQXJCLEdBQTZCOG5CLHNCQUE3QjtBQUNEOztBQUVELFVBQU1DLHdCQUF3Qix5Q0FDNUJKLG9CQUQ0QixFQUU1QjNxQixJQUY0QixFQUc1Qkksb0JBSDRCLEVBSTVCLElBSjRCLENBQTlCO0FBTUF3cUIsMkJBQXFCcm5CLE9BQXJCLEdBQStCd25CLHFCQUEvQjtBQUNBL25CLGNBQVE0bkIsb0JBQVI7QUFDQTtBQUNBO0FBQ0ExckIsYUFBTzZyQixxQkFBUDtBQUNBL25CLFlBQU1sVSxNQUFOLEdBQWVvUSxLQUFLcFEsTUFBTCxHQUFjSCxjQUE3QjtBQUNELEtBakNELE1BaUNPO0FBQ0w7QUFDQSxVQUFNcThCLHNCQUFzQmpyQixVQUFVc1YsUUFBdEM7QUFDQXJTLGNBQVE5RCxPQUFPLHVDQUNidlEsY0FEYSxFQUViLElBRmEsRUFHYnE4QixtQkFIYSxFQUliNXFCLG9CQUphLENBQWY7QUFNRDtBQUNGLEdBOURELE1BOERPO0FBQ0w7QUFDQTtBQUNBLFFBQU1OLFlBQVkvUSxRQUFRMlEsYUFBMUI7QUFDQSxRQUFNdXJCLGlCQUFpQm5yQixjQUFjLElBQXJDO0FBQ0EsUUFBSW1yQixjQUFKLEVBQW9CO0FBQ2xCO0FBRUEsVUFBTUMsOEJBQXNDbjhCLFFBQVFpVSxLQUFwRDtBQUNBLFVBQU1tb0IsK0JBQXVDRCw0QkFBNEIzbkIsT0FBekU7QUFDQSxVQUFJZ25CLGNBQUosRUFBb0I7QUFDbEI7QUFDQTtBQUNBLFlBQU1JLHdCQUF1QjVxQixVQUFVMHFCLFFBQXZDO0FBQ0EsWUFBTUcsd0JBQXVCLHNDQUMzQk0sMkJBRDJCLEVBRTNCQSw0QkFBNEJqWCxZQUZELEVBRzNCMWpCLGdDQUgyQixDQUE3Qjs7QUFNQSxZQUFJLENBQUM1QixlQUFlcVIsSUFBZixHQUFzQi9KLCtCQUF2QixNQUEyQ0QsMEJBQS9DLEVBQTBEO0FBQ3hEO0FBRUEsY0FBTTYwQixtQkFBaUNsOEIsZUFBZStRLGFBQXREO0FBQ0EsY0FBTW9yQiwwQkFDSkQscUJBQW9CLElBQXBCLEdBQ0tsOEIsZUFBZXFVLEtBQWhCLENBQTRCQSxLQURoQyxHQUVLclUsZUFBZXFVLEtBSHRCO0FBSUEsY0FBSThuQiw0QkFBMkJJLDRCQUE0QmxvQixLQUEzRCxFQUFrRTtBQUNoRTRuQixrQ0FBcUI1bkIsS0FBckIsR0FBNkI4bkIsdUJBQTdCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsWUFBSTlnQywwQ0FBdUIyRSxlQUFlcVIsSUFBZixHQUFzQjdKLDRCQUFqRCxFQUE4RDtBQUM1RDtBQUNBLGNBQUl3ZSxtQkFBbUIsQ0FBdkI7QUFDQSxjQUFJeVcsY0FBY1Isc0JBQXFCNW5CLEtBQXZDO0FBQ0EsaUJBQU9vb0IsZ0JBQWdCLElBQXZCLEVBQTZCO0FBQzNCelcsZ0NBQW9CeVcsWUFBWXpXLGdCQUFoQztBQUNBeVcsMEJBQWNBLFlBQVk3bkIsT0FBMUI7QUFDRDtBQUNEcW5CLGdDQUFxQmpXLGdCQUFyQixHQUF3Q0EsZ0JBQXhDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFlBQU1vVyx5QkFBeUJILHNCQUFxQnJuQixPQUFyQixHQUErQixzQ0FDNUQ0bkIsNEJBRDRELEVBRTVEUixxQkFGNEQsRUFHNURRLDZCQUE2QnI2QixjQUgrQixDQUE5RDtBQUtBa1MsZ0JBQVE0bkIscUJBQVI7QUFDQUEsOEJBQXFCN25CLG1CQUFyQixHQUEyQ3hTLGdDQUEzQztBQUNBO0FBQ0E7QUFDQTJPLGVBQU82ckIsc0JBQVA7QUFDQS9uQixjQUFNbFUsTUFBTixHQUFlb1EsS0FBS3BRLE1BQUwsR0FBY0gsY0FBN0I7QUFDRCxPQWpERCxNQWlETztBQUNMO0FBQ0E7QUFDQSxZQUFNcThCLHVCQUFzQmpyQixVQUFVc1YsUUFBdEM7QUFDQSxZQUFNZ1csc0JBQXNCSCw0QkFBNEJsb0IsS0FBeEQ7QUFDQSxZQUFNc29CLGVBQWUsMkNBQ25CMzhCLGNBRG1CLEVBRW5CMDhCLG1CQUZtQixFQUduQkwsb0JBSG1CLEVBSW5CNXFCLG9CQUptQixDQUFyQjs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E0QyxnQkFBUTlELE9BQU9vc0IsWUFBZjtBQUNEO0FBQ0YsS0EzRUQsTUEyRU87QUFDTDtBQUNBO0FBQ0EsVUFBTUQsdUJBQXNCdDhCLFFBQVFpVSxLQUFwQztBQUNBLFVBQUl1bkIsY0FBSixFQUFvQjtBQUNsQjtBQUNBO0FBQ0EsWUFBTUkseUJBQXVCNXFCLFVBQVUwcUIsUUFBdkM7QUFDQSxZQUFNRyx5QkFBdUI7QUFDM0I7QUFDQTtBQUNBLFlBSDJCLEVBSTNCNXFCLElBSjJCLEVBSzNCelAsZ0NBTDJCLEVBTTNCLElBTjJCLENBQTdCO0FBUUFxNkIsK0JBQXFCNW5CLEtBQXJCLEdBQTZCcW9CLG9CQUE3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFJLENBQUMxOEIsZUFBZXFSLElBQWYsR0FBc0IvSiwrQkFBdkIsTUFBMkNELDBCQUEvQyxFQUEwRDtBQUN4RDtBQUVBLGNBQU02MEIsb0JBQWlDbDhCLGVBQWUrUSxhQUF0RDtBQUNBLGNBQU1vckIsMkJBQ0pELHNCQUFvQixJQUFwQixHQUNLbDhCLGVBQWVxVSxLQUFoQixDQUE0QkEsS0FEaEMsR0FFS3JVLGVBQWVxVSxLQUh0QjtBQUlBNG5CLGlDQUFxQjVuQixLQUFyQixHQUE2QjhuQix3QkFBN0I7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsWUFBSTlnQywwQ0FBdUIyRSxlQUFlcVIsSUFBZixHQUFzQjdKLDRCQUFqRCxFQUE4RDtBQUM1RDtBQUNBLGNBQUl3ZSxvQkFBbUIsQ0FBdkI7QUFDQSxjQUFJeVcsZUFBY1IsdUJBQXFCNW5CLEtBQXZDO0FBQ0EsaUJBQU9vb0IsaUJBQWdCLElBQXZCLEVBQTZCO0FBQzNCelcsaUNBQW9CeVcsYUFBWXpXLGdCQUFoQztBQUNBeVcsMkJBQWNBLGFBQVk3bkIsT0FBMUI7QUFDRDtBQUNEcW5CLGlDQUFxQmpXLGdCQUFyQixHQUF3Q0EsaUJBQXhDO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFNb1csMEJBQXlCSCx1QkFBcUJybkIsT0FBckIsR0FBK0IseUNBQzVEb25CLHNCQUQ0RCxFQUU1RDNxQixJQUY0RCxFQUc1REksb0JBSDRELEVBSTVELElBSjRELENBQTlEO0FBTUEycUIsZ0NBQXNCN3FCLFNBQXRCLElBQW1DN1EsOEJBQW5DO0FBQ0EyVCxnQkFBUTRuQixzQkFBUjtBQUNBQSwrQkFBcUI3bkIsbUJBQXJCLEdBQTJDeFMsZ0NBQTNDO0FBQ0E7QUFDQTtBQUNBMk8sZUFBTzZyQix1QkFBUDtBQUNBL25CLGNBQU1sVSxNQUFOLEdBQWVvUSxLQUFLcFEsTUFBTCxHQUFjSCxjQUE3QjtBQUNELE9BekRELE1BeURPO0FBQ0w7QUFDQTtBQUNBLFlBQU1xOEIsd0JBQXNCanJCLFVBQVVzVixRQUF0QztBQUNBblcsZUFBTzhELFFBQVEsMkNBQ2JyVSxjQURhLEVBRWIwOEIsb0JBRmEsRUFHYkwscUJBSGEsRUFJYjVxQixvQkFKYSxDQUFmO0FBTUQ7QUFDRjtBQUNEelIsbUJBQWVtTyxTQUFmLEdBQTJCL04sUUFBUStOLFNBQW5DO0FBQ0Q7O0FBRURuTyxpQkFBZStRLGFBQWYsR0FBK0JPLFNBQS9CO0FBQ0F0UixpQkFBZXFVLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0EsU0FBTzlELElBQVA7QUFDRDs7QUFFRCxTQUFTd3JCLGlDQUFULENBQ0UzN0IsT0FERixFQUVFSixjQUZGLEVBR0V5UixvQkFIRixFQUlFO0FBQ0EsTUFBSXJSLFlBQVksSUFBaEIsRUFBc0I7QUFDcEI7QUFDQTtBQUNBSixtQkFBZW1DLGNBQWYsR0FBZ0NOLCtCQUFoQztBQUNBLFdBQU8sSUFBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLE1BQU0wVixvQkFBb0JuWCxRQUFRZ1UsbUJBQVIsSUFBK0IzQyxvQkFBekQ7QUFDQSxNQUFJMm1CLG9CQUFvQjdnQixpQkFBeEIsRUFBMkM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0FuWCxZQUFRdVEsU0FBUixHQUFvQixJQUFwQjtBQUNBM1EsbUJBQWUyUSxTQUFmLEdBQTJCLElBQTNCOztBQUVBO0FBQ0EsUUFBSW1kLGNBQWM5dEIsZUFBZUcsTUFBakM7QUFDQSw2QkFDRTJ0QixnQkFBZ0IsSUFEbEIsRUFFRSxnREFDRSxrQ0FISjtBQUtBLFFBQU04TyxPQUFPOU8sWUFBWTlkLFVBQXpCO0FBQ0EsUUFBSTRzQixTQUFTLElBQWIsRUFBbUI7QUFDakJBLFdBQUtwc0IsVUFBTCxHQUFrQnBRLE9BQWxCO0FBQ0EwdEIsa0JBQVk5ZCxVQUFaLEdBQXlCNVAsT0FBekI7QUFDRCxLQUhELE1BR087QUFDTDB0QixrQkFBWS9kLFdBQVosR0FBMEIrZCxZQUFZOWQsVUFBWixHQUF5QjVQLE9BQW5EO0FBQ0Q7QUFDREEsWUFBUW9RLFVBQVIsR0FBcUIsSUFBckI7QUFDQXBRLFlBQVFtUixTQUFSLEdBQW9CMVEsNkJBQXBCOztBQUVBO0FBQ0FiLG1CQUFleEMsR0FBZixHQUFxQmQsZ0NBQXJCO0FBQ0FzRCxtQkFBZW1PLFNBQWYsR0FBMkIsSUFBM0I7QUFDQW5PLG1CQUFlK1EsYUFBZixHQUErQixJQUEvQjtBQUNBO0FBQ0EvUSxtQkFBZXVSLFNBQWYsSUFBNEI3USw4QkFBNUI7QUFDQTtBQUNBLFdBQU9pN0Isd0JBQXdCLElBQXhCLEVBQThCMzdCLGNBQTlCLEVBQThDeVIsb0JBQTlDLENBQVA7QUFDRDtBQUNELE1BQUksQ0FBQ3pSLGVBQWV1UixTQUFmLEdBQTJCdlEsK0JBQTVCLE1BQTRDUiw2QkFBaEQsRUFBMEQ7QUFDeEQ7QUFDQSx5RkFBb0RSLGNBQXBEO0FBQ0EsUUFBTW9SLFlBQVlwUixlQUFlc2xCLFlBQWpDO0FBQ0EsUUFBTW9ULGVBQWV0bkIsVUFBVXNWLFFBQS9CO0FBQ0ExbUIsbUJBQWVxVSxLQUFmLEdBQXVCLHVDQUNyQnJVLGNBRHFCLEVBRXJCLElBRnFCLEVBR3JCMDRCLFlBSHFCLEVBSXJCam5CLG9CQUpxQixDQUF2QjtBQU1BLFdBQU96UixlQUFlcVUsS0FBdEI7QUFDRCxHQVpELE1BWU87QUFDTDtBQUNBO0FBQ0FyVSxtQkFBZXFVLEtBQWYsR0FBdUIsSUFBdkI7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNGOztBQUVELFNBQVN3b0IscUJBQVQsQ0FDRXo4QixPQURGLEVBRUVKLGNBRkYsRUFHRXlSLG9CQUhGLEVBSUU7QUFDQSxnREFBa0J6UixjQUFsQixFQUFrQ0EsZUFBZW1PLFNBQWYsQ0FBeUJtWixhQUEzRDtBQUNBLE1BQU1vUixlQUFlMTRCLGVBQWVzbEIsWUFBcEM7QUFDQSxNQUFJbGxCLFlBQVksSUFBaEIsRUFBc0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBSixtQkFBZXFVLEtBQWYsR0FBdUIsMkNBQ3JCclUsY0FEcUIsRUFFckIsSUFGcUIsRUFHckIwNEIsWUFIcUIsRUFJckJqbkIsb0JBSnFCLENBQXZCO0FBTUQsR0FaRCxNQVlPO0FBQ0x5bUIsc0JBQ0U5M0IsT0FERixFQUVFSixjQUZGLEVBR0UwNEIsWUFIRixFQUlFam5CLG9CQUpGO0FBTUQ7QUFDRCxTQUFPelIsZUFBZXFVLEtBQXRCO0FBQ0Q7O0FBRUQsU0FBU3lvQixxQkFBVCxDQUNFMThCLE9BREYsRUFFRUosY0FGRixFQUdFeVIsb0JBSEYsRUFJRTtBQUNBLE1BQU1zckIsZUFBdUMvOEIsZUFBZXpDLElBQTVEO0FBQ0EsTUFBTTBVLFVBQTZCOHFCLGFBQWF4cEIsUUFBaEQ7O0FBRUEsTUFBTXlwQixXQUFXaDlCLGVBQWVzbEIsWUFBaEM7QUFDQSxNQUFNMlgsV0FBV2o5QixlQUFlMGxCLGFBQWhDOztBQUVBLE1BQU01UixXQUFXa3BCLFNBQVNoZ0IsS0FBMUI7O0FBRUEsTUFBSXBrQixJQUFKLEVBQWE7QUFDWCxRQUFNc2tDLG9CQUFvQmw5QixlQUFlekMsSUFBZixDQUFvQnU3QixTQUE5Qzs7QUFFQSxRQUFJb0UsaUJBQUosRUFBdUI7QUFDckIsb0NBQ0VBLGlCQURGLEVBRUVGLFFBRkYsRUFHRSxNQUhGLEVBSUUsa0JBSkYsRUFLRTM5Qiw0Q0FMRjtBQU9EO0FBQ0Y7O0FBRUQsMENBQWFXLGNBQWIsRUFBNkI4VCxRQUE3Qjs7QUFFQSxNQUFJbXBCLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsUUFBTWxwQixXQUFXa3BCLFNBQVNqZ0IsS0FBMUI7QUFDQSxRQUFNaEosY0FBYyxnREFBcUIvQixPQUFyQixFQUE4QjZCLFFBQTlCLEVBQXdDQyxRQUF4QyxDQUFwQjtBQUNBLFFBQUlDLGdCQUFnQixDQUFwQixFQUF1QjtBQUNyQjtBQUNBLFVBQ0VpcEIsU0FBU3ZXLFFBQVQsS0FBc0JzVyxTQUFTdFcsUUFBL0IsSUFDQSxDQUFDLDJDQUZILEVBR0U7QUFDQSxlQUFPcVMsNkJBQ0wzNEIsT0FESyxFQUVMSixjQUZLLEVBR0x5UixvQkFISyxDQUFQO0FBS0Q7QUFDRixLQVpELE1BWU87QUFDTDtBQUNBO0FBQ0Esd0RBQ0V6UixjQURGLEVBRUVpUyxPQUZGLEVBR0UrQixXQUhGLEVBSUV2QyxvQkFKRjtBQU1EO0FBQ0Y7O0FBRUQsTUFBTTByQixjQUFjSCxTQUFTdFcsUUFBN0I7QUFDQXdSLG9CQUFrQjkzQixPQUFsQixFQUEyQkosY0FBM0IsRUFBMkNtOUIsV0FBM0MsRUFBd0QxckIsb0JBQXhEO0FBQ0EsU0FBT3pSLGVBQWVxVSxLQUF0QjtBQUNEOztBQUVELElBQUkrb0IsdUNBQXVDLEtBQTNDOztBQUVBLFNBQVNDLHFCQUFULENBQ0VqOUIsT0FERixFQUVFSixjQUZGLEVBR0V5UixvQkFIRixFQUlFO0FBQ0EsTUFBSVEsVUFBNkJqUyxlQUFlekMsSUFBaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUkzRSxJQUFKLEVBQWE7QUFDWCxRQUFLcVosT0FBRCxDQUFlc0IsUUFBZixLQUE0QnphLFNBQWhDLEVBQTJDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQUltWixZQUFZQSxRQUFRcXJCLFFBQXhCLEVBQWtDO0FBQ2hDLFlBQUksQ0FBQ0Ysb0NBQUwsRUFBMkM7QUFDekNBLGlEQUF1QyxJQUF2QztBQUNBLGlDQUNFLEtBREYsRUFFRSwwRUFDRSw0RUFISjtBQUtEO0FBQ0Y7QUFDRixLQWRELE1BY087QUFDTG5yQixnQkFBV0EsT0FBRCxDQUFlc0IsUUFBekI7QUFDRDtBQUNGO0FBQ0QsTUFBTXlwQixXQUFXaDlCLGVBQWVzbEIsWUFBaEM7QUFDQSxNQUFNbm5CLFNBQVM2K0IsU0FBU3RXLFFBQXhCOztBQUVBLE1BQUk5dEIsSUFBSixFQUFhO0FBQ1gsdUNBQ0UsT0FBT3VGLE1BQVAsS0FBa0IsVUFEcEIsRUFFRSx3RUFDRSxtRUFERixHQUVFLGtFQUZGLEdBR0UsaURBTEo7QUFPRDs7QUFFRCxrREFBcUI2QixjQUFyQixFQUFxQ3lSLG9CQUFyQztBQUNBLE1BQU1xQyxXQUFXLHVDQUFZN0IsT0FBWixFQUFxQitxQixTQUFTTyxxQkFBOUIsQ0FBakI7QUFDQSxNQUFJSixvQkFBSjtBQUNBLE1BQUl2a0MsSUFBSixFQUFhO0FBQ1grdUIsc0JBQWtCdm5CLE9BQWxCLEdBQTRCSixjQUE1QjtBQUNBLDRDQUFnQixRQUFoQjtBQUNBbTlCLGtCQUFjaC9CLE9BQU8yVixRQUFQLENBQWQ7QUFDQSw0Q0FBZ0IsSUFBaEI7QUFDRCxHQUxELE1BS087QUFDTHFwQixrQkFBY2gvQixPQUFPMlYsUUFBUCxDQUFkO0FBQ0Q7O0FBRUQ7QUFDQTlULGlCQUFldVIsU0FBZixJQUE0QjlRLGtDQUE1QjtBQUNBeTNCLG9CQUFrQjkzQixPQUFsQixFQUEyQkosY0FBM0IsRUFBMkNtOUIsV0FBM0MsRUFBd0QxckIsb0JBQXhEO0FBQ0EsU0FBT3pSLGVBQWVxVSxLQUF0QjtBQUNEOztBQUVNLFNBQVM4akIsZ0NBQVQsR0FBNEM7QUFDakRDLHFCQUFtQixJQUFuQjtBQUNEOztBQUVELFNBQVNXLDRCQUFULENBQ0UzNEIsT0FERixFQUVFSixjQUZGLEVBR0V5UixvQkFIRixFQUlnQjtBQUNkLDRDQUFnQnpSLGNBQWhCOztBQUVBLE1BQUlJLFlBQVksSUFBaEIsRUFBc0I7QUFDcEI7QUFDQUosbUJBQWV3VSxtQkFBZixHQUFxQ3BVLFFBQVFvVSxtQkFBN0M7QUFDRDs7QUFFRCxNQUFJblosc0NBQUosRUFBeUI7QUFDdkI7QUFDQSx3REFBMkIyRSxjQUEzQjtBQUNEOztBQUVEO0FBQ0EsTUFBTW9VLHNCQUFzQnBVLGVBQWVvVSxtQkFBM0M7QUFDQSxNQUFJQSxzQkFBc0IzQyxvQkFBMUIsRUFBZ0Q7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0FMRCxNQUtPO0FBQ0w7QUFDQTtBQUNBLDJDQUFpQnJSLE9BQWpCLEVBQTBCSixjQUExQjtBQUNBLFdBQU9BLGVBQWVxVSxLQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU21wQixTQUFULENBQ0VwOUIsT0FERixFQUVFSixjQUZGLEVBR0V5UixvQkFIRixFQUlnQjtBQUNkLE1BQU1LLHVCQUF1QjlSLGVBQWVtQyxjQUE1Qzs7QUFFQSxNQUFJL0IsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixRQUFNNjhCLFdBQVc3OEIsUUFBUXNsQixhQUF6QjtBQUNBLFFBQU1zWCxXQUFXaDlCLGVBQWVzbEIsWUFBaEM7O0FBRUEsUUFBSTJYLGFBQWFELFFBQWIsSUFBeUIsMkNBQTdCLEVBQXdEO0FBQ3REO0FBQ0E7QUFDQTVFLHlCQUFtQixJQUFuQjtBQUNELEtBSkQsTUFJTyxJQUFJdG1CLHVCQUF1Qkwsb0JBQTNCLEVBQWlEO0FBQ3REMm1CLHlCQUFtQixLQUFuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQVFwNEIsZUFBZXhDLEdBQXZCO0FBQ0UsYUFBS3hCLHVCQUFMO0FBQ0VxK0IsOEJBQW9CcjZCLGNBQXBCO0FBQ0E7QUFDQTtBQUNGLGFBQUs5RCw0QkFBTDtBQUNFLHNEQUFnQjhELGNBQWhCO0FBQ0E7QUFDRixhQUFLbEUsNkJBQUw7QUFBcUI7QUFDbkIsZ0JBQU04YSxZQUFZNVcsZUFBZXpDLElBQWpDO0FBQ0EsZ0JBQUksMENBQXdCcVosU0FBeEIsQ0FBSixFQUF3QztBQUN0QywwREFBMEI1VyxjQUExQjtBQUNEO0FBQ0Q7QUFDRDtBQUNELGFBQUsvRCx5QkFBTDtBQUNFLHdEQUNFK0QsY0FERixFQUVFQSxlQUFlbU8sU0FBZixDQUF5Qm1aLGFBRjNCO0FBSUE7QUFDRixhQUFLL3FCLDhCQUFMO0FBQXNCO0FBQ3BCLGdCQUFNdVgsV0FBVzlULGVBQWUwbEIsYUFBZixDQUE2QjFJLEtBQTlDO0FBQ0Esb0RBQWFoZCxjQUFiLEVBQTZCOFQsUUFBN0I7QUFDQTtBQUNEO0FBQ0QsYUFBS3JYLHVCQUFMO0FBQ0UsY0FBSXBCLHNDQUFKLEVBQXlCO0FBQ3ZCMkUsMkJBQWV1UixTQUFmLElBQTRCNVEsMkJBQTVCO0FBQ0Q7QUFDRDtBQUNGLGFBQUtqRSxnQ0FBTDtBQUF3QjtBQUN0QixnQkFBTTA5QixRQUE4QnA2QixlQUFlK1EsYUFBbkQ7QUFDQSxnQkFBTTBzQixhQUFhckQsVUFBVSxJQUE3QjtBQUNBLGdCQUFJcUQsVUFBSixFQUFnQjtBQUNkO0FBQ0E7QUFDQTtBQUVBLGtCQUFNeEIsdUJBQStCajhCLGVBQWVxVSxLQUFwRDtBQUNBLGtCQUFNcXBCLDZCQUNKekIscUJBQXFCN25CLG1CQUR2QjtBQUVBLGtCQUNFc3BCLCtCQUErQjk3QixnQ0FBL0IsSUFDQTg3Qiw4QkFBOEJqc0Isb0JBRmhDLEVBR0U7QUFDQTtBQUNBO0FBQ0EsdUJBQU9rcUIsd0JBQ0x2N0IsT0FESyxFQUVMSixjQUZLLEVBR0x5UixvQkFISyxDQUFQO0FBS0QsZUFYRCxNQVdPO0FBQ0w7QUFDQTtBQUNBLG9CQUFNNEMsUUFBUTBrQiw2QkFDWjM0QixPQURZLEVBRVpKLGNBRlksRUFHWnlSLG9CQUhZLENBQWQ7QUFLQSxvQkFBSTRDLFVBQVUsSUFBZCxFQUFvQjtBQUNsQjtBQUNBO0FBQ0EseUJBQU9BLE1BQU1PLE9BQWI7QUFDRCxpQkFKRCxNQUlPO0FBQ0wseUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNEO0FBQ0Q7QUFDRCxhQUFLN1gsMENBQUw7QUFBa0M7QUFDaEMsZ0JBQUl2QiwrQ0FBSixFQUFrQztBQUNoQztBQUNBO0FBQ0E7QUFDQXdFLDZCQUFldVIsU0FBZixJQUE0QnZRLCtCQUE1QjtBQUNBO0FBQ0Q7QUFDRjtBQWhGSDtBQWtGQSxhQUFPKzNCLDZCQUNMMzRCLE9BREssRUFFTEosY0FGSyxFQUdMeVIsb0JBSEssQ0FBUDtBQUtEO0FBQ0YsR0FyR0QsTUFxR087QUFDTDJtQix1QkFBbUIsS0FBbkI7QUFDRDs7QUFFRDtBQUNBcDRCLGlCQUFlbUMsY0FBZixHQUFnQ1AsZ0NBQWhDOztBQUVBLFVBQVE1QixlQUFleEMsR0FBdkI7QUFDRSxTQUFLekIscUNBQUw7QUFBNkI7QUFDM0IsWUFBTXdwQixjQUFjdmxCLGVBQWV1bEIsV0FBbkM7QUFDQSxlQUFPNFYsNEJBQ0wvNkIsT0FESyxFQUVMSixjQUZLLEVBR0x1bEIsV0FISyxFQUlMOVQsb0JBSkssQ0FBUDtBQU1EO0FBQ0QsU0FBSzVVLDRCQUFMO0FBQW9CO0FBQ2xCLFlBQU0wb0IsZUFBY3ZsQixlQUFldWxCLFdBQW5DO0FBQ0EsZUFBT3NWLG1CQUNMejZCLE9BREssRUFFTEosY0FGSyxFQUdMdWxCLFlBSEssRUFJTHpULG9CQUpLLEVBS0xMLG9CQUxLLENBQVA7QUFPRDtBQUNELFNBQUs1VixnQ0FBTDtBQUF3QjtBQUN0QixZQUFNK2EsYUFBWTVXLGVBQWV6QyxJQUFqQztBQUNBLFlBQU1vZ0Msa0JBQWtCMzlCLGVBQWVzbEIsWUFBdkM7QUFDQSxZQUFNMFYsZ0JBQ0poN0IsZUFBZXVsQixXQUFmLEtBQStCM08sVUFBL0IsR0FDSSttQixlQURKLEdBRUksa0RBQW9CL21CLFVBQXBCLEVBQStCK21CLGVBQS9CLENBSE47QUFJQSxlQUFPakUsd0JBQ0x0NUIsT0FESyxFQUVMSixjQUZLLEVBR0w0VyxVQUhLLEVBSUxva0IsYUFKSyxFQUtMdnBCLG9CQUxLLENBQVA7QUFPRDtBQUNELFNBQUszViw2QkFBTDtBQUFxQjtBQUNuQixZQUFNOGEsY0FBWTVXLGVBQWV6QyxJQUFqQztBQUNBLFlBQU1vZ0MsbUJBQWtCMzlCLGVBQWVzbEIsWUFBdkM7QUFDQSxZQUFNMFYsaUJBQ0poN0IsZUFBZXVsQixXQUFmLEtBQStCM08sV0FBL0IsR0FDSSttQixnQkFESixHQUVJLGtEQUFvQi9tQixXQUFwQixFQUErQittQixnQkFBL0IsQ0FITjtBQUlBLGVBQU81RCxxQkFDTDM1QixPQURLLEVBRUxKLGNBRkssRUFHTDRXLFdBSEssRUFJTG9rQixjQUpLLEVBS0x2cEIsb0JBTEssQ0FBUDtBQU9EO0FBQ0QsU0FBS3pWLHVCQUFMO0FBQ0UsYUFBT3UrQixlQUFlbjZCLE9BQWYsRUFBd0JKLGNBQXhCLEVBQXdDeVIsb0JBQXhDLENBQVA7QUFDRixTQUFLdlYsNEJBQUw7QUFDRSxhQUFPdytCLG9CQUFvQnQ2QixPQUFwQixFQUE2QkosY0FBN0IsRUFBNkN5UixvQkFBN0MsQ0FBUDtBQUNGLFNBQUt0Vix1QkFBTDtBQUNFLGFBQU95K0IsZUFBZXg2QixPQUFmLEVBQXdCSixjQUF4QixDQUFQO0FBQ0YsU0FBS3RELGdDQUFMO0FBQ0UsYUFBT2kvQix3QkFDTHY3QixPQURLLEVBRUxKLGNBRkssRUFHTHlSLG9CQUhLLENBQVA7QUFLRixTQUFLeFYseUJBQUw7QUFDRSxhQUFPNGdDLHNCQUNMejhCLE9BREssRUFFTEosY0FGSyxFQUdMeVIsb0JBSEssQ0FBUDtBQUtGLFNBQUtqVix5QkFBTDtBQUFpQjtBQUNmLFlBQU1lLE9BQU95QyxlQUFlekMsSUFBNUI7QUFDQSxZQUFNb2dDLG9CQUFrQjM5QixlQUFlc2xCLFlBQXZDO0FBQ0EsWUFBTTBWLGtCQUNKaDdCLGVBQWV1bEIsV0FBZixLQUErQmhvQixJQUEvQixHQUNJb2dDLGlCQURKLEdBRUksa0RBQW9CcGdDLElBQXBCLEVBQTBCb2dDLGlCQUExQixDQUhOO0FBSUEsZUFBTy9FLGlCQUNMeDRCLE9BREssRUFFTEosY0FGSyxFQUdMekMsSUFISyxFQUlMeTlCLGVBSkssRUFLTHZwQixvQkFMSyxDQUFQO0FBT0Q7QUFDRCxTQUFLclYsdUJBQUw7QUFDRSxhQUFPdTlCLGVBQWV2NUIsT0FBZixFQUF3QkosY0FBeEIsRUFBd0N5UixvQkFBeEMsQ0FBUDtBQUNGLFNBQUtwVixtQkFBTDtBQUNFLGFBQU91OUIsV0FBV3g1QixPQUFYLEVBQW9CSixjQUFwQixFQUFvQ3lSLG9CQUFwQyxDQUFQO0FBQ0YsU0FBS2hWLHVCQUFMO0FBQ0UsYUFBT285QixlQUFlejVCLE9BQWYsRUFBd0JKLGNBQXhCLEVBQXdDeVIsb0JBQXhDLENBQVA7QUFDRixTQUFLbFYsOEJBQUw7QUFDRSxhQUFPdWdDLHNCQUNMMThCLE9BREssRUFFTEosY0FGSyxFQUdMeVIsb0JBSEssQ0FBUDtBQUtGLFNBQUtuViw4QkFBTDtBQUNFLGFBQU8rZ0Msc0JBQ0xqOUIsT0FESyxFQUVMSixjQUZLLEVBR0x5UixvQkFISyxDQUFQO0FBS0YsU0FBSzlVLDRCQUFMO0FBQW9CO0FBQ2xCLFlBQU1ZLFNBQU95QyxlQUFlekMsSUFBNUI7QUFDQSxZQUFNb2dDLG9CQUFrQjM5QixlQUFlc2xCLFlBQXZDO0FBQ0E7QUFDQSxZQUFJMFYsa0JBQWdCLGtEQUFvQno5QixNQUFwQixFQUEwQm9nQyxpQkFBMUIsQ0FBcEI7QUFDQSxZQUFJL2tDLElBQUosRUFBYTtBQUNYLGNBQUlvSCxlQUFlekMsSUFBZixLQUF3QnlDLGVBQWV1bEIsV0FBM0MsRUFBd0Q7QUFDdEQsZ0JBQU1rVSxpQkFBaUJsOEIsT0FBS3U3QixTQUE1QjtBQUNBLGdCQUFJVyxjQUFKLEVBQW9CO0FBQ2xCLDRDQUNFQSxjQURGLEVBRUV1QixlQUZGLEVBRWlCO0FBQ2Ysb0JBSEYsRUFJRSxnQ0FBaUJ6OUIsTUFBakIsQ0FKRixFQUtFOEIsNENBTEY7QUFPRDtBQUNGO0FBQ0Y7QUFDRDI3QiwwQkFBZ0Isa0RBQW9CejlCLE9BQUtBLElBQXpCLEVBQStCeTlCLGVBQS9CLENBQWhCO0FBQ0EsZUFBT2hDLG9CQUNMNTRCLE9BREssRUFFTEosY0FGSyxFQUdMekMsTUFISyxFQUlMeTlCLGVBSkssRUFLTGxwQixvQkFMSyxFQU1MTCxvQkFOSyxDQUFQO0FBUUQ7QUFDRCxTQUFLN1Usa0NBQUw7QUFBMEI7QUFDeEIsZUFBT3U4QiwwQkFDTC80QixPQURLLEVBRUxKLGNBRkssRUFHTEEsZUFBZXpDLElBSFYsRUFJTHlDLGVBQWVzbEIsWUFKVixFQUtMeFQsb0JBTEssRUFNTEwsb0JBTkssQ0FBUDtBQVFEO0FBQ0QsU0FBSzNVLHVDQUFMO0FBQStCO0FBQzdCLFlBQU04WixjQUFZNVcsZUFBZXpDLElBQWpDO0FBQ0EsWUFBTW9nQyxvQkFBa0IzOUIsZUFBZXNsQixZQUF2QztBQUNBLFlBQU0wVixrQkFDSmg3QixlQUFldWxCLFdBQWYsS0FBK0IzTyxXQUEvQixHQUNJK21CLGlCQURKLEdBRUksa0RBQW9CL21CLFdBQXBCLEVBQStCK21CLGlCQUEvQixDQUhOO0FBSUEsZUFBT3pDLDhCQUNMOTZCLE9BREssRUFFTEosY0FGSyxFQUdMNFcsV0FISyxFQUlMb2tCLGVBSkssRUFLTHZwQixvQkFMSyxDQUFQO0FBT0Q7QUFDRCxTQUFLMVUsMENBQUw7QUFBa0M7QUFDaEMsWUFBSXZCLCtDQUFKLEVBQWtDO0FBQ2hDLGlCQUFPdWdDLGtDQUNMMzdCLE9BREssRUFFTEosY0FGSyxFQUdMeVIsb0JBSEssQ0FBUDtBQUtEO0FBQ0Q7QUFDRDtBQXBLSDtBQXNLQSwyQkFDRSxLQURGLEVBRUUsdUVBQ0UsOEJBSEo7QUFLRDs7UUFFTytyQixTLEdBQUFBLFM7Ozs7Ozs7Ozs7Ozs7O0FDdm5FUjs7OztBQUVBOztBQUNBOzs7O0FBaEJBOzs7Ozs7Ozs7QUFtQkEsSUFBTUksYUFBMEIsRUFBaEM7O0FBRUEsSUFBSXBuQixxQkFBNEQsbUNBQzlEb25CLFVBRDhELENBQWhFO0FBR0EsSUFBSUMsMEJBQTJELG1DQUM3REQsVUFENkQsQ0FBL0Q7QUFHQSxJQUFJRSwwQkFBK0QsbUNBQ2pFRixVQURpRSxDQUFuRTs7QUFJQSxTQUFTRyxlQUFULENBQWdDNWtDLENBQWhDLEVBQThEO0FBQzVELDJCQUNFQSxNQUFNeWtDLFVBRFIsRUFFRSwwRUFDRSxpQ0FISjtBQUtBLFNBQVF6a0MsQ0FBUjtBQUNEOztBQUVELFNBQVM2a0Msb0JBQVQsR0FBMkM7QUFDekMsTUFBTUMsZUFBZUYsZ0JBQWdCRCx3QkFBd0IxOUIsT0FBeEMsQ0FBckI7QUFDQSxTQUFPNjlCLFlBQVA7QUFDRDs7QUFFRCxTQUFTQyxpQkFBVCxDQUEyQngrQixLQUEzQixFQUF5Q3krQixnQkFBekMsRUFBc0U7QUFDcEU7QUFDQTtBQUNBLDZCQUFLTCx1QkFBTCxFQUE4QkssZ0JBQTlCLEVBQWdEeitCLEtBQWhEO0FBQ0E7QUFDQTtBQUNBLDZCQUFLbStCLHVCQUFMLEVBQThCbitCLEtBQTlCLEVBQXFDQSxLQUFyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQUs4VyxrQkFBTCxFQUF5Qm9uQixVQUF6QixFQUFxQ2wrQixLQUFyQztBQUNBLE1BQU0wK0Isa0JBQWtCLDhDQUFtQkQsZ0JBQW5CLENBQXhCO0FBQ0E7QUFDQSw0QkFBSTNuQixrQkFBSixFQUF3QjlXLEtBQXhCO0FBQ0EsNkJBQUs4VyxrQkFBTCxFQUF5QjRuQixlQUF6QixFQUEwQzErQixLQUExQztBQUNEOztBQUVELFNBQVMyK0IsZ0JBQVQsQ0FBMEIzK0IsS0FBMUIsRUFBd0M7QUFDdEMsNEJBQUk4VyxrQkFBSixFQUF3QjlXLEtBQXhCO0FBQ0EsNEJBQUltK0IsdUJBQUosRUFBNkJuK0IsS0FBN0I7QUFDQSw0QkFBSW8rQix1QkFBSixFQUE2QnArQixLQUE3QjtBQUNEOztBQUVELFNBQVM0K0IsY0FBVCxHQUF1QztBQUNyQyxNQUFNcnNCLFVBQVU4ckIsZ0JBQWdCdm5CLG1CQUFtQnBXLE9BQW5DLENBQWhCO0FBQ0EsU0FBTzZSLE9BQVA7QUFDRDs7QUFFRCxTQUFTc3NCLGVBQVQsQ0FBeUI3K0IsS0FBekIsRUFBNkM7QUFDM0MsTUFBTXUrQixlQUEwQkYsZ0JBQzlCRCx3QkFBd0IxOUIsT0FETSxDQUFoQztBQUdBLE1BQU02UixVQUF1QjhyQixnQkFBZ0J2bkIsbUJBQW1CcFcsT0FBbkMsQ0FBN0I7QUFDQSxNQUFNbytCLGNBQWMsK0NBQW9CdnNCLE9BQXBCLEVBQTZCdlMsTUFBTW5DLElBQW5DLEVBQXlDMGdDLFlBQXpDLENBQXBCOztBQUVBO0FBQ0EsTUFBSWhzQixZQUFZdXNCLFdBQWhCLEVBQTZCO0FBQzNCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLDZCQUFLWCx1QkFBTCxFQUE4Qm4rQixLQUE5QixFQUFxQ0EsS0FBckM7QUFDQSw2QkFBSzhXLGtCQUFMLEVBQXlCZ29CLFdBQXpCLEVBQXNDOStCLEtBQXRDO0FBQ0Q7O0FBRUQsU0FBUysrQixjQUFULENBQXdCLytCLEtBQXhCLEVBQTRDO0FBQzFDO0FBQ0E7QUFDQSxNQUFJbStCLHdCQUF3Qno5QixPQUF4QixLQUFvQ1YsS0FBeEMsRUFBK0M7QUFDN0M7QUFDRDs7QUFFRCw0QkFBSThXLGtCQUFKLEVBQXdCOVcsS0FBeEI7QUFDQSw0QkFBSW0rQix1QkFBSixFQUE2Qm4rQixLQUE3QjtBQUNEOztRQUdDNCtCLGMsR0FBQUEsYztRQUNBTixvQixHQUFBQSxvQjtRQUNBSyxnQixHQUFBQSxnQjtRQUNBSSxjLEdBQUFBLGM7UUFDQVAsaUIsR0FBQUEsaUI7UUFDQUssZSxHQUFBQSxlOzs7Ozs7Ozs7Ozs7OztBQ3BHRjs7Ozs7O0FBTUEsSUFBTTVXLG9CQUFvQjtBQUN4Qjs7OztBQUlBdm5CLFdBQVU7QUFMYyxDQUExQixDLENBakJBOzs7Ozs7Ozs7a0JBeUJldW5CLGlCOzs7Ozs7Ozs7Ozs7UUNQQytXLDZCLEdBQUFBLDZCOztBQVBoQjs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNL2pDLHlCQUF5QixFQUEvQixDLENBZEE7Ozs7Ozs7OztBQWdCQSxJQUFJZ2tDLDZCQUE4QixJQUFsQzs7QUFFTyxTQUFTRCw2QkFBVCxDQUF1QzVYLE9BQXZDLEVBQXFFO0FBQzFFLE1BQUlsdUIsSUFBSixFQUFhO0FBQ1grbEMsaUNBQTZCN1gsT0FBN0I7QUFDRDtBQUNGOztBQUVELElBQUlsdUIsSUFBSixFQUFhO0FBQ1g7QUFDQStCLHlCQUF1QjJGLGVBQXZCLEdBQTBDLElBQTFDOztBQUVBM0YseUJBQXVCRyxnQkFBdkIsR0FBMEMsWUFBbUI7QUFDM0QsUUFBSUQsUUFBUSxFQUFaOztBQUVBO0FBQ0EsUUFBSThqQywwQkFBSixFQUFnQztBQUM5QixVQUFNaGxDLE9BQU8sZ0NBQWlCZ2xDLDJCQUEyQnBoQyxJQUE1QyxDQUFiO0FBQ0EsVUFBTW9DLFFBQVFnL0IsMkJBQTJCNVgsTUFBekM7QUFDQWxzQixlQUFTLHNDQUNQbEIsSUFETyxFQUVQZ2xDLDJCQUEyQjNYLE9BRnBCLEVBR1BybkIsU0FBUyxnQ0FBaUJBLE1BQU1wQyxJQUF2QixDQUhGLENBQVQ7QUFLRDs7QUFFRDtBQUNBLFFBQU1xaEMsT0FBT2prQyx1QkFBdUIyRixlQUFwQztBQUNBLFFBQUlzK0IsSUFBSixFQUFVO0FBQ1IvakMsZUFBUytqQyxVQUFVLEVBQW5CO0FBQ0Q7O0FBRUQsV0FBTy9qQyxLQUFQO0FBQ0QsR0FyQkQ7QUFzQkQ7O2tCQUVjRixzQjs7Ozs7Ozs7Ozs7O1FDckJDa2tDLDJCLEdBQUFBLDJCO0FBSlQsSUFBTUMsNEJBQVUsQ0FBaEIsQyxDQTNCUDs7Ozs7Ozs7O0FBNEJPLElBQU1DLDhCQUFXLENBQWpCO0FBQ0EsSUFBTUMsOEJBQVcsQ0FBakI7O0FBRUEsU0FBU0gsMkJBQVQsQ0FDTEksYUFESyxFQUU0QjtBQUNqQyxTQUFPQSxjQUFjQyxPQUFkLEtBQTBCSCxRQUExQixHQUFxQ0UsY0FBY0UsT0FBbkQsR0FBNkQsSUFBcEU7QUFDRCxDOzs7Ozs7Ozs7Ozs7OzhRQ25DRDs7Ozs7OztRQTBLZ0Izd0IsYSxHQUFBQSxhO1FBd0ZBNHdCLGEsR0FBQUEsYTtRQVdBQyxrQixHQUFBQSxrQjtRQWtCQUMsWSxHQUFBQSxZO1FBOEVBQyxjLEdBQUFBLGM7O0FBdFdoQjs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLElBQU16NkIsaUJBQWlCRyxPQUFPNUssU0FBUCxDQUFpQnlLLGNBQXhDOztBQUVBLElBQU0wNkIsaUJBQWlCO0FBQ3JCbG9CLE9BQUssSUFEZ0I7QUFFckJtTyxPQUFLLElBRmdCO0FBR3JCZ2EsVUFBUSxJQUhhO0FBSXJCQyxZQUFVO0FBSlcsQ0FBdkI7O0FBT0EsSUFBSUMsbUNBQUo7QUFBQSxJQUFnQ0MsbUNBQWhDOztBQUVBLFNBQVNDLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCO0FBQzNCLE1BQUlsbkMsSUFBSixFQUFhO0FBQ1gsUUFBSWtNLGVBQWV2SyxJQUFmLENBQW9CdWxDLE1BQXBCLEVBQTRCLEtBQTVCLENBQUosRUFBd0M7QUFDdEMsVUFBTUMsU0FBUzk2QixPQUFPKzZCLHdCQUFQLENBQWdDRixNQUFoQyxFQUF3QyxLQUF4QyxFQUErQ3o1QixHQUE5RDtBQUNBLFVBQUkwNUIsVUFBVUEsT0FBT0UsY0FBckIsRUFBcUM7QUFDbkMsZUFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBT0gsT0FBT3JhLEdBQVAsS0FBZTNzQixTQUF0QjtBQUNEOztBQUVELFNBQVNvbkMsV0FBVCxDQUFxQkosTUFBckIsRUFBNkI7QUFDM0IsTUFBSWxuQyxJQUFKLEVBQWE7QUFDWCxRQUFJa00sZUFBZXZLLElBQWYsQ0FBb0J1bEMsTUFBcEIsRUFBNEIsS0FBNUIsQ0FBSixFQUF3QztBQUN0QyxVQUFNQyxTQUFTOTZCLE9BQU8rNkIsd0JBQVAsQ0FBZ0NGLE1BQWhDLEVBQXdDLEtBQXhDLEVBQStDejVCLEdBQTlEO0FBQ0EsVUFBSTA1QixVQUFVQSxPQUFPRSxjQUFyQixFQUFxQztBQUNuQyxlQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPSCxPQUFPeG9CLEdBQVAsS0FBZXhlLFNBQXRCO0FBQ0Q7O0FBRUQsU0FBU3FuQywwQkFBVCxDQUFvQy94QixLQUFwQyxFQUEyQy9RLFdBQTNDLEVBQXdEO0FBQ3RELE1BQU0raUMsd0JBQXdCLFNBQXhCQSxxQkFBd0IsR0FBVztBQUN2QyxRQUFJLENBQUNULDBCQUFMLEVBQWlDO0FBQy9CQSxtQ0FBNkIsSUFBN0I7QUFDQSx5Q0FDRSxLQURGLEVBRUUsOERBQ0UsZ0VBREYsR0FFRSxzRUFGRixHQUdFLDJDQUxKLEVBTUV0aUMsV0FORjtBQVFEO0FBQ0YsR0FaRDtBQWFBK2lDLHdCQUFzQkgsY0FBdEIsR0FBdUMsSUFBdkM7QUFDQWg3QixTQUFPTSxjQUFQLENBQXNCNkksS0FBdEIsRUFBNkIsS0FBN0IsRUFBb0M7QUFDbEMvSCxTQUFLKzVCLHFCQUQ2QjtBQUVsQ2o2QixrQkFBYztBQUZvQixHQUFwQztBQUlEOztBQUVELFNBQVNrNkIsMEJBQVQsQ0FBb0NqeUIsS0FBcEMsRUFBMkMvUSxXQUEzQyxFQUF3RDtBQUN0RCxNQUFNaWpDLHdCQUF3QixTQUF4QkEscUJBQXdCLEdBQVc7QUFDdkMsUUFBSSxDQUFDViwwQkFBTCxFQUFpQztBQUMvQkEsbUNBQTZCLElBQTdCO0FBQ0EseUNBQ0UsS0FERixFQUVFLDhEQUNFLGdFQURGLEdBRUUsc0VBRkYsR0FHRSwyQ0FMSixFQU1FdmlDLFdBTkY7QUFRRDtBQUNGLEdBWkQ7QUFhQWlqQyx3QkFBc0JMLGNBQXRCLEdBQXVDLElBQXZDO0FBQ0FoN0IsU0FBT00sY0FBUCxDQUFzQjZJLEtBQXRCLEVBQTZCLEtBQTdCLEVBQW9DO0FBQ2xDL0gsU0FBS2k2QixxQkFENkI7QUFFbENuNkIsa0JBQWM7QUFGb0IsR0FBcEM7QUFJRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEsSUFBTW82QixlQUFlLFNBQWZBLFlBQWUsQ0FBU2hqQyxJQUFULEVBQWUrWixHQUFmLEVBQW9CbU8sR0FBcEIsRUFBeUIrYSxJQUF6QixFQUErQjNnQyxNQUEvQixFQUF1Q0YsS0FBdkMsRUFBOEN5TyxLQUE5QyxFQUFxRDtBQUN4RSxNQUFNMFksVUFBVTtBQUNkO0FBQ0Evb0IsY0FBVWEsZ0NBRkk7O0FBSWQ7QUFDQXJCLFVBQU1BLElBTFE7QUFNZCtaLFNBQUtBLEdBTlM7QUFPZG1PLFNBQUtBLEdBUFM7QUFRZHJYLFdBQU9BLEtBUk87O0FBVWQ7QUFDQTJZLFlBQVFwbkI7QUFYTSxHQUFoQjs7QUFjQSxNQUFJL0csSUFBSixFQUFhO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQWt1QixZQUFRMlosTUFBUixHQUFpQixFQUFqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBeDdCLFdBQU9NLGNBQVAsQ0FBc0J1aEIsUUFBUTJaLE1BQTlCLEVBQXNDLFdBQXRDLEVBQW1EO0FBQ2pEdDZCLG9CQUFjLEtBRG1DO0FBRWpEdTZCLGtCQUFZLEtBRnFDO0FBR2pEQyxnQkFBVSxJQUh1QztBQUlqRDNqQixhQUFPO0FBSjBDLEtBQW5EO0FBTUE7QUFDQS9YLFdBQU9NLGNBQVAsQ0FBc0J1aEIsT0FBdEIsRUFBK0IsT0FBL0IsRUFBd0M7QUFDdEMzZ0Isb0JBQWMsS0FEd0I7QUFFdEN1NkIsa0JBQVksS0FGMEI7QUFHdENDLGdCQUFVLEtBSDRCO0FBSXRDM2pCLGFBQU93akI7QUFKK0IsS0FBeEM7QUFNQTtBQUNBO0FBQ0F2N0IsV0FBT00sY0FBUCxDQUFzQnVoQixPQUF0QixFQUErQixTQUEvQixFQUEwQztBQUN4QzNnQixvQkFBYyxLQUQwQjtBQUV4Q3U2QixrQkFBWSxLQUY0QjtBQUd4Q0MsZ0JBQVUsS0FIOEI7QUFJeEMzakIsYUFBT25kO0FBSmlDLEtBQTFDO0FBTUEsUUFBSW9GLE9BQU9zUixNQUFYLEVBQW1CO0FBQ2pCdFIsYUFBT3NSLE1BQVAsQ0FBY3VRLFFBQVExWSxLQUF0QjtBQUNBbkosYUFBT3NSLE1BQVAsQ0FBY3VRLE9BQWQ7QUFDRDtBQUNGOztBQUVELFNBQU9BLE9BQVA7QUFDRCxDQXRERDs7QUF3REE7Ozs7QUFJTyxTQUFTdFksYUFBVCxDQUF1QmpSLElBQXZCLEVBQTZCdWlDLE1BQTdCLEVBQXFDcFosUUFBckMsRUFBK0M7QUFDcEQsTUFBSTdoQixpQkFBSjs7QUFFQTtBQUNBLE1BQU11SixRQUFRLEVBQWQ7O0FBRUEsTUFBSWtKLE1BQU0sSUFBVjtBQUNBLE1BQUltTyxNQUFNLElBQVY7QUFDQSxNQUFJK2EsT0FBTyxJQUFYO0FBQ0EsTUFBSTNnQyxTQUFTLElBQWI7O0FBRUEsTUFBSWlnQyxVQUFVLElBQWQsRUFBb0I7QUFDbEIsUUFBSUQsWUFBWUMsTUFBWixDQUFKLEVBQXlCO0FBQ3ZCcmEsWUFBTXFhLE9BQU9yYSxHQUFiO0FBQ0Q7QUFDRCxRQUFJeWEsWUFBWUosTUFBWixDQUFKLEVBQXlCO0FBQ3ZCeG9CLFlBQU0sS0FBS3dvQixPQUFPeG9CLEdBQWxCO0FBQ0Q7O0FBRURrcEIsV0FBT1YsT0FBT0wsTUFBUCxLQUFrQjNtQyxTQUFsQixHQUE4QixJQUE5QixHQUFxQ2duQyxPQUFPTCxNQUFuRDtBQUNBNS9CLGFBQVNpZ0MsT0FBT0osUUFBUCxLQUFvQjVtQyxTQUFwQixHQUFnQyxJQUFoQyxHQUF1Q2duQyxPQUFPSixRQUF2RDtBQUNBO0FBQ0EsU0FBSzc2QixRQUFMLElBQWlCaTdCLE1BQWpCLEVBQXlCO0FBQ3ZCLFVBQ0VoN0IsZUFBZXZLLElBQWYsQ0FBb0J1bEMsTUFBcEIsRUFBNEJqN0IsUUFBNUIsS0FDQSxDQUFDMjZCLGVBQWUxNkIsY0FBZixDQUE4QkQsUUFBOUIsQ0FGSCxFQUdFO0FBQ0F1SixjQUFNdkosUUFBTixJQUFrQmk3QixPQUFPajdCLFFBQVAsQ0FBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLE1BQU0rN0IsaUJBQWlCNzZCLFVBQVVqTSxNQUFWLEdBQW1CLENBQTFDO0FBQ0EsTUFBSThtQyxtQkFBbUIsQ0FBdkIsRUFBMEI7QUFDeEJ4eUIsVUFBTXNZLFFBQU4sR0FBaUJBLFFBQWpCO0FBQ0QsR0FGRCxNQUVPLElBQUlrYSxpQkFBaUIsQ0FBckIsRUFBd0I7QUFDN0IsUUFBTUMsYUFBYXhsQixNQUFNdWxCLGNBQU4sQ0FBbkI7QUFDQSxTQUFLLElBQUlubkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbW5CLGNBQXBCLEVBQW9Dbm5CLEdBQXBDLEVBQXlDO0FBQ3ZDb25CLGlCQUFXcG5CLENBQVgsSUFBZ0IxVCxVQUFVMFQsSUFBSSxDQUFkLENBQWhCO0FBQ0Q7QUFDRCxRQUFJN2dCLElBQUosRUFBYTtBQUNYLFVBQUlxTSxPQUFPc1IsTUFBWCxFQUFtQjtBQUNqQnRSLGVBQU9zUixNQUFQLENBQWNzcUIsVUFBZDtBQUNEO0FBQ0Y7QUFDRHp5QixVQUFNc1ksUUFBTixHQUFpQm1hLFVBQWpCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJdGpDLFFBQVFBLEtBQUs2b0IsWUFBakIsRUFBK0I7QUFDN0IsUUFBTUEsZUFBZTdvQixLQUFLNm9CLFlBQTFCO0FBQ0EsU0FBS3ZoQixRQUFMLElBQWlCdWhCLFlBQWpCLEVBQStCO0FBQzdCLFVBQUloWSxNQUFNdkosUUFBTixNQUFvQi9MLFNBQXhCLEVBQW1DO0FBQ2pDc1YsY0FBTXZKLFFBQU4sSUFBa0J1aEIsYUFBYXZoQixRQUFiLENBQWxCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsTUFBSWpNLElBQUosRUFBYTtBQUNYLFFBQUkwZSxPQUFPbU8sR0FBWCxFQUFnQjtBQUNkLFVBQU1wb0IsY0FDSixPQUFPRSxJQUFQLEtBQWdCLFVBQWhCLEdBQ0lBLEtBQUtGLFdBQUwsSUFBb0JFLEtBQUs1RCxJQUF6QixJQUFpQyxTQURyQyxHQUVJNEQsSUFITjtBQUlBLFVBQUkrWixHQUFKLEVBQVM7QUFDUDZvQixtQ0FBMkIveEIsS0FBM0IsRUFBa0MvUSxXQUFsQztBQUNEO0FBQ0QsVUFBSW9vQixHQUFKLEVBQVM7QUFDUDRhLG1DQUEyQmp5QixLQUEzQixFQUFrQy9RLFdBQWxDO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBT2tqQyxhQUNMaGpDLElBREssRUFFTCtaLEdBRkssRUFHTG1PLEdBSEssRUFJTCthLElBSkssRUFLTDNnQyxNQUxLLEVBTUw4bkIsNEJBQWtCdm5CLE9BTmIsRUFPTGdPLEtBUEssQ0FBUDtBQVNEOztBQUVEOzs7O0FBSU8sU0FBU2d4QixhQUFULENBQXVCN2hDLElBQXZCLEVBQTZCO0FBQ2xDLE1BQU11akMsVUFBVXR5QixjQUFjc2QsSUFBZCxDQUFtQixJQUFuQixFQUF5QnZ1QixJQUF6QixDQUFoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXVqQyxVQUFRdmpDLElBQVIsR0FBZUEsSUFBZjtBQUNBLFNBQU91akMsT0FBUDtBQUNEOztBQUVNLFNBQVN6QixrQkFBVCxDQUE0QjBCLFVBQTVCLEVBQXdDQyxNQUF4QyxFQUFnRDtBQUNyRCxNQUFNQyxhQUFhVixhQUNqQlEsV0FBV3hqQyxJQURNLEVBRWpCeWpDLE1BRmlCLEVBR2pCRCxXQUFXdGIsR0FITSxFQUlqQnNiLFdBQVdHLEtBSk0sRUFLakJILFdBQVcvWixPQUxNLEVBTWpCK1osV0FBV2hhLE1BTk0sRUFPakJnYSxXQUFXM3lCLEtBUE0sQ0FBbkI7O0FBVUEsU0FBTzZ5QixVQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJTyxTQUFTM0IsWUFBVCxDQUFzQnhZLE9BQXRCLEVBQStCZ1osTUFBL0IsRUFBdUNwWixRQUF2QyxFQUFpRDtBQUN0RCwyQkFDRSxFQUFFSSxZQUFZLElBQVosSUFBb0JBLFlBQVlodUIsU0FBbEMsQ0FERixFQUVFLG1GQUZGLEVBR0VndUIsT0FIRjs7QUFNQSxNQUFJamlCLGlCQUFKOztBQUVBO0FBQ0EsTUFBTXVKLFFBQVFuSixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQjRoQixRQUFRMVksS0FBMUIsQ0FBZDs7QUFFQTtBQUNBLE1BQUlrSixNQUFNd1AsUUFBUXhQLEdBQWxCO0FBQ0EsTUFBSW1PLE1BQU1xQixRQUFRckIsR0FBbEI7QUFDQTtBQUNBLE1BQU0rYSxPQUFPMVosUUFBUW9hLEtBQXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTXJoQyxTQUFTaW5CLFFBQVFFLE9BQXZCOztBQUVBO0FBQ0EsTUFBSXJuQixRQUFRbW5CLFFBQVFDLE1BQXBCOztBQUVBLE1BQUkrWSxVQUFVLElBQWQsRUFBb0I7QUFDbEIsUUFBSUQsWUFBWUMsTUFBWixDQUFKLEVBQXlCO0FBQ3ZCO0FBQ0FyYSxZQUFNcWEsT0FBT3JhLEdBQWI7QUFDQTlsQixjQUFRZ29CLDRCQUFrQnZuQixPQUExQjtBQUNEO0FBQ0QsUUFBSTgvQixZQUFZSixNQUFaLENBQUosRUFBeUI7QUFDdkJ4b0IsWUFBTSxLQUFLd29CLE9BQU94b0IsR0FBbEI7QUFDRDs7QUFFRDtBQUNBLFFBQUk4TyxxQkFBSjtBQUNBLFFBQUlVLFFBQVF2cEIsSUFBUixJQUFnQnVwQixRQUFRdnBCLElBQVIsQ0FBYTZvQixZQUFqQyxFQUErQztBQUM3Q0EscUJBQWVVLFFBQVF2cEIsSUFBUixDQUFhNm9CLFlBQTVCO0FBQ0Q7QUFDRCxTQUFLdmhCLFFBQUwsSUFBaUJpN0IsTUFBakIsRUFBeUI7QUFDdkIsVUFDRWg3QixlQUFldkssSUFBZixDQUFvQnVsQyxNQUFwQixFQUE0Qmo3QixRQUE1QixLQUNBLENBQUMyNkIsZUFBZTE2QixjQUFmLENBQThCRCxRQUE5QixDQUZILEVBR0U7QUFDQSxZQUFJaTdCLE9BQU9qN0IsUUFBUCxNQUFxQi9MLFNBQXJCLElBQWtDc3RCLGlCQUFpQnR0QixTQUF2RCxFQUFrRTtBQUNoRTtBQUNBc1YsZ0JBQU12SixRQUFOLElBQWtCdWhCLGFBQWF2aEIsUUFBYixDQUFsQjtBQUNELFNBSEQsTUFHTztBQUNMdUosZ0JBQU12SixRQUFOLElBQWtCaTdCLE9BQU9qN0IsUUFBUCxDQUFsQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEO0FBQ0E7QUFDQSxNQUFNKzdCLGlCQUFpQjc2QixVQUFVak0sTUFBVixHQUFtQixDQUExQztBQUNBLE1BQUk4bUMsbUJBQW1CLENBQXZCLEVBQTBCO0FBQ3hCeHlCLFVBQU1zWSxRQUFOLEdBQWlCQSxRQUFqQjtBQUNELEdBRkQsTUFFTyxJQUFJa2EsaUJBQWlCLENBQXJCLEVBQXdCO0FBQzdCLFFBQU1DLGFBQWF4bEIsTUFBTXVsQixjQUFOLENBQW5CO0FBQ0EsU0FBSyxJQUFJbm5CLElBQUksQ0FBYixFQUFnQkEsSUFBSW1uQixjQUFwQixFQUFvQ25uQixHQUFwQyxFQUF5QztBQUN2Q29uQixpQkFBV3BuQixDQUFYLElBQWdCMVQsVUFBVTBULElBQUksQ0FBZCxDQUFoQjtBQUNEO0FBQ0RyTCxVQUFNc1ksUUFBTixHQUFpQm1hLFVBQWpCO0FBQ0Q7O0FBRUQsU0FBT04sYUFBYXpaLFFBQVF2cEIsSUFBckIsRUFBMkIrWixHQUEzQixFQUFnQ21PLEdBQWhDLEVBQXFDK2EsSUFBckMsRUFBMkMzZ0MsTUFBM0MsRUFBbURGLEtBQW5ELEVBQTBEeU8sS0FBMUQsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT08sU0FBU214QixjQUFULENBQXdCNEIsTUFBeEIsRUFBZ0M7QUFDckMsU0FDRSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQ0FBLFdBQVcsSUFEWCxJQUVBQSxPQUFPcGpDLFFBQVAsS0FBb0JhLGdDQUh0QjtBQUtELEM7Ozs7Ozs7Ozs7Ozs7UUNwV2V3aUMsZ0IsR0FBQUEsZ0I7UUE0REFDLHdCLEdBQUFBLHdCO1FBdURBQyxrQyxHQUFBQSxrQztRQWdCQUMscUIsR0FBQUEscUI7UUF3QkFDLGEsR0FBQUEsYTs7QUFuS2hCOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVPLElBQUlqMEIsc0VBQStCLElBQW5DLEMsQ0FYUDs7Ozs7OztBQVlPLElBQUlGLG9EQUFzQixJQUExQjtBQUNBLElBQUlDLG9EQUFzQixJQUExQjs7QUFFQSxTQUFTOHpCLGdCQUFULENBQ0xLLGdDQURLLEVBRUxDLHVCQUZLLEVBR0xDLHVCQUhLLEVBSUw7QUFDQSxVQVRTcDBCLDRCQVNULGtDQUErQmswQixnQ0FBL0I7QUFDQSxVQVRTcDBCLG1CQVNULHlCQUFzQnEwQix1QkFBdEI7QUFDQSxVQVRTcDBCLG1CQVNULHlCQUFzQnEwQix1QkFBdEI7QUFDQSxNQUFJL29DLElBQUosRUFBYTtBQUNYLHVDQUNFMFUsdUJBQXVCRCxtQkFEekIsRUFFRSxzREFDRSwrREFISjtBQUtEO0FBQ0Y7O0FBRUQsSUFBSXUwQixnQ0FBSjtBQUNBLElBQUlocEMsSUFBSixFQUFhO0FBQ1hncEMsNEJBQTBCLGlDQUFTbCtCLEtBQVQsRUFBZ0I7QUFDeEMsUUFBTW0rQixvQkFBb0JuK0IsTUFBTStCLGtCQUFoQztBQUNBLFFBQU1xOEIsb0JBQW9CcCtCLE1BQU1nQyxrQkFBaEM7O0FBRUEsUUFBTXE4QixpQkFBaUIxbUIsTUFBTTJtQixPQUFOLENBQWNILGlCQUFkLENBQXZCO0FBQ0EsUUFBTUksZUFBZUYsaUJBQ2pCRixrQkFBa0IvbkMsTUFERCxHQUVqQituQyxvQkFDRSxDQURGLEdBRUUsQ0FKTjs7QUFNQSxRQUFNSyxpQkFBaUI3bUIsTUFBTTJtQixPQUFOLENBQWNGLGlCQUFkLENBQXZCO0FBQ0EsUUFBTUssZUFBZUQsaUJBQ2pCSixrQkFBa0Job0MsTUFERCxHQUVqQmdvQyxvQkFDRSxDQURGLEdBRUUsQ0FKTjs7QUFNQSx1Q0FDRUksbUJBQW1CSCxjQUFuQixJQUFxQ0ksaUJBQWlCRixZQUR4RCxFQUVFLG9DQUZGO0FBSUQsR0F0QkQ7QUF1QkQ7O0FBRUQ7Ozs7OztBQU1BLFNBQVNHLGVBQVQsQ0FBeUIxK0IsS0FBekIsRUFBZ0MrUixRQUFoQyxFQUEwQ3ZILElBQTFDLEVBQWdEO0FBQzlDLE1BQU0zUSxPQUFPbUcsTUFBTW5HLElBQU4sSUFBYyxlQUEzQjtBQUNBbUcsUUFBTUwsYUFBTixHQUFzQmlLLG9CQUFvQlksSUFBcEIsQ0FBdEI7QUFDQSxnRUFBd0MzUSxJQUF4QyxFQUE4Q2tZLFFBQTlDLEVBQXdEM2MsU0FBeEQsRUFBbUU0SyxLQUFuRTtBQUNBQSxRQUFNTCxhQUFOLEdBQXNCLElBQXRCO0FBQ0Q7O0FBRUQ7OztBQUdPLFNBQVNnK0Isd0JBQVQsQ0FBa0MzOUIsS0FBbEMsRUFBeUM7QUFDOUMsTUFBTW0rQixvQkFBb0JuK0IsTUFBTStCLGtCQUFoQztBQUNBLE1BQU1xOEIsb0JBQW9CcCtCLE1BQU1nQyxrQkFBaEM7QUFDQSxNQUFJOU0sSUFBSixFQUFhO0FBQ1hncEMsNEJBQXdCbCtCLEtBQXhCO0FBQ0Q7QUFDRCxNQUFJMlgsTUFBTTJtQixPQUFOLENBQWNILGlCQUFkLENBQUosRUFBc0M7QUFDcEMsU0FBSyxJQUFJcG9CLElBQUksQ0FBYixFQUFnQkEsSUFBSW9vQixrQkFBa0IvbkMsTUFBdEMsRUFBOEMyZixHQUE5QyxFQUFtRDtBQUNqRCxVQUFJL1YsTUFBTWUsb0JBQU4sRUFBSixFQUFrQztBQUNoQztBQUNEO0FBQ0Q7QUFDQTI5QixzQkFBZ0IxK0IsS0FBaEIsRUFBdUJtK0Isa0JBQWtCcG9CLENBQWxCLENBQXZCLEVBQTZDcW9CLGtCQUFrQnJvQixDQUFsQixDQUE3QztBQUNEO0FBQ0YsR0FSRCxNQVFPLElBQUlvb0IsaUJBQUosRUFBdUI7QUFDNUJPLG9CQUFnQjErQixLQUFoQixFQUF1Qm0rQixpQkFBdkIsRUFBMENDLGlCQUExQztBQUNEO0FBQ0RwK0IsUUFBTStCLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0EvQixRQUFNZ0Msa0JBQU4sR0FBMkIsSUFBM0I7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVMyOEIsc0NBQVQsQ0FBZ0QzK0IsS0FBaEQsRUFBdUQ7QUFDckQsTUFBTW0rQixvQkFBb0JuK0IsTUFBTStCLGtCQUFoQztBQUNBLE1BQU1xOEIsb0JBQW9CcCtCLE1BQU1nQyxrQkFBaEM7QUFDQSxNQUFJOU0sSUFBSixFQUFhO0FBQ1hncEMsNEJBQXdCbCtCLEtBQXhCO0FBQ0Q7QUFDRCxNQUFJMlgsTUFBTTJtQixPQUFOLENBQWNILGlCQUFkLENBQUosRUFBc0M7QUFDcEMsU0FBSyxJQUFJcG9CLElBQUksQ0FBYixFQUFnQkEsSUFBSW9vQixrQkFBa0IvbkMsTUFBdEMsRUFBOEMyZixHQUE5QyxFQUFtRDtBQUNqRCxVQUFJL1YsTUFBTWUsb0JBQU4sRUFBSixFQUFrQztBQUNoQztBQUNEO0FBQ0Q7QUFDQSxVQUFJbzlCLGtCQUFrQnBvQixDQUFsQixFQUFxQi9WLEtBQXJCLEVBQTRCbytCLGtCQUFrQnJvQixDQUFsQixDQUE1QixDQUFKLEVBQXVEO0FBQ3JELGVBQU9xb0Isa0JBQWtCcm9CLENBQWxCLENBQVA7QUFDRDtBQUNGO0FBQ0YsR0FWRCxNQVVPLElBQUlvb0IsaUJBQUosRUFBdUI7QUFDNUIsUUFBSUEsa0JBQWtCbitCLEtBQWxCLEVBQXlCbytCLGlCQUF6QixDQUFKLEVBQWlEO0FBQy9DLGFBQU9BLGlCQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVEOzs7QUFHTyxTQUFTUixrQ0FBVCxDQUE0QzU5QixLQUE1QyxFQUFtRDtBQUN4RCxNQUFNNCtCLE1BQU1ELHVDQUF1QzMrQixLQUF2QyxDQUFaO0FBQ0FBLFFBQU1nQyxrQkFBTixHQUEyQixJQUEzQjtBQUNBaEMsUUFBTStCLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0EsU0FBTzY4QixHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVNmLHFCQUFULENBQStCNzlCLEtBQS9CLEVBQXNDO0FBQzNDLE1BQUk5SyxJQUFKLEVBQWE7QUFDWGdwQyw0QkFBd0JsK0IsS0FBeEI7QUFDRDtBQUNELE1BQU02K0IsbUJBQW1CNytCLE1BQU0rQixrQkFBL0I7QUFDQSxNQUFNKzhCLG1CQUFtQjkrQixNQUFNZ0Msa0JBQS9CO0FBQ0EsMkJBQ0UsQ0FBQzJWLE1BQU0ybUIsT0FBTixDQUFjTyxnQkFBZCxDQURILEVBRUUsOENBRkY7QUFJQTcrQixRQUFNTCxhQUFOLEdBQXNCay9CLG1CQUNsQmoxQixvQkFBb0JrMUIsZ0JBQXBCLENBRGtCLEdBRWxCLElBRko7QUFHQSxNQUFNQyxNQUFNRixtQkFBbUJBLGlCQUFpQjcrQixLQUFqQixDQUFuQixHQUE2QyxJQUF6RDtBQUNBQSxRQUFNTCxhQUFOLEdBQXNCLElBQXRCO0FBQ0FLLFFBQU0rQixrQkFBTixHQUEyQixJQUEzQjtBQUNBL0IsUUFBTWdDLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0EsU0FBTys4QixHQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJTyxTQUFTakIsYUFBVCxDQUF1Qjk5QixLQUF2QixFQUE4QjtBQUNuQyxTQUFPLENBQUMsQ0FBQ0EsTUFBTStCLGtCQUFmO0FBQ0QsQzs7Ozs7Ozs7Ozs7O1FDckllaTlCLHdCLEdBQUFBLHdCO1FBTUFDLG1CLEdBQUFBLG1CO1FBWUFDLGlCLEdBQUFBLGlCO1FBSUFDLG9CLEdBQUFBLG9COztBQXBEaEI7Ozs7QUFFQTs7OztBQUtBOztBQWhCQTs7Ozs7Ozs7O0FBa0JBLElBQUlDLGNBQWMsSUFBbEI7QUFDQSxJQUFJQyxnQkFBZ0IsSUFBcEI7QUFDQSxJQUFJQyxlQUFlLElBQW5COztBQUVBLFNBQVNDLG9CQUFULENBQThCNy9CLE1BQTlCLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQSxNQUFNOC9CLG1CQUFtQiwyQ0FBb0I5L0IsTUFBcEIsQ0FBekI7QUFDQSxNQUFJLENBQUM4L0IsZ0JBQUwsRUFBdUI7QUFDckI7QUFDQTtBQUNEO0FBQ0QsMkJBQ0UsT0FBT0osV0FBUCxLQUF1QixVQUR6QixFQUVFLHFGQUNFLDhFQUhKO0FBS0EsTUFBTTEwQixRQUFRLG9EQUE2QjgwQixpQkFBaUIvMEIsU0FBOUMsQ0FBZDtBQUNBMjBCLGNBQVlJLGlCQUFpQi8wQixTQUE3QixFQUF3QyswQixpQkFBaUIzbEMsSUFBekQsRUFBK0Q2USxLQUEvRDtBQUNEOztBQUVNLFNBQVNzMEIsd0JBQVQsQ0FDTDlELElBREssRUFFQztBQUNOa0UsZ0JBQWNsRSxJQUFkO0FBQ0Q7O0FBRU0sU0FBUytELG1CQUFULENBQTZCdi9CLE1BQTdCLEVBQXdEO0FBQzdELE1BQUkyL0IsYUFBSixFQUFtQjtBQUNqQixRQUFJQyxZQUFKLEVBQWtCO0FBQ2hCQSxtQkFBYTk3QixJQUFiLENBQWtCOUQsTUFBbEI7QUFDRCxLQUZELE1BRU87QUFDTDQvQixxQkFBZSxDQUFDNS9CLE1BQUQsQ0FBZjtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0wyL0Isb0JBQWdCMy9CLE1BQWhCO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTdy9CLGlCQUFULEdBQXNDO0FBQzNDLFNBQU9HLGtCQUFrQixJQUFsQixJQUEwQkMsaUJBQWlCLElBQWxEO0FBQ0Q7O0FBRU0sU0FBU0gsb0JBQVQsR0FBZ0M7QUFDckMsTUFBSSxDQUFDRSxhQUFMLEVBQW9CO0FBQ2xCO0FBQ0Q7QUFDRCxNQUFNMy9CLFNBQVMyL0IsYUFBZjtBQUNBLE1BQU1JLGdCQUFnQkgsWUFBdEI7QUFDQUQsa0JBQWdCLElBQWhCO0FBQ0FDLGlCQUFlLElBQWY7O0FBRUFDLHVCQUFxQjcvQixNQUFyQjtBQUNBLE1BQUkrL0IsYUFBSixFQUFtQjtBQUNqQixTQUFLLElBQUkxcEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMHBCLGNBQWNycEMsTUFBbEMsRUFBMEMyZixHQUExQyxFQUErQztBQUM3Q3dwQiwyQkFBcUJFLGNBQWMxcEIsQ0FBZCxDQUFyQjtBQUNEO0FBQ0Y7QUFDRixDOzs7Ozs7Ozs7Ozs7UUNoRGV5YSxjLEdBQUFBLGM7UUEwQkFJLGtCLEdBQUFBLGtCO1FBSUFDLHVCLEdBQUFBLHVCO1FBSUE2Tyx5QixHQUFBQSx5Qjs7QUF2RGhCOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJQyxzQkFBc0IsNkJBQVM3UixFQUFULEVBQWE4UixXQUFiLEVBQTBCO0FBQ2xELFNBQU85UixHQUFHOFIsV0FBSCxDQUFQO0FBQ0QsQ0FGRCxDLENBbkJBOzs7Ozs7O0FBc0JBLElBQUlDLDBCQUEwQixpQ0FBUy9SLEVBQVQsRUFBYXY0QixDQUFiLEVBQWdCQyxDQUFoQixFQUFtQjtBQUMvQyxTQUFPczRCLEdBQUd2NEIsQ0FBSCxFQUFNQyxDQUFOLENBQVA7QUFDRCxDQUZEO0FBR0EsSUFBSXNxQywrQkFBK0Isd0NBQVcsQ0FBRSxDQUFoRDs7QUFFQSxJQUFJQyxhQUFhLEtBQWpCO0FBQ08sU0FBU3ZQLGNBQVQsQ0FBd0IxQyxFQUF4QixFQUE0QjhSLFdBQTVCLEVBQXlDO0FBQzlDLE1BQUlHLFVBQUosRUFBZ0I7QUFDZDtBQUNBO0FBQ0EsV0FBT2pTLEdBQUc4UixXQUFILENBQVA7QUFDRDtBQUNERyxlQUFhLElBQWI7QUFDQSxNQUFJO0FBQ0YsV0FBT0osb0JBQW9CN1IsRUFBcEIsRUFBd0I4UixXQUF4QixDQUFQO0FBQ0QsR0FGRCxTQUVVO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQUcsaUJBQWEsS0FBYjtBQUNBLFFBQU1DLHlDQUF5QyxrREFBL0M7QUFDQSxRQUFJQSxzQ0FBSixFQUE0QztBQUMxQztBQUNBO0FBQ0E7QUFDQUY7QUFDQTtBQUNEO0FBQ0Y7QUFDRjs7QUFFTSxTQUFTbFAsa0JBQVQsQ0FBNEI5QyxFQUE1QixFQUFnQ3Y0QixDQUFoQyxFQUFtQ0MsQ0FBbkMsRUFBc0M7QUFDM0MsU0FBT3FxQyx3QkFBd0IvUixFQUF4QixFQUE0QnY0QixDQUE1QixFQUErQkMsQ0FBL0IsQ0FBUDtBQUNEOztBQUVNLFNBQVNxN0IsdUJBQVQsR0FBbUM7QUFDeEMsU0FBT2lQLDhCQUFQO0FBQ0Q7O0FBRU0sU0FBU0oseUJBQVQsQ0FDTE8sa0JBREssRUFFTEMsc0JBRkssRUFHTEMsMkJBSEssRUFJTDtBQUNBUix3QkFBc0JNLGtCQUF0QjtBQUNBSiw0QkFBMEJLLHNCQUExQjtBQUNBSixpQ0FBK0JLLDJCQUEvQjtBQUNELEM7Ozs7Ozs7Ozs7OztRQ21DZUMsSyxHQUFBQSxLO1FBU0FDLG9CLEdBQUFBLG9CO1FBcUJBQyxZLEdBQUFBLFk7OztBQXRIaEIsU0FBU0MsV0FBVCxDQUFxQkMsSUFBckIsRUFBNkM7QUFDM0MsTUFBTTNtQyxPQUFPMm1DLEtBQUszbUMsSUFBbEI7QUFDQSxNQUFNNG1DLFdBQVdELEtBQUtDLFFBQXRCO0FBQ0EsU0FDRUEsWUFDQUEsU0FBU2xwQixXQUFULE9BQTJCLE9BRDNCLEtBRUMxZCxTQUFTLFVBQVQsSUFBdUJBLFNBQVMsT0FGakMsQ0FERjtBQUtELEMsQ0F6QkQ7Ozs7Ozs7OztBQTJCQSxTQUFTNm1DLFVBQVQsQ0FBb0Jsa0MsSUFBcEIsRUFBbUQ7QUFDakQsU0FBT0EsS0FBS21rQyxhQUFaO0FBQ0Q7O0FBRUQsU0FBU0MsYUFBVCxDQUF1QnBrQyxJQUF2QixFQUFzRDtBQUNwREEsT0FBS21rQyxhQUFMLEdBQXFCLElBQXJCO0FBQ0Q7O0FBRUQsU0FBU0UsZ0JBQVQsQ0FBMEJya0MsSUFBMUIsRUFBMEQ7QUFDeEQsTUFBSThjLFFBQVEsRUFBWjtBQUNBLE1BQUksQ0FBQzljLElBQUwsRUFBVztBQUNULFdBQU84YyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSWluQixZQUFZL2pDLElBQVosQ0FBSixFQUF1QjtBQUNyQjhjLFlBQVE5YyxLQUFLc2tDLE9BQUwsR0FBZSxNQUFmLEdBQXdCLE9BQWhDO0FBQ0QsR0FGRCxNQUVPO0FBQ0x4bkIsWUFBUTljLEtBQUs4YyxLQUFiO0FBQ0Q7O0FBRUQsU0FBT0EsS0FBUDtBQUNEOztBQUVELFNBQVN5bkIsZ0JBQVQsQ0FBMEJ2a0MsSUFBMUIsRUFBb0Q7QUFDbEQsTUFBTXdrQyxhQUFhVCxZQUFZL2pDLElBQVosSUFBb0IsU0FBcEIsR0FBZ0MsT0FBbkQ7QUFDQSxNQUFNeWtDLGFBQWExL0IsT0FBTys2Qix3QkFBUCxDQUNqQjkvQixLQUFLMEUsV0FBTCxDQUFpQnZLLFNBREEsRUFFakJxcUMsVUFGaUIsQ0FBbkI7O0FBS0EsTUFBSTd3QixlQUFlLEtBQUszVCxLQUFLd2tDLFVBQUwsQ0FBeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUNFeGtDLEtBQUs0RSxjQUFMLENBQW9CNC9CLFVBQXBCLEtBQ0EsT0FBT0MsVUFBUCxLQUFzQixXQUR0QixJQUVBLE9BQU9BLFdBQVd0K0IsR0FBbEIsS0FBMEIsVUFGMUIsSUFHQSxPQUFPcytCLFdBQVd2K0IsR0FBbEIsS0FBMEIsVUFKNUIsRUFLRTtBQUNBO0FBQ0Q7QUFwQmlELE1BcUIzQ0MsSUFyQjJDLEdBcUIvQnMrQixVQXJCK0IsQ0FxQjNDdCtCLEdBckIyQztBQUFBLE1BcUJ0Q0QsSUFyQnNDLEdBcUIvQnUrQixVQXJCK0IsQ0FxQnRDditCLEdBckJzQzs7QUFzQmxEbkIsU0FBT00sY0FBUCxDQUFzQnJGLElBQXRCLEVBQTRCd2tDLFVBQTVCLEVBQXdDO0FBQ3RDditCLGtCQUFjLElBRHdCO0FBRXRDRSxTQUFLLGVBQVc7QUFDZCxhQUFPQSxLQUFJOUwsSUFBSixDQUFTLElBQVQsQ0FBUDtBQUNELEtBSnFDO0FBS3RDNkwsU0FBSyxhQUFTNFcsS0FBVCxFQUFnQjtBQUNuQm5KLHFCQUFlLEtBQUttSixLQUFwQjtBQUNBNVcsV0FBSTdMLElBQUosQ0FBUyxJQUFULEVBQWV5aUIsS0FBZjtBQUNEO0FBUnFDLEdBQXhDO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQS9YLFNBQU9NLGNBQVAsQ0FBc0JyRixJQUF0QixFQUE0QndrQyxVQUE1QixFQUF3QztBQUN0Q2hFLGdCQUFZaUUsV0FBV2pFO0FBRGUsR0FBeEM7O0FBSUEsTUFBTWtFLFVBQVU7QUFDZEMsWUFEYyxzQkFDSDtBQUNULGFBQU9oeEIsWUFBUDtBQUNELEtBSGE7QUFJZGl4QixZQUpjLG9CQUlMOW5CLEtBSkssRUFJRTtBQUNkbkoscUJBQWUsS0FBS21KLEtBQXBCO0FBQ0QsS0FOYTtBQU9kZ25CLGdCQVBjLDBCQU9DO0FBQ2JNLG9CQUFjcGtDLElBQWQ7QUFDQSxhQUFPQSxLQUFLd2tDLFVBQUwsQ0FBUDtBQUNEO0FBVmEsR0FBaEI7QUFZQSxTQUFPRSxPQUFQO0FBQ0Q7O0FBRU0sU0FBU2QsS0FBVCxDQUFlNWpDLElBQWYsRUFBOEM7QUFDbkQsTUFBSWtrQyxXQUFXbGtDLElBQVgsQ0FBSixFQUFzQjtBQUNwQjtBQUNEOztBQUVEO0FBQ0FBLE9BQUtta0MsYUFBTCxHQUFxQkksaUJBQWlCdmtDLElBQWpCLENBQXJCO0FBQ0Q7O0FBRU0sU0FBUzZqQyxvQkFBVCxDQUE4QjdqQyxJQUE5QixFQUE2RDtBQUNsRSxNQUFJLENBQUNBLElBQUwsRUFBVztBQUNULFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQU0wa0MsVUFBVVIsV0FBV2xrQyxJQUFYLENBQWhCO0FBQ0E7QUFDQTtBQUNBLE1BQUksQ0FBQzBrQyxPQUFMLEVBQWM7QUFDWixXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFNRyxZQUFZSCxRQUFRQyxRQUFSLEVBQWxCO0FBQ0EsTUFBTXZ4QixZQUFZaXhCLGlCQUFpQnJrQyxJQUFqQixDQUFsQjtBQUNBLE1BQUlvVCxjQUFjeXhCLFNBQWxCLEVBQTZCO0FBQzNCSCxZQUFRRSxRQUFSLENBQWlCeHhCLFNBQWpCO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFTSxTQUFTMHdCLFlBQVQsQ0FBc0I5akMsSUFBdEIsRUFBcUQ7QUFDMUQsTUFBTTBrQyxVQUFVUixXQUFXbGtDLElBQVgsQ0FBaEI7QUFDQSxNQUFJMGtDLE9BQUosRUFBYTtBQUNYQSxZQUFRWixZQUFSO0FBQ0Q7QUFDRixDOzs7Ozs7Ozs7Ozs7O0FDcklEOzs7O0FBQ0E7Ozs7OztBQVJBOzs7Ozs7O0FBVUEsSUFBSXJwQyx5QkFBeUIsSUFBN0I7O0FBRUEsSUFBTXFxQyxnQ0FBZ0M7QUFDcEM1UCxrQkFBZ0I7QUFEb0IsQ0FBdEM7O0FBSUEsSUFBSXg4QixJQUFKLEVBQWE7QUFDWCtCLDJCQUF5QkMsK0JBQXFCRCxzQkFBOUM7O0FBRUEsTUFBTXNxQyxtQkFBbUI7QUFDdkJqbUIsWUFBUSxJQURlO0FBRXZCa21CLGNBQVUsSUFGYTtBQUd2QkMsV0FBTyxJQUhnQjtBQUl2QkMsWUFBUSxJQUplO0FBS3ZCQyxXQUFPLElBTGdCO0FBTXZCQyxXQUFPLElBTmdCO0FBT3ZCQyxZQUFRO0FBUGUsR0FBekI7O0FBVUEsTUFBTXpNLFlBQVk7QUFDaEI5YixXQUFPLGVBQVM1TyxLQUFULEVBQWdCdkosUUFBaEIsRUFBMEJtVCxhQUExQixFQUF5QztBQUM5QyxVQUNFaXRCLGlCQUFpQjcyQixNQUFNN1EsSUFBdkIsS0FDQTZRLE1BQU1vM0IsUUFETixJQUVBcDNCLE1BQU1xM0IsUUFGTixJQUdBcjNCLE1BQU1nTCxRQUhOLElBSUFoTCxNQUFNdkosUUFBTixLQUFtQixJQUxyQixFQU1FO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQUk5TCxLQUFKLENBQ0wsNERBQ0UsNkRBREYsR0FFRSw2REFGRixHQUdFLHNDQUpHLENBQVA7QUFNRCxLQWpCZTtBQWtCaEJ5ckMsYUFBUyxpQkFBU3AyQixLQUFULEVBQWdCdkosUUFBaEIsRUFBMEJtVCxhQUExQixFQUF5QztBQUNoRCxVQUNFNUosTUFBTW8zQixRQUFOLElBQ0FwM0IsTUFBTXEzQixRQUROLElBRUFyM0IsTUFBTWdMLFFBRk4sSUFHQWhMLE1BQU12SixRQUFOLEtBQW1CLElBSnJCLEVBS0U7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNELGFBQU8sSUFBSTlMLEtBQUosQ0FDTCw4REFDRSw2REFERixHQUVFLCtEQUZGLEdBR0Usc0NBSkcsQ0FBUDtBQU1EO0FBakNlLEdBQWxCOztBQW9DQTs7OztBQUlBaXNDLGdDQUE4QjVQLGNBQTlCLEdBQStDLFVBQVNzUSxPQUFULEVBQWtCdDNCLEtBQWxCLEVBQXlCO0FBQ3RFLGtDQUNFMHFCLFNBREYsRUFFRTFxQixLQUZGLEVBR0UsTUFIRixFQUlFczNCLE9BSkYsRUFLRS9xQyx1QkFBdUJHLGdCQUx6QjtBQU9ELEdBUkQ7QUFTRDs7a0JBRWNrcUMsNkI7Ozs7Ozs7Ozs7Ozs7O0FDaEVmLElBQU1XLG9CQUFvQjtBQUN4QkMsT0FBSyxRQURtQjtBQUV4QkMsV0FBUyxTQUZlO0FBR3hCQyxRQUFNLFNBSGtCO0FBSXhCQyxTQUFPO0FBSmlCLENBQTFCOztBQU9BO0FBQ0E7QUFDQTtBQXpCQTs7Ozs7Ozs7O0FBU0E7Ozs7O0FBaUJBLFNBQVNDLG1CQUFULENBQTZCQyxNQUE3QixFQUFzRDtBQUNwRCxNQUFNQyxpQkFBaUIsSUFBdkI7QUFDQSxNQUFNOWhDLGNBQWM4aEMsZUFBZTloQyxXQUFuQztBQUNBLE1BQUlBLFlBQVkwYSxnQkFBaEIsRUFBa0M7QUFDaEMsV0FBTzFhLFlBQVkwYSxnQkFBWixDQUE2Qm1uQixNQUE3QixDQUFQO0FBQ0Q7QUFDRCxNQUFNRSxVQUFVUixrQkFBa0JNLE1BQWxCLENBQWhCO0FBQ0EsU0FBT0UsVUFBVSxDQUFDLENBQUMvaEMsWUFBWStoQyxPQUFaLENBQVosR0FBbUMsS0FBMUM7QUFDRDs7QUFFRCxTQUFTcG5CLHFCQUFULENBQ0UzYSxXQURGLEVBRStCO0FBQzdCLFNBQU80aEMsbUJBQVA7QUFDRDs7a0JBRWNqbkIscUI7Ozs7Ozs7Ozs7Ozs7OFFDMUNmOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FBRUEsSUFBTWphLGlCQUFpQkcsT0FBTzVLLFNBQVAsQ0FBaUJ5SyxjQUF4Qzs7QUFFQTs7Ozs7QUFLQSxTQUFTdzBCLFlBQVQsQ0FBc0I4TSxJQUF0QixFQUFtQ0MsSUFBbkMsRUFBeUQ7QUFDdkQsTUFBSSx3QkFBR0QsSUFBSCxFQUFTQyxJQUFULENBQUosRUFBb0I7QUFDbEIsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFDRSxRQUFPRCxJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQWhCLElBQ0FBLFNBQVMsSUFEVCxJQUVBLFFBQU9DLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFGaEIsSUFHQUEsU0FBUyxJQUpYLEVBS0U7QUFDQSxXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFNQyxRQUFRcmhDLE9BQU80aEIsSUFBUCxDQUFZdWYsSUFBWixDQUFkO0FBQ0EsTUFBTUcsUUFBUXRoQyxPQUFPNGhCLElBQVAsQ0FBWXdmLElBQVosQ0FBZDs7QUFFQSxNQUFJQyxNQUFNeHNDLE1BQU4sS0FBaUJ5c0MsTUFBTXpzQyxNQUEzQixFQUFtQztBQUNqQyxXQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNBLE9BQUssSUFBSTJmLElBQUksQ0FBYixFQUFnQkEsSUFBSTZzQixNQUFNeHNDLE1BQTFCLEVBQWtDMmYsR0FBbEMsRUFBdUM7QUFDckMsUUFDRSxDQUFDM1UsZUFBZXZLLElBQWYsQ0FBb0I4ckMsSUFBcEIsRUFBMEJDLE1BQU03c0IsQ0FBTixDQUExQixDQUFELElBQ0EsQ0FBQyx3QkFBRzJzQixLQUFLRSxNQUFNN3NCLENBQU4sQ0FBTCxDQUFILEVBQW1CNHNCLEtBQUtDLE1BQU03c0IsQ0FBTixDQUFMLENBQW5CLENBRkgsRUFHRTtBQUNBLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7O2tCQUVjNmYsWTs7Ozs7Ozs7Ozs7O0FDcERmOzs7Ozs7Ozs7QUFTQTs7OztBQUlBLFNBQVNrTixFQUFULENBQVkvckMsQ0FBWixFQUFvQmdzQyxDQUFwQixFQUE0QjtBQUMxQixTQUNHaHNDLE1BQU1nc0MsQ0FBTixLQUFZaHNDLE1BQU0sQ0FBTixJQUFXLElBQUlBLENBQUosS0FBVSxJQUFJZ3NDLENBQXJDLENBQUQsSUFBOENoc0MsTUFBTUEsQ0FBTixJQUFXZ3NDLE1BQU1BLENBRGpFLENBQ29FO0FBRHBFO0FBR0Q7O2tCQUVjRCxFOzs7Ozs7Ozs7Ozs7QUNuQmY7Ozs7Ozs7QUFPQTs7Ozs7Ozs7OztBQVVBLFNBQVNFLGdCQUFULENBQTBCdGlDLFdBQTFCLEVBQXVDO0FBQ3JDLE1BQUl1aUMsaUJBQUo7QUFDQSxNQUFNQyxVQUFVeGlDLFlBQVl3aUMsT0FBNUI7O0FBRUEsTUFBSSxjQUFjeGlDLFdBQWxCLEVBQStCO0FBQzdCdWlDLGVBQVd2aUMsWUFBWXVpQyxRQUF2Qjs7QUFFQTtBQUNBLFFBQUlBLGFBQWEsQ0FBYixJQUFrQkMsWUFBWSxFQUFsQyxFQUFzQztBQUNwQ0QsaUJBQVcsRUFBWDtBQUNEO0FBQ0YsR0FQRCxNQU9PO0FBQ0w7QUFDQUEsZUFBV0MsT0FBWDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxNQUFJRCxhQUFhLEVBQWpCLEVBQXFCO0FBQ25CQSxlQUFXLEVBQVg7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSUEsWUFBWSxFQUFaLElBQWtCQSxhQUFhLEVBQW5DLEVBQXVDO0FBQ3JDLFdBQU9BLFFBQVA7QUFDRDs7QUFFRCxTQUFPLENBQVA7QUFDRDs7a0JBRWNELGdCOzs7Ozs7Ozs7Ozs7QUNoRGY7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtrQkFDZSxVOzs7Ozs7Ozs7Ozs7O0FDRGY7O0FBRUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUFoQkE7Ozs7Ozs7OztBQTJCQSxJQUFNNWMsMEJBQTBCO0FBQzlCQyx3QkFEOEIsb0NBQ0MsQ0FBRSxDQURIO0FBRTlCUyxpQ0FGOEIsNkNBRVUsQ0FBRSxDQUZaO0FBRzlCRixxQ0FIOEIsaURBR2MsQ0FBRSxDQUhoQjtBQUk5QnVjLDJCQUo4QixxQ0FJSm5uQyxLQUpJLEVBSVVxSCxRQUpWLEVBSStCLENBQUUsQ0FKakM7QUFLOUIrL0IsK0JBTDhCLHlDQUtBcG5DLEtBTEEsRUFLY3FILFFBTGQsRUFLbUMsQ0FBRSxDQUxyQztBQU05QnEwQiw0QkFOOEIsc0NBTUgxN0IsS0FORyxFQU1XcUgsUUFOWCxFQU1nQyxDQUFFLENBTmxDO0FBTzlCd2pCLDJCQVA4Qix1Q0FPSSxDQUFFO0FBUE4sQ0FBaEM7O0FBVUEsSUFBSTN4QixJQUFKLEVBQWE7QUFDWCxNQUFNbXVDLHdCQUF3QjtBQUM1QkMsK0JBQTJCLG1CQURDO0FBRTVCQyxzQ0FBa0MsaUNBRk47QUFHNUJDLGdDQUE0QjtBQUhBLEdBQTlCOztBQU1BLE1BQUlDLG9DQUFrRCxFQUF0RDtBQUNBLE1BQUlDLDJDQUF5RCxFQUE3RDtBQUNBLE1BQUlDLHFDQUFtRCxFQUF2RDtBQUNBLE1BQUlDLGlDQUFzRCxJQUFJcGlCLEdBQUosRUFBMUQ7QUFDQSxNQUFJcWlCLDhCQUF5RCxJQUFJcmlCLEdBQUosRUFBN0Q7O0FBRUE7QUFDQSxNQUFNc2lCLG1DQUFtQyxJQUFJeGxCLEdBQUosRUFBekM7QUFDQSxNQUFNeWxCLCtCQUErQixJQUFJemxCLEdBQUosRUFBckM7QUFDQSxNQUFNMGxCLDRCQUE0QixJQUFJMWxCLEdBQUosRUFBbEM7O0FBRUEsTUFBTTJsQixvQkFBb0IsU0FBcEJBLGlCQUFvQixNQUFPO0FBQy9CLFFBQU1DLFFBQVEsRUFBZDtBQUNBeGhDLFFBQUlxWCxPQUFKLENBQVksaUJBQVM7QUFDbkJtcUIsWUFBTTFnQyxJQUFOLENBQVc4VixLQUFYO0FBQ0QsS0FGRDtBQUdBLFdBQU80cUIsTUFBTUMsSUFBTixHQUFhQyxJQUFiLENBQWtCLElBQWxCLENBQVA7QUFDRCxHQU5EOztBQVFBaGUsMEJBQXdCQyxzQkFBeEIsR0FBaUQsWUFBTTtBQUNyRG9kLHdDQUFvQyxFQUFwQztBQUNBQywrQ0FBMkMsRUFBM0M7QUFDQUMseUNBQXFDLEVBQXJDO0FBQ0FDLHFDQUFpQyxJQUFJcGlCLEdBQUosRUFBakM7QUFDQXFpQixrQ0FBOEIsSUFBSXJpQixHQUFKLEVBQTlCO0FBQ0QsR0FORDs7QUFRQTRFLDBCQUF3QlEsbUNBQXhCLEdBQThELFlBQU07QUFDaEVnZCxrQ0FBRixDQUE2RDdwQixPQUE3RCxDQUNFLFVBQUNzcUIsb0JBQUQsRUFBdUJDLFVBQXZCLEVBQXNDO0FBQ3BDLFVBQU1DLDRCQUE0QixFQUFsQzs7QUFFQWhqQyxhQUFPNGhCLElBQVAsQ0FBWWtoQixvQkFBWixFQUFrQ3RxQixPQUFsQyxDQUEwQyxxQkFBYTtBQUNyRCxZQUFNeXFCLG9CQUFvQkgscUJBQXFCSSxTQUFyQixDQUExQjtBQUNBLFlBQUlELGtCQUFrQnB1QyxNQUFsQixHQUEyQixDQUEvQixFQUFrQztBQUNoQyxjQUFNc3VDLGlCQUFpQixJQUFJcG1CLEdBQUosRUFBdkI7QUFDQWttQiw0QkFBa0J6cUIsT0FBbEIsQ0FBMEIsaUJBQVM7QUFDakMycUIsMkJBQWVqbEIsR0FBZixDQUFtQixnQ0FBaUJ6akIsTUFBTW5DLElBQXZCLEtBQWdDLFdBQW5EO0FBQ0FrcUMseUNBQTZCdGtCLEdBQTdCLENBQWlDempCLE1BQU1uQyxJQUF2QztBQUNELFdBSEQ7O0FBS0EsY0FBTThxQyxZQUFZRixVQUFVenVDLE9BQVYsQ0FBa0IsU0FBbEIsRUFBNkIsRUFBN0IsQ0FBbEI7QUFDQSxjQUFNNHVDLGFBQWF2QixzQkFBc0JvQixTQUF0QixDQUFuQjtBQUNBLGNBQU1JLHVCQUF1Qlosa0JBQWtCUyxjQUFsQixDQUE3Qjs7QUFFQUgsb0NBQTBCL2dDLElBQTFCLENBQ0ttaEMsU0FBSCx5REFDS0MsVUFETCxrQkFDNEJDLG9CQUQ1QixDQURGO0FBSUQ7QUFDRixPQWxCRDs7QUFvQkEsVUFBSU4sMEJBQTBCbnVDLE1BQTFCLEdBQW1DLENBQXZDLEVBQTBDO0FBQ3hDLFlBQU0wdUMsMkJBQTJCLG9EQUMvQlIsVUFEK0IsQ0FBakM7O0FBSUEsMkNBQ0UsS0FERixFQUVFLHFFQUNFLFFBREYsR0FFRSx5Q0FGRixHQUdFLDRDQUxKLEVBTUVRLHdCQU5GLEVBT0VQLDBCQUEwQkgsSUFBMUIsQ0FBK0IsTUFBL0IsQ0FQRjtBQVNEO0FBQ0YsS0F2Q0g7O0FBMENBUixxQ0FBaUMsSUFBSXBpQixHQUFKLEVBQWpDO0FBQ0QsR0E1Q0Q7O0FBOENBLE1BQU11akIsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFDL29DLEtBQUQsRUFBZ0M7QUFDckQsUUFBSWdwQyxrQkFBa0IsSUFBdEI7O0FBRUEsUUFBSXhvQyxPQUFPUixLQUFYO0FBQ0EsV0FBT1EsU0FBUyxJQUFoQixFQUFzQjtBQUNwQixVQUFJQSxLQUFLbVIsSUFBTCxHQUFZOUosMkJBQWhCLEVBQTRCO0FBQzFCbWhDLDBCQUFrQnhvQyxJQUFsQjtBQUNEO0FBQ0RBLGFBQU9BLEtBQUtDLE1BQVo7QUFDRDs7QUFFRCxXQUFPdW9DLGVBQVA7QUFDRCxHQVpEOztBQWNBNWUsMEJBQXdCVSwrQkFBeEIsR0FBMEQsWUFBTTtBQUM5RCxRQUFJMmMsa0NBQWtDcnRDLE1BQWxDLEdBQTJDLENBQS9DLEVBQWtEO0FBQ2hELFVBQU02dUMsY0FBYyxJQUFJM21CLEdBQUosRUFBcEI7QUFDQW1sQix3Q0FBa0MxcEIsT0FBbEMsQ0FBMEMsaUJBQVM7QUFDakRrckIsb0JBQVl4bEIsR0FBWixDQUFnQixnQ0FBaUJ6akIsTUFBTW5DLElBQXZCLEtBQWdDLFdBQWhEO0FBQ0FpcUMseUNBQWlDcmtCLEdBQWpDLENBQXFDempCLE1BQU1uQyxJQUEzQztBQUNELE9BSEQ7O0FBS0EsVUFBTXFyQyxjQUFjakIsa0JBQWtCZ0IsV0FBbEIsQ0FBcEI7O0FBRUEsd0NBQ0UsS0FERixFQUVFLHFGQUNFLDREQURGLEdBRUUsOENBRkYsR0FHRSxnREFIRixHQUlFLHlDQUpGLEdBS0UsdURBUEosRUFRRUMsV0FSRjs7QUFXQXpCLDBDQUFvQyxFQUFwQztBQUNEOztBQUVELFFBQUlDLHlDQUF5Q3R0QyxNQUF6QyxHQUFrRCxDQUF0RCxFQUF5RDtBQUN2RCxVQUFNNnVDLGVBQWMsSUFBSTNtQixHQUFKLEVBQXBCO0FBQ0FvbEIsK0NBQXlDM3BCLE9BQXpDLENBQWlELGlCQUFTO0FBQ3hEa3JCLHFCQUFZeGxCLEdBQVosQ0FBZ0IsZ0NBQWlCempCLE1BQU1uQyxJQUF2QixLQUFnQyxXQUFoRDtBQUNBaXFDLHlDQUFpQ3JrQixHQUFqQyxDQUFxQ3pqQixNQUFNbkMsSUFBM0M7QUFDRCxPQUhEOztBQUtBLFVBQU1xckMsZUFBY2pCLGtCQUFrQmdCLFlBQWxCLENBQXBCOztBQUVBLHdDQUNFLEtBREYsRUFFRSw0RkFDRSw4Q0FERixHQUVFLGdEQUZGLEdBR0UseUNBSEYsR0FJRSx1REFOSixFQU9FQyxZQVBGOztBQVVBeEIsaURBQTJDLEVBQTNDO0FBQ0Q7O0FBRUQsUUFBSUMsbUNBQW1DdnRDLE1BQW5DLEdBQTRDLENBQWhELEVBQW1EO0FBQ2pELFVBQU02dUMsZ0JBQWMsSUFBSTNtQixHQUFKLEVBQXBCO0FBQ0FxbEIseUNBQW1DNXBCLE9BQW5DLENBQTJDLGlCQUFTO0FBQ2xEa3JCLHNCQUFZeGxCLEdBQVosQ0FBZ0IsZ0NBQWlCempCLE1BQU1uQyxJQUF2QixLQUFnQyxXQUFoRDtBQUNBaXFDLHlDQUFpQ3JrQixHQUFqQyxDQUFxQ3pqQixNQUFNbkMsSUFBM0M7QUFDRCxPQUhEOztBQUtBLFVBQU1xckMsZ0JBQWNqQixrQkFBa0JnQixhQUFsQixDQUFwQjs7QUFFQSx3Q0FDRSxLQURGLEVBRUUsc0ZBQ0UsNkRBREYsR0FFRSwrQ0FGRixHQUdFLGdEQUhGLEdBSUUseUNBSkYsR0FLRSx1REFQSixFQVFFQyxhQVJGOztBQVdBdkIsMkNBQXFDLEVBQXJDO0FBQ0Q7QUFDRixHQXBFRDs7QUFzRUF2ZCwwQkFBd0IrYyx5QkFBeEIsR0FBb0QsVUFDbERubkMsS0FEa0QsRUFFbERxSCxRQUZrRCxFQUcvQztBQUNIO0FBQ0EsUUFBSXlnQyxpQ0FBaUN0a0IsR0FBakMsQ0FBcUN4akIsTUFBTW5DLElBQTNDLENBQUosRUFBc0Q7QUFDcEQ7QUFDRDs7QUFFRDtBQUNBLFFBQ0UsT0FBT3dKLFNBQVM4aEMsa0JBQWhCLEtBQXVDLFVBQXZDLElBQ0E5aEMsU0FBUzhoQyxrQkFBVCxDQUE0QkMsNEJBQTVCLEtBQTZELElBRi9ELEVBR0U7QUFDQTNCLHdDQUFrQ2pnQyxJQUFsQyxDQUF1Q3hILEtBQXZDO0FBQ0Q7QUFDRCxRQUNFLE9BQU9xSCxTQUFTZ2lDLHlCQUFoQixLQUE4QyxVQUE5QyxJQUNBaGlDLFNBQVNnaUMseUJBQVQsQ0FBbUNELDRCQUFuQyxLQUFvRSxJQUZ0RSxFQUdFO0FBQ0ExQiwrQ0FBeUNsZ0MsSUFBekMsQ0FBOEN4SCxLQUE5QztBQUNEO0FBQ0QsUUFDRSxPQUFPcUgsU0FBU2lpQyxtQkFBaEIsS0FBd0MsVUFBeEMsSUFDQWppQyxTQUFTaWlDLG1CQUFULENBQTZCRiw0QkFBN0IsS0FBOEQsSUFGaEUsRUFHRTtBQUNBekIseUNBQW1DbmdDLElBQW5DLENBQXdDeEgsS0FBeEM7QUFDRDtBQUNGLEdBNUJEOztBQThCQW9xQiwwQkFBd0JnZCw2QkFBeEIsR0FBd0QsVUFDdERwbkMsS0FEc0QsRUFFdERxSCxRQUZzRCxFQUduRDtBQUNILFFBQU1paEMsYUFBYVMsZUFBZS9vQyxLQUFmLENBQW5CO0FBQ0EsUUFBSXNvQyxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLHlDQUNFLEtBREYsRUFFRSxvRUFDRSxzRUFISjtBQUtBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUlQLDZCQUE2QnZrQixHQUE3QixDQUFpQ3hqQixNQUFNbkMsSUFBdkMsQ0FBSixFQUFrRDtBQUNoRDtBQUNEOztBQUVELFFBQUkwckMsd0JBQUo7QUFDQSxRQUFJLENBQUMzQiwrQkFBK0Jwa0IsR0FBL0IsQ0FBbUM4a0IsVUFBbkMsQ0FBTCxFQUFxRDtBQUNuRGlCLHdCQUFrQjtBQUNoQmpDLG1DQUEyQixFQURYO0FBRWhCQywwQ0FBa0MsRUFGbEI7QUFHaEJDLG9DQUE0QjtBQUhaLE9BQWxCOztBQU1BSSxxQ0FBK0JsaEMsR0FBL0IsQ0FBbUM0aEMsVUFBbkMsRUFBK0NpQixlQUEvQztBQUNELEtBUkQsTUFRTztBQUNMQSx3QkFBa0IzQiwrQkFBK0JqaEMsR0FBL0IsQ0FBbUMyaEMsVUFBbkMsQ0FBbEI7QUFDRDs7QUFFRCxRQUFNa0IsbUJBQW1CLEVBQXpCO0FBQ0EsUUFDRyxPQUFPbmlDLFNBQVM4aEMsa0JBQWhCLEtBQXVDLFVBQXZDLElBQ0M5aEMsU0FBUzhoQyxrQkFBVCxDQUE0QkMsNEJBQTVCLEtBQTZELElBRC9ELElBRUEsT0FBTy9oQyxTQUFTaWdDLHlCQUFoQixLQUE4QyxVQUhoRCxFQUlFO0FBQ0FrQyx1QkFBaUJoaUMsSUFBakIsQ0FBc0IsMkJBQXRCO0FBQ0Q7QUFDRCxRQUNHLE9BQU9ILFNBQVNnaUMseUJBQWhCLEtBQThDLFVBQTlDLElBQ0NoaUMsU0FBU2dpQyx5QkFBVCxDQUFtQ0QsNEJBQW5DLEtBQ0UsSUFGSixJQUdBLE9BQU8vaEMsU0FBU2tnQyxnQ0FBaEIsS0FBcUQsVUFKdkQsRUFLRTtBQUNBaUMsdUJBQWlCaGlDLElBQWpCLENBQXNCLGtDQUF0QjtBQUNEO0FBQ0QsUUFDRyxPQUFPSCxTQUFTaWlDLG1CQUFoQixLQUF3QyxVQUF4QyxJQUNDamlDLFNBQVNpaUMsbUJBQVQsQ0FBNkJGLDRCQUE3QixLQUE4RCxJQURoRSxJQUVBLE9BQU8vaEMsU0FBU21nQywwQkFBaEIsS0FBK0MsVUFIakQsRUFJRTtBQUNBZ0MsdUJBQWlCaGlDLElBQWpCLENBQXNCLDRCQUF0QjtBQUNEOztBQUVELFFBQUlnaUMsaUJBQWlCcHZDLE1BQWpCLEdBQTBCLENBQTlCLEVBQWlDO0FBQy9Cb3ZDLHVCQUFpQnpyQixPQUFqQixDQUF5QixxQkFBYTtBQUNsQ3dyQix1QkFBRixDQUFtRGQsU0FBbkQsRUFBOERqaEMsSUFBOUQsQ0FDRXhILEtBREY7QUFHRCxPQUpEO0FBS0Q7QUFDRixHQW5FRDs7QUFxRUFvcUIsMEJBQXdCc1IsMEJBQXhCLEdBQXFELFVBQ25EMTdCLEtBRG1ELEVBRW5EcUgsUUFGbUQsRUFHaEQ7QUFDSCxRQUFNaWhDLGFBQWFTLGVBQWUvb0MsS0FBZixDQUFuQjtBQUNBLFFBQUlzb0MsZUFBZSxJQUFuQixFQUF5QjtBQUN2Qix5Q0FDRSxLQURGLEVBRUUsb0VBQ0Usc0VBSEo7QUFLQTtBQUNEOztBQUVEO0FBQ0EsUUFBSU4sMEJBQTBCeGtCLEdBQTFCLENBQThCeGpCLE1BQU1uQyxJQUFwQyxDQUFKLEVBQStDO0FBQzdDO0FBQ0Q7O0FBRUQsUUFBSTByQyxrQkFBa0IxQiw0QkFBNEJsaEMsR0FBNUIsQ0FBZ0MyaEMsVUFBaEMsQ0FBdEI7O0FBRUEsUUFDRXRvQyxNQUFNbkMsSUFBTixDQUFXOFosWUFBWCxJQUEyQixJQUEzQixJQUNBM1gsTUFBTW5DLElBQU4sQ0FBV2lhLGlCQUFYLElBQWdDLElBRGhDLElBRUN6USxhQUFhLElBQWIsSUFBcUIsT0FBT0EsU0FBU2dSLGVBQWhCLEtBQW9DLFVBSDVELEVBSUU7QUFDQSxVQUFJa3hCLG9CQUFvQm53QyxTQUF4QixFQUFtQztBQUNqQ213QywwQkFBa0IsRUFBbEI7QUFDQTFCLG9DQUE0Qm5oQyxHQUE1QixDQUFnQzRoQyxVQUFoQyxFQUE0Q2lCLGVBQTVDO0FBQ0Q7QUFDREEsc0JBQWdCL2hDLElBQWhCLENBQXFCeEgsS0FBckI7QUFDRDtBQUNGLEdBaENEOztBQWtDQW9xQiwwQkFBd0JTLHlCQUF4QixHQUFvRCxZQUFNO0FBQ3REZ2QsK0JBQUYsQ0FBZ0U5cEIsT0FBaEUsQ0FDRSxVQUFDMHJCLFVBQUQsRUFBeUJuQixVQUF6QixFQUF3QztBQUN0QyxVQUFNVyxjQUFjLElBQUkzbUIsR0FBSixFQUFwQjtBQUNBbW5CLGlCQUFXMXJCLE9BQVgsQ0FBbUIsaUJBQVM7QUFDMUJrckIsb0JBQVl4bEIsR0FBWixDQUFnQixnQ0FBaUJ6akIsTUFBTW5DLElBQXZCLEtBQWdDLFdBQWhEO0FBQ0FtcUMsa0NBQTBCdmtCLEdBQTFCLENBQThCempCLE1BQU1uQyxJQUFwQztBQUNELE9BSEQ7O0FBS0EsVUFBTXFyQyxjQUFjakIsa0JBQWtCZ0IsV0FBbEIsQ0FBcEI7QUFDQSxVQUFNSCwyQkFBMkIsb0RBQy9CUixVQUQrQixDQUFqQzs7QUFJQSx5Q0FDRSxLQURGLEVBRUUsdUVBQ0UsZ0RBREYsR0FFRSx5Q0FGRixHQUdFLDRDQUxKLEVBTUVRLHdCQU5GLEVBT0VJLFdBUEY7QUFTRCxLQXRCSDtBQXdCRCxHQXpCRDtBQTBCRDs7a0JBRWM5ZSx1Qjs7Ozs7Ozs7Ozs7O1FDNVZDc2YsbUIsR0FBQUEsbUI7UUFlQUMscUIsR0FBQUEscUI7O0FBbEJoQjs7QUFDQTs7Ozs7O0FBRU8sU0FBU0QsbUJBQVQsQ0FBNkJ4eUIsU0FBN0IsRUFBNkMweUIsU0FBN0MsRUFBd0U7QUFDN0UsTUFBSTF5QixhQUFhQSxVQUFVd1AsWUFBM0IsRUFBeUM7QUFDdkM7QUFDQSxRQUFNaFksUUFBUW5KLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCb2tDLFNBQWxCLENBQWQ7QUFDQSxRQUFNbGpCLGVBQWV4UCxVQUFVd1AsWUFBL0I7QUFDQSxTQUFLLElBQUl2aEIsUUFBVCxJQUFxQnVoQixZQUFyQixFQUFtQztBQUNqQyxVQUFJaFksTUFBTXZKLFFBQU4sTUFBb0IvTCxTQUF4QixFQUFtQztBQUNqQ3NWLGNBQU12SixRQUFOLElBQWtCdWhCLGFBQWF2aEIsUUFBYixDQUFsQjtBQUNEO0FBQ0Y7QUFDRCxXQUFPdUosS0FBUDtBQUNEO0FBQ0QsU0FBT2s3QixTQUFQO0FBQ0QsQyxDQTNCRDs7Ozs7Ozs7O0FBNkJPLFNBQVNELHFCQUFULENBQWtDcEssYUFBbEMsRUFBc0U7QUFDM0UsTUFBTXNLLFNBQVN0SyxjQUFjQyxPQUE3QjtBQUNBLE1BQU16NEIsU0FBU3c0QixjQUFjRSxPQUE3QjtBQUNBLFVBQVFvSyxNQUFSO0FBQ0UsU0FBS3hLLDRCQUFMO0FBQWU7QUFDYixZQUFNbm9CLFlBQWVuUSxNQUFyQjtBQUNBLGVBQU9tUSxTQUFQO0FBQ0Q7QUFDRCxTQUFLb29CLDRCQUFMO0FBQWU7QUFDYixZQUFNemxDLFFBQWVrTixNQUFyQjtBQUNBLGNBQU1sTixLQUFOO0FBQ0Q7QUFDRCxTQUFLdWxDLDJCQUFMO0FBQWM7QUFDWixZQUFNeGdDLFdBQStCbUksTUFBckM7QUFDQSxjQUFNbkksUUFBTjtBQUNEO0FBQ0Q7QUFBUztBQUNQMmdDLHNCQUFjQyxPQUFkLEdBQXdCSiwyQkFBeEI7QUFDQSxZQUFNclAsT0FBT3dQLGNBQWN1SyxLQUEzQjtBQUNBLFlBQU1sckMsWUFBV214QixNQUFqQjtBQUNBbnhCLGtCQUFTaXJCLElBQVQsQ0FDRSx3QkFBZ0I7QUFDZCxjQUFJMFYsY0FBY0MsT0FBZCxLQUEwQkosMkJBQTlCLEVBQXVDO0FBQ3JDLGdCQUFNMkssZ0JBQWdCQyxhQUFhL3dCLE9BQW5DO0FBQ0EsZ0JBQUkvZixJQUFKLEVBQWE7QUFDWCxrQkFBSTZ3QyxrQkFBa0Izd0MsU0FBdEIsRUFBaUM7QUFDL0IsdUNBQ0UsS0FERixFQUVFLDJEQUNFLDBEQURGLEdBRUUseURBSkosRUFLRTR3QyxZQUxGO0FBT0Q7QUFDRjtBQUNEekssMEJBQWNDLE9BQWQsR0FBd0JILDRCQUF4QjtBQUNBRSwwQkFBY0UsT0FBZCxHQUF3QnNLLGFBQXhCO0FBQ0Q7QUFDRixTQWxCSCxFQW1CRSxpQkFBUztBQUNQLGNBQUl4SyxjQUFjQyxPQUFkLEtBQTBCSiwyQkFBOUIsRUFBdUM7QUFDckNHLDBCQUFjQyxPQUFkLEdBQXdCRiw0QkFBeEI7QUFDQUMsMEJBQWNFLE9BQWQsR0FBd0I1bEMsS0FBeEI7QUFDRDtBQUNGLFNBeEJIO0FBMEJBO0FBQ0EsZ0JBQVEwbEMsY0FBY0MsT0FBdEI7QUFDRSxlQUFLSCw0QkFBTDtBQUNFLG1CQUFPRSxjQUFjRSxPQUFyQjtBQUNGLGVBQUtILDRCQUFMO0FBQ0Usa0JBQU1DLGNBQWNFLE9BQXBCO0FBSko7QUFNQUYsc0JBQWNFLE9BQWQsR0FBd0I3Z0MsU0FBeEI7QUFDQSxjQUFNQSxTQUFOO0FBQ0Q7QUFwREg7QUFzREQsQzs7Ozs7Ozs7Ozs7Ozs7QUMzRUQ7O0FBRUE7O0FBVUEsSUFBSXFyQyxhQUFxQixDQUF6QixDLENBdkJBOzs7Ozs7Ozs7QUF3QkEsSUFBSUMsb0JBQTRCLENBQUMsQ0FBakM7O0FBRUEsU0FBU0MsYUFBVCxHQUFpQztBQUMvQixTQUFPRixVQUFQO0FBQ0Q7O0FBRUQsU0FBU0csZ0JBQVQsR0FBa0M7QUFDaEMsTUFBSSxDQUFDenVDLHNDQUFMLEVBQTBCO0FBQ3hCO0FBQ0Q7QUFDRHN1QyxlQUFhLGdDQUFiO0FBQ0Q7O0FBRUQsU0FBU0ksa0JBQVQsQ0FBNEJycUMsS0FBNUIsRUFBZ0Q7QUFDOUMsTUFBSSxDQUFDckUsc0NBQUwsRUFBMEI7QUFDeEI7QUFDRDs7QUFFRHV1QyxzQkFBb0IsZ0NBQXBCOztBQUVBLE1BQU1scUMsTUFBTW9tQixlQUFSLEdBQXlDLENBQTdDLEVBQWdEO0FBQzlDcG1CLFVBQU1vbUIsZUFBTixHQUF3QixnQ0FBeEI7QUFDRDtBQUNGOztBQUVELFNBQVNra0IsMEJBQVQsQ0FBb0N0cUMsS0FBcEMsRUFBd0Q7QUFDdEQsTUFBSSxDQUFDckUsc0NBQUwsRUFBMEI7QUFDeEI7QUFDRDtBQUNEdXVDLHNCQUFvQixDQUFDLENBQXJCO0FBQ0Q7O0FBRUQsU0FBU0ssd0NBQVQsQ0FDRXZxQyxLQURGLEVBRUV3cUMsZ0JBRkYsRUFHUTtBQUNOLE1BQUksQ0FBQzd1QyxzQ0FBTCxFQUEwQjtBQUN4QjtBQUNEOztBQUVELE1BQUl1dUMscUJBQXFCLENBQXpCLEVBQTRCO0FBQzFCLFFBQU1PLGNBQWMsbUNBQVFQLGlCQUE1QjtBQUNBbHFDLFVBQU1pbUIsY0FBTixJQUF3QndrQixXQUF4QjtBQUNBLFFBQUlELGdCQUFKLEVBQXNCO0FBQ3BCeHFDLFlBQU1xbUIsZ0JBQU4sR0FBeUJva0IsV0FBekI7QUFDRDtBQUNEUCx3QkFBb0IsQ0FBQyxDQUFyQjtBQUNEO0FBQ0Y7O1FBR0NDLGEsR0FBQUEsYTtRQUNBQyxnQixHQUFBQSxnQjtRQUNBQyxrQixHQUFBQSxrQjtRQUNBQywwQixHQUFBQSwwQjtRQUNBQyx3QyxHQUFBQSx3Qzs7Ozs7Ozs7Ozs7O0FDL0VGOzs7Ozs7Ozs7QUFTQSxTQUFTRyxpQkFBVCxDQUEyQjFFLE9BQTNCLEVBQTRDdDNCLEtBQTVDLEVBQTJEO0FBQ3pELE1BQUlzM0IsUUFBUXRyQixPQUFSLENBQWdCLEdBQWhCLE1BQXlCLENBQUMsQ0FBOUIsRUFBaUM7QUFDL0IsV0FBTyxPQUFPaE0sTUFBTW80QixFQUFiLEtBQW9CLFFBQTNCO0FBQ0Q7QUFDRCxVQUFRZCxPQUFSO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFLLGdCQUFMO0FBQ0EsU0FBSyxlQUFMO0FBQ0EsU0FBSyxXQUFMO0FBQ0EsU0FBSyxlQUFMO0FBQ0EsU0FBSyxlQUFMO0FBQ0EsU0FBSyxrQkFBTDtBQUNBLFNBQUssZ0JBQUw7QUFDQSxTQUFLLGVBQUw7QUFDRSxhQUFPLEtBQVA7QUFDRjtBQUNFLGFBQU8sSUFBUDtBQWZKO0FBaUJEOztrQkFFYzBFLGlCOzs7Ozs7O0FDaENmOzs7Ozs7O0FBT2E7O0FBRWI7O0FBQ0EzeEIsT0FBT0MsT0FBUCxHQUFpQixRQUFqQixDOzs7Ozs7Ozs7Ozs7O0FDSEE7Ozs7QUFDQTs7QUFhQTs7QUFXQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQWxDQTs7Ozs7OztBQW9DQSxJQUFNOWQsdUJBQXVCO0FBQzNCOHNCLDBEQUQyQjtBQUUzQkMsZ0RBRjJCO0FBRzNCO0FBQ0F6aUI7QUFKMkIsQ0FBN0I7O0FBT0EsSUFBSW1sQyxLQUFKLEVBQWE7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FwbEMsU0FBT0MsTUFBUCxDQUFjdEssb0JBQWQsRUFBb0M7QUFDbEMwdkMsZUFBVztBQUNUQyxpRUFEUztBQUVUQywyREFGUztBQUdUQywyQ0FIUztBQUlUQyxxRUFKUztBQUtUQyxtRUFMUztBQU1UQyw2Q0FOUztBQU9UQyw2REFQUztBQVFUQyw2RUFSUztBQVNUQyxpRUFUUztBQVVUQyx1RUFWUztBQVdUQztBQVhTLEtBRHVCO0FBY2xDQyxzQkFBa0I7QUFDaEJsakIsbURBRGdCO0FBRWhCd0UsK0NBRmdCO0FBR2hCMmUsNkNBSGdCO0FBSWhCQyx1REFKZ0I7QUFLaEJDLHlEQUxnQjtBQU1oQkMscURBTmdCO0FBT2hCQyw2Q0FQZ0I7QUFRaEJDLHlEQVJnQjtBQVNoQkM7QUFUZ0I7QUFkZ0IsR0FBcEM7QUEwQkQ7O0FBRUQsSUFBSTd5QyxJQUFKLEVBQWE7QUFDWHFNLFNBQU9DLE1BQVAsQ0FBY3RLLG9CQUFkLEVBQW9DO0FBQ2xDO0FBQ0FELDREQUZrQztBQUdsQztBQUNBO0FBQ0Erd0MsNEJBQXdCO0FBTFUsR0FBcEM7QUFPRDs7a0JBRWM5d0Msb0I7Ozs7Ozs7QUN2RmY7Ozs7Ozs7QUFPYTs7Ozs7Ozs7QUFFYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7Ozs7Ozs7Ozs7OztRQzBFZ0J1d0MsYyxHQUFBQSxjO1FBZUFDLG1CLEdBQUFBLG1CO1FBUUFDLG9CLEdBQUFBLG9CO1FBSUFFLGMsR0FBQUEsYztRQWdFQUUsYSxHQUFBQSxhOztBQXJLaEI7O0FBZ0RBLElBQU1FLG9CQUFvQixDQUExQjs7QUFFQTtBQTNEQTs7Ozs7Ozs7O0FBNERBLElBQUlDLHVCQUErQixDQUFuQztBQUNBLElBQUlDLGtCQUEwQixDQUE5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLGtCQUFvQyxJQUF4Qzs7QUFFQTtBQUNBLElBQUlDLGdCQUFnQyxJQUFwQzs7QUFFQSxJQUFJeHdDLHlDQUFKLEVBQTRCO0FBQzFCLFVBUXlCeXNCLGlCQVJ6QixxQkFBa0I7QUFDaEI1bkIsYUFBUyxJQUFJNGhCLEdBQUo7QUFETyxHQUFsQjtBQUdBLFVBSzZEd0ssZUFMN0QsbUJBQWdCO0FBQ2Rwc0IsYUFBUztBQURLLEdBQWhCO0FBR0Q7O1FBRTBCNG5CLGlCLEdBQW5COGpCLGU7UUFBdUR0ZixlLEdBQWpCdWYsYTtBQUV2QyxTQUFTWixjQUFULENBQXdCNzZCLFFBQXhCLEVBQWlEO0FBQ3RELE1BQUksQ0FBQy9VLHlDQUFMLEVBQTZCO0FBQzNCLFdBQU8rVSxVQUFQO0FBQ0Q7O0FBRUQsTUFBTXNiLG1CQUFtQmtnQixnQkFBZ0IxckMsT0FBekM7QUFDQTByQyxrQkFBZ0IxckMsT0FBaEIsR0FBMEIsSUFBSTRoQixHQUFKLEVBQTFCOztBQUVBLE1BQUk7QUFDRixXQUFPMVIsVUFBUDtBQUNELEdBRkQsU0FFVTtBQUNSdzdCLG9CQUFnQjFyQyxPQUFoQixHQUEwQndyQixnQkFBMUI7QUFDRDtBQUNGOztBQUVNLFNBQVN3ZixtQkFBVCxHQUF3RDtBQUM3RCxNQUFJLENBQUM3dkMseUNBQUwsRUFBNkI7QUFDM0IsV0FBTyxJQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT3V3QyxnQkFBZ0IxckMsT0FBdkI7QUFDRDtBQUNGOztBQUVNLFNBQVNpckMsb0JBQVQsR0FBd0M7QUFDN0MsU0FBTyxFQUFFUSxlQUFUO0FBQ0Q7O0FBRU0sU0FBU04sY0FBVCxDQUNMNXhDLElBREssRUFFTHF5QyxTQUZLLEVBR0wxN0IsUUFISyxFQUtBO0FBQUEsTUFETG9jLFFBQ0ssdUVBRGNpZixpQkFDZDs7QUFDTCxNQUFJLENBQUNwd0MseUNBQUwsRUFBNkI7QUFDM0IsV0FBTytVLFVBQVA7QUFDRDs7QUFFRCxNQUFNOGMsY0FBMkI7QUFDL0JDLGFBQVMsQ0FEc0I7QUFFL0JuRyxRQUFJMGtCLHNCQUYyQjtBQUcvQmp5QyxjQUgrQjtBQUkvQnF5QztBQUorQixHQUFqQzs7QUFPQSxNQUFNcGdCLG1CQUFtQmtnQixnQkFBZ0IxckMsT0FBekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTW91QixlQUFlLElBQUl4TSxHQUFKLENBQVE0SixnQkFBUixDQUFyQjtBQUNBNEMsZUFBYXJMLEdBQWIsQ0FBaUJpSyxXQUFqQjtBQUNBMGUsa0JBQWdCMXJDLE9BQWhCLEdBQTBCb3VCLFlBQTFCOztBQUVBLE1BQU1qQyxhQUFhd2YsY0FBYzNyQyxPQUFqQztBQUNBLE1BQUk0RSxvQkFBSjs7QUFFQSxNQUFJO0FBQ0YsUUFBSXVuQixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSxpQkFBVzBmLG1CQUFYLENBQStCN2UsV0FBL0I7QUFDRDtBQUNGLEdBSkQsU0FJVTtBQUNSLFFBQUk7QUFDRixVQUFJYixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSxtQkFBV2tDLGFBQVgsQ0FBeUJELFlBQXpCLEVBQXVDOUIsUUFBdkM7QUFDRDtBQUNGLEtBSkQsU0FJVTtBQUNSLFVBQUk7QUFDRjFuQixzQkFBY3NMLFVBQWQ7QUFDRCxPQUZELFNBRVU7QUFDUnc3Qix3QkFBZ0IxckMsT0FBaEIsR0FBMEJ3ckIsZ0JBQTFCOztBQUVBLFlBQUk7QUFDRixjQUFJVyxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSx1QkFBV00sYUFBWCxDQUF5QjJCLFlBQXpCLEVBQXVDOUIsUUFBdkM7QUFDRDtBQUNGLFNBSkQsU0FJVTtBQUNSVSxzQkFBWUMsT0FBWjs7QUFFQTtBQUNBO0FBQ0EsY0FBSWQsZUFBZSxJQUFmLElBQXVCYSxZQUFZQyxPQUFaLEtBQXdCLENBQW5ELEVBQXNEO0FBQ3BEZCx1QkFBV2UsbUNBQVgsQ0FBK0NGLFdBQS9DO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPcG9CLFdBQVA7QUFDRDs7QUFFTSxTQUFTeW1DLGFBQVQsQ0FDTG43QixRQURLLEVBR0s7QUFBQSxNQURWb2MsUUFDVSx1RUFEU2lmLGlCQUNUOztBQUNWLE1BQUksQ0FBQ3B3Qyx5Q0FBTCxFQUE2QjtBQUMzQixXQUFPK1UsUUFBUDtBQUNEOztBQUVELE1BQU00N0Isc0JBQXNCSixnQkFBZ0IxckMsT0FBNUM7O0FBRUEsTUFBSW1zQixhQUFhd2YsY0FBYzNyQyxPQUEvQjtBQUNBLE1BQUltc0IsZUFBZSxJQUFuQixFQUF5QjtBQUN2QkEsZUFBVzZFLGVBQVgsQ0FBMkI4YSxtQkFBM0IsRUFBZ0R4ZixRQUFoRDtBQUNEOztBQUVEO0FBQ0E7QUFDQXdmLHNCQUFvQnp1QixPQUFwQixDQUE0Qix1QkFBZTtBQUN6QzJQLGdCQUFZQyxPQUFaO0FBQ0QsR0FGRDs7QUFJQSxNQUFJOGUsU0FBUyxLQUFiOztBQUVBLFdBQVNDLE9BQVQsR0FBbUI7QUFDakIsUUFBTXhnQixtQkFBbUJrZ0IsZ0JBQWdCMXJDLE9BQXpDO0FBQ0EwckMsb0JBQWdCMXJDLE9BQWhCLEdBQTBCOHJDLG1CQUExQjs7QUFFQTNmLGlCQUFhd2YsY0FBYzNyQyxPQUEzQjs7QUFFQSxRQUFJO0FBQ0YsVUFBSTRFLG9CQUFKOztBQUVBLFVBQUk7QUFDRixZQUFJdW5CLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkJBLHFCQUFXa0MsYUFBWCxDQUF5QnlkLG1CQUF6QixFQUE4Q3hmLFFBQTlDO0FBQ0Q7QUFDRixPQUpELFNBSVU7QUFDUixZQUFJO0FBQ0YxbkIsd0JBQWNzTCxTQUFTaFcsS0FBVCxDQUFleEIsU0FBZixFQUEwQmlOLFNBQTFCLENBQWQ7QUFDRCxTQUZELFNBRVU7QUFDUitsQywwQkFBZ0IxckMsT0FBaEIsR0FBMEJ3ckIsZ0JBQTFCOztBQUVBLGNBQUlXLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkJBLHVCQUFXTSxhQUFYLENBQXlCcWYsbUJBQXpCLEVBQThDeGYsUUFBOUM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBTzFuQixXQUFQO0FBQ0QsS0FwQkQsU0FvQlU7QUFDUixVQUFJLENBQUNtbkMsTUFBTCxFQUFhO0FBQ1g7QUFDQTtBQUNBO0FBQ0FBLGlCQUFTLElBQVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0FELDRCQUFvQnp1QixPQUFwQixDQUE0Qix1QkFBZTtBQUN6QzJQLHNCQUFZQyxPQUFaOztBQUVBLGNBQUlkLGVBQWUsSUFBZixJQUF1QmEsWUFBWUMsT0FBWixLQUF3QixDQUFuRCxFQUFzRDtBQUNwRGQsdUJBQVdlLG1DQUFYLENBQStDRixXQUEvQztBQUNEO0FBQ0YsU0FORDtBQU9EO0FBQ0Y7QUFDRjs7QUFFRGdmLFVBQVFDLE1BQVIsR0FBaUIsU0FBU0EsTUFBVCxHQUFrQjtBQUNqQzlmLGlCQUFhd2YsY0FBYzNyQyxPQUEzQjs7QUFFQSxRQUFJO0FBQ0YsVUFBSW1zQixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSxtQkFBVytmLGNBQVgsQ0FBMEJKLG1CQUExQixFQUErQ3hmLFFBQS9DO0FBQ0Q7QUFDRixLQUpELFNBSVU7QUFDUjtBQUNBO0FBQ0E7QUFDQXdmLDBCQUFvQnp1QixPQUFwQixDQUE0Qix1QkFBZTtBQUN6QzJQLG9CQUFZQyxPQUFaOztBQUVBLFlBQUlkLGNBQWNhLFlBQVlDLE9BQVosS0FBd0IsQ0FBMUMsRUFBNkM7QUFDM0NkLHFCQUFXZSxtQ0FBWCxDQUErQ0YsV0FBL0M7QUFDRDtBQUNGLE9BTkQ7QUFPRDtBQUNGLEdBbkJEOztBQXFCQSxTQUFPZ2YsT0FBUDtBQUNELEM7Ozs7Ozs7Ozs7Ozs7O0FDL1BEOzs7QUFHQSxJQUFNMWtCLHlCQUF5QjtBQUM3Qjs7OztBQUlBdG5CLFdBQVU7QUFMbUIsQ0FBL0IsQyxDQWRBOzs7Ozs7Ozs7a0JBc0Jlc25CLHNCOzs7Ozs7Ozs7Ozs7O2tCQ1hBLFVBQ2IvdEIsSUFEYSxFQUVia0csTUFGYSxFQUdiRSxTQUhhLEVBSWI7QUFDQSxNQUFJd3NDLGFBQWEsRUFBakI7QUFDQSxNQUFJMXNDLE1BQUosRUFBWTtBQUNWLFFBQUkyc0MsT0FBTzNzQyxPQUFPMjdCLFFBQWxCO0FBQ0EsUUFBSUEsV0FBV2dSLEtBQUs5eUMsT0FBTCxDQUFhK3lDLGVBQWIsRUFBOEIsRUFBOUIsQ0FBZjtBQUNBLFFBQUk3ekMsSUFBSixFQUFhO0FBQ1g7QUFDQTtBQUNBLFVBQUksV0FBV2lrQixJQUFYLENBQWdCMmUsUUFBaEIsQ0FBSixFQUErQjtBQUM3QixZQUFNa1IsUUFBUUYsS0FBS0UsS0FBTCxDQUFXRCxlQUFYLENBQWQ7QUFDQSxZQUFJQyxLQUFKLEVBQVc7QUFDVCxjQUFNQyxrQkFBa0JELE1BQU0sQ0FBTixDQUF4QjtBQUNBLGNBQUlDLGVBQUosRUFBcUI7QUFDbkIsZ0JBQU1DLGFBQWFELGdCQUFnQmp6QyxPQUFoQixDQUF3Qit5QyxlQUF4QixFQUF5QyxFQUF6QyxDQUFuQjtBQUNBalIsdUJBQVdvUixhQUFhLEdBQWIsR0FBbUJwUixRQUE5QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QrUSxpQkFBYSxVQUFVL1EsUUFBVixHQUFxQixHQUFyQixHQUEyQjM3QixPQUFPNDdCLFVBQWxDLEdBQStDLEdBQTVEO0FBQ0QsR0FsQkQsTUFrQk8sSUFBSTE3QixTQUFKLEVBQWU7QUFDcEJ3c0MsaUJBQWEsa0JBQWtCeHNDLFNBQWxCLEdBQThCLEdBQTNDO0FBQ0Q7QUFDRCxTQUFPLGVBQWVwRyxRQUFRLFNBQXZCLElBQW9DNHlDLFVBQTNDO0FBQ0QsQzs7QUF2Q0Q7Ozs7Ozs7OztBQVNBLElBQU1FLGtCQUFrQixhQUF4QixDOzs7Ozs7Ozs7Ozs7OzhRQ1RBOzs7Ozs7Ozs7a0JBc0J3Qkksa0I7O0FBYnhCOztBQWFlLFNBQVNBLGtCQUFULENBQTRCdHZDLElBQTVCLEVBQXlDO0FBQ3RELFNBQ0UsT0FBT0EsSUFBUCxLQUFnQixRQUFoQixJQUNBLE9BQU9BLElBQVAsS0FBZ0IsVUFEaEI7QUFFQTtBQUNBQSxXQUFTRyxpQ0FIVCxJQUlBSCxTQUFTRSx3Q0FKVCxJQUtBRixTQUFTSyxpQ0FMVCxJQU1BTCxTQUFTTSxvQ0FOVCxJQU9BTixTQUFTTyxpQ0FQVCxJQVFDLFFBQU9QLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFDQ0EsU0FBUyxJQURWLEtBRUVBLEtBQUtRLFFBQUwsS0FBa0JNLDZCQUFsQixJQUNDZCxLQUFLUSxRQUFMLEtBQWtCSyw2QkFEbkIsSUFFQ2IsS0FBS1EsUUFBTCxLQUFrQkUsaUNBRm5CLElBR0NWLEtBQUtRLFFBQUwsS0FBa0JDLGdDQUhuQixJQUlDVCxLQUFLUSxRQUFMLEtBQWtCRyxvQ0FOckIsQ0FUSDtBQWlCRCxDOzs7Ozs7Ozs7Ozs7O0FDL0JEOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVM0dUMsY0FBVCxDQUNFMXNDLE9BREYsRUFFRW1RLElBRkYsRUFHZ0I7QUFDZCwyQkFDRUEsUUFBUSxJQURWLEVBRUUsdUVBRkY7O0FBS0EsTUFBSW5RLFdBQVcsSUFBZixFQUFxQjtBQUNuQixXQUFPbVEsSUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxNQUFJOEssTUFBTTJtQixPQUFOLENBQWM1aEMsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFFBQUlpYixNQUFNMm1CLE9BQU4sQ0FBY3p4QixJQUFkLENBQUosRUFBeUI7QUFDdkJuUSxjQUFROEcsSUFBUixDQUFhNU0sS0FBYixDQUFtQjhGLE9BQW5CLEVBQTRCbVEsSUFBNUI7QUFDQSxhQUFPblEsT0FBUDtBQUNEO0FBQ0RBLFlBQVE4RyxJQUFSLENBQWFxSixJQUFiO0FBQ0EsV0FBT25RLE9BQVA7QUFDRDs7QUFFRCxNQUFJaWIsTUFBTTJtQixPQUFOLENBQWN6eEIsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCO0FBQ0EsV0FBTyxDQUFDblEsT0FBRCxFQUFVMnNDLE1BQVYsQ0FBaUJ4OEIsSUFBakIsQ0FBUDtBQUNEOztBQUVELFNBQU8sQ0FBQ25RLE9BQUQsRUFBVW1RLElBQVYsQ0FBUDtBQUNELEMsQ0F0REQ7Ozs7Ozs7OztrQkF3RGV1OEIsYzs7Ozs7Ozs7Ozs7O0FDeERmOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7O0FBU0EsU0FBU0Usa0JBQVQsQ0FDRUMsR0FERixFQUVFQyxFQUZGLEVBR0VDLEtBSEYsRUFJRTtBQUNBLE1BQUk5eEIsTUFBTTJtQixPQUFOLENBQWNpTCxHQUFkLENBQUosRUFBd0I7QUFDdEJBLFFBQUl4dkIsT0FBSixDQUFZeXZCLEVBQVosRUFBZ0JDLEtBQWhCO0FBQ0QsR0FGRCxNQUVPLElBQUlGLEdBQUosRUFBUztBQUNkQyxPQUFHM3lDLElBQUgsQ0FBUTR5QyxLQUFSLEVBQWVGLEdBQWY7QUFDRDtBQUNGOztrQkFFY0Qsa0I7Ozs7Ozs7Ozs7OztBQzlCZjs7Ozs7Ozs7O0FBWUEsSUFBTUksc0JBQW9EO0FBQ3hEQyxTQUFPLElBRGlEO0FBRXhEQyxRQUFNLElBRmtEO0FBR3hEQyxZQUFVLElBSDhDO0FBSXhELG9CQUFrQixJQUpzQztBQUt4REMsU0FBTyxJQUxpRDtBQU14REMsU0FBTyxJQU5pRDtBQU94REMsVUFBUSxJQVBnRDtBQVF4REMsWUFBVSxJQVI4QztBQVN4REMsU0FBTyxJQVRpRDtBQVV4REMsVUFBUSxJQVZnRDtBQVd4REMsT0FBSyxJQVhtRDtBQVl4RDNZLFFBQU0sSUFaa0Q7QUFheEQ0WSxRQUFNLElBYmtEO0FBY3hEQyxPQUFLLElBZG1EO0FBZXhEQyxRQUFNO0FBZmtELENBQTFEOztBQWtCQSxTQUFTQyxrQkFBVCxDQUE0QmhLLElBQTVCLEVBQXlEO0FBQ3ZELE1BQU1DLFdBQVdELFFBQVFBLEtBQUtDLFFBQWIsSUFBeUJELEtBQUtDLFFBQUwsQ0FBY2xwQixXQUFkLEVBQTFDOztBQUVBLE1BQUlrcEIsYUFBYSxPQUFqQixFQUEwQjtBQUN4QixXQUFPLENBQUMsQ0FBQ2lKLG9CQUFzQmxKLElBQUYsQ0FBZ0MzbUMsSUFBcEQsQ0FBVDtBQUNEOztBQUVELE1BQUk0bUMsYUFBYSxVQUFqQixFQUE2QjtBQUMzQixXQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRDs7a0JBRWMrSixrQjs7Ozs7Ozs7Ozs7OztBQ3JDZjs7QUFFQTs7Ozs7OztBQU9BLFNBQVNDLGNBQVQsQ0FBd0IvcEMsV0FBeEIsRUFBcUM7QUFDbkM7QUFDQTtBQUNBLE1BQUloQixTQUFTZ0IsWUFBWWhCLE1BQVosSUFBc0JnQixZQUFZZ2IsVUFBbEMsSUFBZ0Q5USxNQUE3RDs7QUFFQTtBQUNBLE1BQUlsTCxPQUFPZ3JDLHVCQUFYLEVBQW9DO0FBQ2xDaHJDLGFBQVNBLE9BQU9nckMsdUJBQWhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQU9ockMsT0FBT2lyQyxRQUFQLEtBQW9CdGhDLHVCQUFwQixHQUFnQzNKLE9BQU82SyxVQUF2QyxHQUFvRDdLLE1BQTNEO0FBQ0QsQyxDQTdCRDs7Ozs7OztrQkErQmUrcUMsYzs7Ozs7Ozs7Ozs7OztBQ3hCZjs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVNHLGdCQUFULENBQTBCQyxlQUExQixFQUEyQztBQUN6QyxNQUFJLENBQUNsZ0MsK0JBQUwsRUFBZ0I7QUFDZCxXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFNa00sWUFBWSxPQUFPZzBCLGVBQXpCO0FBQ0EsTUFBSUMsY0FBY2owQixhQUFhaE0sUUFBL0I7O0FBRUEsTUFBSSxDQUFDaWdDLFdBQUwsRUFBa0I7QUFDaEIsUUFBTTFuQixVQUFVdlksU0FBU0MsYUFBVCxDQUF1QixLQUF2QixDQUFoQjtBQUNBc1ksWUFBUTJuQixZQUFSLENBQXFCbDBCLFNBQXJCLEVBQWdDLFNBQWhDO0FBQ0FpMEIsa0JBQWMsT0FBTzFuQixRQUFRdk0sU0FBUixDQUFQLEtBQThCLFVBQTVDO0FBQ0Q7O0FBRUQsU0FBT2kwQixXQUFQO0FBQ0QsQyxDQXJDRDs7Ozs7OztrQkF1Q2VGLGdCOzs7Ozs7Ozs7Ozs7UUNtQkNJLFksR0FBQUEsWTtRQWNBQyxnQixHQUFBQSxnQjtRQXVEQUMsYSxHQUFBQSxhO1FBUUFDLGEsR0FBQUEsYTtRQW9HQUMsZ0IsR0FBQUEsZ0I7UUFnSEFDLHNCLEdBQUFBLHNCO1FBOERBQyxlLEdBQUFBLGU7O0FBL1loQjs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQVlBLElBQUlDLDJCQUEyQixLQUEvQixDLENBL0JBOzs7Ozs7Ozs7QUFTQTs7QUF1QkEsSUFBSUMsK0JBQStCLEtBQW5DO0FBQ0EsSUFBSUMsa0NBQWtDLEtBQXRDO0FBQ0EsSUFBSUMsa0NBQWtDLEtBQXRDOztBQUVBLFNBQVNDLFlBQVQsQ0FBc0JqaEMsS0FBdEIsRUFBNkI7QUFDM0IsTUFBTWtoQyxjQUFjbGhDLE1BQU03USxJQUFOLEtBQWUsVUFBZixJQUE2QjZRLE1BQU03USxJQUFOLEtBQWUsT0FBaEU7QUFDQSxTQUFPK3hDLGNBQWNsaEMsTUFBTW8yQixPQUFOLElBQWlCLElBQS9CLEdBQXNDcDJCLE1BQU00TyxLQUFOLElBQWUsSUFBNUQ7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQk8sU0FBUzB4QixZQUFULENBQXNCNW5CLE9BQXRCLEVBQXdDMVksS0FBeEMsRUFBdUQ7QUFDNUQsTUFBTWxPLE9BQVM0bUIsT0FBZjtBQUNBLE1BQU0wZCxVQUFVcDJCLE1BQU1vMkIsT0FBdEI7O0FBRUEsTUFBTStLLFlBQVl0cUMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JrSixLQUFsQixFQUF5QjtBQUN6Q29oQyxvQkFBZ0IxMkMsU0FEeUI7QUFFekNnK0Isa0JBQWNoK0IsU0FGMkI7QUFHekNra0IsV0FBT2xrQixTQUhrQztBQUl6QzByQyxhQUFTQSxXQUFXLElBQVgsR0FBa0JBLE9BQWxCLEdBQTRCdGtDLEtBQUt1dkMsYUFBTCxDQUFtQkM7QUFKZixHQUF6QixDQUFsQjs7QUFPQSxTQUFPSCxTQUFQO0FBQ0Q7O0FBRU0sU0FBU1osZ0JBQVQsQ0FBMEI3bkIsT0FBMUIsRUFBNEMxWSxLQUE1QyxFQUEyRDtBQUNoRSxNQUFJeFYsSUFBSixFQUFhO0FBQ1hvc0MsNENBQThCNVAsY0FBOUIsQ0FBNkMsT0FBN0MsRUFBc0RobkIsS0FBdEQ7O0FBRUEsUUFDRUEsTUFBTW8yQixPQUFOLEtBQWtCMXJDLFNBQWxCLElBQ0FzVixNQUFNb2hDLGNBQU4sS0FBeUIxMkMsU0FEekIsSUFFQSxDQUFDbzJDLDRCQUhILEVBSUU7QUFDQSw2QkFDRSxLQURGLEVBRUUsaUZBQ0UsMkRBREYsR0FFRSx3RUFGRixHQUdFLGlFQUhGLEdBSUUsb0RBSkYsR0FLRSwyQ0FQSixFQVFFLGlFQUF5QyxhQVIzQyxFQVNFOWdDLE1BQU03USxJQVRSO0FBV0EyeEMscUNBQStCLElBQS9CO0FBQ0Q7QUFDRCxRQUNFOWdDLE1BQU00TyxLQUFOLEtBQWdCbGtCLFNBQWhCLElBQ0FzVixNQUFNMG9CLFlBQU4sS0FBdUJoK0IsU0FEdkIsSUFFQSxDQUFDbTJDLHdCQUhILEVBSUU7QUFDQSw2QkFDRSxLQURGLEVBRUUsNkVBQ0UsMkRBREYsR0FFRSxvRUFGRixHQUdFLGlFQUhGLEdBSUUsb0RBSkYsR0FLRSwyQ0FQSixFQVFFLGlFQUF5QyxhQVIzQyxFQVNFN2dDLE1BQU03USxJQVRSO0FBV0EweEMsaUNBQTJCLElBQTNCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNL3VDLE9BQVM0bUIsT0FBZjtBQUNBLE1BQU1nUSxlQUFlMW9CLE1BQU0wb0IsWUFBTixJQUFzQixJQUF0QixHQUE2QixFQUE3QixHQUFrQzFvQixNQUFNMG9CLFlBQTdEOztBQUVBNTJCLE9BQUt1dkMsYUFBTCxHQUFxQjtBQUNuQkMsb0JBQ0V0aEMsTUFBTW8yQixPQUFOLElBQWlCLElBQWpCLEdBQXdCcDJCLE1BQU1vMkIsT0FBOUIsR0FBd0NwMkIsTUFBTW9oQyxjQUY3QjtBQUduQkcsa0JBQWMscUNBQ1p2aEMsTUFBTTRPLEtBQU4sSUFBZSxJQUFmLEdBQXNCNU8sTUFBTTRPLEtBQTVCLEdBQW9DOFosWUFEeEIsQ0FISztBQU1uQjhZLGdCQUFZUCxhQUFhamhDLEtBQWI7QUFOTyxHQUFyQjtBQVFEOztBQUVNLFNBQVN3Z0MsYUFBVCxDQUF1QjluQixPQUF2QixFQUF5QzFZLEtBQXpDLEVBQXdEO0FBQzdELE1BQU1sTyxPQUFTNG1CLE9BQWY7QUFDQSxNQUFNMGQsVUFBVXAyQixNQUFNbzJCLE9BQXRCO0FBQ0EsTUFBSUEsV0FBVyxJQUFmLEVBQXFCO0FBQ25CLG9EQUFvQnRrQyxJQUFwQixFQUEwQixTQUExQixFQUFxQ3NrQyxPQUFyQyxFQUE4QyxLQUE5QztBQUNEO0FBQ0Y7O0FBRU0sU0FBU3FLLGFBQVQsQ0FBdUIvbkIsT0FBdkIsRUFBeUMxWSxLQUF6QyxFQUF3RDtBQUM3RCxNQUFNbE8sT0FBUzRtQixPQUFmO0FBQ0EsTUFBSWx1QixJQUFKLEVBQWE7QUFDWCxRQUFNZzNDLGNBQWFQLGFBQWFqaEMsS0FBYixDQUFuQjs7QUFFQSxRQUNFLENBQUNsTyxLQUFLdXZDLGFBQUwsQ0FBbUJHLFVBQXBCLElBQ0FBLFdBREEsSUFFQSxDQUFDUiwrQkFISCxFQUlFO0FBQ0EsNkJBQ0UsS0FERixFQUVFLGdGQUNFLG9GQURGLEdBRUUsMERBRkYsR0FHRSxpR0FMSixFQU1FaGhDLE1BQU03USxJQU5SO0FBUUE2eEMsd0NBQWtDLElBQWxDO0FBQ0Q7QUFDRCxRQUNFbHZDLEtBQUt1dkMsYUFBTCxDQUFtQkcsVUFBbkIsSUFDQSxDQUFDQSxXQURELElBRUEsQ0FBQ1QsK0JBSEgsRUFJRTtBQUNBLDZCQUNFLEtBREYsRUFFRSwrRUFDRSxvRkFERixHQUVFLDBEQUZGLEdBR0UsaUdBTEosRUFNRS9nQyxNQUFNN1EsSUFOUjtBQVFBNHhDLHdDQUFrQyxJQUFsQztBQUNEO0FBQ0Y7O0FBRURQLGdCQUFjOW5CLE9BQWQsRUFBdUIxWSxLQUF2Qjs7QUFFQSxNQUFNNE8sUUFBUSxxQ0FBaUI1TyxNQUFNNE8sS0FBdkIsQ0FBZDtBQUNBLE1BQU16ZixPQUFPNlEsTUFBTTdRLElBQW5COztBQUVBLE1BQUl5ZixTQUFTLElBQWIsRUFBbUI7QUFDakIsUUFBSXpmLFNBQVMsUUFBYixFQUF1QjtBQUNyQixVQUNHeWYsVUFBVSxDQUFWLElBQWU5YyxLQUFLOGMsS0FBTCxLQUFlLEVBQS9CO0FBQ0E7QUFDQTtBQUNBOWMsV0FBSzhjLEtBQUwsSUFBZUEsS0FKakIsRUFLRTtBQUNBOWMsYUFBSzhjLEtBQUwsR0FBYSw2QkFBU0EsS0FBVCxDQUFiO0FBQ0Q7QUFDRixLQVRELE1BU08sSUFBSTljLEtBQUs4YyxLQUFMLEtBQWUsNkJBQVNBLEtBQVQsQ0FBbkIsRUFBb0M7QUFDekM5YyxXQUFLOGMsS0FBTCxHQUFhLDZCQUFTQSxLQUFULENBQWI7QUFDRDtBQUNGLEdBYkQsTUFhTyxJQUFJemYsU0FBUyxRQUFULElBQXFCQSxTQUFTLE9BQWxDLEVBQTJDO0FBQ2hEO0FBQ0E7QUFDQTJDLFNBQUsydkMsZUFBTCxDQUFxQixPQUFyQjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSW4wQywrQ0FBSixFQUFrQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFJMFMsTUFBTXRKLGNBQU4sQ0FBcUIsY0FBckIsQ0FBSixFQUEwQztBQUN4Q2txQyxzQkFBZ0I5dUMsSUFBaEIsRUFBc0JrTyxNQUFNN1EsSUFBNUIsRUFBa0MscUNBQWlCNlEsTUFBTTBvQixZQUF2QixDQUFsQztBQUNEO0FBQ0YsR0FQRCxNQU9PO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUkxb0IsTUFBTXRKLGNBQU4sQ0FBcUIsT0FBckIsQ0FBSixFQUFtQztBQUNqQ2txQyxzQkFBZ0I5dUMsSUFBaEIsRUFBc0JrTyxNQUFNN1EsSUFBNUIsRUFBa0N5ZixLQUFsQztBQUNELEtBRkQsTUFFTyxJQUFJNU8sTUFBTXRKLGNBQU4sQ0FBcUIsY0FBckIsQ0FBSixFQUEwQztBQUMvQ2txQyxzQkFBZ0I5dUMsSUFBaEIsRUFBc0JrTyxNQUFNN1EsSUFBNUIsRUFBa0MscUNBQWlCNlEsTUFBTTBvQixZQUF2QixDQUFsQztBQUNEO0FBQ0Y7O0FBRUQsTUFBSXA3QiwrQ0FBSixFQUFrQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFJMFMsTUFBTW9oQyxjQUFOLElBQXdCLElBQTVCLEVBQWtDO0FBQ2hDdHZDLFdBQUsydkMsZUFBTCxDQUFxQixTQUFyQjtBQUNELEtBRkQsTUFFTztBQUNMM3ZDLFdBQUtzdkMsY0FBTCxHQUFzQixDQUFDLENBQUNwaEMsTUFBTW9oQyxjQUE5QjtBQUNEO0FBQ0YsR0FURCxNQVNPO0FBQ0w7QUFDQTtBQUNBLFFBQUlwaEMsTUFBTW8yQixPQUFOLElBQWlCLElBQWpCLElBQXlCcDJCLE1BQU1vaEMsY0FBTixJQUF3QixJQUFyRCxFQUEyRDtBQUN6RHR2QyxXQUFLc3ZDLGNBQUwsR0FBc0IsQ0FBQyxDQUFDcGhDLE1BQU1vaEMsY0FBOUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBU1YsZ0JBQVQsQ0FDTGhvQixPQURLLEVBRUwxWSxLQUZLLEVBR0wwaEMsV0FISyxFQUlMO0FBQ0EsTUFBTTV2QyxPQUFTNG1CLE9BQWY7O0FBRUE7QUFDQTtBQUNBLE1BQUkxWSxNQUFNdEosY0FBTixDQUFxQixPQUFyQixLQUFpQ3NKLE1BQU10SixjQUFOLENBQXFCLGNBQXJCLENBQXJDLEVBQTJFO0FBQ3pFLFFBQU12SCxPQUFPNlEsTUFBTTdRLElBQW5CO0FBQ0EsUUFBTXd5QyxXQUFXeHlDLFNBQVMsUUFBVCxJQUFxQkEsU0FBUyxPQUEvQzs7QUFFQTtBQUNBO0FBQ0EsUUFBSXd5QyxhQUFhM2hDLE1BQU00TyxLQUFOLEtBQWdCbGtCLFNBQWhCLElBQTZCc1YsTUFBTTRPLEtBQU4sS0FBZ0IsSUFBMUQsQ0FBSixFQUFxRTtBQUNuRTtBQUNEOztBQUVELFFBQU0yeUIsZ0JBQWUsNkJBQVN6dkMsS0FBS3V2QyxhQUFMLENBQW1CRSxZQUE1QixDQUFyQjs7QUFFQTtBQUNBO0FBQ0EsUUFBSSxDQUFDRyxXQUFMLEVBQWtCO0FBQ2hCLFVBQUlwMEMsK0NBQUosRUFBa0M7QUFDaEMsWUFBTXNoQixRQUFRLHFDQUFpQjVPLE1BQU00TyxLQUF2QixDQUFkOztBQUVBO0FBQ0E7QUFDQSxZQUFJQSxTQUFTLElBQWIsRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQUkreUIsWUFBWS95QixVQUFVOWMsS0FBSzhjLEtBQS9CLEVBQXNDO0FBQ3BDOWMsaUJBQUs4YyxLQUFMLEdBQWEsNkJBQVNBLEtBQVQsQ0FBYjtBQUNEO0FBQ0Y7QUFDRixPQWxCRCxNQWtCTztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUkyeUIsa0JBQWlCenZDLEtBQUs4YyxLQUExQixFQUFpQztBQUMvQjljLGVBQUs4YyxLQUFMLEdBQWEyeUIsYUFBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJajBDLCtDQUFKLEVBQWtDO0FBQ2hDO0FBQ0E7QUFDQSxVQUFNbzdCLGVBQWUscUNBQWlCMW9CLE1BQU0wb0IsWUFBdkIsQ0FBckI7QUFDQSxVQUFJQSxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEI1MkIsYUFBSzQyQixZQUFMLEdBQW9CLDZCQUFTQSxZQUFULENBQXBCO0FBQ0Q7QUFDRixLQVBELE1BT087QUFDTDtBQUNBO0FBQ0E7QUFDQTUyQixXQUFLNDJCLFlBQUwsR0FBb0I2WSxhQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1oMkMsT0FBT3VHLEtBQUt2RyxJQUFsQjtBQUNBLE1BQUlBLFNBQVMsRUFBYixFQUFpQjtBQUNmdUcsU0FBS3ZHLElBQUwsR0FBWSxFQUFaO0FBQ0Q7O0FBRUQsTUFBSStCLCtDQUFKLEVBQWtDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDbzBDLFdBQUwsRUFBa0I7QUFDaEJsQixvQkFBYzluQixPQUFkLEVBQXVCMVksS0FBdkI7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUFJQSxNQUFNdEosY0FBTixDQUFxQixnQkFBckIsQ0FBSixFQUE0QztBQUMxQzVFLFdBQUtzdkMsY0FBTCxHQUFzQixDQUFDdHZDLEtBQUtzdkMsY0FBNUI7QUFDQXR2QyxXQUFLc3ZDLGNBQUwsR0FBc0IsQ0FBQyxDQUFDcGhDLE1BQU1vaEMsY0FBOUI7QUFDRDtBQUNGLEdBaEJELE1BZ0JPO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0F0dkMsU0FBS3N2QyxjQUFMLEdBQXNCLENBQUN0dkMsS0FBS3N2QyxjQUE1QjtBQUNBdHZDLFNBQUtzdkMsY0FBTCxHQUFzQixDQUFDLENBQUN0dkMsS0FBS3V2QyxhQUFMLENBQW1CQyxjQUEzQztBQUNEOztBQUVELE1BQUkvMUMsU0FBUyxFQUFiLEVBQWlCO0FBQ2Z1RyxTQUFLdkcsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTbzFDLHNCQUFULENBQWdDam9CLE9BQWhDLEVBQWtEMVksS0FBbEQsRUFBaUU7QUFDdEUsTUFBTWxPLE9BQVM0bUIsT0FBZjtBQUNBK25CLGdCQUFjM3VDLElBQWQsRUFBb0JrTyxLQUFwQjtBQUNBNGhDLHFCQUFtQjl2QyxJQUFuQixFQUF5QmtPLEtBQXpCO0FBQ0Q7O0FBRUQsU0FBUzRoQyxrQkFBVCxDQUE0QkMsUUFBNUIsRUFBc0M3aEMsS0FBdEMsRUFBNkM7QUFDM0MsTUFBTXpVLE9BQU95VSxNQUFNelUsSUFBbkI7QUFDQSxNQUFJeVUsTUFBTTdRLElBQU4sS0FBZSxPQUFmLElBQTBCNUQsUUFBUSxJQUF0QyxFQUE0QztBQUMxQyxRQUFJdTJDLFlBQXFCRCxRQUF6Qjs7QUFFQSxXQUFPQyxVQUFVamlDLFVBQWpCLEVBQTZCO0FBQzNCaWlDLGtCQUFjQSxVQUFVamlDLFVBQXhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNa2lDLFFBQVFELFVBQVVFLGdCQUFWLENBQ1osZ0JBQWdCQyxLQUFLQyxTQUFMLENBQWUsS0FBSzMyQyxJQUFwQixDQUFoQixHQUE0QyxpQkFEaEMsQ0FBZDs7QUFJQSxTQUFLLElBQUk4ZixJQUFJLENBQWIsRUFBZ0JBLElBQUkwMkIsTUFBTXIyQyxNQUExQixFQUFrQzJmLEdBQWxDLEVBQXVDO0FBQ3JDLFVBQU04MkIsWUFBY0osTUFBTTEyQixDQUFOLENBQXBCO0FBQ0EsVUFBSTgyQixjQUFjTixRQUFkLElBQTBCTSxVQUFVQyxJQUFWLEtBQW1CUCxTQUFTTyxJQUExRCxFQUFnRTtBQUM5RDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFNQyxhQUFhLHlEQUE2QkYsU0FBN0IsQ0FBbkI7QUFDQSwrQkFDRUUsVUFERixFQUVFLHFFQUNFLCtCQUhKOztBQU1BO0FBQ0E7QUFDQSxvREFBcUJGLFNBQXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBMUIsb0JBQWMwQixTQUFkLEVBQXlCRSxVQUF6QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU3pCLGVBQVQsQ0FDTDl1QyxJQURLLEVBRUwzQyxJQUZLLEVBR0x5ZixLQUhLLEVBSUw7QUFDQTtBQUNFO0FBQ0F6ZixXQUFTLFFBQVQsSUFDQTJDLEtBQUt3d0MsYUFBTCxDQUFtQkMsYUFBbkIsS0FBcUN6d0MsSUFIdkMsRUFJRTtBQUNBLFFBQUk4YyxTQUFTLElBQWIsRUFBbUI7QUFDakI5YyxXQUFLNDJCLFlBQUwsR0FBb0IsNkJBQVM1MkIsS0FBS3V2QyxhQUFMLENBQW1CRSxZQUE1QixDQUFwQjtBQUNELEtBRkQsTUFFTyxJQUFJenZDLEtBQUs0MkIsWUFBTCxLQUFzQiw2QkFBUzlaLEtBQVQsQ0FBMUIsRUFBMkM7QUFDaEQ5YyxXQUFLNDJCLFlBQUwsR0FBb0IsNkJBQVM5WixLQUFULENBQXBCO0FBQ0Q7QUFDRjtBQUNGLEM7Ozs7Ozs7Ozs7OztRQ2haZTR6QixtQixHQUFBQSxtQjtRQStEQUMsb0IsR0FBQUEsb0I7UUEyQkFDLG1CLEdBQUFBLG1COztBQTFHaEI7O0FBV0E7Ozs7O0FBS08sU0FBU0YsbUJBQVQsQ0FDTDF3QyxJQURLLEVBRUx2RyxJQUZLLEVBR0xvM0MsUUFISyxFQUlMajBCLFlBSkssRUFLRTtBQUNQLE1BQUlsa0IsSUFBSixFQUFhO0FBQ1gsUUFBSWtrQixhQUFhUSxlQUFqQixFQUFrQztBQUFBLFVBQ3pCRSxZQUR5QixHQUNUVixZQURTLENBQ3pCVSxZQUR5Qjs7QUFFaEMsYUFBUXRkLElBQUQsQ0FBWXNkLFlBQVosQ0FBUDtBQUNELEtBSEQsTUFHTztBQUNMLFVBQU1aLGdCQUFnQkUsYUFBYUYsYUFBbkM7O0FBRUEsVUFBSW8wQixjQUFjLElBQWxCOztBQUVBLFVBQUlsMEIsYUFBYXZmLElBQWIsS0FBc0IwZSwrQkFBMUIsRUFBOEM7QUFDNUMsWUFBSS9iLEtBQUsrd0MsWUFBTCxDQUFrQnIwQixhQUFsQixDQUFKLEVBQXNDO0FBQ3BDLGNBQU1JLFFBQVE5YyxLQUFLZ3hDLFlBQUwsQ0FBa0J0MEIsYUFBbEIsQ0FBZDtBQUNBLGNBQUlJLFVBQVUsRUFBZCxFQUFrQjtBQUNoQixtQkFBTyxJQUFQO0FBQ0Q7QUFDRCxjQUFJLHdDQUFzQnJqQixJQUF0QixFQUE0Qm8zQyxRQUE1QixFQUFzQ2owQixZQUF0QyxFQUFvRCxLQUFwRCxDQUFKLEVBQWdFO0FBQzlELG1CQUFPRSxLQUFQO0FBQ0Q7QUFDRCxjQUFJQSxVQUFVLEtBQU0rekIsUUFBcEIsRUFBb0M7QUFDbEMsbUJBQU9BLFFBQVA7QUFDRDtBQUNELGlCQUFPL3pCLEtBQVA7QUFDRDtBQUNGLE9BZEQsTUFjTyxJQUFJOWMsS0FBSyt3QyxZQUFMLENBQWtCcjBCLGFBQWxCLENBQUosRUFBc0M7QUFDM0MsWUFBSSx3Q0FBc0JqakIsSUFBdEIsRUFBNEJvM0MsUUFBNUIsRUFBc0NqMEIsWUFBdEMsRUFBb0QsS0FBcEQsQ0FBSixFQUFnRTtBQUM5RDtBQUNBO0FBQ0EsaUJBQU81YyxLQUFLZ3hDLFlBQUwsQ0FBa0J0MEIsYUFBbEIsQ0FBUDtBQUNEO0FBQ0QsWUFBSUUsYUFBYXZmLElBQWIsS0FBc0J5ZSxvQkFBMUIsRUFBbUM7QUFDakM7QUFDQTtBQUNBLGlCQUFPKzBCLFFBQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLHNCQUFjOXdDLEtBQUtneEMsWUFBTCxDQUFrQnQwQixhQUFsQixDQUFkO0FBQ0Q7O0FBRUQsVUFBSSx3Q0FBc0JqakIsSUFBdEIsRUFBNEJvM0MsUUFBNUIsRUFBc0NqMEIsWUFBdEMsRUFBb0QsS0FBcEQsQ0FBSixFQUFnRTtBQUM5RCxlQUFPazBCLGdCQUFnQixJQUFoQixHQUF1QkQsUUFBdkIsR0FBa0NDLFdBQXpDO0FBQ0QsT0FGRCxNQUVPLElBQUlBLGdCQUFnQixLQUFNRCxRQUExQixFQUEwQztBQUMvQyxlQUFPQSxRQUFQO0FBQ0QsT0FGTSxNQUVBO0FBQ0wsZUFBT0MsV0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEOzs7OztBQW5GQTs7Ozs7Ozs7O0FBd0ZPLFNBQVNILG9CQUFULENBQ0wzd0MsSUFESyxFQUVMdkcsSUFGSyxFQUdMbzNDLFFBSEssRUFJRTtBQUNQLE1BQUluNEMsSUFBSixFQUFhO0FBQ1gsUUFBSSxDQUFDLHNDQUFvQmUsSUFBcEIsQ0FBTCxFQUFnQztBQUM5QjtBQUNEO0FBQ0QsUUFBSSxDQUFDdUcsS0FBSyt3QyxZQUFMLENBQWtCdDNDLElBQWxCLENBQUwsRUFBOEI7QUFDNUIsYUFBT28zQyxhQUFhajRDLFNBQWIsR0FBeUJBLFNBQXpCLEdBQXFDLElBQTVDO0FBQ0Q7QUFDRCxRQUFNa2tCLFFBQVE5YyxLQUFLZ3hDLFlBQUwsQ0FBa0J2M0MsSUFBbEIsQ0FBZDtBQUNBLFFBQUlxakIsVUFBVSxLQUFNK3pCLFFBQXBCLEVBQW9DO0FBQ2xDLGFBQU9BLFFBQVA7QUFDRDtBQUNELFdBQU8vekIsS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTOHpCLG1CQUFULENBQ0w1d0MsSUFESyxFQUVMdkcsSUFGSyxFQUdMcWpCLEtBSEssRUFJTEQsb0JBSkssRUFLTDtBQUNBLE1BQU1ELGVBQWUsa0NBQWdCbmpCLElBQWhCLENBQXJCO0FBQ0EsTUFBSSx3Q0FBc0JBLElBQXRCLEVBQTRCbWpCLFlBQTVCLEVBQTBDQyxvQkFBMUMsQ0FBSixFQUFxRTtBQUNuRTtBQUNEO0FBQ0QsTUFBSSx3Q0FBc0JwakIsSUFBdEIsRUFBNEJxakIsS0FBNUIsRUFBbUNGLFlBQW5DLEVBQWlEQyxvQkFBakQsQ0FBSixFQUE0RTtBQUMxRUMsWUFBUSxJQUFSO0FBQ0Q7QUFDRDtBQUNBLE1BQUlELHdCQUF3QkQsaUJBQWlCLElBQTdDLEVBQW1EO0FBQ2pELFFBQUksc0NBQW9CbmpCLElBQXBCLENBQUosRUFBK0I7QUFDN0IsVUFBTWlqQixpQkFBZ0JqakIsSUFBdEI7QUFDQSxVQUFJcWpCLFVBQVUsSUFBZCxFQUFvQjtBQUNsQjljLGFBQUsydkMsZUFBTCxDQUFxQmp6QixjQUFyQjtBQUNELE9BRkQsTUFFTztBQUNMMWMsYUFBS3V1QyxZQUFMLENBQWtCN3hCLGNBQWxCLEVBQWlDLEtBQU1JLEtBQXZDO0FBQ0Q7QUFDRjtBQUNEO0FBQ0Q7QUFuQkQsTUFvQk9NLGVBcEJQLEdBb0IwQlIsWUFwQjFCLENBb0JPUSxlQXBCUDs7QUFxQkEsTUFBSUEsZUFBSixFQUFxQjtBQUFBLFFBQ1pFLFlBRFksR0FDSVYsWUFESixDQUNaVSxZQURZOztBQUVuQixRQUFJUixVQUFVLElBQWQsRUFBb0I7QUFBQSxVQUNYemYsSUFEVyxHQUNIdWYsWUFERyxDQUNYdmYsSUFEVzs7QUFFakIyQyxVQUFELENBQVlzZCxZQUFaLElBQTRCamdCLFNBQVN5ZSxvQkFBVCxHQUFtQixLQUFuQixHQUEyQixFQUF2RDtBQUNELEtBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQzliLFVBQUQsQ0FBWXNkLFlBQVosSUFBNEJSLEtBQTVCO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFqQ0EsTUFrQ09KLGFBbENQLEdBa0M0Q0UsWUFsQzVDLENBa0NPRixhQWxDUDtBQUFBLE1Ba0NzQlcsa0JBbEN0QixHQWtDNENULFlBbEM1QyxDQWtDc0JTLGtCQWxDdEI7O0FBbUNBLE1BQUlQLFVBQVUsSUFBZCxFQUFvQjtBQUNsQjljLFNBQUsydkMsZUFBTCxDQUFxQmp6QixhQUFyQjtBQUNELEdBRkQsTUFFTztBQUFBLFFBQ0VyZixLQURGLEdBQ1V1ZixZQURWLENBQ0V2ZixJQURGOztBQUVMLFFBQUk0ekMsdUJBQUo7QUFDQSxRQUFJNXpDLFVBQVN5ZSxvQkFBVCxJQUFxQnplLFVBQVMwZSwrQkFBVCxJQUErQmUsVUFBVSxJQUFsRSxFQUF5RTtBQUN2RW0wQix1QkFBaUIsRUFBakI7QUFDRCxLQUZELE1BRU87QUFDTDtBQUNBO0FBQ0FBLHVCQUFpQixLQUFNbjBCLEtBQXZCO0FBQ0Q7QUFDRCxRQUFJTyxrQkFBSixFQUF3QjtBQUN0QnJkLFdBQUtreEMsY0FBTCxDQUFvQjd6QixrQkFBcEIsRUFBd0NYLGFBQXhDLEVBQXVEdTBCLGNBQXZEO0FBQ0QsS0FGRCxNQUVPO0FBQ0xqeEMsV0FBS3V1QyxZQUFMLENBQWtCN3hCLGFBQWxCLEVBQWlDdTBCLGNBQWpDO0FBQ0Q7QUFDRjtBQUNGLEM7Ozs7Ozs7Ozs7Ozs7QUN0S0Q7Ozs7OztBQUVBOzs7O0FBSUEsSUFBTUUsd0JBQXdCbnpCLDhCQUFvQnZZLE1BQXBCLENBQTJCO0FBQ3ZEMnJDLGFBQVcsSUFENEM7QUFFdkRDLFNBQU8sSUFGZ0Q7QUFHdkRDLFVBQVEsSUFIK0M7QUFJdkRDLFlBQVUsSUFKNkM7QUFLdkRDLHNCQUFvQixJQUxtQztBQU12REMsU0FBTyxJQU5nRDtBQU92REMsU0FBTyxJQVBnRDtBQVF2REMsU0FBTyxJQVJnRDtBQVN2REMsZUFBYSxJQVQwQztBQVV2REMsYUFBVztBQVY0QyxDQUEzQixDQUE5QixDLENBYkE7Ozs7Ozs7a0JBMEJlVixxQjs7Ozs7Ozs7Ozs7OztRQ21HQ1csUSxHQUFBQSxRO1FBaURBQyw0QixHQUFBQSw0Qjs7QUFyS2hCOztBQUNBOztBQVlBOztBQU1BOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE5QkE7Ozs7Ozs7OztBQXNGQSxJQUFNQyxxQkFBcUIsRUFBM0I7QUFDQSxJQUFJQywyQkFBMkIsQ0FBL0I7O0FBRUE7OztBQUdBLElBQU1DLG9CQUFvQixzQkFBc0IsQ0FBQyxLQUFLMWtDLEtBQUtDLE1BQUwsRUFBTixFQUFxQkUsS0FBckIsQ0FBMkIsQ0FBM0IsQ0FBaEQ7O0FBRUEsU0FBU3drQyx1QkFBVCxDQUFpQ0MsT0FBakMsRUFBK0M7QUFDN0M7QUFDQTtBQUNBLE1BQUksQ0FBQ3J0QyxPQUFPNUssU0FBUCxDQUFpQnlLLGNBQWpCLENBQWdDdkssSUFBaEMsQ0FBcUMrM0MsT0FBckMsRUFBOENGLGlCQUE5QyxDQUFMLEVBQXVFO0FBQ3JFRSxZQUFRRixpQkFBUixJQUE2QkQsMEJBQTdCO0FBQ0FELHVCQUFtQkksUUFBUUYsaUJBQVIsQ0FBbkIsSUFBaUQsRUFBakQ7QUFDRDtBQUNELFNBQU9GLG1CQUFtQkksUUFBUUYsaUJBQVIsQ0FBbkIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQk8sU0FBU0osUUFBVCxDQUNMMThCLGdCQURLLEVBRUxnOUIsT0FGSyxFQUdMO0FBQ0EsTUFBTUMsY0FBY0Ysd0JBQXdCQyxPQUF4QixDQUFwQjtBQUNBLE1BQU12M0IsZUFBZUQsa0RBQTZCeEYsZ0JBQTdCLENBQXJCOztBQUVBLE9BQUssSUFBSW1FLElBQUksQ0FBYixFQUFnQkEsSUFBSXNCLGFBQWFqaEIsTUFBakMsRUFBeUMyZixHQUF6QyxFQUE4QztBQUM1QyxRQUFNaEYsYUFBYXNHLGFBQWF0QixDQUFiLENBQW5CO0FBQ0EsUUFBSSxFQUFFODRCLFlBQVl6dEMsY0FBWixDQUEyQjJQLFVBQTNCLEtBQTBDODlCLFlBQVk5OUIsVUFBWixDQUE1QyxDQUFKLEVBQTBFO0FBQ3hFLGNBQVFBLFVBQVI7QUFDRSxhQUFLL0ksaUNBQUw7QUFDRSx3REFBa0JBLGlDQUFsQixFQUE4QjRtQyxPQUE5QjtBQUNBO0FBQ0YsYUFBSzVvQyxnQ0FBTDtBQUNBLGFBQUs1QiwrQkFBTDtBQUNFLHdEQUFrQjRCLGdDQUFsQixFQUE2QjRvQyxPQUE3QjtBQUNBLHdEQUFrQnhxQywrQkFBbEIsRUFBNEJ3cUMsT0FBNUI7QUFDQTtBQUNBO0FBQ0FDLHNCQUFZenFDLCtCQUFaLElBQXdCLElBQXhCO0FBQ0F5cUMsc0JBQVk3b0MsZ0NBQVosSUFBeUIsSUFBekI7QUFDQTtBQUNGLGFBQUt6QixpQ0FBTDtBQUNBLGFBQUtHLGdDQUFMO0FBQ0UsY0FBSSxnQ0FBaUIsNENBQWdCcU0sVUFBaEIsQ0FBakIsQ0FBSixFQUFtRDtBQUNqRCwwREFBa0JBLFVBQWxCLEVBQThCNjlCLE9BQTlCO0FBQ0Q7QUFDRDtBQUNGLGFBQUt6b0Msa0NBQUw7QUFDQSxhQUFLa0MsaUNBQUw7QUFDQSxhQUFLTixnQ0FBTDtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBLGNBQU0rbUMsZUFBZTVsQyx1Q0FBZ0J3TixPQUFoQixDQUF3QjNGLFVBQXhCLE1BQXdDLENBQUMsQ0FBOUQ7QUFDQSxjQUFJLENBQUMrOUIsWUFBTCxFQUFtQjtBQUNqQix5REFBaUIvOUIsVUFBakIsRUFBNkI2OUIsT0FBN0I7QUFDRDtBQUNEO0FBaENKO0FBa0NBQyxrQkFBWTk5QixVQUFaLElBQTBCLElBQTFCO0FBQ0Q7QUFDRjtBQUNGOztBQUVNLFNBQVN3OUIsNEJBQVQsQ0FDTDM4QixnQkFESyxFQUVMZzlCLE9BRkssRUFHTDtBQUNBLE1BQU1DLGNBQWNGLHdCQUF3QkMsT0FBeEIsQ0FBcEI7QUFDQSxNQUFNdjNCLGVBQWVELGtEQUE2QnhGLGdCQUE3QixDQUFyQjtBQUNBLE9BQUssSUFBSW1FLElBQUksQ0FBYixFQUFnQkEsSUFBSXNCLGFBQWFqaEIsTUFBakMsRUFBeUMyZixHQUF6QyxFQUE4QztBQUM1QyxRQUFNaEYsYUFBYXNHLGFBQWF0QixDQUFiLENBQW5CO0FBQ0EsUUFBSSxFQUFFODRCLFlBQVl6dEMsY0FBWixDQUEyQjJQLFVBQTNCLEtBQTBDODlCLFlBQVk5OUIsVUFBWixDQUE1QyxDQUFKLEVBQTBFO0FBQ3hFLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLElBQVA7QUFDRDs7UUFFT2crQixVLEdBQUFBLGlDO1FBQVlDLFMsR0FBQUEsZ0M7UUFBV0MsZ0IsR0FBQUEsdUM7UUFBa0JDLGlCLEdBQUFBLHdDOzs7Ozs7Ozs7Ozs7O1FDdEVqQ0gsVSxHQUFBQSxVO1FBSUFDLFMsR0FBQUEsUztRQWFBQyxnQixHQUFBQSxnQjtRQTRCQUMsaUIsR0FBQUEsaUI7UUF1QkFDLGEsR0FBQUEsYTs7QUE5S2hCOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQXRCQTs7Ozs7Ozs7O0lBd0JPQyw4QixHQUFrQ0MsMkIsQ0FBbENELDhCOzs7QUFFUCxJQUFNRSxpQ0FBaUMsRUFBdkM7QUFDQSxJQUFNQywwQkFBMEIsRUFBaEM7O0FBRUE7Ozs7O0FBS0EsU0FBU0MscUJBQVQsQ0FBK0JobEMsSUFBL0IsRUFBcUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsU0FBT0EsS0FBSy9OLE1BQVosRUFBb0I7QUFDbEIrTixXQUFPQSxLQUFLL04sTUFBWjtBQUNEO0FBQ0QsTUFBSStOLEtBQUsxUSxHQUFMLEtBQWF4Qix1QkFBakIsRUFBMkI7QUFDekI7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNELFNBQU9rUyxLQUFLQyxTQUFMLENBQWVtWixhQUF0QjtBQUNEOztBQUVEO0FBQ0EsU0FBUzZyQiw4QkFBVCxDQUNFdG1DLFlBREYsRUFFRXpJLFdBRkYsRUFHRUQsVUFIRixFQVNFO0FBQ0EsTUFBSTh1Qyx3QkFBd0JuNUMsTUFBNUIsRUFBb0M7QUFDbEMsUUFBTWlOLFdBQVdrc0Msd0JBQXdCanNDLEdBQXhCLEVBQWpCO0FBQ0FELGFBQVM4RixZQUFULEdBQXdCQSxZQUF4QjtBQUNBOUYsYUFBUzNDLFdBQVQsR0FBdUJBLFdBQXZCO0FBQ0EyQyxhQUFTNUMsVUFBVCxHQUFzQkEsVUFBdEI7QUFDQSxXQUFPNEMsUUFBUDtBQUNEO0FBQ0QsU0FBTztBQUNMOEYsOEJBREs7QUFFTHpJLDRCQUZLO0FBR0xELDBCQUhLO0FBSUxpdkMsZUFBVztBQUpOLEdBQVA7QUFNRDs7QUFFRCxTQUFTQyxrQ0FBVCxDQUE0Q3RzQyxRQUE1QyxFQUFzRDtBQUNwREEsV0FBUzhGLFlBQVQsR0FBd0IsSUFBeEI7QUFDQTlGLFdBQVMzQyxXQUFULEdBQXVCLElBQXZCO0FBQ0EyQyxXQUFTNUMsVUFBVCxHQUFzQixJQUF0QjtBQUNBNEMsV0FBU3FzQyxTQUFULENBQW1CdDVDLE1BQW5CLEdBQTRCLENBQTVCO0FBQ0EsTUFBSW01Qyx3QkFBd0JuNUMsTUFBeEIsR0FBaUNrNUMsOEJBQXJDLEVBQXFFO0FBQ25FQyw0QkFBd0IvckMsSUFBeEIsQ0FBNkJILFFBQTdCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTdXNDLGNBQVQsQ0FBd0JDLFdBQXhCLEVBQXFDO0FBQ25DLE1BQUlwdkMsYUFBYW92QyxZQUFZcHZDLFVBQTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSXF2QyxXQUFXcnZDLFVBQWY7QUFDQSxLQUFHO0FBQ0QsUUFBSSxDQUFDcXZDLFFBQUwsRUFBZTtBQUNiRCxrQkFBWUgsU0FBWixDQUFzQmxzQyxJQUF0QixDQUEyQnNzQyxRQUEzQjtBQUNBO0FBQ0Q7QUFDRCxRQUFNOW9CLE9BQU93b0Isc0JBQXNCTSxRQUF0QixDQUFiO0FBQ0EsUUFBSSxDQUFDOW9CLElBQUwsRUFBVztBQUNUO0FBQ0Q7QUFDRDZvQixnQkFBWUgsU0FBWixDQUFzQmxzQyxJQUF0QixDQUEyQnNzQyxRQUEzQjtBQUNBQSxlQUFXLHVEQUEyQjlvQixJQUEzQixDQUFYO0FBQ0QsR0FYRCxRQVdTOG9CLFFBWFQ7O0FBYUEsT0FBSyxJQUFJLzVCLElBQUksQ0FBYixFQUFnQkEsSUFBSTg1QixZQUFZSCxTQUFaLENBQXNCdDVDLE1BQTFDLEVBQWtEMmYsR0FBbEQsRUFBdUQ7QUFDckR0VixpQkFBYW92QyxZQUFZSCxTQUFaLENBQXNCMzVCLENBQXRCLENBQWI7QUFDQSxtREFDRTg1QixZQUFZMW1DLFlBRGQsRUFFRTFJLFVBRkYsRUFHRW92QyxZQUFZbnZDLFdBSGQsRUFJRSw4QkFBZW12QyxZQUFZbnZDLFdBQTNCLENBSkY7QUFNRDtBQUNGOztBQUVEO0FBQ08sSUFBSXF2Qyw4QkFBVyxJQUFmOztBQUVBLFNBQVNoQixVQUFULENBQW9CaUIsT0FBcEIsRUFBdUM7QUFDNUMsVUFIU0QsUUFHVCxjQUFXLENBQUMsQ0FBQ0MsT0FBYjtBQUNEOztBQUVNLFNBQVNoQixTQUFULEdBQXFCO0FBQzFCLFNBQU9lLFFBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBU2QsZ0JBQVQsQ0FDTDlsQyxZQURLLEVBRUxpYSxPQUZLLEVBR0w7QUFDQSxNQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBTTZzQixXQUFXYiwrQkFBK0JqbUMsWUFBL0IsSUFDYittQyx3QkFEYSxHQUViZixhQUZKOztBQUlBLDZDQUNFL3JCLE9BREYsRUFFRSw0Q0FBZ0JqYSxZQUFoQixDQUZGO0FBR0U7QUFDQThtQyxXQUFTN25CLElBQVQsQ0FBYyxJQUFkLEVBQW9CamYsWUFBcEIsQ0FKRjtBQU1EOztBQUVEOzs7Ozs7Ozs7QUFTTyxTQUFTK2xDLGlCQUFULENBQ0wvbEMsWUFESyxFQUVMaWEsT0FGSyxFQUdMO0FBQ0EsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWixXQUFPLElBQVA7QUFDRDtBQUNELE1BQU02c0IsV0FBV2IsK0JBQStCam1DLFlBQS9CLElBQ2IrbUMsd0JBRGEsR0FFYmYsYUFGSjs7QUFJQSw4Q0FDRS9yQixPQURGLEVBRUUsNENBQWdCamEsWUFBaEIsQ0FGRjtBQUdFO0FBQ0E4bUMsV0FBUzduQixJQUFULENBQWMsSUFBZCxFQUFvQmpmLFlBQXBCLENBSkY7QUFNRDs7QUFFRCxTQUFTK21DLHdCQUFULENBQWtDL21DLFlBQWxDLEVBQWdEekksV0FBaEQsRUFBNkQ7QUFDM0QsZ0RBQW1CeXVDLGFBQW5CLEVBQWtDaG1DLFlBQWxDLEVBQWdEekksV0FBaEQ7QUFDRDs7QUFFTSxTQUFTeXVDLGFBQVQsQ0FDTGhtQyxZQURLLEVBRUx6SSxXQUZLLEVBR0w7QUFDQSxNQUFJLENBQUNxdkMsUUFBTCxFQUFlO0FBQ2I7QUFDRDs7QUFFRCxNQUFNcHZDLG9CQUFvQiw4QkFBZUQsV0FBZixDQUExQjtBQUNBLE1BQUlELGFBQWEsdURBQTJCRSxpQkFBM0IsQ0FBakI7QUFDQSxNQUNFRixlQUFlLElBQWYsSUFDQSxPQUFPQSxXQUFXM0csR0FBbEIsS0FBMEIsUUFEMUIsSUFFQSxDQUFDLGdDQUFlMkcsVUFBZixDQUhILEVBSUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxpQkFBYSxJQUFiO0FBQ0Q7O0FBRUQsTUFBTW92QyxjQUFjSiwrQkFDbEJ0bUMsWUFEa0IsRUFFbEJ6SSxXQUZrQixFQUdsQkQsVUFIa0IsQ0FBcEI7O0FBTUEsTUFBSTtBQUNGO0FBQ0E7QUFDQSw4Q0FBZW12QyxjQUFmLEVBQStCQyxXQUEvQjtBQUNELEdBSkQsU0FJVTtBQUNSRix1Q0FBbUNFLFdBQW5DO0FBQ0Q7QUFDRixDOzs7Ozs7Ozs7Ozs7O3lwQkM5TkQ7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7OztBQUVBOztJQUFZTSxxQjs7QUFDWjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLElBQU1DLDRCQUErQyxDQUNuRCxDQUFDRCxzQkFBc0IvckMsUUFBdkIsRUFBaUMsTUFBakMsQ0FEbUQsRUFFbkQsQ0FBQytyQyxzQkFBc0I1ckMsVUFBdkIsRUFBbUMsUUFBbkMsQ0FGbUQsRUFHbkQsQ0FBQzRyQyxzQkFBc0IxckMsU0FBdkIsRUFBa0MsT0FBbEMsQ0FIbUQsRUFJbkQsQ0FBQzByQyxzQkFBc0J6ckMsU0FBdkIsRUFBa0MsT0FBbEMsQ0FKbUQsRUFLbkQsQ0FBQ3lyQyxzQkFBc0JyckMsZ0JBQXZCLEVBQXlDLGFBQXpDLENBTG1ELEVBTW5ELENBQUNxckMsc0JBQXNCcHJDLFFBQXZCLEVBQWlDLE1BQWpDLENBTm1ELEVBT25ELENBQUNvckMsc0JBQXNCbnJDLE9BQXZCLEVBQWdDLEtBQWhDLENBUG1ELEVBUW5ELENBQUNtckMsc0JBQXNCanJDLGFBQXZCLEVBQXNDLFVBQXRDLENBUm1ELEVBU25ELENBQUNpckMsc0JBQXNCbHJDLGdCQUF2QixFQUF5QyxhQUF6QyxDQVRtRCxFQVVuRCxDQUFDa3JDLHNCQUFzQi9xQyxZQUF2QixFQUFxQyxTQUFyQyxDQVZtRCxFQVduRCxDQUFDK3FDLHNCQUFzQjFxQyxjQUF2QixFQUF1QyxXQUF2QyxDQVhtRCxFQVluRCxDQUFDMHFDLHNCQUFzQnpxQyxRQUF2QixFQUFpQyxNQUFqQyxDQVptRCxFQWFuRCxDQUFDeXFDLHNCQUFzQm5xQyxTQUF2QixFQUFrQyxPQUFsQyxDQWJtRCxFQWNuRCxDQUFDbXFDLHNCQUFzQmpxQyxTQUF2QixFQUFrQyxPQUFsQyxDQWRtRCxFQWVuRCxDQUFDaXFDLHNCQUFzQmhxQyxXQUF2QixFQUFvQyxTQUFwQyxDQWZtRCxFQWdCbkQsQ0FBQ2dxQyxzQkFBc0IvcEMsWUFBdkIsRUFBcUMsU0FBckMsQ0FoQm1ELEVBaUJuRCxDQUFDK3BDLHNCQUFzQjlwQyxhQUF2QixFQUFzQyxVQUF0QyxDQWpCbUQsRUFrQm5ELENBQUM4cEMsc0JBQXNCN3BDLFVBQXZCLEVBQW1DLE9BQW5DLENBbEJtRCxFQW1CbkQsQ0FBQzZwQyxzQkFBc0J2cEMsY0FBdkIsRUFBdUMsV0FBdkMsQ0FuQm1ELEVBb0JuRCxDQUFDdXBDLHNCQUFzQm5wQyxZQUF2QixFQUFxQyxTQUFyQyxDQXBCbUQsRUFxQm5ELENBQUNtcEMsc0JBQXNCbHBDLFNBQXZCLEVBQWtDLE9BQWxDLENBckJtRCxFQXNCbkQsQ0FBQ2twQyxzQkFBc0JqcEMsU0FBdkIsRUFBa0MsT0FBbEMsQ0F0Qm1ELEVBdUJuRCxDQUFDaXBDLHNCQUFzQmhwQyxRQUF2QixFQUFpQyxNQUFqQyxDQXZCbUQsRUF3Qm5ELENBQUNncEMsc0JBQXNCOW9DLGtCQUF2QixFQUEyQyxlQUEzQyxDQXhCbUQsRUF5Qm5ELENBQUM4b0Msc0JBQXNCN29DLGdCQUF2QixFQUF5QyxhQUF6QyxDQXpCbUQsRUEwQm5ELENBQUM2b0Msc0JBQXNCdm9DLGNBQXZCLEVBQXVDLFdBQXZDLENBMUJtRCxFQTJCbkQsQ0FBQ3VvQyxzQkFBc0Jyb0MsZUFBdkIsRUFBd0MsWUFBeEMsQ0EzQm1ELEVBNEJuRCxDQUFDcW9DLHNCQUFzQnBvQyxTQUF2QixFQUFrQyxPQUFsQyxDQTVCbUQsRUE2Qm5ELENBQUNvb0Msc0JBQXNCbG9DLFVBQXZCLEVBQW1DLFFBQW5DLENBN0JtRCxFQThCbkQsQ0FBQ2tvQyxzQkFBc0I5bkMsVUFBdkIsRUFBbUMsUUFBbkMsQ0E5Qm1ELEVBK0JuRCxDQUFDOG5DLHNCQUFzQnpuQyxnQkFBdkIsRUFBeUMsYUFBekMsQ0EvQm1ELEVBZ0NuRCxDQUFDeW5DLHNCQUFzQnhuQyxhQUF2QixFQUFzQyxVQUF0QyxDQWhDbUQsRUFpQ25ELENBQUN3bkMsc0JBQXNCdG5DLGVBQXZCLEVBQXdDLFlBQXhDLENBakNtRCxFQWtDbkQsQ0FBQ3NuQyxzQkFBc0JwbkMsaUJBQXZCLEVBQTBDLGNBQTFDLENBbENtRCxDQUFyRDtBQW9DQSxJQUFNc25DLCtCQUFrRCxDQUN0RCxDQUFDRixzQkFBc0Juc0MsU0FBdkIsRUFBa0MsT0FBbEMsQ0FEc0QsRUFFdEQsQ0FBQ21zQyxzQkFBc0Jsc0MsaUJBQXZCLEVBQTBDLGNBQTFDLENBRnNELEVBR3RELENBQUNrc0Msc0JBQXNCanNDLHVCQUF2QixFQUFnRCxvQkFBaEQsQ0FIc0QsRUFJdEQsQ0FBQ2lzQyxzQkFBc0Joc0MsbUJBQXZCLEVBQTRDLGdCQUE1QyxDQUpzRCxFQUt0RCxDQUFDZ3NDLHNCQUFzQjlyQyxZQUF2QixFQUFxQyxTQUFyQyxDQUxzRCxFQU10RCxDQUFDOHJDLHNCQUFzQjdyQyxvQkFBdkIsRUFBNkMsZ0JBQTdDLENBTnNELEVBT3RELENBQUM2ckMsc0JBQXNCaHJDLFFBQXZCLEVBQWlDLE1BQWpDLENBUHNELEVBUXRELENBQUNnckMsc0JBQXNCOXFDLGNBQXZCLEVBQXVDLFdBQXZDLENBUnNELEVBU3RELENBQUM4cUMsc0JBQXNCN3FDLGFBQXZCLEVBQXNDLFVBQXRDLENBVHNELEVBVXRELENBQUM2cUMsc0JBQXNCNXFDLGNBQXZCLEVBQXVDLFdBQXZDLENBVnNELEVBV3RELENBQUM0cUMsc0JBQXNCM3FDLGFBQXZCLEVBQXNDLFVBQXRDLENBWHNELEVBWXRELENBQUMycUMsc0JBQXNCeHFDLG1CQUF2QixFQUE0QyxnQkFBNUMsQ0Fac0QsRUFhdEQsQ0FBQ3dxQyxzQkFBc0J2cUMsV0FBdkIsRUFBb0MsU0FBcEMsQ0Fic0QsRUFjdEQsQ0FBQ3VxQyxzQkFBc0J0cUMsYUFBdkIsRUFBc0MsV0FBdEMsQ0Fkc0QsRUFldEQsQ0FBQ3NxQyxzQkFBc0JycUMsU0FBdkIsRUFBa0MsT0FBbEMsQ0Fmc0QsRUFnQnRELENBQUNxcUMsc0JBQXNCcHFDLFNBQXZCLEVBQWtDLE9BQWxDLENBaEJzRCxFQWlCdEQsQ0FBQ29xQyxzQkFBc0JscUMsdUJBQXZCLEVBQWdELG1CQUFoRCxDQWpCc0QsRUFrQnRELENBQUNrcUMsc0JBQXNCNXBDLFFBQXZCLEVBQWlDLE1BQWpDLENBbEJzRCxFQW1CdEQsQ0FBQzRwQyxzQkFBc0IxcEMsZUFBdkIsRUFBd0MsWUFBeEMsQ0FuQnNELEVBb0J0RCxDQUFDMHBDLHNCQUFzQnpwQyxtQkFBdkIsRUFBNEMsZ0JBQTVDLENBcEJzRCxFQXFCdEQsQ0FBQ3lwQyxzQkFBc0IzcEMsY0FBdkIsRUFBdUMsV0FBdkMsQ0FyQnNELEVBc0J0RCxDQUFDMnBDLHNCQUFzQnhwQyx3QkFBdkIsRUFBaUQsb0JBQWpELENBdEJzRCxFQXVCdEQsQ0FBQ3dwQyxzQkFBc0J0cEMsY0FBdkIsRUFBdUMsV0FBdkMsQ0F2QnNELEVBd0J0RCxDQUFDc3BDLHNCQUFzQnJwQyxhQUF2QixFQUFzQyxVQUF0QyxDQXhCc0QsRUF5QnRELENBQUNxcEMsc0JBQXNCcHBDLGNBQXZCLEVBQXVDLFdBQXZDLENBekJzRCxFQTBCdEQsQ0FBQ29wQyxzQkFBc0Ivb0MsV0FBdkIsRUFBb0MsU0FBcEMsQ0ExQnNELEVBMkJ0RCxDQUFDK29DLHNCQUFzQjFvQyxnQkFBdkIsRUFBeUMsYUFBekMsQ0EzQnNELEVBNEJ0RCxDQUFDMG9DLHNCQUFzQnpvQyxlQUF2QixFQUF3QyxZQUF4QyxDQTVCc0QsRUE2QnRELENBQUN5b0Msc0JBQXNCeG9DLGdCQUF2QixFQUF5QyxhQUF6QyxDQTdCc0QsRUE4QnRELENBQUN3b0Msc0JBQXNCdG9DLFlBQXZCLEVBQXFDLFVBQXJDLENBOUJzRCxFQStCdEQsQ0FBQ3NvQyxzQkFBc0Jub0MsVUFBdkIsRUFBbUMsUUFBbkMsQ0EvQnNELEVBZ0N0RCxDQUFDbW9DLHNCQUFzQmpvQyxXQUF2QixFQUFvQyxTQUFwQyxDQWhDc0QsRUFpQ3RELENBQUNpb0Msc0JBQXNCL25DLFdBQXZCLEVBQW9DLFNBQXBDLENBakNzRCxFQWtDdEQsQ0FBQytuQyxzQkFBc0I3bkMsV0FBdkIsRUFBb0MsU0FBcEMsQ0FsQ3NELEVBbUN0RCxDQUFDNm5DLHNCQUFzQjNuQyxlQUF2QixFQUF3QyxZQUF4QyxDQW5Dc0QsRUFvQ3RELENBQUMybkMsc0JBQXNCMW5DLFVBQXZCLEVBQW1DLFFBQW5DLENBcENzRCxFQXFDdEQsQ0FBQzBuQyxzQkFBc0J2bkMsY0FBdkIsRUFBdUMsV0FBdkMsQ0FyQ3NELEVBc0N0RCxDQUFDdW5DLHNCQUFzQnJuQyxrQkFBdkIsRUFBMkMsZUFBM0MsQ0F0Q3NELEVBdUN0RCxDQUFDcW5DLHNCQUFzQm5uQyxXQUF2QixFQUFvQyxTQUFwQyxDQXZDc0QsRUF3Q3RELENBQUNtbkMsc0JBQXNCbG5DLFNBQXZCLEVBQWtDLE9BQWxDLENBeENzRCxDQUF4RDs7QUEyQ0EsSUFBTTJOLGFBQXlCLEVBQS9CO0FBQ0EsSUFBTTA1QixpQ0FFRixFQUZKOztBQUlBLFNBQVNDLHdCQUFULE9BRUUvNkIsYUFGRixFQUdFO0FBQUE7QUFBQSxNQUZDZzdCLFFBRUQ7QUFBQSxNQUZXeHdDLEtBRVg7O0FBQ0EsTUFBTXl3QyxtQkFBbUJ6d0MsTUFBTSxDQUFOLEVBQVNtYSxXQUFULEtBQXlCbmEsTUFBTW1LLEtBQU4sQ0FBWSxDQUFaLENBQWxEO0FBQ0EsTUFBTXVtQyxVQUFVLE9BQU9ELGdCQUF2Qjs7QUFFQSxNQUFNNTJDLE9BQU87QUFDWGdZLDZCQUF5QjtBQUN2QjgrQixlQUFTRCxPQURjO0FBRXZCRSxnQkFBVUYsVUFBVTtBQUZHLEtBRGQ7QUFLWHI1QixrQkFBYyxDQUFDbTVCLFFBQUQsQ0FMSDtBQU1YaDdCO0FBTlcsR0FBYjtBQVFBb0IsYUFBVzVXLEtBQVgsSUFBb0JuRyxJQUFwQjtBQUNBeTJDLGlDQUErQkUsUUFBL0IsSUFBMkMzMkMsSUFBM0M7QUFDRDs7QUFFRHUyQywwQkFBMEJyMkIsT0FBMUIsQ0FBa0Msc0JBQWM7QUFDOUN3MkIsMkJBQXlCTSxVQUF6QixFQUFxQyxJQUFyQztBQUNELENBRkQ7QUFHQVIsNkJBQTZCdDJCLE9BQTdCLENBQXFDLHNCQUFjO0FBQ2pEdzJCLDJCQUF5Qk0sVUFBekIsRUFBcUMsS0FBckM7QUFDRCxDQUZEOztBQUlBO0FBQ0EsSUFBTUMseUJBQXNELENBQzFEWCxzQkFBc0Juc0MsU0FEb0MsRUFFMURtc0Msc0JBQXNCNXJDLFVBRm9DLEVBRzFENHJDLHNCQUFzQjlyQyxZQUhvQyxFQUkxRDhyQyxzQkFBc0I3ckMsb0JBSm9DLEVBSzFENnJDLHNCQUFzQnpyQyxTQUxvQyxFQU0xRHlyQyxzQkFBc0J4cUMsbUJBTm9DLEVBTzFEd3FDLHNCQUFzQnZxQyxXQVBvQyxFQVExRHVxQyxzQkFBc0J0cUMsYUFSb0MsRUFTMURzcUMsc0JBQXNCcnFDLFNBVG9DLEVBVTFEcXFDLHNCQUFzQnBxQyxTQVZvQyxFQVcxRG9xQyxzQkFBc0JqcUMsU0FYb0MsRUFZMURpcUMsc0JBQXNCaHFDLFdBWm9DLEVBYTFEZ3FDLHNCQUFzQjVwQyxRQWJvQyxFQWMxRDRwQyxzQkFBc0IxcEMsZUFkb0MsRUFlMUQwcEMsc0JBQXNCenBDLG1CQWZvQyxFQWdCMUR5cEMsc0JBQXNCM3BDLGNBaEJvQyxFQWlCMUQycEMsc0JBQXNCanBDLFNBakJvQyxFQWtCMURpcEMsc0JBQXNCaHBDLFFBbEJvQyxFQW1CMURncEMsc0JBQXNCL29DLFdBbkJvQyxFQW9CMUQrb0Msc0JBQXNCdG9DLFlBcEJvQyxFQXFCMURzb0Msc0JBQXNCcm9DLGVBckJvQyxFQXNCMURxb0Msc0JBQXNCcG9DLFNBdEJvQyxFQXVCMURvb0Msc0JBQXNCbG9DLFVBdkJvQyxFQXdCMURrb0Msc0JBQXNCam9DLFdBeEJvQyxFQXlCMURpb0Msc0JBQXNCL25DLFdBekJvQyxFQTBCMUQrbkMsc0JBQXNCOW5DLFVBMUJvQyxFQTJCMUQ4bkMsc0JBQXNCN25DLFdBM0JvQyxFQTRCMUQ2bkMsc0JBQXNCM25DLGVBNUJvQyxFQTZCMUQybkMsc0JBQXNCMW5DLFVBN0JvQyxFQThCMUQwbkMsc0JBQXNCcG5DLGlCQTlCb0MsRUErQjFEb25DLHNCQUFzQm5uQyxXQS9Cb0MsQ0FBNUQ7O0FBa0NBLElBQU1xbUMsb0JBRUY7QUFDRno0QixjQUFZQSxVQURWOztBQUdGdzRCLGdDQUhFLDBDQUc2QmptQyxZQUg3QixFQUdrRTtBQUNsRSxRQUFNaXpCLFNBQVNrVSwrQkFBK0JubkMsWUFBL0IsQ0FBZjtBQUNBLFdBQU9pekIsV0FBV2huQyxTQUFYLElBQXdCZ25DLE9BQU81bUIsYUFBUCxLQUF5QixJQUF4RDtBQUNELEdBTkM7OztBQVFGTSxpQkFBZSx1QkFDYjNNLFlBRGEsRUFFYjFJLFVBRmEsRUFHYkMsV0FIYSxFQUliQyxpQkFKYSxFQUtlO0FBQzVCLFFBQU1ILGlCQUFpQjh2QywrQkFBK0JubkMsWUFBL0IsQ0FBdkI7QUFDQSxRQUFJLENBQUMzSSxjQUFMLEVBQXFCO0FBQ25CLGFBQU8sSUFBUDtBQUNEO0FBQ0QsUUFBSTJDLHlCQUFKO0FBQ0EsWUFBUWdHLFlBQVI7QUFDRSxXQUFLZ25DLHNCQUFzQjlwQyxhQUEzQjtBQUNFO0FBQ0E7QUFDQTtBQUNBLFlBQUksZ0NBQWlCM0YsV0FBakIsTUFBa0MsQ0FBdEMsRUFBeUM7QUFDdkMsaUJBQU8sSUFBUDtBQUNEO0FBQ0g7QUFDQSxXQUFLeXZDLHNCQUFzQi9wQyxZQUEzQjtBQUNBLFdBQUsrcEMsc0JBQXNCN3BDLFVBQTNCO0FBQ0VuRCwyQkFBbUI0dEMsZ0NBQW5CO0FBQ0E7QUFDRixXQUFLWixzQkFBc0IvckMsUUFBM0I7QUFDQSxXQUFLK3JDLHNCQUFzQm5xQyxTQUEzQjtBQUNFN0MsMkJBQW1CNnRDLDZCQUFuQjtBQUNBO0FBQ0YsV0FBS2Isc0JBQXNCMXJDLFNBQTNCO0FBQ0U7QUFDQTtBQUNBLFlBQUkvRCxZQUFZNGEsTUFBWixLQUF1QixDQUEzQixFQUE4QjtBQUM1QixpQkFBTyxJQUFQO0FBQ0Q7QUFDSDtBQUNBLFdBQUs2MEIsc0JBQXNCanJDLGFBQTNCO0FBQ0EsV0FBS2lyQyxzQkFBc0JsckMsZ0JBQTNCO0FBQ0EsV0FBS2tyQyxzQkFBc0J2cEMsY0FBM0I7QUFDQSxXQUFLdXBDLHNCQUFzQnRwQyxjQUEzQjtBQUNBLFdBQUtzcEMsc0JBQXNCbnBDLFlBQTNCO0FBQ0E7QUFDQTtBQUNBLFdBQUttcEMsc0JBQXNCcnBDLGFBQTNCO0FBQ0EsV0FBS3FwQyxzQkFBc0JwcEMsY0FBM0I7QUFDQSxXQUFLb3BDLHNCQUFzQnJyQyxnQkFBM0I7QUFDRTNCLDJCQUFtQnFYLDZCQUFuQjtBQUNBO0FBQ0YsV0FBSzIxQixzQkFBc0JockMsUUFBM0I7QUFDQSxXQUFLZ3JDLHNCQUFzQi9xQyxZQUEzQjtBQUNBLFdBQUsrcUMsc0JBQXNCOXFDLGNBQTNCO0FBQ0EsV0FBSzhxQyxzQkFBc0I3cUMsYUFBM0I7QUFDQSxXQUFLNnFDLHNCQUFzQjVxQyxjQUEzQjtBQUNBLFdBQUs0cUMsc0JBQXNCM3FDLGFBQTNCO0FBQ0EsV0FBSzJxQyxzQkFBc0IxcUMsY0FBM0I7QUFDQSxXQUFLMHFDLHNCQUFzQnpxQyxRQUEzQjtBQUNFdkMsMkJBQW1COHRDLDRCQUFuQjtBQUNBO0FBQ0YsV0FBS2Qsc0JBQXNCem5DLGdCQUEzQjtBQUNBLFdBQUt5bkMsc0JBQXNCeG5DLGFBQTNCO0FBQ0EsV0FBS3duQyxzQkFBc0J2bkMsY0FBM0I7QUFDQSxXQUFLdW5DLHNCQUFzQnRuQyxlQUEzQjtBQUNFMUYsMkJBQW1CK3RDLDZCQUFuQjtBQUNBO0FBQ0YsV0FBS2Ysc0JBQXNCbHNDLGlCQUEzQjtBQUNBLFdBQUtrc0Msc0JBQXNCanNDLHVCQUEzQjtBQUNBLFdBQUtpc0Msc0JBQXNCaHNDLG1CQUEzQjtBQUNFaEIsMkJBQW1CZ3VDLGlDQUFuQjtBQUNBO0FBQ0YsV0FBS2hCLHNCQUFzQnJuQyxrQkFBM0I7QUFDRTNGLDJCQUFtQml1QyxrQ0FBbkI7QUFDQTtBQUNGLFdBQUtqQixzQkFBc0Jub0MsVUFBM0I7QUFDRTdFLDJCQUFtQnNYLDBCQUFuQjtBQUNBO0FBQ0YsV0FBSzAxQixzQkFBc0JsbkMsU0FBM0I7QUFDRTlGLDJCQUFtQmt1Qyw2QkFBbkI7QUFDQTtBQUNGLFdBQUtsQixzQkFBc0JwckMsUUFBM0I7QUFDQSxXQUFLb3JDLHNCQUFzQm5yQyxPQUEzQjtBQUNBLFdBQUttckMsc0JBQXNCbHBDLFNBQTNCO0FBQ0U5RCwyQkFBbUJtdUMsaUNBQW5CO0FBQ0E7QUFDRixXQUFLbkIsc0JBQXNCbHFDLHVCQUEzQjtBQUNBLFdBQUtrcUMsc0JBQXNCeHBDLHdCQUEzQjtBQUNBLFdBQUt3cEMsc0JBQXNCOW9DLGtCQUEzQjtBQUNBLFdBQUs4b0Msc0JBQXNCN29DLGdCQUEzQjtBQUNBLFdBQUs2b0Msc0JBQXNCMW9DLGdCQUEzQjtBQUNBLFdBQUswb0Msc0JBQXNCem9DLGVBQTNCO0FBQ0EsV0FBS3lvQyxzQkFBc0J4b0MsZ0JBQTNCO0FBQ0EsV0FBS3dvQyxzQkFBc0J2b0MsY0FBM0I7QUFDRXpFLDJCQUFtQndxQywrQkFBbkI7QUFDQTtBQUNGO0FBQ0UsWUFBSXo0QyxJQUFKLEVBQWE7QUFDWCxjQUFJNDdDLHVCQUF1QnA2QixPQUF2QixDQUErQnZOLFlBQS9CLE1BQWlELENBQUMsQ0FBdEQsRUFBeUQ7QUFDdkQsK0NBQ0UsS0FERixFQUVFLGlFQUNFLDJEQUhKLEVBSUVBLFlBSkY7QUFNRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBaEcsMkJBQW1CNUMsd0JBQW5CO0FBQ0E7QUEvRko7QUFpR0EsUUFBTVAsUUFBUW1ELGlCQUFpQk0sU0FBakIsQ0FDWmpELGNBRFksRUFFWkMsVUFGWSxFQUdaQyxXQUhZLEVBSVpDLGlCQUpZLENBQWQ7QUFNQSx3REFBNkJYLEtBQTdCO0FBQ0EsV0FBT0EsS0FBUDtBQUNEO0FBNUhDLENBRko7O2tCQWlJZXF2QyxpQjs7Ozs7Ozs7Ozs7O2tCQ25VU2tDLGdCO0FBVHhCOzs7Ozs7Ozs7QUFTZSxTQUFTQSxnQkFBVCxDQUEwQkMsR0FBMUIsRUFBb0Q7QUFDakVBLFFBQU1BLFFBQVEsT0FBTzNtQyxRQUFQLEtBQW9CLFdBQXBCLEdBQWtDQSxRQUFsQyxHQUE2Q3pWLFNBQXJELENBQU47QUFDQSxNQUFJLE9BQU9vOEMsR0FBUCxLQUFlLFdBQW5CLEVBQWdDO0FBQzlCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSTtBQUNGLFdBQU9BLElBQUl2RSxhQUFKLElBQXFCdUUsSUFBSUMsSUFBaEM7QUFDRCxHQUZELENBRUUsT0FBTzk3QyxDQUFQLEVBQVU7QUFDVixXQUFPNjdDLElBQUlDLElBQVg7QUFDRDtBQUNGLEM7Ozs7Ozs7OztBQ25CRDs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNbnBCLDRCQUE0QjtBQUNoQ0MsYUFBVztBQURxQixDQUFsQzs7QUFJQXhULE9BQU9DLE9BQVAsR0FBaUJzVCx5QkFBakIsQzs7Ozs7Ozs7Ozs7O1FDQ2dCb3BCLHdCLEdBQUFBLHdCO1FBNkJBQywyQixHQUFBQSwyQjtRQThFQUMsb0IsR0FBQUEsb0I7UUFnQkFDLHdCLEdBQUFBLHdCO1FBYUFDLDBCLEdBQUFBLDBCO1FBNENBQyx1QixHQUFBQSx1QjtRQXVCQUMsb0MsR0FBQUEsb0M7UUFpQkFDLHlCLEdBQUFBLHlCOztBQWxPaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVPLFNBQVNQLHdCQUFULENBQ0wxcUIsSUFESyxFQUVMdm9CLGNBRkssRUFHQztBQUNOO0FBQ0E7QUFDQTtBQUNBdW9CLE9BQUtHLFFBQUwsR0FBZ0IsS0FBaEI7O0FBRUE7QUFDQSxNQUFNK3FCLHNCQUFzQmxyQixLQUFLa3JCLG1CQUFqQztBQUNBLE1BQUlBLHdCQUF3QmgwQyxnQ0FBNUIsRUFBb0M7QUFDbEM7QUFDQThvQixTQUFLa3JCLG1CQUFMLEdBQTJCbHJCLEtBQUttckIsaUJBQUwsR0FBeUIxekMsY0FBcEQ7QUFDRCxHQUhELE1BR087QUFDTCxRQUFJeXpDLHNCQUFzQnp6QyxjQUExQixFQUEwQztBQUN4QztBQUNBdW9CLFdBQUtrckIsbUJBQUwsR0FBMkJ6ekMsY0FBM0I7QUFDRCxLQUhELE1BR087QUFDTCxVQUFNMHpDLG9CQUFvQm5yQixLQUFLbXJCLGlCQUEvQjtBQUNBLFVBQUlBLG9CQUFvQjF6QyxjQUF4QixFQUF3QztBQUN0QztBQUNBdW9CLGFBQUttckIsaUJBQUwsR0FBeUIxekMsY0FBekI7QUFDRDtBQUNGO0FBQ0Y7QUFDRDJ6QyxpQ0FBK0IzekMsY0FBL0IsRUFBK0N1b0IsSUFBL0M7QUFDRCxDLENBN0NEOzs7Ozs7Ozs7QUErQ08sU0FBUzJxQiwyQkFBVCxDQUNMM3FCLElBREssRUFFTHFyQixxQkFGSyxFQUdDO0FBQ05yckIsT0FBS0csUUFBTCxHQUFnQixLQUFoQjs7QUFFQSxNQUFJa3JCLDBCQUEwQm4wQyxnQ0FBOUIsRUFBc0M7QUFDcEM7QUFDQThvQixTQUFLa3JCLG1CQUFMLEdBQTJCaDBDLGdDQUEzQjtBQUNBOG9CLFNBQUttckIsaUJBQUwsR0FBeUJqMEMsZ0NBQXpCO0FBQ0E4b0IsU0FBS3NyQixxQkFBTCxHQUE2QnAwQyxnQ0FBN0I7QUFDQThvQixTQUFLdXJCLG1CQUFMLEdBQTJCcjBDLGdDQUEzQjtBQUNBOG9CLFNBQUt3ckIsZ0JBQUwsR0FBd0J0MEMsZ0NBQXhCO0FBQ0FrMEMsbUNBQStCbDBDLGdDQUEvQixFQUF1QzhvQixJQUF2QztBQUNBO0FBQ0Q7O0FBRUQsTUFBSXFyQix3QkFBd0JyckIsS0FBS3dyQixnQkFBakMsRUFBbUQ7QUFDakR4ckIsU0FBS3dyQixnQkFBTCxHQUF3QnQwQyxnQ0FBeEI7QUFDRDs7QUFFRDtBQUNBLE1BQU1pMEMsb0JBQW9CbnJCLEtBQUttckIsaUJBQS9CO0FBQ0EsTUFBSUEsc0JBQXNCajBDLGdDQUExQixFQUFrQztBQUNoQyxRQUFJaTBDLG9CQUFvQkUscUJBQXhCLEVBQStDO0FBQzdDO0FBQ0FyckIsV0FBS2tyQixtQkFBTCxHQUEyQmxyQixLQUFLbXJCLGlCQUFMLEdBQXlCajBDLGdDQUFwRDtBQUNELEtBSEQsTUFHTztBQUNMLFVBQU1nMEMsc0JBQXNCbHJCLEtBQUtrckIsbUJBQWpDO0FBQ0EsVUFBSUEsc0JBQXNCRyxxQkFBMUIsRUFBaUQ7QUFDL0M7QUFDQTtBQUNBcnJCLGFBQUtrckIsbUJBQUwsR0FBMkJsckIsS0FBS21yQixpQkFBaEM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLE1BQU1HLHdCQUF3QnRyQixLQUFLc3JCLHFCQUFuQztBQUNBLE1BQUlBLDBCQUEwQnAwQyxnQ0FBOUIsRUFBc0M7QUFDcEM7QUFDQTtBQUNBd3pDLDZCQUF5QjFxQixJQUF6QixFQUErQnFyQixxQkFBL0I7QUFDQUQsbUNBQStCbDBDLGdDQUEvQixFQUF1QzhvQixJQUF2QztBQUNBO0FBQ0Q7O0FBRUQsTUFBTXVyQixzQkFBc0J2ckIsS0FBS3VyQixtQkFBakM7QUFDQSxNQUFJRix3QkFBd0JFLG1CQUE1QixFQUFpRDtBQUMvQztBQUNBO0FBQ0F2ckIsU0FBS3NyQixxQkFBTCxHQUE2QnAwQyxnQ0FBN0I7QUFDQThvQixTQUFLdXJCLG1CQUFMLEdBQTJCcjBDLGdDQUEzQjtBQUNBOG9CLFNBQUt3ckIsZ0JBQUwsR0FBd0J0MEMsZ0NBQXhCOztBQUVBO0FBQ0E7QUFDQXd6Qyw2QkFBeUIxcUIsSUFBekIsRUFBK0JxckIscUJBQS9CO0FBQ0FELG1DQUErQmwwQyxnQ0FBL0IsRUFBdUM4b0IsSUFBdkM7QUFDQTtBQUNEOztBQUVELE1BQUlxckIsd0JBQXdCQyxxQkFBNUIsRUFBbUQ7QUFDakQ7QUFDQTtBQUNBWiw2QkFBeUIxcUIsSUFBekIsRUFBK0JxckIscUJBQS9CO0FBQ0FELG1DQUErQmwwQyxnQ0FBL0IsRUFBdUM4b0IsSUFBdkM7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQW9yQixpQ0FBK0JsMEMsZ0NBQS9CLEVBQXVDOG9CLElBQXZDO0FBQ0Q7O0FBRU0sU0FBUzRxQixvQkFBVCxDQUNMNXFCLElBREssRUFFTHlyQixxQkFGSyxFQUdJO0FBQ1QsTUFBTU4sb0JBQW9CbnJCLEtBQUttckIsaUJBQS9CO0FBQ0EsTUFBTUksc0JBQXNCdnJCLEtBQUt1ckIsbUJBQWpDO0FBQ0EsTUFBTUMsbUJBQW1CeHJCLEtBQUt3ckIsZ0JBQTlCO0FBQ0EsU0FDR0wsc0JBQXNCajBDLGdDQUF0QixJQUNDaTBDLG9CQUFvQk0scUJBRHRCLElBRUNGLHdCQUF3QnIwQyxnQ0FBeEIsSUFDQ3EwQyxzQkFBc0JFLHFCQUh4QixJQUlDRCxxQkFBcUJ0MEMsZ0NBQXJCLElBQStCczBDLG1CQUFtQkMscUJBTHJEO0FBT0Q7O0FBRU0sU0FBU1osd0JBQVQsQ0FDTDdxQixJQURLLEVBRUx2b0IsY0FGSyxFQUdJO0FBQ1QsTUFBTTZ6Qyx3QkFBd0J0ckIsS0FBS3NyQixxQkFBbkM7QUFDQSxNQUFNQyxzQkFBc0J2ckIsS0FBS3VyQixtQkFBakM7QUFDQSxTQUNFRCwwQkFBMEJwMEMsZ0NBQTFCLElBQ0FPLGtCQUFrQjZ6QyxxQkFEbEIsSUFFQTd6QyxrQkFBa0I4ekMsbUJBSHBCO0FBS0Q7O0FBRU0sU0FBU1QsMEJBQVQsQ0FDTDlxQixJQURLLEVBRUwrRixhQUZLLEVBR0M7QUFDTi9GLE9BQUtHLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQXVyQixZQUFVMXJCLElBQVYsRUFBZ0IrRixhQUFoQjs7QUFFQTtBQUNBLE1BQU1tbEIsc0JBQXNCbHJCLEtBQUtrckIsbUJBQWpDO0FBQ0EsTUFBTUMsb0JBQW9CbnJCLEtBQUttckIsaUJBQS9CO0FBQ0EsTUFBSUQsd0JBQXdCbmxCLGFBQTVCLEVBQTJDO0FBQ3pDLFFBQUlvbEIsc0JBQXNCcGxCLGFBQTFCLEVBQXlDO0FBQ3ZDO0FBQ0EvRixXQUFLa3JCLG1CQUFMLEdBQTJCbHJCLEtBQUttckIsaUJBQUwsR0FBeUJqMEMsZ0NBQXBEO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBOG9CLFdBQUtrckIsbUJBQUwsR0FBMkJDLGlCQUEzQjtBQUNEO0FBQ0YsR0FURCxNQVNPLElBQUlBLHNCQUFzQnBsQixhQUExQixFQUF5QztBQUM5QztBQUNBO0FBQ0EvRixTQUFLbXJCLGlCQUFMLEdBQXlCRCxtQkFBekI7QUFDRDs7QUFFRDtBQUNBLE1BQU1JLHdCQUF3QnRyQixLQUFLc3JCLHFCQUFuQztBQUNBLE1BQU1DLHNCQUFzQnZyQixLQUFLdXJCLG1CQUFqQztBQUNBLE1BQUlELDBCQUEwQnAwQyxnQ0FBOUIsRUFBc0M7QUFDcEM7QUFDQThvQixTQUFLc3JCLHFCQUFMLEdBQTZCdHJCLEtBQUt1ckIsbUJBQUwsR0FBMkJ4bEIsYUFBeEQ7QUFDRCxHQUhELE1BR087QUFDTCxRQUFJdWxCLHdCQUF3QnZsQixhQUE1QixFQUEyQztBQUN6QztBQUNBL0YsV0FBS3NyQixxQkFBTCxHQUE2QnZsQixhQUE3QjtBQUNELEtBSEQsTUFHTyxJQUFJd2xCLHNCQUFzQnhsQixhQUExQixFQUF5QztBQUM5QztBQUNBL0YsV0FBS3VyQixtQkFBTCxHQUEyQnhsQixhQUEzQjtBQUNEO0FBQ0Y7O0FBRURxbEIsaUNBQStCcmxCLGFBQS9CLEVBQThDL0YsSUFBOUM7QUFDRDs7QUFFTSxTQUFTK3FCLHVCQUFULENBQ0wvcUIsSUFESyxFQUVMMnJCLFVBRkssRUFHQztBQUNOM3JCLE9BQUtHLFFBQUwsR0FBZ0IsS0FBaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTXFyQixtQkFBbUJ4ckIsS0FBS3dyQixnQkFBOUI7QUFDQSxNQUFJQSxxQkFBcUJ0MEMsZ0NBQXJCLElBQStCczBDLG1CQUFtQkcsVUFBdEQsRUFBa0U7QUFDaEUzckIsU0FBS3dyQixnQkFBTCxHQUF3QkcsVUFBeEI7QUFDRDtBQUNEUCxpQ0FBK0JPLFVBQS9CLEVBQTJDM3JCLElBQTNDO0FBQ0Q7O0FBRUQsU0FBUzByQixTQUFULENBQW1CMXJCLElBQW5CLEVBQXlCNHJCLGFBQXpCLEVBQXdDO0FBQ3RDLE1BQU1KLG1CQUFtQnhyQixLQUFLd3JCLGdCQUE5QjtBQUNBLE1BQUlBLG9CQUFvQkksYUFBeEIsRUFBdUM7QUFDckM1ckIsU0FBS3dyQixnQkFBTCxHQUF3QnQwQyxnQ0FBeEI7QUFDRDtBQUNGOztBQUVNLFNBQVM4ekMsb0NBQVQsQ0FDTGhyQixJQURLLEVBRUxqWixvQkFGSyxFQUdXO0FBQ2hCLE1BQUkwZCx5QkFBeUIxZCxvQkFBN0I7O0FBRUEsTUFBTW1rQyxzQkFBc0JsckIsS0FBS2tyQixtQkFBakM7QUFDQSxNQUFNSSx3QkFBd0J0ckIsS0FBS3NyQixxQkFBbkM7QUFDQSxNQUFJSixzQkFBc0J6bUIsc0JBQTFCLEVBQWtEO0FBQ2hEQSw2QkFBeUJ5bUIsbUJBQXpCO0FBQ0Q7QUFDRCxNQUFJSSx3QkFBd0I3bUIsc0JBQTVCLEVBQW9EO0FBQ2xEQSw2QkFBeUI2bUIscUJBQXpCO0FBQ0Q7QUFDRCxTQUFPN21CLHNCQUFQO0FBQ0Q7O0FBRU0sU0FBU3dtQix5QkFBVCxDQUNManJCLElBREssRUFFTGxvQixXQUZLLEVBR0M7QUFDTixNQUFNTCxpQkFBaUJ1b0IsS0FBS3ZvQixjQUE1QjtBQUNBLE1BQUlBLG1CQUFtQlAsZ0NBQW5CLElBQTZCWSxlQUFlTCxjQUFoRCxFQUFnRTtBQUM5RDtBQUNBdW9CLFNBQUs2RCwwQkFBTCxHQUFrQy9yQixXQUFsQztBQUNEO0FBQ0Y7O0FBRUQsU0FBU3N6Qyw4QkFBVCxDQUF3Q1MsdUJBQXhDLEVBQWlFN3JCLElBQWpFLEVBQXVFO0FBQ3JFLE1BQU1zckIsd0JBQXdCdHJCLEtBQUtzckIscUJBQW5DO0FBQ0EsTUFBTUMsc0JBQXNCdnJCLEtBQUt1ckIsbUJBQWpDO0FBQ0EsTUFBTUwsc0JBQXNCbHJCLEtBQUtrckIsbUJBQWpDO0FBQ0EsTUFBTU0sbUJBQW1CeHJCLEtBQUt3ckIsZ0JBQTlCOztBQUVBO0FBQ0E7QUFDQSxNQUFJM25CLDZCQUNGcW5CLHdCQUF3QmgwQyxnQ0FBeEIsR0FBaUNnMEMsbUJBQWpDLEdBQXVETSxnQkFEekQ7O0FBR0E7QUFDQTtBQUNBLE1BQ0UzbkIsK0JBQStCM3NCLGdDQUEvQixLQUNDMjBDLDRCQUE0QjMwQyxnQ0FBNUIsSUFDQ3EwQyxzQkFBc0JNLHVCQUZ4QixDQURGLEVBSUU7QUFDQTtBQUNBO0FBQ0E7QUFDQWhvQixpQ0FBNkIwbkIsbUJBQTdCO0FBQ0Q7O0FBRUQsTUFBSTl6QyxpQkFBaUJvc0IsMEJBQXJCO0FBQ0EsTUFBSXBzQixtQkFBbUJQLGdDQUFuQixJQUE2Qm8wQyx3QkFBd0I3ekMsY0FBekQsRUFBeUU7QUFDdkU7QUFDQUEscUJBQWlCNnpDLHFCQUFqQjtBQUNEOztBQUVEdHJCLE9BQUs2RCwwQkFBTCxHQUFrQ0EsMEJBQWxDO0FBQ0E3RCxPQUFLdm9CLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0QsQzs7Ozs7Ozs7Ozs7Ozs7OFFDelJEOzs7Ozs7Ozs7UUE2SWdCcTBDLDBCLEdBQUFBLDBCOztBQWpJaEI7Ozs7QUFDQTs7QUFDQTs7QUFLQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBU0E7O0FBQ0E7O0FBT0E7O0FBQ0E7Ozs7QUFPQSxJQUFNQyx1QkFBdUIsRUFBN0I7QUFDQSxJQUFNelUsVUFBVTNtQixNQUFNMm1CLE9BQXRCOztBQUVBO0FBQ0E7QUFDTyxJQUFNMFUsNENBQWtCLElBQUkzekMsZ0JBQU02VCxTQUFWLEdBQXNCKy9CLElBQTlDOztBQUVQLElBQUlDLGdEQUFKO0FBQ0EsSUFBSUMsdUNBQUo7QUFDQSxJQUFJQyw0REFBSjtBQUNBLElBQUlDLG9EQUFKO0FBQ0EsSUFBSUMsMENBQUo7QUFDQSxJQUFJQyxvQ0FBSjtBQUNBLElBQUlDLDhCQUFKO0FBQ0EsSUFBSUMsa0RBQUo7QUFDQSxJQUFJQywrQ0FBSjtBQUNBLElBQUlDLDBDQUFKOztBQUVBLElBQUl6K0MsSUFBSixFQUFhO0FBQ1hnK0MsNENBQTBDLElBQUk1MEIsR0FBSixFQUExQztBQUNBNjBCLG1DQUFpQyxJQUFJNzBCLEdBQUosRUFBakM7QUFDQTgwQix3REFBc0QsSUFBSTkwQixHQUFKLEVBQXREO0FBQ0ErMEIsZ0RBQThDLElBQUkvMEIsR0FBSixFQUE5QztBQUNBbTFCLDhDQUE0QyxJQUFJbjFCLEdBQUosRUFBNUM7QUFDQWcxQixzQ0FBb0MsSUFBSWgxQixHQUFKLEVBQXBDO0FBQ0FvMUIsMkNBQXlDLElBQUlwMUIsR0FBSixFQUF6QztBQUNBcTFCLHNDQUFvQyxJQUFJcjFCLEdBQUosRUFBcEM7O0FBRUEsTUFBTXMxQiwyQkFBMkIsSUFBSXQxQixHQUFKLEVBQWpDOztBQUVBazFCLDBCQUF3QiwrQkFBUzVtQyxRQUFULEVBQTBCaW5DLFVBQTFCLEVBQThDO0FBQ3BFLFFBQUlqbkMsYUFBYSxJQUFiLElBQXFCLE9BQU9BLFFBQVAsS0FBb0IsVUFBN0MsRUFBeUQ7QUFDdkQ7QUFDRDtBQUNELFFBQU1nSCxNQUFTaWdDLFVBQVQsU0FBd0JqbkMsUUFBOUI7QUFDQSxRQUFJLENBQUNnbkMseUJBQXlCcDBCLEdBQXpCLENBQTZCNUwsR0FBN0IsQ0FBTCxFQUF3QztBQUN0Q2dnQywrQkFBeUJuMEIsR0FBekIsQ0FBNkI3TCxHQUE3QjtBQUNBLHlDQUNFLEtBREYsRUFFRSxxRUFDRSxpQ0FISixFQUlFaWdDLFVBSkYsRUFLRWpuQyxRQUxGO0FBT0Q7QUFDRixHQWZEOztBQWlCQTJtQyxnQ0FBOEIscUNBQVMxNUMsSUFBVCxFQUFlaVUsWUFBZixFQUE2QjtBQUN6RCxRQUFJQSxpQkFBaUIxWSxTQUFyQixFQUFnQztBQUM5QixVQUFNa2YsZ0JBQWdCLGdDQUFpQnphLElBQWpCLEtBQTBCLFdBQWhEO0FBQ0EsVUFBSSxDQUFDeTVDLGtDQUFrQzl6QixHQUFsQyxDQUFzQ2xMLGFBQXRDLENBQUwsRUFBMkQ7QUFDekRnL0IsMENBQWtDN3pCLEdBQWxDLENBQXNDbkwsYUFBdEM7QUFDQSwyQ0FDRSxLQURGLEVBRUUscUZBQ0UsOEJBSEosRUFJRUEsYUFKRjtBQU1EO0FBQ0Y7QUFDRixHQWJEOztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQS9TLFNBQU9NLGNBQVAsQ0FBc0JreEMsb0JBQXRCLEVBQTRDLHNCQUE1QyxFQUFvRTtBQUNsRS9WLGdCQUFZLEtBRHNEO0FBRWxFMWpCLFdBQU8saUJBQVc7QUFDaEIsK0JBQ0UsS0FERixFQUVFLHFFQUNFLHFFQURGLEdBRUUsK0NBRkYsR0FHRSxrRUFIRixHQUlFLG9FQUpGLEdBS0UsNEJBUEo7QUFTRDtBQVppRSxHQUFwRTtBQWNBL1gsU0FBT3NSLE1BQVAsQ0FBY2tnQyxvQkFBZDtBQUNEOztBQUVNLFNBQVNELDBCQUFULENBQ0x4MkMsY0FESyxFQUVMeXZCLElBRkssRUFHTDRMLHdCQUhLLEVBSUxqcUIsU0FKSyxFQUtMO0FBQ0EsTUFBTUQsWUFBWW5SLGVBQWUrUSxhQUFqQzs7QUFFQSxNQUFJblksSUFBSixFQUFhO0FBQ1gsUUFDRXFDLGtEQUNDQywrREFDQzhFLGVBQWVxUixJQUFmLEdBQXNCOUosMkJBSDFCLEVBSUU7QUFDQTtBQUNBOHpCLCtCQUF5QmpxQixTQUF6QixFQUFvQ0QsU0FBcEM7QUFDRDtBQUNGOztBQUVELE1BQU1LLGVBQWU2cEIseUJBQXlCanFCLFNBQXpCLEVBQW9DRCxTQUFwQyxDQUFyQjs7QUFFQSxNQUFJdlksSUFBSixFQUFhO0FBQ1hxK0MsZ0NBQTRCeG5CLElBQTVCLEVBQWtDamUsWUFBbEM7QUFDRDtBQUNEO0FBQ0EsTUFBTVQsZ0JBQ0pTLGlCQUFpQixJQUFqQixJQUF5QkEsaUJBQWlCMVksU0FBMUMsR0FDSXFZLFNBREosR0FFSWxNLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCaU0sU0FBbEIsRUFBNkJLLFlBQTdCLENBSE47QUFJQXhSLGlCQUFlK1EsYUFBZixHQUErQkEsYUFBL0I7O0FBRUE7QUFDQTtBQUNBLE1BQU1ELGNBQWM5USxlQUFlOFEsV0FBbkM7QUFDQSxNQUFJQSxnQkFBZ0IsSUFBaEIsSUFBd0I5USxlQUFlbUMsY0FBZixLQUFrQ1AsZ0NBQTlELEVBQXNFO0FBQ3BFa1AsZ0JBQVlyQixTQUFaLEdBQXdCc0IsYUFBeEI7QUFDRDtBQUNGOztBQUVELElBQU15bUMsd0JBQXdCO0FBQzVCejBCLGtDQUQ0QjtBQUU1QjAwQixpQkFGNEIsMkJBRVp2cEMsSUFGWSxFQUVObUMsT0FGTSxFQUVHQyxRQUZILEVBRWE7QUFDdkMsUUFBTTVRLFFBQVEsMkJBQVl3TyxJQUFaLENBQWQ7QUFDQSxRQUFNMUwsY0FBYyw4Q0FBcEI7QUFDQSxRQUFNTCxpQkFBaUIsb0RBQTBCSyxXQUExQixFQUF1QzlDLEtBQXZDLENBQXZCOztBQUVBLFFBQU1nUixTQUFTLG9DQUFhdk8sY0FBYixDQUFmO0FBQ0F1TyxXQUFPTCxPQUFQLEdBQWlCQSxPQUFqQjtBQUNBLFFBQUlDLGFBQWF4WCxTQUFiLElBQTBCd1gsYUFBYSxJQUEzQyxFQUFpRDtBQUMvQyxVQUFJMVgsSUFBSixFQUFhO0FBQ1hzK0MsOEJBQXNCNW1DLFFBQXRCLEVBQWdDLFVBQWhDO0FBQ0Q7QUFDREksYUFBT0osUUFBUCxHQUFrQkEsUUFBbEI7QUFDRDs7QUFFRDtBQUNBLHlDQUFjNVEsS0FBZCxFQUFxQmdSLE1BQXJCO0FBQ0EsMkNBQWFoUixLQUFiLEVBQW9CeUMsY0FBcEI7QUFDRCxHQW5CMkI7QUFvQjVCdTFDLHFCQXBCNEIsK0JBb0JSeHBDLElBcEJRLEVBb0JGbUMsT0FwQkUsRUFvQk9DLFFBcEJQLEVBb0JpQjtBQUMzQyxRQUFNNVEsUUFBUSwyQkFBWXdPLElBQVosQ0FBZDtBQUNBLFFBQU0xTCxjQUFjLDhDQUFwQjtBQUNBLFFBQU1MLGlCQUFpQixvREFBMEJLLFdBQTFCLEVBQXVDOUMsS0FBdkMsQ0FBdkI7O0FBRUEsUUFBTWdSLFNBQVMsb0NBQWF2TyxjQUFiLENBQWY7QUFDQXVPLFdBQU9sVCxHQUFQLEdBQWEwUiw4QkFBYjtBQUNBd0IsV0FBT0wsT0FBUCxHQUFpQkEsT0FBakI7O0FBRUEsUUFBSUMsYUFBYXhYLFNBQWIsSUFBMEJ3WCxhQUFhLElBQTNDLEVBQWlEO0FBQy9DLFVBQUkxWCxJQUFKLEVBQWE7QUFDWHMrQyw4QkFBc0I1bUMsUUFBdEIsRUFBZ0MsY0FBaEM7QUFDRDtBQUNESSxhQUFPSixRQUFQLEdBQWtCQSxRQUFsQjtBQUNEOztBQUVEO0FBQ0EseUNBQWM1USxLQUFkLEVBQXFCZ1IsTUFBckI7QUFDQSwyQ0FBYWhSLEtBQWIsRUFBb0J5QyxjQUFwQjtBQUNELEdBdkMyQjtBQXdDNUJ3MUMsb0JBeEM0Qiw4QkF3Q1R6cEMsSUF4Q1MsRUF3Q0hvQyxRQXhDRyxFQXdDTztBQUNqQyxRQUFNNVEsUUFBUSwyQkFBWXdPLElBQVosQ0FBZDtBQUNBLFFBQU0xTCxjQUFjLDhDQUFwQjtBQUNBLFFBQU1MLGlCQUFpQixvREFBMEJLLFdBQTFCLEVBQXVDOUMsS0FBdkMsQ0FBdkI7O0FBRUEsUUFBTWdSLFNBQVMsb0NBQWF2TyxjQUFiLENBQWY7QUFDQXVPLFdBQU9sVCxHQUFQLEdBQWEyUiw2QkFBYjs7QUFFQSxRQUFJbUIsYUFBYXhYLFNBQWIsSUFBMEJ3WCxhQUFhLElBQTNDLEVBQWlEO0FBQy9DLFVBQUkxWCxJQUFKLEVBQWE7QUFDWHMrQyw4QkFBc0I1bUMsUUFBdEIsRUFBZ0MsYUFBaEM7QUFDRDtBQUNESSxhQUFPSixRQUFQLEdBQWtCQSxRQUFsQjtBQUNEOztBQUVEO0FBQ0EseUNBQWM1USxLQUFkLEVBQXFCZ1IsTUFBckI7QUFDQSwyQ0FBYWhSLEtBQWIsRUFBb0J5QyxjQUFwQjtBQUNEO0FBMUQyQixDQUE5Qjs7QUE2REEsU0FBU3kxQywwQkFBVCxDQUNFNTNDLGNBREYsRUFFRXl2QixJQUZGLEVBR0V3TixRQUhGLEVBSUVELFFBSkYsRUFLRTZhLFFBTEYsRUFNRUMsUUFORixFQU9FdFosV0FQRixFQVFFO0FBQ0EsTUFBTXozQixXQUFXL0csZUFBZW1PLFNBQWhDO0FBQ0EsTUFBSSxPQUFPcEgsU0FBU2d4QyxxQkFBaEIsS0FBMEMsVUFBOUMsRUFBMEQ7QUFDeEQsOENBQWdCLzNDLGNBQWhCLEVBQWdDLHVCQUFoQztBQUNBLFFBQU1pNkIsZUFBZWx6QixTQUFTZ3hDLHFCQUFULENBQ25CL2EsUUFEbUIsRUFFbkI4YSxRQUZtQixFQUduQnRaLFdBSG1CLENBQXJCO0FBS0E7O0FBRUEsUUFBSTVsQyxJQUFKLEVBQWE7QUFDWCx5Q0FDRXFoQyxpQkFBaUJuaEMsU0FEbkIsRUFFRSxpRUFDRSxtREFISixFQUlFLGdDQUFpQjIyQixJQUFqQixLQUEwQixXQUo1QjtBQU1EOztBQUVELFdBQU93SyxZQUFQO0FBQ0Q7O0FBRUQsTUFBSXhLLEtBQUtwMUIsU0FBTCxJQUFrQm8xQixLQUFLcDFCLFNBQUwsQ0FBZTI5QyxvQkFBckMsRUFBMkQ7QUFDekQsV0FDRSxDQUFDLDRCQUFhL2EsUUFBYixFQUF1QkQsUUFBdkIsQ0FBRCxJQUFxQyxDQUFDLDRCQUFhNmEsUUFBYixFQUF1QkMsUUFBdkIsQ0FEeEM7QUFHRDs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTRyxrQkFBVCxDQUE0Qmo0QyxjQUE1QixFQUFtRHl2QixJQUFuRCxFQUE4RHVOLFFBQTlELEVBQTZFO0FBQzNFLE1BQU1qMkIsV0FBVy9HLGVBQWVtTyxTQUFoQztBQUNBLE1BQUl2VixJQUFKLEVBQWE7QUFDWCxRQUFNZSxPQUFPLGdDQUFpQjgxQixJQUFqQixLQUEwQixXQUF2QztBQUNBLFFBQU15b0IsZ0JBQWdCbnhDLFNBQVM1SSxNQUEvQjs7QUFFQSxRQUFJLENBQUMrNUMsYUFBTCxFQUFvQjtBQUNsQixVQUFJem9CLEtBQUtwMUIsU0FBTCxJQUFrQixPQUFPbzFCLEtBQUtwMUIsU0FBTCxDQUFlOEQsTUFBdEIsS0FBaUMsVUFBdkQsRUFBbUU7QUFDakUsMkNBQ0UsS0FERixFQUVFLGlFQUNFLHVFQUhKLEVBSUV4RSxJQUpGO0FBTUQsT0FQRCxNQU9PO0FBQ0wsMkNBQ0UsS0FERixFQUVFLGlFQUNFLHNEQUhKLEVBSUVBLElBSkY7QUFNRDtBQUNGOztBQUVELFFBQU13K0MseUJBQ0osQ0FBQ3B4QyxTQUFTcXhDLGVBQVYsSUFDQXJ4QyxTQUFTcXhDLGVBQVQsQ0FBeUJDLG9CQUR6QixJQUVBdHhDLFNBQVNxekIsS0FIWDtBQUlBLHVDQUNFK2Qsc0JBREYsRUFFRSxrRUFDRSxzRUFERixHQUVFLGtEQUpKLEVBS0V4K0MsSUFMRjtBQU9BLFFBQU0yK0MseUJBQ0osQ0FBQ3Z4QyxTQUFTd3hDLGVBQVYsSUFDQXh4QyxTQUFTd3hDLGVBQVQsQ0FBeUJGLG9CQUYzQjtBQUdBLHVDQUNFQyxzQkFERixFQUVFLGtFQUNFLHNFQURGLEdBRUUsdURBSkosRUFLRTMrQyxJQUxGO0FBT0EsUUFBTTYrQyxzQkFBc0IsQ0FBQ3p4QyxTQUFTK3hCLFNBQXRDO0FBQ0EsdUNBQ0UwZixtQkFERixFQUVFLHVFQUNFLHVDQUhKLEVBSUU3K0MsSUFKRjtBQU1BLFFBQU04K0Msd0JBQXdCLENBQUMxeEMsU0FBUzIwQixXQUF4QztBQUNBLHVDQUNFK2MscUJBREYsRUFFRSx5RUFDRSx5Q0FISixFQUlFOStDLElBSkY7QUFNQSxRQUFNKytDLHlCQUF5QixDQUFDM3hDLFNBQVNzUSxZQUF6QztBQUNBLHVDQUNFcWhDLHNCQURGLEVBRUUsMEVBQ0UsMENBSEosRUFJRS8rQyxJQUpGOztBQU9BLFFBQ0U4MUIsS0FBS2lNLFdBQUwsSUFDQWpNLEtBQUtwWSxZQURMLElBRUEsQ0FBQysvQix1Q0FBdUNsMEIsR0FBdkMsQ0FBMkN1TSxJQUEzQyxDQUhILEVBSUU7QUFDQTJuQiw2Q0FBdUNqMEIsR0FBdkMsQ0FBMkNzTSxJQUEzQztBQUNBLHlDQUNFLEtBREYsRUFFRSxzRUFDRSxtREFISixFQUlFOTFCLElBSkY7QUFNRDs7QUFFRCxRQUFNZy9DLDBCQUNKLE9BQU81eEMsU0FBUzZ4QyxxQkFBaEIsS0FBMEMsVUFENUM7QUFFQSx1Q0FDRUQsdUJBREYsRUFFRSw0QkFDRSxpRUFERixHQUVFLDREQUZGLEdBR0UsNkJBTEosRUFNRWgvQyxJQU5GO0FBUUEsUUFDRTgxQixLQUFLcDFCLFNBQUwsSUFDQW8xQixLQUFLcDFCLFNBQUwsQ0FBZTI5QyxvQkFEZixJQUVBLE9BQU9qeEMsU0FBU2d4QyxxQkFBaEIsS0FBMEMsV0FINUMsRUFJRTtBQUNBLHlDQUNFLEtBREYsRUFFRSxxREFDRSwrRUFERixHQUVFLGlFQUpKLEVBS0UsZ0NBQWlCdG9CLElBQWpCLEtBQTBCLGtCQUw1QjtBQU9EO0FBQ0QsUUFBTW9wQix3QkFDSixPQUFPOXhDLFNBQVMreEMsbUJBQWhCLEtBQXdDLFVBRDFDO0FBRUEsdUNBQ0VELHFCQURGLEVBRUUsNEJBQ0UsZ0VBREYsR0FFRSxzQ0FKSixFQUtFbC9DLElBTEY7QUFPQSxRQUFNby9DLDZCQUNKLE9BQU9oeUMsU0FBU2l5Qyx3QkFBaEIsS0FBNkMsVUFEL0M7QUFFQSx1Q0FDRUQsMEJBREYsRUFFRSw0QkFDRSxxRUFERixHQUVFLGtFQUZGLEdBR0UsaUVBSEYsR0FJRSx5RkFOSixFQU9FcC9DLElBUEY7QUFTQSxRQUFNcy9DLDhCQUNKLE9BQU9seUMsU0FBU215Qyx5QkFBaEIsS0FBOEMsVUFEaEQ7QUFFQSx1Q0FDRUQsMkJBREYsRUFFRSw0QkFDRSx3RUFISixFQUlFdC9DLElBSkY7QUFNQSxRQUFNdy9DLG9DQUNKLE9BQU9weUMsU0FBU3F5QyxnQ0FBaEIsS0FBcUQsVUFEdkQ7QUFFQSx1Q0FDRUQsaUNBREYsRUFFRSw0QkFDRSxzRkFISixFQUlFeC9DLElBSkY7QUFNQSxRQUFNMC9DLGtCQUFrQnR5QyxTQUFTcUgsS0FBVCxLQUFtQjR1QixRQUEzQztBQUNBLHVDQUNFajJCLFNBQVNxSCxLQUFULEtBQW1CdFYsU0FBbkIsSUFBZ0MsQ0FBQ3VnRCxlQURuQyxFQUVFLDhEQUNFLGlFQUhKLEVBSUUxL0MsSUFKRixFQUtFQSxJQUxGO0FBT0EsUUFBTTIvQyx5QkFBeUIsQ0FBQ3Z5QyxTQUFTcWYsWUFBekM7QUFDQSx1Q0FDRWt6QixzQkFERixFQUVFLDZGQUNFLDJEQUhKLEVBSUUzL0MsSUFKRixFQUtFQSxJQUxGOztBQVFBLFFBQ0UsT0FBT29OLFNBQVN3eUMsdUJBQWhCLEtBQTRDLFVBQTVDLElBQ0EsT0FBT3h5QyxTQUFTeXlDLGtCQUFoQixLQUF1QyxVQUR2QyxJQUVBLENBQUMxQyxvREFBb0Q1ekIsR0FBcEQsQ0FBd0R1TSxJQUF4RCxDQUhILEVBSUU7QUFDQXFuQiwwREFBb0QzekIsR0FBcEQsQ0FBd0RzTSxJQUF4RDtBQUNBLHlDQUNFLEtBREYsRUFFRSw2RUFDRSx3REFISixFQUlFLGdDQUFpQkEsSUFBakIsQ0FKRjtBQU1EOztBQUVELFFBQU1ncUIscUNBQ0osT0FBTzF5QyxTQUFTczBCLHdCQUFoQixLQUE2QyxVQUQvQztBQUVBLHVDQUNFb2Usa0NBREYsRUFFRSxxRUFDRSw4REFISixFQUlFOS9DLElBSkY7QUFNQSxRQUFNKy9DLHFDQUNKLE9BQU8zeUMsU0FBUzJvQix3QkFBaEIsS0FBNkMsVUFEL0M7QUFFQSx1Q0FDRWdxQixrQ0FERixFQUVFLHFFQUNFLDhEQUhKLEVBSUUvL0MsSUFKRjtBQU1BLFFBQU1nZ0Qsa0NBQ0osT0FBT2xxQixLQUFLOHBCLHVCQUFaLEtBQXdDLFVBRDFDO0FBRUEsdUNBQ0VJLCtCQURGLEVBRUUsaUVBQ0UsaUVBSEosRUFJRWhnRCxJQUpGO0FBTUEsUUFBTXlnQyxTQUFRcnpCLFNBQVNxekIsS0FBdkI7QUFDQSxRQUFJQSxXQUFVLFFBQU9BLE1BQVAseUNBQU9BLE1BQVAsT0FBaUIsUUFBakIsSUFBNkI0SCxRQUFRNUgsTUFBUixDQUF2QyxDQUFKLEVBQTREO0FBQzFELHlDQUNFLEtBREYsRUFFRSw0Q0FGRixFQUdFemdDLElBSEY7QUFLRDtBQUNELFFBQUksT0FBT29OLFNBQVNnUixlQUFoQixLQUFvQyxVQUF4QyxFQUFvRDtBQUNsRCx5Q0FDRSxRQUFPMFgsS0FBS2pZLGlCQUFaLE1BQWtDLFFBRHBDLEVBRUUseUVBQ0Usd0JBSEosRUFJRTdkLElBSkY7QUFNRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU2lnRCxrQkFBVCxDQUE0QjU1QyxjQUE1QixFQUFtRCtHLFFBQW5ELEVBQXdFO0FBQ3RFQSxXQUFTOHlDLE9BQVQsR0FBbUJyQyxxQkFBbkI7QUFDQXgzQyxpQkFBZW1PLFNBQWYsR0FBMkJwSCxRQUEzQjtBQUNBO0FBQ0EsNkJBQVlBLFFBQVosRUFBc0IvRyxjQUF0QjtBQUNBLE1BQUlwSCxJQUFKLEVBQWE7QUFDWG1PLGFBQVMreUMsc0JBQVQsR0FBa0NyRCxvQkFBbEM7QUFDRDtBQUNGOztBQUVELFNBQVNzRCxzQkFBVCxDQUNFLzVDLGNBREYsRUFFRXl2QixJQUZGLEVBR0VyaEIsS0FIRixFQUlFcUQsb0JBSkYsRUFLTztBQUNMLE1BQUl1b0MsMEJBQTBCLEtBQTlCO0FBQ0EsTUFBSWhqQyxrQkFBa0JWLHFDQUF0QjtBQUNBLE1BQUlyRSxVQUFVLElBQWQ7QUFDQSxNQUFNeXBCLGNBQWNqTSxLQUFLaU0sV0FBekI7QUFDQSxNQUFJLFFBQU9BLFdBQVAseUNBQU9BLFdBQVAsT0FBdUIsUUFBdkIsSUFBbUNBLGdCQUFnQixJQUF2RCxFQUE2RDtBQUMzRCxRQUFJOWlDLElBQUosRUFBYTtBQUNYLFVBQ0U4aUMsWUFBWTM5QixRQUFaLEtBQXlCQyxnQ0FBekIsSUFDQSxDQUFDcTVDLGtDQUFrQ24wQixHQUFsQyxDQUFzQ3VNLElBQXRDLENBRkgsRUFHRTtBQUNBNG5CLDBDQUFrQ2wwQixHQUFsQyxDQUFzQ3NNLElBQXRDO0FBQ0EsMkNBQ0UsS0FERixFQUVFLHdDQUNFLG9GQURGLEdBRUUseURBSkosRUFLRSxnQ0FBaUJBLElBQWpCLEtBQTBCLFdBTDVCO0FBT0Q7QUFDRjs7QUFFRHhkLGNBQVUsdUNBQWF5cEIsV0FBYixDQUFWO0FBQ0QsR0FsQkQsTUFrQk87QUFDTDFrQixzQkFBa0IsMkNBQW1CaFgsY0FBbkIsRUFBbUN5dkIsSUFBbkMsRUFBeUMsSUFBekMsQ0FBbEI7QUFDQSxRQUFNcFksZUFBZW9ZLEtBQUtwWSxZQUExQjtBQUNBMmlDLDhCQUNFM2lDLGlCQUFpQixJQUFqQixJQUF5QkEsaUJBQWlCdmUsU0FENUM7QUFFQW1aLGNBQVUrbkMsMEJBQ04seUNBQWlCaDZDLGNBQWpCLEVBQWlDZ1gsZUFBakMsQ0FETSxHQUVOVixxQ0FGSjtBQUdEOztBQUVEO0FBQ0EsTUFBSTFkLElBQUosRUFBYTtBQUNYLFFBQ0VxQyxrREFDQ0MsK0RBQ0M4RSxlQUFlcVIsSUFBZixHQUFzQjlKLDJCQUgxQixFQUlFO0FBQ0EsVUFBSWtvQixJQUFKLENBQVNyaEIsS0FBVCxFQUFnQjZELE9BQWhCLEVBREEsQ0FDMEI7QUFDM0I7QUFDRjs7QUFFRCxNQUFNbEwsV0FBVyxJQUFJMG9CLElBQUosQ0FBU3JoQixLQUFULEVBQWdCNkQsT0FBaEIsQ0FBakI7QUFDQSxNQUFNbW9CLFFBQVNwNkIsZUFBZStRLGFBQWYsR0FDYmhLLFNBQVNxekIsS0FBVCxLQUFtQixJQUFuQixJQUEyQnJ6QixTQUFTcXpCLEtBQVQsS0FBbUJ0aEMsU0FBOUMsR0FDSWlPLFNBQVNxekIsS0FEYixHQUVJLElBSE47QUFJQXdmLHFCQUFtQjU1QyxjQUFuQixFQUFtQytHLFFBQW5DOztBQUVBLE1BQUluTyxJQUFKLEVBQWE7QUFDWCxRQUFJLE9BQU82MkIsS0FBSzRMLHdCQUFaLEtBQXlDLFVBQXpDLElBQXVEakIsVUFBVSxJQUFyRSxFQUEyRTtBQUN6RSxVQUFNcGlCLGdCQUFnQixnQ0FBaUJ5WCxJQUFqQixLQUEwQixXQUFoRDtBQUNBLFVBQUksQ0FBQ29uQiwrQkFBK0IzekIsR0FBL0IsQ0FBbUNsTCxhQUFuQyxDQUFMLEVBQXdEO0FBQ3RENitCLHVDQUErQjF6QixHQUEvQixDQUFtQ25MLGFBQW5DO0FBQ0EsMkNBQ0UsS0FERixFQUVFLG1FQUNFLG9FQURGLEdBRUUsa0VBRkYsR0FHRSxpRkFMSixFQU1FQSxhQU5GLEVBT0VqUixTQUFTcXpCLEtBQVQsS0FBbUIsSUFBbkIsR0FBMEIsTUFBMUIsR0FBbUMsV0FQckMsRUFRRXBpQixhQVJGO0FBVUQ7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUNFLE9BQU95WCxLQUFLNEwsd0JBQVosS0FBeUMsVUFBekMsSUFDQSxPQUFPdDBCLFNBQVN3eUMsdUJBQWhCLEtBQTRDLFVBRjlDLEVBR0U7QUFDQSxVQUFJVSxxQkFBcUIsSUFBekI7QUFDQSxVQUFJQyw0QkFBNEIsSUFBaEM7QUFDQSxVQUFJQyxzQkFBc0IsSUFBMUI7QUFDQSxVQUNFLE9BQU9wekMsU0FBUzhoQyxrQkFBaEIsS0FBdUMsVUFBdkMsSUFDQTloQyxTQUFTOGhDLGtCQUFULENBQTRCQyw0QkFBNUIsS0FBNkQsSUFGL0QsRUFHRTtBQUNBbVIsNkJBQXFCLG9CQUFyQjtBQUNELE9BTEQsTUFLTyxJQUFJLE9BQU9sekMsU0FBU2lnQyx5QkFBaEIsS0FBOEMsVUFBbEQsRUFBOEQ7QUFDbkVpVCw2QkFBcUIsMkJBQXJCO0FBQ0Q7QUFDRCxVQUNFLE9BQU9sekMsU0FBU2dpQyx5QkFBaEIsS0FBOEMsVUFBOUMsSUFDQWhpQyxTQUFTZ2lDLHlCQUFULENBQW1DRCw0QkFBbkMsS0FBb0UsSUFGdEUsRUFHRTtBQUNBb1Isb0NBQTRCLDJCQUE1QjtBQUNELE9BTEQsTUFLTyxJQUNMLE9BQU9uekMsU0FBU2tnQyxnQ0FBaEIsS0FBcUQsVUFEaEQsRUFFTDtBQUNBaVQsb0NBQTRCLGtDQUE1QjtBQUNEO0FBQ0QsVUFDRSxPQUFPbnpDLFNBQVNpaUMsbUJBQWhCLEtBQXdDLFVBQXhDLElBQ0FqaUMsU0FBU2lpQyxtQkFBVCxDQUE2QkYsNEJBQTdCLEtBQThELElBRmhFLEVBR0U7QUFDQXFSLDhCQUFzQixxQkFBdEI7QUFDRCxPQUxELE1BS08sSUFBSSxPQUFPcHpDLFNBQVNtZ0MsMEJBQWhCLEtBQStDLFVBQW5ELEVBQStEO0FBQ3BFaVQsOEJBQXNCLDRCQUF0QjtBQUNEO0FBQ0QsVUFDRUYsdUJBQXVCLElBQXZCLElBQ0FDLDhCQUE4QixJQUQ5QixJQUVBQyx3QkFBd0IsSUFIMUIsRUFJRTtBQUNBLFlBQU1uaUMsaUJBQWdCLGdDQUFpQnlYLElBQWpCLEtBQTBCLFdBQWhEO0FBQ0EsWUFBTTJxQixhQUNKLE9BQU8zcUIsS0FBSzRMLHdCQUFaLEtBQXlDLFVBQXpDLEdBQ0ksNEJBREosR0FFSSwyQkFITjtBQUlBLFlBQUksQ0FBQzBiLDRDQUE0Qzd6QixHQUE1QyxDQUFnRGxMLGNBQWhELENBQUwsRUFBcUU7QUFDbkUrK0Isc0RBQTRDNXpCLEdBQTVDLENBQWdEbkwsY0FBaEQ7QUFDQSw2Q0FDRSxLQURGLEVBRUUsNkZBQ0UseUVBREYsR0FFRSwrRUFGRixHQUdFLHFEQUxKLEVBTUVBLGNBTkYsRUFPRW9pQyxVQVBGLEVBUUVILHVCQUF1QixJQUF2QixZQUFxQ0Esa0JBQXJDLEdBQTRELEVBUjlELEVBU0VDLDhCQUE4QixJQUE5QixZQUNXQSx5QkFEWCxHQUVJLEVBWE4sRUFZRUMsd0JBQXdCLElBQXhCLFlBQXNDQSxtQkFBdEMsR0FBOEQsRUFaaEU7QUFjRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsTUFBSUgsdUJBQUosRUFBNkI7QUFDM0IseUNBQWFoNkMsY0FBYixFQUE2QmdYLGVBQTdCLEVBQThDL0UsT0FBOUM7QUFDRDs7QUFFRCxTQUFPbEwsUUFBUDtBQUNEOztBQUVELFNBQVNzekMsc0JBQVQsQ0FBZ0NyNkMsY0FBaEMsRUFBZ0QrRyxRQUFoRCxFQUEwRDtBQUN4RCw0Q0FBZ0IvRyxjQUFoQixFQUFnQyxvQkFBaEM7QUFDQSxNQUFNNjNDLFdBQVc5d0MsU0FBU3F6QixLQUExQjs7QUFFQSxNQUFJLE9BQU9yekIsU0FBUzhoQyxrQkFBaEIsS0FBdUMsVUFBM0MsRUFBdUQ7QUFDckQ5aEMsYUFBUzhoQyxrQkFBVDtBQUNEO0FBQ0QsTUFBSSxPQUFPOWhDLFNBQVNpZ0MseUJBQWhCLEtBQThDLFVBQWxELEVBQThEO0FBQzVEamdDLGFBQVNpZ0MseUJBQVQ7QUFDRDs7QUFFRDs7QUFFQSxNQUFJNlEsYUFBYTl3QyxTQUFTcXpCLEtBQTFCLEVBQWlDO0FBQy9CLFFBQUl4aEMsSUFBSixFQUFhO0FBQ1gseUNBQ0UsS0FERixFQUVFLGtFQUNFLDBDQURGLEdBRUUscUNBSkosRUFLRSxnQ0FBaUJvSCxlQUFlekMsSUFBaEMsS0FBeUMsV0FMM0M7QUFPRDtBQUNEaTZDLDBCQUFzQkUsbUJBQXRCLENBQTBDM3dDLFFBQTFDLEVBQW9EQSxTQUFTcXpCLEtBQTdELEVBQW9FLElBQXBFO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTa2dCLDZCQUFULENBQ0V0NkMsY0FERixFQUVFK0csUUFGRixFQUdFaTJCLFFBSEYsRUFJRXdCLFdBSkYsRUFLRTtBQUNBLE1BQU1xWixXQUFXOXdDLFNBQVNxekIsS0FBMUI7QUFDQSw0Q0FBZ0JwNkIsY0FBaEIsRUFBZ0MsMkJBQWhDO0FBQ0EsTUFBSSxPQUFPK0csU0FBU2dpQyx5QkFBaEIsS0FBOEMsVUFBbEQsRUFBOEQ7QUFDNURoaUMsYUFBU2dpQyx5QkFBVCxDQUFtQy9MLFFBQW5DLEVBQTZDd0IsV0FBN0M7QUFDRDtBQUNELE1BQUksT0FBT3ozQixTQUFTa2dDLGdDQUFoQixLQUFxRCxVQUF6RCxFQUFxRTtBQUNuRWxnQyxhQUFTa2dDLGdDQUFULENBQTBDakssUUFBMUMsRUFBb0R3QixXQUFwRDtBQUNEO0FBQ0Q7O0FBRUEsTUFBSXozQixTQUFTcXpCLEtBQVQsS0FBbUJ5ZCxRQUF2QixFQUFpQztBQUMvQixRQUFJai9DLElBQUosRUFBYTtBQUNYLFVBQU1vZixnQkFDSixnQ0FBaUJoWSxlQUFlekMsSUFBaEMsS0FBeUMsV0FEM0M7QUFFQSxVQUFJLENBQUNxNUMsd0NBQXdDMXpCLEdBQXhDLENBQTRDbEwsYUFBNUMsQ0FBTCxFQUFpRTtBQUMvRDQrQixnREFBd0N6ekIsR0FBeEMsQ0FBNENuTCxhQUE1QztBQUNBLDJDQUNFLEtBREYsRUFFRSwyREFDRSx3REFERixHQUVFLHFDQUpKLEVBS0VBLGFBTEY7QUFPRDtBQUNGO0FBQ0R3L0IsMEJBQXNCRSxtQkFBdEIsQ0FBMEMzd0MsUUFBMUMsRUFBb0RBLFNBQVNxekIsS0FBN0QsRUFBb0UsSUFBcEU7QUFDRDtBQUNGOztBQUVEO0FBQ0EsU0FBU21nQixrQkFBVCxDQUNFdjZDLGNBREYsRUFFRXl2QixJQUZGLEVBR0V1TixRQUhGLEVBSUV2ckIsb0JBSkYsRUFLUTtBQUNOLE1BQUk3WSxJQUFKLEVBQWE7QUFDWHEvQyx1QkFBbUJqNEMsY0FBbkIsRUFBbUN5dkIsSUFBbkMsRUFBeUN1TixRQUF6QztBQUNEOztBQUVELE1BQU1qMkIsV0FBVy9HLGVBQWVtTyxTQUFoQztBQUNBcEgsV0FBU3FILEtBQVQsR0FBaUI0dUIsUUFBakI7QUFDQWoyQixXQUFTcXpCLEtBQVQsR0FBaUJwNkIsZUFBZStRLGFBQWhDO0FBQ0FoSyxXQUFTNHZDLElBQVQsR0FBZ0JELGVBQWhCOztBQUVBLE1BQU1oYixjQUFjak0sS0FBS2lNLFdBQXpCO0FBQ0EsTUFBSSxRQUFPQSxXQUFQLHlDQUFPQSxXQUFQLE9BQXVCLFFBQXZCLElBQW1DQSxnQkFBZ0IsSUFBdkQsRUFBNkQ7QUFDM0QzMEIsYUFBU2tMLE9BQVQsR0FBbUIsdUNBQVl5cEIsV0FBWixDQUFuQjtBQUNELEdBRkQsTUFFTztBQUNMLFFBQU0xa0Isa0JBQWtCLDJDQUFtQmhYLGNBQW5CLEVBQW1DeXZCLElBQW5DLEVBQXlDLElBQXpDLENBQXhCO0FBQ0Exb0IsYUFBU2tMLE9BQVQsR0FBbUIseUNBQWlCalMsY0FBakIsRUFBaUNnWCxlQUFqQyxDQUFuQjtBQUNEOztBQUVELE1BQUlwZSxJQUFKLEVBQWE7QUFDWCxRQUFJbU8sU0FBU3F6QixLQUFULEtBQW1CNEMsUUFBdkIsRUFBaUM7QUFDL0IsVUFBTWhsQixnQkFBZ0IsZ0NBQWlCeVgsSUFBakIsS0FBMEIsV0FBaEQ7QUFDQSxVQUFJLENBQUMwbkIsMENBQTBDajBCLEdBQTFDLENBQThDbEwsYUFBOUMsQ0FBTCxFQUFtRTtBQUNqRW0vQixrREFBMENoMEIsR0FBMUMsQ0FBOENuTCxhQUE5QztBQUNBLDJDQUNFLEtBREYsRUFFRSxpRUFDRSx3REFERixHQUVFLG9EQUpKLEVBS0VBLGFBTEY7QUFPRDtBQUNGOztBQUVELFFBQUloWSxlQUFlcVIsSUFBZixHQUFzQjlKLDJCQUExQixFQUFzQztBQUNwQ3VpQix3Q0FBd0JnZCw2QkFBeEIsQ0FDRTltQyxjQURGLEVBRUUrRyxRQUZGOztBQUtBK2lCLHdDQUF3QnNSLDBCQUF4QixDQUNFcDdCLGNBREYsRUFFRStHLFFBRkY7QUFJRDs7QUFFRCxRQUFJM0wsZ0RBQUosRUFBbUM7QUFDakMwdUIsd0NBQXdCK2MseUJBQXhCLENBQ0U3bUMsY0FERixFQUVFK0csUUFGRjtBQUlEO0FBQ0Y7O0FBRUQsTUFBSStKLGNBQWM5USxlQUFlOFEsV0FBakM7QUFDQSxNQUFJQSxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsOENBQ0U5USxjQURGLEVBRUU4USxXQUZGLEVBR0Vrc0IsUUFIRixFQUlFajJCLFFBSkYsRUFLRTBLLG9CQUxGO0FBT0ExSyxhQUFTcXpCLEtBQVQsR0FBaUJwNkIsZUFBZStRLGFBQWhDO0FBQ0Q7O0FBRUQsTUFBTXNxQiwyQkFBMkI1TCxLQUFLNEwsd0JBQXRDO0FBQ0EsTUFBSSxPQUFPQSx3QkFBUCxLQUFvQyxVQUF4QyxFQUFvRDtBQUNsRG1iLCtCQUNFeDJDLGNBREYsRUFFRXl2QixJQUZGLEVBR0U0TCx3QkFIRixFQUlFMkIsUUFKRjtBQU1BajJCLGFBQVNxekIsS0FBVCxHQUFpQnA2QixlQUFlK1EsYUFBaEM7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFDRSxPQUFPMGUsS0FBSzRMLHdCQUFaLEtBQXlDLFVBQXpDLElBQ0EsT0FBT3QwQixTQUFTd3lDLHVCQUFoQixLQUE0QyxVQUQ1QyxLQUVDLE9BQU94eUMsU0FBU2lnQyx5QkFBaEIsS0FBOEMsVUFBOUMsSUFDQyxPQUFPamdDLFNBQVM4aEMsa0JBQWhCLEtBQXVDLFVBSHpDLENBREYsRUFLRTtBQUNBd1IsMkJBQXVCcjZDLGNBQXZCLEVBQXVDK0csUUFBdkM7QUFDQTtBQUNBO0FBQ0ErSixrQkFBYzlRLGVBQWU4USxXQUE3QjtBQUNBLFFBQUlBLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixnREFDRTlRLGNBREYsRUFFRThRLFdBRkYsRUFHRWtzQixRQUhGLEVBSUVqMkIsUUFKRixFQUtFMEssb0JBTEY7QUFPQTFLLGVBQVNxekIsS0FBVCxHQUFpQnA2QixlQUFlK1EsYUFBaEM7QUFDRDtBQUNGOztBQUVELE1BQUksT0FBT2hLLFNBQVN5ekMsaUJBQWhCLEtBQXNDLFVBQTFDLEVBQXNEO0FBQ3BEeDZDLG1CQUFldVIsU0FBZixJQUE0QjVRLDJCQUE1QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUzg1Qyx3QkFBVCxDQUNFejZDLGNBREYsRUFFRXl2QixJQUZGLEVBR0V1TixRQUhGLEVBSUV2ckIsb0JBSkYsRUFLVztBQUNULE1BQU0xSyxXQUFXL0csZUFBZW1PLFNBQWhDOztBQUVBLE1BQU04dUIsV0FBV2o5QixlQUFlMGxCLGFBQWhDO0FBQ0EzZSxXQUFTcUgsS0FBVCxHQUFpQjZ1QixRQUFqQjs7QUFFQSxNQUFNeWQsYUFBYTN6QyxTQUFTa0wsT0FBNUI7QUFDQSxNQUFNeXBCLGNBQWNqTSxLQUFLaU0sV0FBekI7QUFDQSxNQUFJOEMsb0JBQUo7QUFDQSxNQUFJLFFBQU85QyxXQUFQLHlDQUFPQSxXQUFQLE9BQXVCLFFBQXZCLElBQW1DQSxnQkFBZ0IsSUFBdkQsRUFBNkQ7QUFDM0Q4QyxrQkFBYyx1Q0FBWTlDLFdBQVosQ0FBZDtBQUNELEdBRkQsTUFFTztBQUNMLFFBQU1pZiw0QkFBNEIsMkNBQ2hDMzZDLGNBRGdDLEVBRWhDeXZCLElBRmdDLEVBR2hDLElBSGdDLENBQWxDO0FBS0ErTyxrQkFBYyx5Q0FBaUJ4K0IsY0FBakIsRUFBaUMyNkMseUJBQWpDLENBQWQ7QUFDRDs7QUFFRCxNQUFNdGYsMkJBQTJCNUwsS0FBSzRMLHdCQUF0QztBQUNBLE1BQU11ZixtQkFDSixPQUFPdmYsd0JBQVAsS0FBb0MsVUFBcEMsSUFDQSxPQUFPdDBCLFNBQVN3eUMsdUJBQWhCLEtBQTRDLFVBRjlDOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFDRSxDQUFDcUIsZ0JBQUQsS0FDQyxPQUFPN3pDLFNBQVNrZ0MsZ0NBQWhCLEtBQXFELFVBQXJELElBQ0MsT0FBT2xnQyxTQUFTZ2lDLHlCQUFoQixLQUE4QyxVQUZoRCxDQURGLEVBSUU7QUFDQSxRQUFJOUwsYUFBYUQsUUFBYixJQUF5QjBkLGVBQWVsYyxXQUE1QyxFQUF5RDtBQUN2RDhiLG9DQUNFdDZDLGNBREYsRUFFRStHLFFBRkYsRUFHRWkyQixRQUhGLEVBSUV3QixXQUpGO0FBTUQ7QUFDRjs7QUFFRDs7QUFFQSxNQUFNcVosV0FBVzczQyxlQUFlK1EsYUFBaEM7QUFDQSxNQUFJK21DLFdBQVkvd0MsU0FBU3F6QixLQUFULEdBQWlCeWQsUUFBakM7QUFDQSxNQUFJL21DLGNBQWM5USxlQUFlOFEsV0FBakM7QUFDQSxNQUFJQSxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsOENBQ0U5USxjQURGLEVBRUU4USxXQUZGLEVBR0Vrc0IsUUFIRixFQUlFajJCLFFBSkYsRUFLRTBLLG9CQUxGO0FBT0FxbUMsZUFBVzkzQyxlQUFlK1EsYUFBMUI7QUFDRDtBQUNELE1BQ0Vrc0IsYUFBYUQsUUFBYixJQUNBNmEsYUFBYUMsUUFEYixJQUVBLENBQUMsMkNBRkQsSUFHQSxDQUFDLDJEQUpILEVBS0U7QUFDQTtBQUNBO0FBQ0EsUUFBSSxPQUFPL3dDLFNBQVN5ekMsaUJBQWhCLEtBQXNDLFVBQTFDLEVBQXNEO0FBQ3BEeDZDLHFCQUFldVIsU0FBZixJQUE0QjVRLDJCQUE1QjtBQUNEO0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPMDZCLHdCQUFQLEtBQW9DLFVBQXhDLEVBQW9EO0FBQ2xEbWIsK0JBQ0V4MkMsY0FERixFQUVFeXZCLElBRkYsRUFHRTRMLHdCQUhGLEVBSUUyQixRQUpGO0FBTUE4YSxlQUFXOTNDLGVBQWUrUSxhQUExQjtBQUNEOztBQUVELE1BQU1rcEIsZUFDSiwrREFDQTJkLDJCQUNFNTNDLGNBREYsRUFFRXl2QixJQUZGLEVBR0V3TixRQUhGLEVBSUVELFFBSkYsRUFLRTZhLFFBTEYsRUFNRUMsUUFORixFQU9FdFosV0FQRixDQUZGOztBQVlBLE1BQUl2RSxZQUFKLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDQSxRQUNFLENBQUMyZ0IsZ0JBQUQsS0FDQyxPQUFPN3pDLFNBQVNpZ0MseUJBQWhCLEtBQThDLFVBQTlDLElBQ0MsT0FBT2pnQyxTQUFTOGhDLGtCQUFoQixLQUF1QyxVQUZ6QyxDQURGLEVBSUU7QUFDQSxnREFBZ0I3b0MsY0FBaEIsRUFBZ0Msb0JBQWhDO0FBQ0EsVUFBSSxPQUFPK0csU0FBUzhoQyxrQkFBaEIsS0FBdUMsVUFBM0MsRUFBdUQ7QUFDckQ5aEMsaUJBQVM4aEMsa0JBQVQ7QUFDRDtBQUNELFVBQUksT0FBTzloQyxTQUFTaWdDLHlCQUFoQixLQUE4QyxVQUFsRCxFQUE4RDtBQUM1RGpnQyxpQkFBU2lnQyx5QkFBVDtBQUNEO0FBQ0Q7QUFDRDtBQUNELFFBQUksT0FBT2pnQyxTQUFTeXpDLGlCQUFoQixLQUFzQyxVQUExQyxFQUFzRDtBQUNwRHg2QyxxQkFBZXVSLFNBQWYsSUFBNEI1USwyQkFBNUI7QUFDRDtBQUNGLEdBcEJELE1Bb0JPO0FBQ0w7QUFDQTtBQUNBLFFBQUksT0FBT29HLFNBQVN5ekMsaUJBQWhCLEtBQXNDLFVBQTFDLEVBQXNEO0FBQ3BEeDZDLHFCQUFldVIsU0FBZixJQUE0QjVRLDJCQUE1QjtBQUNEOztBQUVEO0FBQ0E7QUFDQVgsbUJBQWUwbEIsYUFBZixHQUErQnNYLFFBQS9CO0FBQ0FoOUIsbUJBQWUrUSxhQUFmLEdBQStCK21DLFFBQS9CO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBL3dDLFdBQVNxSCxLQUFULEdBQWlCNHVCLFFBQWpCO0FBQ0FqMkIsV0FBU3F6QixLQUFULEdBQWlCMGQsUUFBakI7QUFDQS93QyxXQUFTa0wsT0FBVCxHQUFtQnVzQixXQUFuQjs7QUFFQSxTQUFPdkUsWUFBUDtBQUNEOztBQUVEO0FBQ0EsU0FBUzRnQixtQkFBVCxDQUNFejZDLE9BREYsRUFFRUosY0FGRixFQUdFeXZCLElBSEYsRUFJRXVOLFFBSkYsRUFLRXZyQixvQkFMRixFQU1XO0FBQ1QsTUFBTTFLLFdBQVcvRyxlQUFlbU8sU0FBaEM7O0FBRUEsTUFBTTh1QixXQUFXajlCLGVBQWUwbEIsYUFBaEM7QUFDQTNlLFdBQVNxSCxLQUFULEdBQ0VwTyxlQUFlekMsSUFBZixLQUF3QnlDLGVBQWV1bEIsV0FBdkMsR0FDSTBYLFFBREosR0FFSSxrREFBb0JqOUIsZUFBZXpDLElBQW5DLEVBQXlDMC9CLFFBQXpDLENBSE47O0FBS0EsTUFBTXlkLGFBQWEzekMsU0FBU2tMLE9BQTVCO0FBQ0EsTUFBTXlwQixjQUFjak0sS0FBS2lNLFdBQXpCO0FBQ0EsTUFBSThDLG9CQUFKO0FBQ0EsTUFBSSxRQUFPOUMsV0FBUCx5Q0FBT0EsV0FBUCxPQUF1QixRQUF2QixJQUFtQ0EsZ0JBQWdCLElBQXZELEVBQTZEO0FBQzNEOEMsa0JBQWMsdUNBQVk5QyxXQUFaLENBQWQ7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFNb2Ysc0JBQXNCLDJDQUFtQjk2QyxjQUFuQixFQUFtQ3l2QixJQUFuQyxFQUF5QyxJQUF6QyxDQUE1QjtBQUNBK08sa0JBQWMseUNBQWlCeCtCLGNBQWpCLEVBQWlDODZDLG1CQUFqQyxDQUFkO0FBQ0Q7O0FBRUQsTUFBTXpmLDJCQUEyQjVMLEtBQUs0TCx3QkFBdEM7QUFDQSxNQUFNdWYsbUJBQ0osT0FBT3ZmLHdCQUFQLEtBQW9DLFVBQXBDLElBQ0EsT0FBT3QwQixTQUFTd3lDLHVCQUFoQixLQUE0QyxVQUY5Qzs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQ0UsQ0FBQ3FCLGdCQUFELEtBQ0MsT0FBTzd6QyxTQUFTa2dDLGdDQUFoQixLQUFxRCxVQUFyRCxJQUNDLE9BQU9sZ0MsU0FBU2dpQyx5QkFBaEIsS0FBOEMsVUFGaEQsQ0FERixFQUlFO0FBQ0EsUUFBSTlMLGFBQWFELFFBQWIsSUFBeUIwZCxlQUFlbGMsV0FBNUMsRUFBeUQ7QUFDdkQ4YixvQ0FDRXQ2QyxjQURGLEVBRUUrRyxRQUZGLEVBR0VpMkIsUUFIRixFQUlFd0IsV0FKRjtBQU1EO0FBQ0Y7O0FBRUQ7O0FBRUEsTUFBTXFaLFdBQVc3M0MsZUFBZStRLGFBQWhDO0FBQ0EsTUFBSSttQyxXQUFZL3dDLFNBQVNxekIsS0FBVCxHQUFpQnlkLFFBQWpDO0FBQ0EsTUFBSS9tQyxjQUFjOVEsZUFBZThRLFdBQWpDO0FBQ0EsTUFBSUEsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCLDhDQUNFOVEsY0FERixFQUVFOFEsV0FGRixFQUdFa3NCLFFBSEYsRUFJRWoyQixRQUpGLEVBS0UwSyxvQkFMRjtBQU9BcW1DLGVBQVc5M0MsZUFBZStRLGFBQTFCO0FBQ0Q7O0FBRUQsTUFDRWtzQixhQUFhRCxRQUFiLElBQ0E2YSxhQUFhQyxRQURiLElBRUEsQ0FBQywyQ0FGRCxJQUdBLENBQUMsMkRBSkgsRUFLRTtBQUNBO0FBQ0E7QUFDQSxRQUFJLE9BQU8vd0MsU0FBU3l5QyxrQkFBaEIsS0FBdUMsVUFBM0MsRUFBdUQ7QUFDckQsVUFDRXZjLGFBQWE3OEIsUUFBUXNsQixhQUFyQixJQUNBbXlCLGFBQWF6M0MsUUFBUTJRLGFBRnZCLEVBR0U7QUFDQS9RLHVCQUFldVIsU0FBZixJQUE0QjVRLDJCQUE1QjtBQUNEO0FBQ0Y7QUFDRCxRQUFJLE9BQU9vRyxTQUFTd3lDLHVCQUFoQixLQUE0QyxVQUFoRCxFQUE0RDtBQUMxRCxVQUNFdGMsYUFBYTc4QixRQUFRc2xCLGFBQXJCLElBQ0FteUIsYUFBYXozQyxRQUFRMlEsYUFGdkIsRUFHRTtBQUNBL1EsdUJBQWV1UixTQUFmLElBQTRCclEsNkJBQTVCO0FBQ0Q7QUFDRjtBQUNELFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksT0FBT202Qix3QkFBUCxLQUFvQyxVQUF4QyxFQUFvRDtBQUNsRG1iLCtCQUNFeDJDLGNBREYsRUFFRXl2QixJQUZGLEVBR0U0TCx3QkFIRixFQUlFMkIsUUFKRjtBQU1BOGEsZUFBVzkzQyxlQUFlK1EsYUFBMUI7QUFDRDs7QUFFRCxNQUFNa3BCLGVBQ0osK0RBQ0EyZCwyQkFDRTUzQyxjQURGLEVBRUV5dkIsSUFGRixFQUdFd04sUUFIRixFQUlFRCxRQUpGLEVBS0U2YSxRQUxGLEVBTUVDLFFBTkYsRUFPRXRaLFdBUEYsQ0FGRjs7QUFZQSxNQUFJdkUsWUFBSixFQUFrQjtBQUNoQjtBQUNBO0FBQ0EsUUFDRSxDQUFDMmdCLGdCQUFELEtBQ0MsT0FBTzd6QyxTQUFTbWdDLDBCQUFoQixLQUErQyxVQUEvQyxJQUNDLE9BQU9uZ0MsU0FBU2lpQyxtQkFBaEIsS0FBd0MsVUFGMUMsQ0FERixFQUlFO0FBQ0EsZ0RBQWdCaHBDLGNBQWhCLEVBQWdDLHFCQUFoQztBQUNBLFVBQUksT0FBTytHLFNBQVNpaUMsbUJBQWhCLEtBQXdDLFVBQTVDLEVBQXdEO0FBQ3REamlDLGlCQUFTaWlDLG1CQUFULENBQTZCaE0sUUFBN0IsRUFBdUM4YSxRQUF2QyxFQUFpRHRaLFdBQWpEO0FBQ0Q7QUFDRCxVQUFJLE9BQU96M0IsU0FBU21nQywwQkFBaEIsS0FBK0MsVUFBbkQsRUFBK0Q7QUFDN0RuZ0MsaUJBQVNtZ0MsMEJBQVQsQ0FBb0NsSyxRQUFwQyxFQUE4QzhhLFFBQTlDLEVBQXdEdFosV0FBeEQ7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxRQUFJLE9BQU96M0IsU0FBU3l5QyxrQkFBaEIsS0FBdUMsVUFBM0MsRUFBdUQ7QUFDckR4NUMscUJBQWV1UixTQUFmLElBQTRCNVEsMkJBQTVCO0FBQ0Q7QUFDRCxRQUFJLE9BQU9vRyxTQUFTd3lDLHVCQUFoQixLQUE0QyxVQUFoRCxFQUE0RDtBQUMxRHY1QyxxQkFBZXVSLFNBQWYsSUFBNEJyUSw2QkFBNUI7QUFDRDtBQUNGLEdBdkJELE1BdUJPO0FBQ0w7QUFDQTtBQUNBLFFBQUksT0FBTzZGLFNBQVN5eUMsa0JBQWhCLEtBQXVDLFVBQTNDLEVBQXVEO0FBQ3JELFVBQ0V2YyxhQUFhNzhCLFFBQVFzbEIsYUFBckIsSUFDQW15QixhQUFhejNDLFFBQVEyUSxhQUZ2QixFQUdFO0FBQ0EvUSx1QkFBZXVSLFNBQWYsSUFBNEI1USwyQkFBNUI7QUFDRDtBQUNGO0FBQ0QsUUFBSSxPQUFPb0csU0FBU3d5Qyx1QkFBaEIsS0FBNEMsVUFBaEQsRUFBNEQ7QUFDMUQsVUFDRXRjLGFBQWE3OEIsUUFBUXNsQixhQUFyQixJQUNBbXlCLGFBQWF6M0MsUUFBUTJRLGFBRnZCLEVBR0U7QUFDQS9RLHVCQUFldVIsU0FBZixJQUE0QnJRLDZCQUE1QjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBbEIsbUJBQWUwbEIsYUFBZixHQUErQnNYLFFBQS9CO0FBQ0FoOUIsbUJBQWUrUSxhQUFmLEdBQStCK21DLFFBQS9CO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBL3dDLFdBQVNxSCxLQUFULEdBQWlCNHVCLFFBQWpCO0FBQ0FqMkIsV0FBU3F6QixLQUFULEdBQWlCMGQsUUFBakI7QUFDQS93QyxXQUFTa0wsT0FBVCxHQUFtQnVzQixXQUFuQjs7QUFFQSxTQUFPdkUsWUFBUDtBQUNEOztRQUdDMmYsa0IsR0FBQUEsa0I7UUFDQUcsc0IsR0FBQUEsc0I7UUFDQVEsa0IsR0FBQUEsa0I7UUFDQUUsd0IsR0FBQUEsd0I7UUFDQUksbUIsR0FBQUEsbUI7Ozs7Ozs7Ozs7Ozs7OzhRQ2hvQ0Y7Ozs7Ozs7OztRQTZSZ0JFLGUsR0FBQUEsZTtRQThHQUMsWSxHQUFBQSxZO1FBWUFDLFUsR0FBQUEsVTs7QUF4WWhCOzs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBSUE7O0FBT0E7O0FBUUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztJQUVPdnpCLHNCLEdBQTBCOXNCLDhCLENBQTFCOHNCLHNCOzs7QUErRFAsSUFBSXd6QixnREFBSjtBQUNBLElBQUl0aUQsSUFBSixFQUFhO0FBQ1hzaUQsNENBQTBDLElBQUlsNUIsR0FBSixFQUExQztBQUNEOztBQWdDRDtBQUNBLElBQUl2USx1QkFBdUM3UCxnQ0FBM0M7QUFDQTtBQUNBO0FBQ0EsSUFBSXFSLDBCQUF3QyxJQUE1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlrb0MsbUJBQWdDLElBQXBDO0FBQ0EsSUFBSUMsY0FBMkIsSUFBL0I7QUFDQSxJQUFJQyxrQkFBK0IsSUFBbkM7QUFDQSxJQUFJQywwQkFBdUMsSUFBM0M7QUFDQSxJQUFJQyxxQkFBa0MsSUFBdEM7QUFDQSxJQUFJQyx5QkFBc0MsSUFBMUM7O0FBRUEsSUFBSXRvQiwwQkFBMEN0eEIsZ0NBQTlDO0FBQ0EsSUFBSTY1Qyx1QkFBNEQsSUFBaEU7QUFDQSxJQUFJQyxnQkFBK0IsQ0FBbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJQywrQkFBd0MsS0FBNUM7QUFDQTtBQUNBLElBQUlDLHFCQUdPLElBSFg7QUFJQTtBQUNBLElBQUlDLG9CQUE0QixDQUFoQztBQUNBLElBQU1DLGtCQUFrQixFQUF4Qjs7QUFFQTtBQUNBLElBQUlDLHVCQUFrQyxJQUF0Qzs7QUFFQSxTQUFTQyx1QkFBVCxHQUFtQztBQUNqQyxNQUFJcGpELElBQUosRUFBYTtBQUNYLFFBQU1vZixnQkFBZ0IsZ0NBQ2xCL0UsdUJBQUYsQ0FBd0MxVixJQURwQixDQUF0QjtBQUdBLFFBQUksQ0FBQzI5Qyx3Q0FBd0NoNEIsR0FBeEMsQ0FBNENsTCxhQUE1QyxDQUFMLEVBQWlFO0FBQy9Ea2pDLDhDQUF3Qy8zQixHQUF4QyxDQUE0Q25MLGFBQTVDOztBQUVBLFVBQU1pa0Msb0JBQW9CLEVBQTFCOztBQUVBLFVBQUlDLFFBQVEsRUFBWjtBQUNBLFVBQUlDLFdBQTRCaEIsZ0JBQWhDO0FBQ0EsVUFBSWlCLFdBQTRCZCx1QkFBaEM7QUFDQSxVQUFJZSxJQUFJLENBQVI7QUFDQSxhQUFPRixhQUFhLElBQWIsSUFBcUJDLGFBQWEsSUFBekMsRUFBK0M7QUFDN0MsWUFBTUUsY0FBY0gsU0FBU0ksVUFBN0I7QUFDQSxZQUFNQyxjQUFjSixTQUFTRyxVQUE3Qjs7QUFFQSxZQUFJRSxNQUFTSixDQUFULFVBQWVDLFdBQW5COztBQUVBO0FBQ0E7QUFDQSxlQUFPRyxJQUFJM2lELE1BQUosR0FBYW1pRCxpQkFBcEIsRUFBdUM7QUFDckNRLGlCQUFPLEdBQVA7QUFDRDs7QUFFREEsZUFBT0QsY0FBYyxJQUFyQjs7QUFFQU4saUJBQVNPLEdBQVQ7QUFDQU4sbUJBQVlBLFNBQVM1ckMsSUFBckI7QUFDQTZyQyxtQkFBWUEsU0FBUzdyQyxJQUFyQjtBQUNBOHJDO0FBQ0Q7O0FBRUQsNkJBQ0UsS0FERixFQUVFLHFFQUNFLGtEQURGLEdBRUUsaUZBRkYsR0FHRSxxQ0FIRixHQUlFLHNDQUpGLEdBS0UsSUFMRixHQU1FLHNDQVJKLEVBU0Vya0MsYUFURixFQVVFa2tDLEtBVkY7QUFZRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU1EscUJBQVQsR0FBaUM7QUFDL0IsMkJBQ0UsS0FERixFQUVFLHVFQUNFLHlDQUhKO0FBS0Q7O0FBRUQsU0FBU0Msa0JBQVQsQ0FDRUMsUUFERixFQUVFQyxRQUZGLEVBR0U7QUFDQSxNQUFJQSxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCLFFBQUlqa0QsSUFBSixFQUFhO0FBQ1gsNkJBQ0UsS0FERixFQUVFLHFFQUNFLG1FQURGLEdBRUUseUNBSkosRUFLRW1qRCxvQkFMRjtBQU9EO0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSW5qRCxJQUFKLEVBQWE7QUFDWDtBQUNBO0FBQ0EsUUFBSWdrRCxTQUFTOWlELE1BQVQsS0FBb0IraUQsU0FBUy9pRCxNQUFqQyxFQUF5QztBQUN2Qyw2QkFDRSxLQURGLEVBRUUsdUVBQ0Usd0RBREYsR0FFRSxnQkFGRixHQUdFLGNBTEosRUFNRWlpRCxvQkFORixRQU9NYSxTQUFTOVUsSUFBVCxDQUFjLElBQWQsQ0FQTixjQVFNK1UsU0FBUy9VLElBQVQsQ0FBYyxJQUFkLENBUk47QUFVRDtBQUNGO0FBQ0QsT0FBSyxJQUFJcnVCLElBQUksQ0FBYixFQUFnQkEsSUFBSW9qQyxTQUFTL2lELE1BQWIsSUFBdUIyZixJQUFJbWpDLFNBQVM5aUQsTUFBcEQsRUFBNEQyZixHQUE1RCxFQUFpRTtBQUMvRCxRQUFJLHdCQUFHbWpDLFNBQVNuakMsQ0FBVCxDQUFILEVBQWdCb2pDLFNBQVNwakMsQ0FBVCxDQUFoQixDQUFKLEVBQWtDO0FBQ2hDO0FBQ0Q7QUFDRCxXQUFPLEtBQVA7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVNLFNBQVNzaEMsZUFBVCxDQUNMMzZDLE9BREssRUFFTEosY0FGSyxFQUdMNFcsU0FISyxFQUlMeEksS0FKSyxFQUtMMHVDLFlBTEssRUFNTHYwQix3QkFOSyxFQU9BO0FBQ0w5Vyx5QkFBdUI4Vyx3QkFBdkI7QUFDQXRWLDRCQUEwQmpULGNBQTFCO0FBQ0FtN0MscUJBQW1CRSxrQkFDakJqN0MsWUFBWSxJQUFaLEdBQW1CQSxRQUFRMlEsYUFBM0IsR0FBMkMsSUFEN0M7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSW5ZLElBQUosRUFBYTtBQUNYOHVCLDJCQUF1QnRuQixPQUF2QixHQUNFaTdDLG9CQUFvQixJQUFwQixHQUNJMEIsMkJBREosR0FFSUMsNEJBSE47QUFJRCxHQUxELE1BS087QUFDTHQxQiwyQkFBdUJ0bkIsT0FBdkIsR0FDRWk3QyxvQkFBb0IsSUFBcEIsR0FDSTRCLHNCQURKLEdBRUlDLHVCQUhOO0FBSUQ7O0FBRUQsTUFBSXgyQixXQUFXOVAsVUFBVXhJLEtBQVYsRUFBaUIwdUMsWUFBakIsQ0FBZjs7QUFFQSxNQUFJbkIsNEJBQUosRUFBa0M7QUFDaEMsT0FBRztBQUNEQSxxQ0FBK0IsS0FBL0I7QUFDQUUsMkJBQXFCLENBQXJCOztBQUVBO0FBQ0FWLHlCQUFtQkUsa0JBQ2pCajdDLFlBQVksSUFBWixHQUFtQkEsUUFBUTJRLGFBQTNCLEdBQTJDLElBRDdDO0FBRUF5cUMsK0JBQXlCRix1QkFBekI7O0FBRUFGLG9CQUFjLElBQWQ7QUFDQUcsMkJBQXFCLElBQXJCO0FBQ0FFLDZCQUF1QixJQUF2Qjs7QUFFQS96Qiw2QkFBdUJ0bkIsT0FBdkIsR0FBaUN4SCxLQUFPQSxHQUNwQ29rRCw0QkFENkIsR0FFN0JFLHVCQUZKOztBQUlBeDJCLGlCQUFXOVAsVUFBVXhJLEtBQVYsRUFBaUIwdUMsWUFBakIsQ0FBWDtBQUNELEtBbEJELFFBa0JTbkIsNEJBbEJUOztBQW9CQUMseUJBQXFCLElBQXJCO0FBQ0FDLHdCQUFvQixDQUFwQjtBQUNEOztBQUVELE1BQUlqakQsSUFBSixFQUFhO0FBQ1htakQsMkJBQXVCLElBQXZCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBcjBCLHlCQUF1QnRuQixPQUF2QixHQUFpQ2t1QixxQkFBakM7O0FBRUEsTUFBTTZ1QixlQUF1QmxxQyx1QkFBN0I7O0FBRUFrcUMsZUFBYXBzQyxhQUFiLEdBQTZCdXFDLHVCQUE3QjtBQUNBNkIsZUFBYWg3QyxjQUFiLEdBQThCK3dCLHVCQUE5QjtBQUNBaXFCLGVBQWFyc0MsV0FBYixHQUE0QjJxQyxvQkFBNUI7QUFDQTBCLGVBQWE1ckMsU0FBYixJQUEwQm1xQyxhQUExQjs7QUFFQSxNQUFNMEIsdUJBQ0poQyxnQkFBZ0IsSUFBaEIsSUFBd0JBLFlBQVk3cUMsSUFBWixLQUFxQixJQUQvQzs7QUFHQWtCLHlCQUF1QjdQLGdDQUF2QjtBQUNBcVIsNEJBQTBCLElBQTFCOztBQUVBa29DLHFCQUFtQixJQUFuQjtBQUNBQyxnQkFBYyxJQUFkO0FBQ0FDLG9CQUFrQixJQUFsQjtBQUNBQyw0QkFBMEIsSUFBMUI7QUFDQUMsdUJBQXFCLElBQXJCO0FBQ0FDLDJCQUF5QixJQUF6Qjs7QUFFQXRvQiw0QkFBMEJ0eEIsZ0NBQTFCO0FBQ0E2NUMseUJBQXVCLElBQXZCO0FBQ0FDLGtCQUFnQixDQUFoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFDRSxDQUFDMEIsb0JBREgsRUFFRSw2RUFDRSx5QkFISjs7QUFNQSxTQUFPMTJCLFFBQVA7QUFDRDs7QUFFTSxTQUFTczBCLFlBQVQsQ0FDTDU2QyxPQURLLEVBRUxKLGNBRkssRUFHTG1DLGNBSEssRUFJTDtBQUNBbkMsaUJBQWU4USxXQUFmLEdBQTZCMVEsUUFBUTBRLFdBQXJDO0FBQ0E5USxpQkFBZXVSLFNBQWYsSUFBNEIsRUFBRThyQywrQkFBZ0JDLDJCQUFsQixDQUE1QjtBQUNBLE1BQUlsOUMsUUFBUStCLGNBQVIsSUFBMEJBLGNBQTlCLEVBQThDO0FBQzVDL0IsWUFBUStCLGNBQVIsR0FBeUJQLGdDQUF6QjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU3E1QyxVQUFULEdBQTRCO0FBQ2pDO0FBQ0E7QUFDQXZ6Qix5QkFBdUJ0bkIsT0FBdkIsR0FBaUNrdUIscUJBQWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBN2MseUJBQXVCN1AsZ0NBQXZCO0FBQ0FxUiw0QkFBMEIsSUFBMUI7O0FBRUFrb0MscUJBQW1CLElBQW5CO0FBQ0FDLGdCQUFjLElBQWQ7QUFDQUMsb0JBQWtCLElBQWxCO0FBQ0FDLDRCQUEwQixJQUExQjtBQUNBQyx1QkFBcUIsSUFBckI7QUFDQUMsMkJBQXlCLElBQXpCOztBQUVBdG9CLDRCQUEwQnR4QixnQ0FBMUI7QUFDQTY1Qyx5QkFBdUIsSUFBdkI7QUFDQUMsa0JBQWdCLENBQWhCOztBQUVBLE1BQUk5aUQsSUFBSixFQUFhO0FBQ1htakQsMkJBQXVCLElBQXZCO0FBQ0Q7O0FBRURKLGlDQUErQixLQUEvQjtBQUNBQyx1QkFBcUIsSUFBckI7QUFDQUMsc0JBQW9CLENBQXBCO0FBQ0Q7O0FBRUQsU0FBUzBCLHVCQUFULEdBQXlDO0FBQ3ZDLE1BQU0xbEIsT0FBYTtBQUNqQjltQixtQkFBZSxJQURFOztBQUdqQnRCLGVBQVcsSUFITTtBQUlqQkMsV0FBTyxJQUpVO0FBS2pCOHRDLGdCQUFZLElBTEs7O0FBT2pCanRDLFVBQU07QUFQVyxHQUFuQjs7QUFVQSxNQUFJM1gsSUFBSixFQUFhO0FBQ1ZpL0IsUUFBRCxDQUFZMGtCLFVBQVosR0FBMEJSLG9CQUExQjtBQUNEO0FBQ0QsTUFBSVIsdUJBQXVCLElBQTNCLEVBQWlDO0FBQy9CO0FBQ0FELDhCQUEwQkMscUJBQXFCMWpCLElBQS9DO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQTBqQix5QkFBcUJBLG1CQUFtQmhyQyxJQUFuQixHQUEwQnNuQixJQUEvQztBQUNEO0FBQ0QsU0FBTzBqQixrQkFBUDtBQUNEOztBQUVELFNBQVNrQyx3QkFBVCxHQUEwQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSWpDLDJCQUEyQixJQUEvQixFQUFxQztBQUNuQztBQUNBRCx5QkFBcUJDLHNCQUFyQjtBQUNBQSw2QkFBeUJELG1CQUFtQmhyQyxJQUE1Qzs7QUFFQTZxQyxrQkFBY0MsZUFBZDtBQUNBQSxzQkFBa0JELGdCQUFnQixJQUFoQixHQUF1QkEsWUFBWTdxQyxJQUFuQyxHQUEwQyxJQUE1RDtBQUNELEdBUEQsTUFPTztBQUNMO0FBQ0EsNkJBQ0U4cUMsb0JBQW9CLElBRHRCLEVBRUUsc0RBRkY7QUFJQUQsa0JBQWNDLGVBQWQ7O0FBRUEsUUFBTXFDLFVBQWdCO0FBQ3BCM3NDLHFCQUFlcXFDLFlBQVlycUMsYUFEUDs7QUFHcEJ0QixpQkFBVzJyQyxZQUFZM3JDLFNBSEg7QUFJcEJDLGFBQU8wckMsWUFBWTFyQyxLQUpDO0FBS3BCOHRDLGtCQUFZcEMsWUFBWW9DLFVBTEo7O0FBT3BCanRDLFlBQU07QUFQYyxLQUF0Qjs7QUFVQSxRQUFJZ3JDLHVCQUF1QixJQUEzQixFQUFpQztBQUMvQjtBQUNBQSwyQkFBcUJELDBCQUEwQm9DLE9BQS9DO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQW5DLDJCQUFxQkEsbUJBQW1CaHJDLElBQW5CLEdBQTBCbXRDLE9BQS9DO0FBQ0Q7QUFDRHJDLHNCQUFrQkQsWUFBWTdxQyxJQUE5Qjs7QUFFQSxRQUFJM1gsSUFBSixFQUFhO0FBQ1Y4a0QsYUFBRCxDQUFlbkIsVUFBZixHQUE2QlIsb0JBQTdCO0FBQ0EsVUFBSUEseUJBQTJCWCxXQUFGLENBQThCbUIsVUFBM0QsRUFBdUU7QUFDckVQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBT1Qsa0JBQVA7QUFDRDs7QUFFRCxTQUFTb0Msa0NBQVQsR0FBNEU7QUFDMUUsU0FBTztBQUNMM3RDLGdCQUFZO0FBRFAsR0FBUDtBQUdEOztBQUVELFNBQVM0dEMsaUJBQVQsQ0FBOEJ4akIsS0FBOUIsRUFBd0M3ekIsTUFBeEMsRUFBd0U7QUFDdEUsU0FBTyxPQUFPQSxNQUFQLEtBQWtCLFVBQWxCLEdBQStCQSxPQUFPNnpCLEtBQVAsQ0FBL0IsR0FBK0M3ekIsTUFBdEQ7QUFDRDs7QUFFRCxTQUFTczNDLFlBQVQsQ0FDRTVyQyxPQURGLEVBRUUwQyxZQUZGLEVBR0s7QUFDSCxNQUFJL2IsSUFBSixFQUFhO0FBQ1gya0Q7QUFDRDtBQUNELFNBQU8sdUNBQVl0ckMsT0FBWixFQUFxQjBDLFlBQXJCLENBQVA7QUFDRDs7QUFFRCxTQUFTbXBDLGFBQVQsQ0FDRTdyQyxPQURGLEVBRUUwQyxZQUZGLEVBR0s7QUFDSCxNQUFJL2IsSUFBSixFQUFhO0FBQ1g2a0Q7QUFDRDtBQUNELFNBQU8sdUNBQVl4ckMsT0FBWixFQUFxQjBDLFlBQXJCLENBQVA7QUFDRDs7QUFFRCxTQUFTb3BDLFlBQVQsQ0FDRUMsT0FERixFQUVFQyxVQUZGLEVBR0VDLElBSEYsRUFJb0I7QUFDbEIsTUFBTXJtQixPQUFPMGxCLHlCQUFiO0FBQ0EsTUFBSVkscUJBQUo7QUFDQSxNQUFJRCxTQUFTcGxELFNBQWIsRUFBd0I7QUFDdEJxbEQsbUJBQWVELEtBQUtELFVBQUwsQ0FBZjtBQUNELEdBRkQsTUFFTztBQUNMRSxtQkFBaUJGLFVBQWpCO0FBQ0Q7QUFDRHBtQixPQUFLOW1CLGFBQUwsR0FBcUI4bUIsS0FBS3BvQixTQUFMLEdBQWlCMHVDLFlBQXRDO0FBQ0EsTUFBTXp1QyxRQUFTbW9CLEtBQUtub0IsS0FBTCxHQUFhO0FBQzFCa3RCLFVBQU0sSUFEb0I7QUFFMUIrVyxjQUFVLElBRmdCO0FBRzFCeUssa0JBQWNKLE9BSFk7QUFJMUJLLGdCQUFhRjtBQUphLEdBQTVCO0FBTUEsTUFBTXhLLFdBQXlCamtDLE1BQU1pa0MsUUFBTixHQUFrQjJLLGVBQWV4eUIsSUFBZixDQUMvQyxJQUQrQztBQUUvQztBQUNFN1kseUJBSDZDLEVBSS9DdkQsS0FKK0MsQ0FBakQ7QUFNQSxTQUFPLENBQUNtb0IsS0FBSzltQixhQUFOLEVBQXFCNGlDLFFBQXJCLENBQVA7QUFDRDs7QUFFRCxTQUFTNEssYUFBVCxDQUNFUCxPQURGLEVBRUVDLFVBRkYsRUFHRUMsSUFIRixFQUlvQjtBQUNsQixNQUFNcm1CLE9BQU80bEIsMEJBQWI7QUFDQSxNQUFNL3RDLFFBQVFtb0IsS0FBS25vQixLQUFuQjtBQUNBLDJCQUNFQSxVQUFVLElBRFosRUFFRSwyRUFGRjs7QUFLQSxNQUFJbXNDLG9CQUFvQixDQUF4QixFQUEyQjtBQUN6QjtBQUVBLFFBQU1sSSxZQUF5QmprQyxNQUFNaWtDLFFBQXJDO0FBQ0EsUUFBSWlJLHVCQUF1QixJQUEzQixFQUFpQztBQUMvQjtBQUNBLFVBQU00Qyx5QkFBeUI1QyxtQkFBbUJ2MUMsR0FBbkIsQ0FBdUJxSixLQUF2QixDQUEvQjtBQUNBLFVBQUk4dUMsMkJBQTJCMWxELFNBQS9CLEVBQTBDO0FBQ3hDOGlELDJCQUFtQnp1QixNQUFuQixDQUEwQnpkLEtBQTFCO0FBQ0EsWUFBSW9vQyxXQUFXamdCLEtBQUs5bUIsYUFBcEI7QUFDQSxZQUFJTCxTQUFTOHRDLHNCQUFiO0FBQ0EsV0FBRztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQU1qNEMsVUFBU21LLE9BQU9uSyxNQUF0QjtBQUNBdXhDLHFCQUFXa0csUUFBUWxHLFFBQVIsRUFBa0J2eEMsT0FBbEIsQ0FBWDtBQUNBbUssbUJBQVNBLE9BQU9ILElBQWhCO0FBQ0QsU0FQRCxRQU9TRyxXQUFXLElBUHBCOztBQVNBO0FBQ0E7QUFDQSxZQUFJLENBQUMsd0JBQUdvbkMsUUFBSCxFQUFhamdCLEtBQUs5bUIsYUFBbEIsQ0FBTCxFQUF1QztBQUNyQztBQUNEOztBQUVEOG1CLGFBQUs5bUIsYUFBTCxHQUFxQittQyxRQUFyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUlqZ0IsS0FBSzJsQixVQUFMLEtBQW9COXRDLE1BQU1rdEIsSUFBOUIsRUFBb0M7QUFDbEMvRSxlQUFLcG9CLFNBQUwsR0FBaUJxb0MsUUFBakI7QUFDRDs7QUFFRCxlQUFPLENBQUNBLFFBQUQsRUFBV25FLFNBQVgsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFPLENBQUM5YixLQUFLOW1CLGFBQU4sRUFBcUI0aUMsU0FBckIsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsTUFBTS9XLE9BQU9sdEIsTUFBTWt0QixJQUFuQjtBQUNBO0FBQ0EsTUFBTTRnQixhQUFhM2xCLEtBQUsybEIsVUFBeEI7QUFDQSxNQUFNL3RDLFlBQVlvb0IsS0FBS3BvQixTQUF2Qjs7QUFFQTtBQUNBLE1BQUlpRixjQUFKO0FBQ0EsTUFBSThvQyxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLFFBQUk1Z0IsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBQSxXQUFLcnNCLElBQUwsR0FBWSxJQUFaO0FBQ0Q7QUFDRG1FLFlBQVE4b0MsV0FBV2p0QyxJQUFuQjtBQUNELEdBUkQsTUFRTztBQUNMbUUsWUFBUWtvQixTQUFTLElBQVQsR0FBZ0JBLEtBQUtyc0IsSUFBckIsR0FBNEIsSUFBcEM7QUFDRDtBQUNELE1BQUltRSxVQUFVLElBQWQsRUFBb0I7QUFDbEIsUUFBSW9qQyxZQUFXcm9DLFNBQWY7QUFDQSxRQUFJaUMsZUFBZSxJQUFuQjtBQUNBLFFBQUkrc0MsZ0JBQWdCLElBQXBCO0FBQ0EsUUFBSUMsYUFBYWxCLFVBQWpCO0FBQ0EsUUFBSTlzQyxVQUFTZ0UsS0FBYjtBQUNBLFFBQUlpcUMsVUFBVSxLQUFkO0FBQ0EsT0FBRztBQUNELFVBQU03c0MsdUJBQXVCcEIsUUFBT3ZPLGNBQXBDO0FBQ0EsVUFBSTJQLHVCQUF1Qkwsb0JBQTNCLEVBQWlEO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQUksQ0FBQ2t0QyxPQUFMLEVBQWM7QUFDWkEsb0JBQVUsSUFBVjtBQUNBRiwwQkFBZ0JDLFVBQWhCO0FBQ0FodEMseUJBQWVvbUMsU0FBZjtBQUNEO0FBQ0Q7QUFDQSxZQUFJaG1DLHVCQUF1Qm9oQix1QkFBM0IsRUFBb0Q7QUFDbERBLG9DQUEwQnBoQixvQkFBMUI7QUFDRDtBQUNGLE9BYkQsTUFhTztBQUNMO0FBQ0EsWUFBSXBCLFFBQU8wdEMsWUFBUCxLQUF3QkosT0FBNUIsRUFBcUM7QUFDbkM7QUFDQTtBQUNBbEcsc0JBQWFwbkMsUUFBTzJ0QyxVQUFwQjtBQUNELFNBSkQsTUFJTztBQUNMLGNBQU05M0MsV0FBU21LLFFBQU9uSyxNQUF0QjtBQUNBdXhDLHNCQUFXa0csUUFBUWxHLFNBQVIsRUFBa0J2eEMsUUFBbEIsQ0FBWDtBQUNEO0FBQ0Y7QUFDRG00QyxtQkFBYWh1QyxPQUFiO0FBQ0FBLGdCQUFTQSxRQUFPSCxJQUFoQjtBQUNELEtBNUJELFFBNEJTRyxZQUFXLElBQVgsSUFBbUJBLFlBQVdnRSxLQTVCdkM7O0FBOEJBLFFBQUksQ0FBQ2lxQyxPQUFMLEVBQWM7QUFDWkYsc0JBQWdCQyxVQUFoQjtBQUNBaHRDLHFCQUFlb21DLFNBQWY7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsUUFBSSxDQUFDLHdCQUFHQSxTQUFILEVBQWFqZ0IsS0FBSzltQixhQUFsQixDQUFMLEVBQXVDO0FBQ3JDO0FBQ0Q7O0FBRUQ4bUIsU0FBSzltQixhQUFMLEdBQXFCK21DLFNBQXJCO0FBQ0FqZ0IsU0FBSzJsQixVQUFMLEdBQWtCaUIsYUFBbEI7QUFDQTVtQixTQUFLcG9CLFNBQUwsR0FBaUJpQyxZQUFqQjs7QUFFQWhDLFVBQU0wdUMsWUFBTixHQUFxQkosT0FBckI7QUFDQXR1QyxVQUFNMnVDLFVBQU4sR0FBbUJ2RyxTQUFuQjtBQUNEOztBQUVELE1BQU1uRSxXQUF5QmprQyxNQUFNaWtDLFFBQXJDO0FBQ0EsU0FBTyxDQUFDOWIsS0FBSzltQixhQUFOLEVBQXFCNGlDLFFBQXJCLENBQVA7QUFDRDs7QUFFRCxTQUFTaUwsVUFBVCxDQUNFVCxZQURGLEVBRXNDO0FBQ3BDLE1BQU10bUIsT0FBTzBsQix5QkFBYjtBQUNBLE1BQUksT0FBT1ksWUFBUCxLQUF3QixVQUE1QixFQUF3QztBQUN0Q0EsbUJBQWVBLGNBQWY7QUFDRDtBQUNEdG1CLE9BQUs5bUIsYUFBTCxHQUFxQjhtQixLQUFLcG9CLFNBQUwsR0FBaUIwdUMsWUFBdEM7QUFDQSxNQUFNenVDLFFBQVNtb0IsS0FBS25vQixLQUFMLEdBQWE7QUFDMUJrdEIsVUFBTSxJQURvQjtBQUUxQitXLGNBQVUsSUFGZ0I7QUFHMUJ5SyxrQkFBY1IsaUJBSFk7QUFJMUJTLGdCQUFhRjtBQUphLEdBQTVCO0FBTUEsTUFBTXhLLFdBRURqa0MsTUFBTWlrQyxRQUFOLEdBQWtCMkssZUFBZXh5QixJQUFmLENBQ3JCLElBRHFCO0FBRXJCO0FBQ0U3WSx5QkFIbUIsRUFJckJ2RCxLQUpxQixDQUZ2QjtBQVFBLFNBQU8sQ0FBQ21vQixLQUFLOW1CLGFBQU4sRUFBcUI0aUMsUUFBckIsQ0FBUDtBQUNEOztBQUVELFNBQVNrTCxXQUFULENBQ0VWLFlBREYsRUFFc0M7QUFDcEMsU0FBT0ksY0FBY1gsaUJBQWQsRUFBa0NPLFlBQWxDLENBQVA7QUFDRDs7QUFFRCxTQUFTVyxVQUFULENBQW9CdGhELEdBQXBCLEVBQXlCdWhELE1BQXpCLEVBQWlDQyxPQUFqQyxFQUEwQ0MsSUFBMUMsRUFBZ0Q7QUFDOUMsTUFBTTVzQyxTQUFpQjtBQUNyQjdVLFlBRHFCO0FBRXJCdWhELGtCQUZxQjtBQUdyQkMsb0JBSHFCO0FBSXJCQyxjQUpxQjtBQUtyQjtBQUNBMXVDLFVBQU87QUFOYyxHQUF2QjtBQVFBLE1BQUlrckMseUJBQXlCLElBQTdCLEVBQW1DO0FBQ2pDQSwyQkFBdUJrQyxvQ0FBdkI7QUFDQWxDLHlCQUFxQnpyQyxVQUFyQixHQUFrQ3FDLE9BQU85QixJQUFQLEdBQWM4QixNQUFoRDtBQUNELEdBSEQsTUFHTztBQUNMLFFBQU1yQyxjQUFheXJDLHFCQUFxQnpyQyxVQUF4QztBQUNBLFFBQUlBLGdCQUFlLElBQW5CLEVBQXlCO0FBQ3ZCeXJDLDJCQUFxQnpyQyxVQUFyQixHQUFrQ3FDLE9BQU85QixJQUFQLEdBQWM4QixNQUFoRDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQU10QyxjQUFjQyxZQUFXTyxJQUEvQjtBQUNBUCxrQkFBV08sSUFBWCxHQUFrQjhCLE1BQWxCO0FBQ0FBLGFBQU85QixJQUFQLEdBQWNSLFdBQWQ7QUFDQTByQywyQkFBcUJ6ckMsVUFBckIsR0FBa0NxQyxNQUFsQztBQUNEO0FBQ0Y7QUFDRCxTQUFPQSxNQUFQO0FBQ0Q7O0FBRUQsU0FBUzZzQyxRQUFULENBQXFCdlAsWUFBckIsRUFBb0Q7QUFDbEQsTUFBTTlYLE9BQU8wbEIseUJBQWI7QUFDQSxNQUFNOTNCLE1BQU0sRUFBQ3JsQixTQUFTdXZDLFlBQVYsRUFBWjtBQUNBLE1BQUkvMkMsSUFBSixFQUFhO0FBQ1hxTSxXQUFPazZDLElBQVAsQ0FBWTE1QixHQUFaO0FBQ0Q7QUFDRG9TLE9BQUs5bUIsYUFBTCxHQUFxQjBVLEdBQXJCO0FBQ0EsU0FBT0EsR0FBUDtBQUNEOztBQUVELFNBQVMyNUIsU0FBVCxDQUFzQnpQLFlBQXRCLEVBQXFEO0FBQ25ELE1BQU05WCxPQUFPNGxCLDBCQUFiO0FBQ0EsU0FBTzVsQixLQUFLOW1CLGFBQVo7QUFDRDs7QUFFRCxTQUFTc3VDLGVBQVQsQ0FBeUJDLGNBQXpCLEVBQXlDQyxhQUF6QyxFQUF3RFIsTUFBeEQsRUFBZ0VFLElBQWhFLEVBQTRFO0FBQzFFLE1BQU1wbkIsT0FBTzBsQix5QkFBYjtBQUNBLE1BQU1YLFdBQVdxQyxTQUFTbm1ELFNBQVQsR0FBcUIsSUFBckIsR0FBNEJtbUQsSUFBN0M7QUFDQXZELG1CQUFpQjRELGNBQWpCO0FBQ0F6bkIsT0FBSzltQixhQUFMLEdBQXFCK3RDLFdBQVdTLGFBQVgsRUFBMEJSLE1BQTFCLEVBQWtDam1ELFNBQWxDLEVBQTZDOGpELFFBQTdDLENBQXJCO0FBQ0Q7O0FBRUQsU0FBUzRDLGdCQUFULENBQTBCRixjQUExQixFQUEwQ0MsYUFBMUMsRUFBeURSLE1BQXpELEVBQWlFRSxJQUFqRSxFQUE2RTtBQUMzRSxNQUFNcG5CLE9BQU80bEIsMEJBQWI7QUFDQSxNQUFNYixXQUFXcUMsU0FBU25tRCxTQUFULEdBQXFCLElBQXJCLEdBQTRCbW1ELElBQTdDO0FBQ0EsTUFBSUQsVUFBVWxtRCxTQUFkOztBQUVBLE1BQUlzaUQsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCLFFBQU1xRSxhQUFhckUsWUFBWXJxQyxhQUEvQjtBQUNBaXVDLGNBQVVTLFdBQVdULE9BQXJCO0FBQ0EsUUFBSXBDLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsVUFBTUMsV0FBVzRDLFdBQVdSLElBQTVCO0FBQ0EsVUFBSXRDLG1CQUFtQkMsUUFBbkIsRUFBNkJDLFFBQTdCLENBQUosRUFBNEM7QUFDMUNpQyxtQkFBV1ksNkJBQVgsRUFBeUJYLE1BQXpCLEVBQWlDQyxPQUFqQyxFQUEwQ3BDLFFBQTFDO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7O0FBRURsQixtQkFBaUI0RCxjQUFqQjtBQUNBem5CLE9BQUs5bUIsYUFBTCxHQUFxQit0QyxXQUFXUyxhQUFYLEVBQTBCUixNQUExQixFQUFrQ0MsT0FBbEMsRUFBMkNwQyxRQUEzQyxDQUFyQjtBQUNEOztBQUVELFNBQVMrQyxXQUFULENBQ0VaLE1BREYsRUFFRUUsSUFGRixFQUdRO0FBQ04sU0FBT0ksZ0JBQ0wvQiw4QkFBZUQsNEJBRFYsRUFFTHVDLHNDQUFpQkMsaUNBRlosRUFHTGQsTUFISyxFQUlMRSxJQUpLLENBQVA7QUFNRDs7QUFFRCxTQUFTYSxZQUFULENBQ0VmLE1BREYsRUFFRUUsSUFGRixFQUdRO0FBQ04sU0FBT08saUJBQ0xsQyw4QkFBZUQsNEJBRFYsRUFFTHVDLHNDQUFpQkMsaUNBRlosRUFHTGQsTUFISyxFQUlMRSxJQUpLLENBQVA7QUFNRDs7QUFFRCxTQUFTYyxpQkFBVCxDQUNFaEIsTUFERixFQUVFRSxJQUZGLEVBR1E7QUFDTixTQUFPSSxnQkFDTC9CLDJCQURLLEVBRUwwQyx1Q0FBa0JDLGdDQUZiLEVBR0xsQixNQUhLLEVBSUxFLElBSkssQ0FBUDtBQU1EOztBQUVELFNBQVNpQixrQkFBVCxDQUNFbkIsTUFERixFQUVFRSxJQUZGLEVBR1E7QUFDTixTQUFPTyxpQkFDTGxDLDJCQURLLEVBRUwwQyx1Q0FBa0JDLGdDQUZiLEVBR0xsQixNQUhLLEVBSUxFLElBSkssQ0FBUDtBQU1EOztBQUVELFNBQVNrQixzQkFBVCxDQUNFcEIsTUFERixFQUVFdDVCLEdBRkYsRUFHRTtBQUNBLE1BQUksT0FBT0EsR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQzdCLFFBQU0yNkIsY0FBYzM2QixHQUFwQjtBQUNBLFFBQU12WCxRQUFPNndDLFFBQWI7QUFDQXFCLGdCQUFZbHlDLEtBQVo7QUFDQSxXQUFPLFlBQU07QUFDWGt5QyxrQkFBWSxJQUFaO0FBQ0QsS0FGRDtBQUdELEdBUEQsTUFPTyxJQUFJMzZCLFFBQVEsSUFBUixJQUFnQkEsUUFBUTNzQixTQUE1QixFQUF1QztBQUM1QyxRQUFNdW5ELFlBQVk1NkIsR0FBbEI7QUFDQSxRQUFJN3NCLElBQUosRUFBYTtBQUNYLDZCQUNFeW5ELFVBQVV2N0MsY0FBVixDQUF5QixTQUF6QixDQURGLEVBRUUsa0VBQ0UsaUVBSEosRUFJRSwwQkFBMEJHLE9BQU80aEIsSUFBUCxDQUFZdzVCLFNBQVosRUFBdUJ2WSxJQUF2QixDQUE0QixJQUE1QixDQUExQixHQUE4RCxHQUpoRTtBQU1EO0FBQ0QsUUFBTTU1QixTQUFPNndDLFFBQWI7QUFDQXNCLGNBQVVqZ0QsT0FBVixHQUFvQjhOLE1BQXBCO0FBQ0EsV0FBTyxZQUFNO0FBQ1hteUMsZ0JBQVVqZ0QsT0FBVixHQUFvQixJQUFwQjtBQUNELEtBRkQ7QUFHRDtBQUNGOztBQUVELFNBQVNrZ0QscUJBQVQsQ0FDRTc2QixHQURGLEVBRUVzNUIsTUFGRixFQUdFRSxJQUhGLEVBSVE7QUFDTixNQUFJcm1ELElBQUosRUFBYTtBQUNYLDJCQUNFLE9BQU9tbUQsTUFBUCxLQUFrQixVQURwQixFQUVFLHFFQUNFLDhDQUhKLEVBSUVBLFdBQVcsSUFBWCxVQUF5QkEsTUFBekIseUNBQXlCQSxNQUF6QixJQUFrQyxNQUpwQztBQU1EOztBQUVEO0FBQ0EsTUFBTXdCLGFBQ0p0QixTQUFTLElBQVQsSUFBaUJBLFNBQVNubUQsU0FBMUIsR0FBc0NtbUQsS0FBS2xTLE1BQUwsQ0FBWSxDQUFDdG5CLEdBQUQsQ0FBWixDQUF0QyxHQUEyRCxJQUQ3RDs7QUFHQSxTQUFPNDVCLGdCQUNML0IsMkJBREssRUFFTDBDLHVDQUFrQkMsZ0NBRmIsRUFHTEUsdUJBQXVCcjBCLElBQXZCLENBQTRCLElBQTVCLEVBQWtDaXpCLE1BQWxDLEVBQTBDdDVCLEdBQTFDLENBSEssRUFJTDg2QixVQUpLLENBQVA7QUFNRDs7QUFFRCxTQUFTQyxzQkFBVCxDQUNFLzZCLEdBREYsRUFFRXM1QixNQUZGLEVBR0VFLElBSEYsRUFJUTtBQUNOLE1BQUlybUQsSUFBSixFQUFhO0FBQ1gsMkJBQ0UsT0FBT21tRCxNQUFQLEtBQWtCLFVBRHBCLEVBRUUscUVBQ0UsOENBSEosRUFJRUEsV0FBVyxJQUFYLFVBQXlCQSxNQUF6Qix5Q0FBeUJBLE1BQXpCLElBQWtDLE1BSnBDO0FBTUQ7O0FBRUQ7QUFDQSxNQUFNd0IsYUFDSnRCLFNBQVMsSUFBVCxJQUFpQkEsU0FBU25tRCxTQUExQixHQUFzQ21tRCxLQUFLbFMsTUFBTCxDQUFZLENBQUN0bkIsR0FBRCxDQUFaLENBQXRDLEdBQTJELElBRDdEOztBQUdBLFNBQU8rNUIsaUJBQ0xsQywyQkFESyxFQUVMMEMsdUNBQWtCQyxnQ0FGYixFQUdMRSx1QkFBdUJyMEIsSUFBdkIsQ0FBNEIsSUFBNUIsRUFBa0NpekIsTUFBbEMsRUFBMEN0NUIsR0FBMUMsQ0FISyxFQUlMODZCLFVBSkssQ0FBUDtBQU1EOztBQUVELFNBQVNFLGVBQVQsQ0FBNEJ6akMsS0FBNUIsRUFBc0MwakMsV0FBdEMsRUFBK0U7QUFDN0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsSUFBTUMsbUJBQW1CRixlQUF6Qjs7QUFFQSxTQUFTRyxhQUFULENBQTBCdHdDLFFBQTFCLEVBQXVDMnVDLElBQXZDLEVBQTRFO0FBQzFFLE1BQU1wbkIsT0FBTzBsQix5QkFBYjtBQUNBLE1BQU1YLFdBQVdxQyxTQUFTbm1ELFNBQVQsR0FBcUIsSUFBckIsR0FBNEJtbUQsSUFBN0M7QUFDQXBuQixPQUFLOW1CLGFBQUwsR0FBcUIsQ0FBQ1QsUUFBRCxFQUFXc3NDLFFBQVgsQ0FBckI7QUFDQSxTQUFPdHNDLFFBQVA7QUFDRDs7QUFFRCxTQUFTdXdDLGNBQVQsQ0FBMkJ2d0MsUUFBM0IsRUFBd0MydUMsSUFBeEMsRUFBNkU7QUFDM0UsTUFBTXBuQixPQUFPNGxCLDBCQUFiO0FBQ0EsTUFBTWIsV0FBV3FDLFNBQVNubUQsU0FBVCxHQUFxQixJQUFyQixHQUE0Qm1tRCxJQUE3QztBQUNBLE1BQU05dEMsWUFBWTBtQixLQUFLOW1CLGFBQXZCO0FBQ0EsTUFBSUksY0FBYyxJQUFsQixFQUF3QjtBQUN0QixRQUFJeXJDLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsVUFBTUMsV0FBZ0MxckMsVUFBVSxDQUFWLENBQXRDO0FBQ0EsVUFBSXdyQyxtQkFBbUJDLFFBQW5CLEVBQTZCQyxRQUE3QixDQUFKLEVBQTRDO0FBQzFDLGVBQU8xckMsVUFBVSxDQUFWLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRDBtQixPQUFLOW1CLGFBQUwsR0FBcUIsQ0FBQ1QsUUFBRCxFQUFXc3NDLFFBQVgsQ0FBckI7QUFDQSxTQUFPdHNDLFFBQVA7QUFDRDs7QUFFRCxTQUFTd3dDLFNBQVQsQ0FDRUMsVUFERixFQUVFOUIsSUFGRixFQUdLO0FBQ0gsTUFBTXBuQixPQUFPMGxCLHlCQUFiO0FBQ0EsTUFBTVgsV0FBV3FDLFNBQVNubUQsU0FBVCxHQUFxQixJQUFyQixHQUE0Qm1tRCxJQUE3QztBQUNBLE1BQU0zckMsWUFBWXl0QyxZQUFsQjtBQUNBbHBCLE9BQUs5bUIsYUFBTCxHQUFxQixDQUFDdUMsU0FBRCxFQUFZc3BDLFFBQVosQ0FBckI7QUFDQSxTQUFPdHBDLFNBQVA7QUFDRDs7QUFFRCxTQUFTMHRDLFVBQVQsQ0FDRUQsVUFERixFQUVFOUIsSUFGRixFQUdLO0FBQ0gsTUFBTXBuQixPQUFPNGxCLDBCQUFiO0FBQ0EsTUFBTWIsV0FBV3FDLFNBQVNubUQsU0FBVCxHQUFxQixJQUFyQixHQUE0Qm1tRCxJQUE3QztBQUNBLE1BQU05dEMsWUFBWTBtQixLQUFLOW1CLGFBQXZCO0FBQ0EsTUFBSUksY0FBYyxJQUFsQixFQUF3QjtBQUN0QjtBQUNBLFFBQUl5ckMsYUFBYSxJQUFqQixFQUF1QjtBQUNyQixVQUFNQyxXQUFnQzFyQyxVQUFVLENBQVYsQ0FBdEM7QUFDQSxVQUFJd3JDLG1CQUFtQkMsUUFBbkIsRUFBNkJDLFFBQTdCLENBQUosRUFBNEM7QUFDMUMsZUFBTzFyQyxVQUFVLENBQVYsQ0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNELE1BQU1tQyxZQUFZeXRDLFlBQWxCO0FBQ0FscEIsT0FBSzltQixhQUFMLEdBQXFCLENBQUN1QyxTQUFELEVBQVlzcEMsUUFBWixDQUFyQjtBQUNBLFNBQU90cEMsU0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxJQUFJMnRDLGlDQUFpQyxLQUFyQzs7QUFFQSxJQUFJcm9ELElBQUosRUFBYTtBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQUksZ0JBQWdCLE9BQU9zb0QsSUFBM0IsRUFBaUM7QUFDL0JELHFDQUFpQyxJQUFqQztBQUNEO0FBQ0Y7O0FBRUQsU0FBUzNDLGNBQVQsQ0FDRTUrQyxLQURGLEVBRUVnUSxLQUZGLEVBR0VuSixNQUhGLEVBSUU7QUFDQSwyQkFDRXMxQyxvQkFBb0JDLGVBRHRCLEVBRUUsd0VBQ0UsbUJBSEo7O0FBTUEsTUFBSWxqRCxJQUFKLEVBQWE7QUFDWCwyQkFDRW1OLFVBQVVqTSxNQUFWLElBQW9CLENBRHRCLEVBRUUsZ0ZBQ0UsMkRBREYsR0FFRSwrREFKSjtBQU1EOztBQUVELE1BQU02VyxZQUFZalIsTUFBTWlSLFNBQXhCO0FBQ0EsTUFDRWpSLFVBQVV1VCx1QkFBVixJQUNDdEMsY0FBYyxJQUFkLElBQXNCQSxjQUFjc0MsdUJBRnZDLEVBR0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTBvQyxtQ0FBK0IsSUFBL0I7QUFDQSxRQUFNanJDLFNBQXVCO0FBQzNCdk8sc0JBQWdCc1Asb0JBRFc7QUFFM0JsTCxvQkFGMkI7QUFHM0I2M0Msb0JBQWMsSUFIYTtBQUkzQkMsa0JBQVksSUFKZTtBQUszQjl0QyxZQUFNO0FBTHFCLEtBQTdCO0FBT0EsUUFBSXFyQyx1QkFBdUIsSUFBM0IsRUFBaUM7QUFDL0JBLDJCQUFxQixJQUFJMTJCLEdBQUosRUFBckI7QUFDRDtBQUNELFFBQU1zNUIseUJBQXlCNUMsbUJBQW1CdjFDLEdBQW5CLENBQXVCcUosS0FBdkIsQ0FBL0I7QUFDQSxRQUFJOHVDLDJCQUEyQjFsRCxTQUEvQixFQUEwQztBQUN4QzhpRCx5QkFBbUJ4MUMsR0FBbkIsQ0FBdUJzSixLQUF2QixFQUE4QmdCLE1BQTlCO0FBQ0QsS0FGRCxNQUVPO0FBQ0w7QUFDQSxVQUFJeXdDLHdCQUF3QjNDLHNCQUE1QjtBQUNBLGFBQU8yQyxzQkFBc0I1d0MsSUFBdEIsS0FBK0IsSUFBdEMsRUFBNEM7QUFDMUM0d0MsZ0NBQXdCQSxzQkFBc0I1d0MsSUFBOUM7QUFDRDtBQUNENHdDLDRCQUFzQjV3QyxJQUF0QixHQUE2QkcsTUFBN0I7QUFDRDtBQUNGLEdBN0JELE1BNkJPO0FBQ0w7O0FBRUEsUUFBTWxPLGNBQWMsOENBQXBCO0FBQ0EsUUFBTUwsa0JBQWlCLG9EQUEwQkssV0FBMUIsRUFBdUM5QyxLQUF2QyxDQUF2Qjs7QUFFQSxRQUFNZ1IsV0FBdUI7QUFDM0J2TyxxQ0FEMkI7QUFFM0JvRSxvQkFGMkI7QUFHM0I2M0Msb0JBQWMsSUFIYTtBQUkzQkMsa0JBQVksSUFKZTtBQUszQjl0QyxZQUFNO0FBTHFCLEtBQTdCOztBQVFBO0FBQ0EsUUFBTXFzQixRQUFPbHRCLE1BQU1rdEIsSUFBbkI7QUFDQSxRQUFJQSxVQUFTLElBQWIsRUFBbUI7QUFDakI7QUFDQWxzQixlQUFPSCxJQUFQLEdBQWNHLFFBQWQ7QUFDRCxLQUhELE1BR087QUFDTCxVQUFNZ0UsUUFBUWtvQixNQUFLcnNCLElBQW5CO0FBQ0EsVUFBSW1FLFVBQVUsSUFBZCxFQUFvQjtBQUNsQjtBQUNBaEUsaUJBQU9ILElBQVAsR0FBY21FLEtBQWQ7QUFDRDtBQUNEa29CLFlBQUtyc0IsSUFBTCxHQUFZRyxRQUFaO0FBQ0Q7QUFDRGhCLFVBQU1rdEIsSUFBTixHQUFhbHNCLFFBQWI7O0FBRUEsUUFDRWhSLE1BQU15QyxjQUFOLEtBQXlCUCxnQ0FBekIsS0FDQytPLGNBQWMsSUFBZCxJQUFzQkEsVUFBVXhPLGNBQVYsS0FBNkJQLGdDQURwRCxDQURGLEVBR0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFNdzhDLGdCQUFlMXVDLE1BQU0wdUMsWUFBM0I7QUFDQSxVQUFJQSxrQkFBaUIsSUFBckIsRUFBMkI7QUFDekIsWUFBSWdELHVCQUFKO0FBQ0EsWUFBSXhvRCxJQUFKLEVBQWE7QUFDWHdvRCwyQkFBaUIxNUIsdUJBQXVCdG5CLE9BQXhDO0FBQ0FzbkIsaUNBQXVCdG5CLE9BQXZCLEdBQWlDaWhELHlDQUFqQztBQUNEO0FBQ0QsWUFBSTtBQUNGLGNBQU1DLGVBQW1CNXhDLE1BQU0ydUMsVUFBL0I7QUFDQSxjQUFNQSxjQUFhRCxjQUFha0QsWUFBYixFQUEyQi82QyxNQUEzQixDQUFuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FtSyxtQkFBTzB0QyxZQUFQLEdBQXNCQSxhQUF0QjtBQUNBMXRDLG1CQUFPMnRDLFVBQVAsR0FBb0JBLFdBQXBCO0FBQ0EsY0FBSSx3QkFBR0EsV0FBSCxFQUFlaUQsWUFBZixDQUFKLEVBQWtDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNGLFNBaEJELENBZ0JFLE9BQU8vbkQsS0FBUCxFQUFjO0FBQ2Q7QUFDRCxTQWxCRCxTQWtCVTtBQUNSLGNBQUlYLElBQUosRUFBYTtBQUNYOHVCLG1DQUF1QnRuQixPQUF2QixHQUFpQ2doRCxjQUFqQztBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsUUFBSXhvRCxJQUFKLEVBQWE7QUFDWCxVQUFJcW9ELG1DQUFtQyxJQUF2QyxFQUE2QztBQUMzQyxrRUFBZ0N2aEQsS0FBaEM7QUFDRDtBQUNGO0FBQ0QsMkNBQWFBLEtBQWIsRUFBb0J5QyxlQUFwQjtBQUNEO0FBQ0Y7O0FBRU0sSUFBTW1zQix3REFBb0M7QUFDL0N4YixnREFEK0M7O0FBRy9DeXVDLGVBQWE3RSxxQkFIa0M7QUFJL0M4RSxjQUFZOUUscUJBSm1DO0FBSy9DK0UsYUFBVy9FLHFCQUxvQztBQU0vQ2dGLHVCQUFxQmhGLHFCQU4wQjtBQU8vQ2lGLG1CQUFpQmpGLHFCQVA4QjtBQVEvQ2tGLFdBQVNsRixxQkFSc0M7QUFTL0NtRixjQUFZbkYscUJBVG1DO0FBVS9Db0YsVUFBUXBGLHFCQVZ1QztBQVcvQ3FGLFlBQVVyRixxQkFYcUM7QUFZL0NzRixpQkFBZXRGO0FBWmdDLENBQTFDOztBQWVQLElBQU1PLHlCQUFxQztBQUN6Q25xQyxnREFEeUM7O0FBR3pDeXVDLGVBQWFYLGFBSDRCO0FBSXpDWSxjQUFZMXVDLGlDQUo2QjtBQUt6QzJ1QyxhQUFXOUIsV0FMOEI7QUFNekMrQix1QkFBcUJwQixxQkFOb0I7QUFPekNxQixtQkFBaUI1QixpQkFQd0I7QUFRekM2QixXQUFTZCxTQVJnQztBQVN6Q2UsY0FBWTlELFlBVDZCO0FBVXpDK0QsVUFBUTVDLFFBVmlDO0FBV3pDNkMsWUFBVW5ELFVBWCtCO0FBWXpDb0QsaUJBQWV2QjtBQVowQixDQUEzQzs7QUFlQSxJQUFNdkQsMEJBQXNDO0FBQzFDcHFDLGdEQUQwQzs7QUFHMUN5dUMsZUFBYVYsY0FINkI7QUFJMUNXLGNBQVkxdUMsaUNBSjhCO0FBSzFDMnVDLGFBQVczQixZQUwrQjtBQU0xQzRCLHVCQUFxQmxCLHNCQU5xQjtBQU8xQ21CLG1CQUFpQnpCLGtCQVB5QjtBQVExQzBCLFdBQVNaLFVBUmlDO0FBUzFDYSxjQUFZdEQsYUFUOEI7QUFVMUN1RCxVQUFRMUMsU0FWa0M7QUFXMUMyQyxZQUFVbEQsV0FYZ0M7QUFZMUNtRCxpQkFBZXJCO0FBWjJCLENBQTVDOztBQWVBLElBQUk1RCw4QkFBaUQsSUFBckQ7QUFDQSxJQUFJQywrQkFBa0QsSUFBdEQ7QUFDQSxJQUFJaUYsMkNBQThELElBQWxFO0FBQ0EsSUFBSVosNENBQStELElBQW5FOztBQUVBLElBQUl6b0QsSUFBSixFQUFhO0FBQ1gsTUFBTXNwRCwyQkFBMkIsU0FBM0JBLHdCQUEyQixHQUFNO0FBQ3JDLDJCQUNFLEtBREYsRUFFRSx3REFDRSxnRkFERixHQUVFLGlGQUZGLEdBR0UsOENBTEo7QUFPRCxHQVJEOztBQVVBLE1BQU1DLHdCQUF3QixTQUF4QkEscUJBQXdCLEdBQU07QUFDbEMsMkJBQ0UsS0FERixFQUVFLHFGQUNFLG1FQURGLEdBRUUsNEJBRkYsR0FHRSw4QkFMSjtBQU9ELEdBUkQ7O0FBVUFwRixnQ0FBOEI7QUFDNUJqcUMsZUFENEIsdUJBRTFCYixPQUYwQixFQUcxQjBDLFlBSDBCLEVBSXZCO0FBQ0gsYUFBTyx1Q0FBWTFDLE9BQVosRUFBcUIwQyxZQUFyQixDQUFQO0FBQ0QsS0FOMkI7QUFRNUI0c0MsZUFSNEIsdUJBUWJqeEMsUUFSYSxFQVFBMnVDLElBUkEsRUFRcUM7QUFDL0RsRCw2QkFBdUIsYUFBdkI7QUFDQSxhQUFPNkUsY0FBY3R3QyxRQUFkLEVBQXdCMnVDLElBQXhCLENBQVA7QUFDRCxLQVgyQjtBQVk1QnVDLGNBWjRCLHNCQWExQnZ2QyxPQWIwQixFQWMxQjBDLFlBZDBCLEVBZXZCO0FBQ0hvbkMsNkJBQXVCLFlBQXZCO0FBQ0EsYUFBTzhCLGFBQWE1ckMsT0FBYixFQUFzQjBDLFlBQXRCLENBQVA7QUFDRCxLQWxCMkI7QUFtQjVCOHNDLGFBbkI0QixxQkFvQjFCMUMsTUFwQjBCLEVBcUIxQkUsSUFyQjBCLEVBc0JwQjtBQUNObEQsNkJBQXVCLFdBQXZCO0FBQ0EsYUFBTzRELFlBQVlaLE1BQVosRUFBb0JFLElBQXBCLENBQVA7QUFDRCxLQXpCMkI7QUEwQjVCeUMsdUJBMUI0QiwrQkEyQjFCajhCLEdBM0IwQixFQTRCMUJzNUIsTUE1QjBCLEVBNkIxQkUsSUE3QjBCLEVBOEJwQjtBQUNObEQsNkJBQXVCLHFCQUF2QjtBQUNBLGFBQU91RSxzQkFBc0I3NkIsR0FBdEIsRUFBMkJzNUIsTUFBM0IsRUFBbUNFLElBQW5DLENBQVA7QUFDRCxLQWpDMkI7QUFrQzVCMEMsbUJBbEM0QiwyQkFtQzFCNUMsTUFuQzBCLEVBb0MxQkUsSUFwQzBCLEVBcUNwQjtBQUNObEQsNkJBQXVCLGlCQUF2QjtBQUNBLGFBQU9nRSxrQkFBa0JoQixNQUFsQixFQUEwQkUsSUFBMUIsQ0FBUDtBQUNELEtBeEMyQjtBQXlDNUIyQyxXQXpDNEIsbUJBeUNqQjdDLE1BekNpQixFQXlDQUUsSUF6Q0EsRUF5Q3FDO0FBQy9EbEQsNkJBQXVCLFNBQXZCO0FBQ0EsVUFBTXFGLGlCQUFpQjE1Qix1QkFBdUJ0bkIsT0FBOUM7QUFDQXNuQiw2QkFBdUJ0bkIsT0FBdkIsR0FBaUM2aEQsd0NBQWpDO0FBQ0EsVUFBSTtBQUNGLGVBQU9uQixVQUFVL0IsTUFBVixFQUFrQkUsSUFBbEIsQ0FBUDtBQUNELE9BRkQsU0FFVTtBQUNSdjNCLCtCQUF1QnRuQixPQUF2QixHQUFpQ2doRCxjQUFqQztBQUNEO0FBQ0YsS0FsRDJCO0FBbUQ1QlMsY0FuRDRCLHNCQW9EMUI3RCxPQXBEMEIsRUFxRDFCQyxVQXJEMEIsRUFzRDFCQyxJQXREMEIsRUF1RFI7QUFDbEJuQyw2QkFBdUIsWUFBdkI7QUFDQSxVQUFNcUYsaUJBQWlCMTVCLHVCQUF1QnRuQixPQUE5QztBQUNBc25CLDZCQUF1QnRuQixPQUF2QixHQUFpQzZoRCx3Q0FBakM7QUFDQSxVQUFJO0FBQ0YsZUFBT2xFLGFBQWFDLE9BQWIsRUFBc0JDLFVBQXRCLEVBQWtDQyxJQUFsQyxDQUFQO0FBQ0QsT0FGRCxTQUVVO0FBQ1J4MkIsK0JBQXVCdG5CLE9BQXZCLEdBQWlDZ2hELGNBQWpDO0FBQ0Q7QUFDRixLQWhFMkI7QUFpRTVCVSxVQWpFNEIsa0JBaUVsQm5TLFlBakVrQixFQWlFYTtBQUN2Q29NLDZCQUF1QixRQUF2QjtBQUNBLGFBQU9tRCxTQUFTdlAsWUFBVCxDQUFQO0FBQ0QsS0FwRTJCO0FBcUU1Qm9TLFlBckU0QixvQkFzRTFCNUQsWUF0RTBCLEVBdUVVO0FBQ3BDcEMsNkJBQXVCLFVBQXZCO0FBQ0EsVUFBTXFGLGlCQUFpQjE1Qix1QkFBdUJ0bkIsT0FBOUM7QUFDQXNuQiw2QkFBdUJ0bkIsT0FBdkIsR0FBaUM2aEQsd0NBQWpDO0FBQ0EsVUFBSTtBQUNGLGVBQU9yRCxXQUFXVCxZQUFYLENBQVA7QUFDRCxPQUZELFNBRVU7QUFDUnoyQiwrQkFBdUJ0bkIsT0FBdkIsR0FBaUNnaEQsY0FBakM7QUFDRDtBQUNGLEtBaEYyQjtBQWlGNUJZLGlCQWpGNEIseUJBaUZYaGxDLEtBakZXLEVBaUZEMGpDLFdBakZDLEVBaUZ3QztBQUNsRTNFLDZCQUF1QixlQUF2QjtBQUNBLGFBQU8wRSxnQkFBZ0J6akMsS0FBaEIsRUFBdUIwakMsV0FBdkIsQ0FBUDtBQUNEO0FBcEYyQixHQUE5Qjs7QUF1RkExRCxpQ0FBK0I7QUFDN0JscUMsZUFENkIsdUJBRTNCYixPQUYyQixFQUczQjBDLFlBSDJCLEVBSXhCO0FBQ0gsYUFBTyx1Q0FBWTFDLE9BQVosRUFBcUIwQyxZQUFyQixDQUFQO0FBQ0QsS0FONEI7QUFRN0I0c0MsZUFSNkIsdUJBUWRqeEMsUUFSYyxFQVFEMnVDLElBUkMsRUFRb0M7QUFDL0RsRCw2QkFBdUIsYUFBdkI7QUFDQSxhQUFPOEUsZUFBZXZ3QyxRQUFmLEVBQXlCMnVDLElBQXpCLENBQVA7QUFDRCxLQVg0QjtBQVk3QnVDLGNBWjZCLHNCQWEzQnZ2QyxPQWIyQixFQWMzQjBDLFlBZDJCLEVBZXhCO0FBQ0hvbkMsNkJBQXVCLFlBQXZCO0FBQ0EsYUFBTytCLGNBQWM3ckMsT0FBZCxFQUF1QjBDLFlBQXZCLENBQVA7QUFDRCxLQWxCNEI7QUFtQjdCOHNDLGFBbkI2QixxQkFvQjNCMUMsTUFwQjJCLEVBcUIzQkUsSUFyQjJCLEVBc0JyQjtBQUNObEQsNkJBQXVCLFdBQXZCO0FBQ0EsYUFBTytELGFBQWFmLE1BQWIsRUFBcUJFLElBQXJCLENBQVA7QUFDRCxLQXpCNEI7QUEwQjdCeUMsdUJBMUI2QiwrQkEyQjNCajhCLEdBM0IyQixFQTRCM0JzNUIsTUE1QjJCLEVBNkIzQkUsSUE3QjJCLEVBOEJyQjtBQUNObEQsNkJBQXVCLHFCQUF2QjtBQUNBLGFBQU95RSx1QkFBdUIvNkIsR0FBdkIsRUFBNEJzNUIsTUFBNUIsRUFBb0NFLElBQXBDLENBQVA7QUFDRCxLQWpDNEI7QUFrQzdCMEMsbUJBbEM2QiwyQkFtQzNCNUMsTUFuQzJCLEVBb0MzQkUsSUFwQzJCLEVBcUNyQjtBQUNObEQsNkJBQXVCLGlCQUF2QjtBQUNBLGFBQU9tRSxtQkFBbUJuQixNQUFuQixFQUEyQkUsSUFBM0IsQ0FBUDtBQUNELEtBeEM0QjtBQXlDN0IyQyxXQXpDNkIsbUJBeUNsQjdDLE1BekNrQixFQXlDREUsSUF6Q0MsRUF5Q29DO0FBQy9EbEQsNkJBQXVCLFNBQXZCO0FBQ0EsVUFBTXFGLGlCQUFpQjE1Qix1QkFBdUJ0bkIsT0FBOUM7QUFDQXNuQiw2QkFBdUJ0bkIsT0FBdkIsR0FBaUNpaEQseUNBQWpDO0FBQ0EsVUFBSTtBQUNGLGVBQU9MLFdBQVdqQyxNQUFYLEVBQW1CRSxJQUFuQixDQUFQO0FBQ0QsT0FGRCxTQUVVO0FBQ1J2M0IsK0JBQXVCdG5CLE9BQXZCLEdBQWlDZ2hELGNBQWpDO0FBQ0Q7QUFDRixLQWxENEI7QUFtRDdCUyxjQW5ENkIsc0JBb0QzQjdELE9BcEQyQixFQXFEM0JDLFVBckQyQixFQXNEM0JDLElBdEQyQixFQXVEVDtBQUNsQm5DLDZCQUF1QixZQUF2QjtBQUNBLFVBQU1xRixpQkFBaUIxNUIsdUJBQXVCdG5CLE9BQTlDO0FBQ0FzbkIsNkJBQXVCdG5CLE9BQXZCLEdBQWlDaWhELHlDQUFqQztBQUNBLFVBQUk7QUFDRixlQUFPOUMsY0FBY1AsT0FBZCxFQUF1QkMsVUFBdkIsRUFBbUNDLElBQW5DLENBQVA7QUFDRCxPQUZELFNBRVU7QUFDUngyQiwrQkFBdUJ0bkIsT0FBdkIsR0FBaUNnaEQsY0FBakM7QUFDRDtBQUNGLEtBaEU0QjtBQWlFN0JVLFVBakU2QixrQkFpRW5CblMsWUFqRW1CLEVBaUVZO0FBQ3ZDb00sNkJBQXVCLFFBQXZCO0FBQ0EsYUFBT3FELFVBQVV6UCxZQUFWLENBQVA7QUFDRCxLQXBFNEI7QUFxRTdCb1MsWUFyRTZCLG9CQXNFM0I1RCxZQXRFMkIsRUF1RVM7QUFDcENwQyw2QkFBdUIsVUFBdkI7QUFDQSxVQUFNcUYsaUJBQWlCMTVCLHVCQUF1QnRuQixPQUE5QztBQUNBc25CLDZCQUF1QnRuQixPQUF2QixHQUFpQ2loRCx5Q0FBakM7QUFDQSxVQUFJO0FBQ0YsZUFBT3hDLFlBQVlWLFlBQVosQ0FBUDtBQUNELE9BRkQsU0FFVTtBQUNSejJCLCtCQUF1QnRuQixPQUF2QixHQUFpQ2doRCxjQUFqQztBQUNEO0FBQ0YsS0FoRjRCO0FBaUY3QlksaUJBakY2Qix5QkFpRlpobEMsS0FqRlksRUFpRkYwakMsV0FqRkUsRUFpRnVDO0FBQ2xFM0UsNkJBQXVCLGVBQXZCO0FBQ0EsYUFBTzRFLGlCQUFpQjNqQyxLQUFqQixFQUF3QjBqQyxXQUF4QixDQUFQO0FBQ0Q7QUFwRjRCLEdBQS9COztBQXVGQXVCLDZDQUEyQztBQUN6Q252QyxlQUR5Qyx1QkFFdkNiLE9BRnVDLEVBR3ZDMEMsWUFIdUMsRUFJcEM7QUFDSHV0QztBQUNBLGFBQU8sdUNBQVlqd0MsT0FBWixFQUFxQjBDLFlBQXJCLENBQVA7QUFDRCxLQVB3QztBQVN6QzRzQyxlQVR5Qyx1QkFTMUJqeEMsUUFUMEIsRUFTYjJ1QyxJQVRhLEVBU3dCO0FBQy9EbEQsNkJBQXVCLGFBQXZCO0FBQ0FvRztBQUNBLGFBQU92QixjQUFjdHdDLFFBQWQsRUFBd0IydUMsSUFBeEIsQ0FBUDtBQUNELEtBYndDO0FBY3pDdUMsY0FkeUMsc0JBZXZDdnZDLE9BZnVDLEVBZ0J2QzBDLFlBaEJ1QyxFQWlCcEM7QUFDSG9uQyw2QkFBdUIsWUFBdkI7QUFDQW9HO0FBQ0EsYUFBT3RFLGFBQWE1ckMsT0FBYixFQUFzQjBDLFlBQXRCLENBQVA7QUFDRCxLQXJCd0M7QUFzQnpDOHNDLGFBdEJ5QyxxQkF1QnZDMUMsTUF2QnVDLEVBd0J2Q0UsSUF4QnVDLEVBeUJqQztBQUNObEQsNkJBQXVCLFdBQXZCO0FBQ0FvRztBQUNBLGFBQU94QyxZQUFZWixNQUFaLEVBQW9CRSxJQUFwQixDQUFQO0FBQ0QsS0E3QndDO0FBOEJ6Q3lDLHVCQTlCeUMsK0JBK0J2Q2o4QixHQS9CdUMsRUFnQ3ZDczVCLE1BaEN1QyxFQWlDdkNFLElBakN1QyxFQWtDakM7QUFDTmxELDZCQUF1QixxQkFBdkI7QUFDQW9HO0FBQ0EsYUFBTzdCLHNCQUFzQjc2QixHQUF0QixFQUEyQnM1QixNQUEzQixFQUFtQ0UsSUFBbkMsQ0FBUDtBQUNELEtBdEN3QztBQXVDekMwQyxtQkF2Q3lDLDJCQXdDdkM1QyxNQXhDdUMsRUF5Q3ZDRSxJQXpDdUMsRUEwQ2pDO0FBQ05sRCw2QkFBdUIsaUJBQXZCO0FBQ0FvRztBQUNBLGFBQU9wQyxrQkFBa0JoQixNQUFsQixFQUEwQkUsSUFBMUIsQ0FBUDtBQUNELEtBOUN3QztBQStDekMyQyxXQS9DeUMsbUJBK0M5QjdDLE1BL0M4QixFQStDYkUsSUEvQ2EsRUErQ3dCO0FBQy9EbEQsNkJBQXVCLFNBQXZCO0FBQ0FvRztBQUNBLFVBQU1mLGlCQUFpQjE1Qix1QkFBdUJ0bkIsT0FBOUM7QUFDQXNuQiw2QkFBdUJ0bkIsT0FBdkIsR0FBaUM2aEQsd0NBQWpDO0FBQ0EsVUFBSTtBQUNGLGVBQU9uQixVQUFVL0IsTUFBVixFQUFrQkUsSUFBbEIsQ0FBUDtBQUNELE9BRkQsU0FFVTtBQUNSdjNCLCtCQUF1QnRuQixPQUF2QixHQUFpQ2doRCxjQUFqQztBQUNEO0FBQ0YsS0F6RHdDO0FBMER6Q1MsY0ExRHlDLHNCQTJEdkM3RCxPQTNEdUMsRUE0RHZDQyxVQTVEdUMsRUE2RHZDQyxJQTdEdUMsRUE4RHJCO0FBQ2xCbkMsNkJBQXVCLFlBQXZCO0FBQ0FvRztBQUNBLFVBQU1mLGlCQUFpQjE1Qix1QkFBdUJ0bkIsT0FBOUM7QUFDQXNuQiw2QkFBdUJ0bkIsT0FBdkIsR0FBaUM2aEQsd0NBQWpDO0FBQ0EsVUFBSTtBQUNGLGVBQU9sRSxhQUFhQyxPQUFiLEVBQXNCQyxVQUF0QixFQUFrQ0MsSUFBbEMsQ0FBUDtBQUNELE9BRkQsU0FFVTtBQUNSeDJCLCtCQUF1QnRuQixPQUF2QixHQUFpQ2doRCxjQUFqQztBQUNEO0FBQ0YsS0F4RXdDO0FBeUV6Q1UsVUF6RXlDLGtCQXlFL0JuUyxZQXpFK0IsRUF5RUE7QUFDdkNvTSw2QkFBdUIsUUFBdkI7QUFDQW9HO0FBQ0EsYUFBT2pELFNBQVN2UCxZQUFULENBQVA7QUFDRCxLQTdFd0M7QUE4RXpDb1MsWUE5RXlDLG9CQStFdkM1RCxZQS9FdUMsRUFnRkg7QUFDcENwQyw2QkFBdUIsVUFBdkI7QUFDQW9HO0FBQ0EsVUFBTWYsaUJBQWlCMTVCLHVCQUF1QnRuQixPQUE5QztBQUNBc25CLDZCQUF1QnRuQixPQUF2QixHQUFpQzZoRCx3Q0FBakM7QUFDQSxVQUFJO0FBQ0YsZUFBT3JELFdBQVdULFlBQVgsQ0FBUDtBQUNELE9BRkQsU0FFVTtBQUNSejJCLCtCQUF1QnRuQixPQUF2QixHQUFpQ2doRCxjQUFqQztBQUNEO0FBQ0YsS0ExRndDO0FBMkZ6Q1ksaUJBM0Z5Qyx5QkEyRnhCaGxDLEtBM0Z3QixFQTJGZDBqQyxXQTNGYyxFQTJGMkI7QUFDbEUzRSw2QkFBdUIsZUFBdkI7QUFDQW9HO0FBQ0EsYUFBTzFCLGdCQUFnQnpqQyxLQUFoQixFQUF1QjBqQyxXQUF2QixDQUFQO0FBQ0Q7QUEvRndDLEdBQTNDOztBQWtHQVcsOENBQTRDO0FBQzFDdnVDLGVBRDBDLHVCQUV4Q2IsT0FGd0MsRUFHeEMwQyxZQUh3QyxFQUlyQztBQUNIdXRDO0FBQ0EsYUFBTyx1Q0FBWWp3QyxPQUFaLEVBQXFCMEMsWUFBckIsQ0FBUDtBQUNELEtBUHlDO0FBUzFDNHNDLGVBVDBDLHVCQVMzQmp4QyxRQVQyQixFQVNkMnVDLElBVGMsRUFTdUI7QUFDL0RsRCw2QkFBdUIsYUFBdkI7QUFDQW9HO0FBQ0EsYUFBT3RCLGVBQWV2d0MsUUFBZixFQUF5QjJ1QyxJQUF6QixDQUFQO0FBQ0QsS0FieUM7QUFjMUN1QyxjQWQwQyxzQkFleEN2dkMsT0Fmd0MsRUFnQnhDMEMsWUFoQndDLEVBaUJyQztBQUNIb25DLDZCQUF1QixZQUF2QjtBQUNBb0c7QUFDQSxhQUFPckUsY0FBYzdyQyxPQUFkLEVBQXVCMEMsWUFBdkIsQ0FBUDtBQUNELEtBckJ5QztBQXNCMUM4c0MsYUF0QjBDLHFCQXVCeEMxQyxNQXZCd0MsRUF3QnhDRSxJQXhCd0MsRUF5QmxDO0FBQ05sRCw2QkFBdUIsV0FBdkI7QUFDQW9HO0FBQ0EsYUFBT3JDLGFBQWFmLE1BQWIsRUFBcUJFLElBQXJCLENBQVA7QUFDRCxLQTdCeUM7QUE4QjFDeUMsdUJBOUIwQywrQkErQnhDajhCLEdBL0J3QyxFQWdDeENzNUIsTUFoQ3dDLEVBaUN4Q0UsSUFqQ3dDLEVBa0NsQztBQUNObEQsNkJBQXVCLHFCQUF2QjtBQUNBb0c7QUFDQSxhQUFPM0IsdUJBQXVCLzZCLEdBQXZCLEVBQTRCczVCLE1BQTVCLEVBQW9DRSxJQUFwQyxDQUFQO0FBQ0QsS0F0Q3lDO0FBdUMxQzBDLG1CQXZDMEMsMkJBd0N4QzVDLE1BeEN3QyxFQXlDeENFLElBekN3QyxFQTBDbEM7QUFDTmxELDZCQUF1QixpQkFBdkI7QUFDQW9HO0FBQ0EsYUFBT2pDLG1CQUFtQm5CLE1BQW5CLEVBQTJCRSxJQUEzQixDQUFQO0FBQ0QsS0E5Q3lDO0FBK0MxQzJDLFdBL0MwQyxtQkErQy9CN0MsTUEvQytCLEVBK0NkRSxJQS9DYyxFQStDdUI7QUFDL0RsRCw2QkFBdUIsU0FBdkI7QUFDQW9HO0FBQ0EsVUFBTWYsaUJBQWlCMTVCLHVCQUF1QnRuQixPQUE5QztBQUNBc25CLDZCQUF1QnRuQixPQUF2QixHQUFpQ2loRCx5Q0FBakM7QUFDQSxVQUFJO0FBQ0YsZUFBT0wsV0FBV2pDLE1BQVgsRUFBbUJFLElBQW5CLENBQVA7QUFDRCxPQUZELFNBRVU7QUFDUnYzQiwrQkFBdUJ0bkIsT0FBdkIsR0FBaUNnaEQsY0FBakM7QUFDRDtBQUNGLEtBekR5QztBQTBEMUNTLGNBMUQwQyxzQkEyRHhDN0QsT0EzRHdDLEVBNER4Q0MsVUE1RHdDLEVBNkR4Q0MsSUE3RHdDLEVBOER0QjtBQUNsQm5DLDZCQUF1QixZQUF2QjtBQUNBb0c7QUFDQSxVQUFNZixpQkFBaUIxNUIsdUJBQXVCdG5CLE9BQTlDO0FBQ0FzbkIsNkJBQXVCdG5CLE9BQXZCLEdBQWlDaWhELHlDQUFqQztBQUNBLFVBQUk7QUFDRixlQUFPOUMsY0FBY1AsT0FBZCxFQUF1QkMsVUFBdkIsRUFBbUNDLElBQW5DLENBQVA7QUFDRCxPQUZELFNBRVU7QUFDUngyQiwrQkFBdUJ0bkIsT0FBdkIsR0FBaUNnaEQsY0FBakM7QUFDRDtBQUNGLEtBeEV5QztBQXlFMUNVLFVBekUwQyxrQkF5RWhDblMsWUF6RWdDLEVBeUVEO0FBQ3ZDb00sNkJBQXVCLFFBQXZCO0FBQ0FvRztBQUNBLGFBQU8vQyxVQUFVelAsWUFBVixDQUFQO0FBQ0QsS0E3RXlDO0FBOEUxQ29TLFlBOUUwQyxvQkErRXhDNUQsWUEvRXdDLEVBZ0ZKO0FBQ3BDcEMsNkJBQXVCLFVBQXZCO0FBQ0FvRztBQUNBLFVBQU1mLGlCQUFpQjE1Qix1QkFBdUJ0bkIsT0FBOUM7QUFDQXNuQiw2QkFBdUJ0bkIsT0FBdkIsR0FBaUNpaEQseUNBQWpDO0FBQ0EsVUFBSTtBQUNGLGVBQU94QyxZQUFZVixZQUFaLENBQVA7QUFDRCxPQUZELFNBRVU7QUFDUnoyQiwrQkFBdUJ0bkIsT0FBdkIsR0FBaUNnaEQsY0FBakM7QUFDRDtBQUNGLEtBMUZ5QztBQTJGMUNZLGlCQTNGMEMseUJBMkZ6QmhsQyxLQTNGeUIsRUEyRmYwakMsV0EzRmUsRUEyRjBCO0FBQ2xFM0UsNkJBQXVCLGVBQXZCO0FBQ0FvRztBQUNBLGFBQU94QixpQkFBaUIzakMsS0FBakIsRUFBd0IwakMsV0FBeEIsQ0FBUDtBQUNEO0FBL0Z5QyxHQUE1QztBQWlHRCxDOzs7Ozs7Ozs7Ozs7QUM1aERNLElBQU1sZ0QsV0FBVyxpQkFBWCxtQkFBNkIsQ0FBbkMsQyxDQVhQOzs7Ozs7Ozs7QUFZTyxJQUFNNGhELGtCQUFrQixVQUFsQiwwQkFBNkIsQ0FBbkM7QUFDQSxJQUFNcEMsa0JBQWtCLFVBQWxCLDBCQUE2QixDQUFuQztBQUNBLElBQU1xQyxnQkFBZ0IsWUFBaEIsd0JBQTZCLENBQW5DO0FBQ0EsSUFBTUMsZ0JBQWdCLFlBQWhCLHdCQUE2QixFQUFuQztBQUNBLElBQU1yQyxjQUFjLGNBQWQsc0JBQTZCLEVBQW5DO0FBQ0EsSUFBTUosZUFBZSxhQUFmLHVCQUE2QixFQUFuQztBQUNBLElBQU1ELGlCQUFpQixXQUFqQix5QkFBNkIsR0FBbkMsQzs7Ozs7Ozs7Ozs7Ozs7QUNDUDs7QUFPQTs7QUFDQTs7OztBQUVBOztBQUNBOztBQXNCQTs7OztBQUVBO0FBQ0E7QUF2REE7Ozs7Ozs7OztBQXdEQSxJQUFJMkMsdUJBQXFDLElBQXpDO0FBQ0EsSUFBSUMseUJBQW9ELElBQXhEO0FBQ0EsSUFBSTFTLGNBQXVCLEtBQTNCOztBQUVBLFNBQVMyUyxtQkFBVCxDQUE2Qi9pRCxLQUE3QixFQUFvRDtBQUNsRCxNQUFJLENBQUNnakQsdUNBQUwsRUFBd0I7QUFDdEIsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBTUMsaUJBQWlCampELE1BQU15TyxTQUFOLENBQWdCbVosYUFBdkM7QUFDQWs3QiwyQkFBeUIsbURBQXdCRyxjQUF4QixDQUF6QjtBQUNBSix5QkFBdUI3aUQsS0FBdkI7QUFDQW93QyxnQkFBYyxJQUFkO0FBQ0EsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBUzhTLG1EQUFULENBQ0VsakQsS0FERixFQUVXO0FBQ1QsTUFBSSxDQUFDZ2pELHVDQUFMLEVBQXdCO0FBQ3RCLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQU1HLG1CQUFtQm5qRCxNQUFNeU8sU0FBL0I7QUFDQXEwQywyQkFBeUIsb0RBQXlCSyxnQkFBekIsQ0FBekI7QUFDQUMsc0JBQW9CcGpELEtBQXBCO0FBQ0Fvd0MsZ0JBQWMsSUFBZDtBQUNBLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVNpVCx3QkFBVCxDQUNFajFCLFdBREYsRUFFRS9tQixRQUZGLEVBR0U7QUFDQSxNQUFJbk8sSUFBSixFQUFhO0FBQ1gsWUFBUWsxQixZQUFZdHdCLEdBQXBCO0FBQ0UsV0FBS3hCLHVCQUFMO0FBQ0Usa0VBQ0U4eEIsWUFBWTNmLFNBQVosQ0FBc0JtWixhQUR4QixFQUVFdmdCLFFBRkY7QUFJQTtBQUNGLFdBQUs3Syw0QkFBTDtBQUNFLHlEQUNFNHhCLFlBQVl2d0IsSUFEZCxFQUVFdXdCLFlBQVlwSSxhQUZkLEVBR0VvSSxZQUFZM2YsU0FIZCxFQUlFcEgsUUFKRjtBQU1BO0FBZEo7QUFnQkQ7O0FBRUQsTUFBTWk4QyxnQkFBZ0IseURBQXRCO0FBQ0FBLGdCQUFjNzBDLFNBQWQsR0FBMEJwSCxRQUExQjtBQUNBaThDLGdCQUFjN2lELE1BQWQsR0FBdUIydEIsV0FBdkI7QUFDQWsxQixnQkFBY3p4QyxTQUFkLEdBQTBCMVEsNkJBQTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJaXRCLFlBQVk5ZCxVQUFaLEtBQTJCLElBQS9CLEVBQXFDO0FBQ25DOGQsZ0JBQVk5ZCxVQUFaLENBQXVCUSxVQUF2QixHQUFvQ3d5QyxhQUFwQztBQUNBbDFCLGdCQUFZOWQsVUFBWixHQUF5Qmd6QyxhQUF6QjtBQUNELEdBSEQsTUFHTztBQUNMbDFCLGdCQUFZL2QsV0FBWixHQUEwQitkLFlBQVk5ZCxVQUFaLEdBQXlCZ3pDLGFBQW5EO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyx5QkFBVCxDQUFtQ24xQixXQUFuQyxFQUF1RHB1QixLQUF2RCxFQUFxRTtBQUNuRUEsUUFBTTZSLFNBQU4sSUFBbUI3USw4QkFBbkI7QUFDQSxNQUFJOUgsSUFBSixFQUFhO0FBQ1gsWUFBUWsxQixZQUFZdHdCLEdBQXBCO0FBQ0UsV0FBS3hCLHVCQUFMO0FBQWU7QUFDYixjQUFNa25ELGtCQUFrQnAxQixZQUFZM2YsU0FBWixDQUFzQm1aLGFBQTlDO0FBQ0Esa0JBQVE1bkIsTUFBTWxDLEdBQWQ7QUFDRSxpQkFBS3RCLDRCQUFMO0FBQ0Usa0JBQU1xQixPQUFPbUMsTUFBTW5DLElBQW5CO0FBQ0Esa0JBQU02USxRQUFRMU8sTUFBTTRsQixZQUFwQjtBQUNBLCtFQUFzQzQ5QixlQUF0QyxFQUF1RDNsRCxJQUF2RCxFQUE2RDZRLEtBQTdEO0FBQ0E7QUFDRixpQkFBS2pTLHVCQUFMO0FBQ0Usa0JBQU1nNUIsT0FBT3oxQixNQUFNNGxCLFlBQW5CO0FBQ0EsbUZBQTBDNDlCLGVBQTFDLEVBQTJEL3RCLElBQTNEO0FBQ0E7QUFDRixpQkFBS3o0QixnQ0FBTDtBQUNFLHVGQUE4Q3dtRCxlQUE5QztBQUNBO0FBWko7QUFjQTtBQUNEO0FBQ0QsV0FBS2huRCw0QkFBTDtBQUFvQjtBQUNsQixjQUFNaW5ELGFBQWFyMUIsWUFBWXZ3QixJQUEvQjtBQUNBLGNBQU02bEQsY0FBY3QxQixZQUFZcEksYUFBaEM7QUFDQSxjQUFNaTlCLGlCQUFpQjcwQixZQUFZM2YsU0FBbkM7QUFDQSxrQkFBUXpPLE1BQU1sQyxHQUFkO0FBQ0UsaUJBQUt0Qiw0QkFBTDtBQUNFLGtCQUFNcUIsUUFBT21DLE1BQU1uQyxJQUFuQjtBQUNBLGtCQUFNNlEsU0FBUTFPLE1BQU00bEIsWUFBcEI7QUFDQSxzRUFDRTY5QixVQURGLEVBRUVDLFdBRkYsRUFHRVQsY0FIRixFQUlFcGxELEtBSkYsRUFLRTZRLE1BTEY7QUFPQTtBQUNGLGlCQUFLalMsdUJBQUw7QUFDRSxrQkFBTWc1QixRQUFPejFCLE1BQU00bEIsWUFBbkI7QUFDQSwwRUFDRTY5QixVQURGLEVBRUVDLFdBRkYsRUFHRVQsY0FIRixFQUlFeHRCLEtBSkY7QUFNQTtBQUNGLGlCQUFLejRCLGdDQUFMO0FBQ0UsOEVBQ0V5bUQsVUFERixFQUVFQyxXQUZGLEVBR0VULGNBSEY7QUFLQTtBQTNCSjtBQTZCQTtBQUNEO0FBQ0Q7QUFDRTtBQXZESjtBQXlERDtBQUNGOztBQUVELFNBQVNVLFVBQVQsQ0FBb0IzakQsS0FBcEIsRUFBMkI0akQsWUFBM0IsRUFBeUM7QUFDdkMsVUFBUTVqRCxNQUFNbEMsR0FBZDtBQUNFLFNBQUt0Qiw0QkFBTDtBQUFvQjtBQUNsQixZQUFNcUIsT0FBT21DLE1BQU1uQyxJQUFuQjtBQUNBLFlBQU02USxRQUFRMU8sTUFBTTRsQixZQUFwQjtBQUNBLFlBQU12ZSxXQUFXLDhDQUFtQnU4QyxZQUFuQixFQUFpQy9sRCxJQUFqQyxFQUF1QzZRLEtBQXZDLENBQWpCO0FBQ0EsWUFBSXJILGFBQWEsSUFBakIsRUFBdUI7QUFDckJySCxnQkFBTXlPLFNBQU4sR0FBbUJwSCxRQUFuQjtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNELGVBQU8sS0FBUDtBQUNEO0FBQ0QsU0FBSzVLLHVCQUFMO0FBQWU7QUFDYixZQUFNZzVCLE9BQU96MUIsTUFBTTRsQixZQUFuQjtBQUNBLFlBQU1pK0IsZUFBZSxrREFBdUJELFlBQXZCLEVBQXFDbnVCLElBQXJDLENBQXJCO0FBQ0EsWUFBSW91QixpQkFBaUIsSUFBckIsRUFBMkI7QUFDekI3akQsZ0JBQU15TyxTQUFOLEdBQW1CbzFDLFlBQW5CO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0QsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFLN21ELGdDQUFMO0FBQXdCO0FBQ3RCLFlBQUlsQiwrQ0FBSixFQUFrQztBQUNoQyxjQUFNcW5ELG1CQUFtQixzREFBMkJTLFlBQTNCLENBQXpCO0FBQ0EsY0FBSVQscUJBQXFCLElBQXpCLEVBQStCO0FBQzdCO0FBQ0FuakQsa0JBQU1sQyxHQUFOLEdBQVlULDBDQUFaO0FBQ0EyQyxrQkFBTXlPLFNBQU4sR0FBbUIwMEMsZ0JBQW5CO0FBQ0EsbUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxlQUFPLEtBQVA7QUFDRDtBQUNEO0FBQ0UsYUFBTyxLQUFQO0FBakNKO0FBbUNEOztBQUVELFNBQVNXLGdDQUFULENBQTBDOWpELEtBQTFDLEVBQThEO0FBQzVELE1BQUksQ0FBQ293QyxXQUFMLEVBQWtCO0FBQ2hCO0FBQ0Q7QUFDRCxNQUFJd1QsZUFBZWQsc0JBQW5CO0FBQ0EsTUFBSSxDQUFDYyxZQUFMLEVBQW1CO0FBQ2pCO0FBQ0FMLDhCQUEyQlYsb0JBQTNCLEVBQXVEN2lELEtBQXZEO0FBQ0Fvd0Msa0JBQWMsS0FBZDtBQUNBeVMsMkJBQXVCN2lELEtBQXZCO0FBQ0E7QUFDRDtBQUNELE1BQU0rakQseUJBQXlCSCxZQUEvQjtBQUNBLE1BQUksQ0FBQ0QsV0FBVzNqRCxLQUFYLEVBQWtCNGpELFlBQWxCLENBQUwsRUFBc0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0FBLG1CQUFlLG9EQUF5Qkcsc0JBQXpCLENBQWY7QUFDQSxRQUFJLENBQUNILFlBQUQsSUFBaUIsQ0FBQ0QsV0FBVzNqRCxLQUFYLEVBQWtCNGpELFlBQWxCLENBQXRCLEVBQXVEO0FBQ3JEO0FBQ0FMLGdDQUEyQlYsb0JBQTNCLEVBQXVEN2lELEtBQXZEO0FBQ0Fvd0Msb0JBQWMsS0FBZDtBQUNBeVMsNkJBQXVCN2lELEtBQXZCO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0FxakQsNkJBQ0dSLG9CQURILEVBRUVrQixzQkFGRjtBQUlEO0FBQ0RsQix5QkFBdUI3aUQsS0FBdkI7QUFDQThpRCwyQkFBeUIsbURBQXlCYyxZQUF6QixDQUF6QjtBQUNEOztBQUVELFNBQVNJLDRCQUFULENBQ0Voa0QsS0FERixFQUVFaWtELHFCQUZGLEVBR0VDLFdBSEYsRUFJVztBQUNULE1BQUksQ0FBQ2xCLHVDQUFMLEVBQXdCO0FBQ3RCLDZCQUNFLEtBREYsRUFFRSxpRUFDRSxzRUFISjtBQUtEOztBQUVELE1BQU0zN0MsV0FBcUJySCxNQUFNeU8sU0FBakM7QUFDQSxNQUFNMDFDLGdCQUFnQiwyQ0FDcEI5OEMsUUFEb0IsRUFFcEJySCxNQUFNbkMsSUFGYyxFQUdwQm1DLE1BQU1nbUIsYUFIYyxFQUlwQmkrQixxQkFKb0IsRUFLcEJDLFdBTG9CLEVBTXBCbGtELEtBTm9CLENBQXRCO0FBUUE7QUFDQUEsUUFBTW9SLFdBQU4sR0FBcUIreUMsYUFBckI7QUFDQTtBQUNBO0FBQ0EsTUFBSUEsa0JBQWtCLElBQXRCLEVBQTRCO0FBQzFCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsZ0NBQVQsQ0FBMENwa0QsS0FBMUMsRUFBaUU7QUFDL0QsTUFBSSxDQUFDZ2pELHVDQUFMLEVBQXdCO0FBQ3RCLDZCQUNFLEtBREYsRUFFRSxxRUFDRSxzRUFISjtBQUtEOztBQUVELE1BQU1hLGVBQTZCN2pELE1BQU15TyxTQUF6QztBQUNBLE1BQU00MUMsY0FBc0Jya0QsTUFBTWdtQixhQUFsQztBQUNBLE1BQU11VSxlQUFlLCtDQUFvQnNwQixZQUFwQixFQUFrQ1EsV0FBbEMsRUFBK0Nya0QsS0FBL0MsQ0FBckI7QUFDQSxNQUFJOUcsSUFBSixFQUFhO0FBQ1gsUUFBSXFoQyxZQUFKLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDQSxVQUFNbk0sY0FBY3kwQixvQkFBcEI7QUFDQSxVQUFJejBCLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixnQkFBUUEsWUFBWXR3QixHQUFwQjtBQUNFLGVBQUt4Qix1QkFBTDtBQUFlO0FBQ2Isa0JBQU1rbkQsa0JBQWtCcDFCLFlBQVkzZixTQUFaLENBQXNCbVosYUFBOUM7QUFDQSxrRkFDRTQ3QixlQURGLEVBRUVLLFlBRkYsRUFHRVEsV0FIRjtBQUtBO0FBQ0Q7QUFDRCxlQUFLN25ELDRCQUFMO0FBQW9CO0FBQ2xCLGtCQUFNaW5ELGFBQWFyMUIsWUFBWXZ3QixJQUEvQjtBQUNBLGtCQUFNNmxELGNBQWN0MUIsWUFBWXBJLGFBQWhDO0FBQ0Esa0JBQU1pOUIsaUJBQWlCNzBCLFlBQVkzZixTQUFuQztBQUNBLHlFQUNFZzFDLFVBREYsRUFFRUMsV0FGRixFQUdFVCxjQUhGLEVBSUVZLFlBSkYsRUFLRVEsV0FMRjtBQU9BO0FBQ0Q7QUF0Qkg7QUF3QkQ7QUFDRjtBQUNGO0FBQ0QsU0FBTzlwQixZQUFQO0FBQ0Q7O0FBRUQsU0FBUytwQixrQ0FBVCxDQUE0Q3RrRCxLQUE1QyxFQUFnRTtBQUM5RCxNQUFJLENBQUNnakQsdUNBQUwsRUFBd0I7QUFDdEIsNkJBQ0UsS0FERixFQUVFLHVFQUNFLHNFQUhKO0FBS0Q7QUFDRCxNQUFJRyxtQkFBbUJuakQsTUFBTXlPLFNBQTdCO0FBQ0EsMkJBQ0UwMEMsZ0JBREYsRUFFRSxvREFDRSxzRUFISjtBQUtBTCwyQkFBeUIsMEVBQ3ZCSyxnQkFEdUIsQ0FBekI7QUFHRDs7QUFFRCxTQUFTQyxtQkFBVCxDQUE2QnBqRCxLQUE3QixFQUFpRDtBQUMvQyxNQUFJeVUsU0FBU3pVLE1BQU1TLE1BQW5CO0FBQ0EsU0FDRWdVLFdBQVcsSUFBWCxJQUNBQSxPQUFPM1csR0FBUCxLQUFldEIsNEJBRGYsSUFFQWlZLE9BQU8zVyxHQUFQLEtBQWV4Qix1QkFGZixJQUdBbVksT0FBTzNXLEdBQVAsS0FBZVQsMENBSmpCLEVBS0U7QUFDQW9YLGFBQVNBLE9BQU9oVSxNQUFoQjtBQUNEO0FBQ0RvaUQseUJBQXVCcHVDLE1BQXZCO0FBQ0Q7O0FBRUQsU0FBUzh2QyxpQkFBVCxDQUEyQnZrRCxLQUEzQixFQUFrRDtBQUNoRCxNQUFJLENBQUNnakQsdUNBQUwsRUFBd0I7QUFDdEIsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFJaGpELFVBQVU2aUQsb0JBQWQsRUFBb0M7QUFDbEM7QUFDQTtBQUNBLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSSxDQUFDelMsV0FBTCxFQUFrQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQWdULHdCQUFvQnBqRCxLQUFwQjtBQUNBb3dDLGtCQUFjLElBQWQ7QUFDQSxXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFNdnlDLE9BQU9tQyxNQUFNbkMsSUFBbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQ0VtQyxNQUFNbEMsR0FBTixLQUFjdEIsNEJBQWQsSUFDQ3FCLFNBQVMsTUFBVCxJQUNDQSxTQUFTLE1BRFYsSUFFQyxDQUFDLGdEQUFxQkEsSUFBckIsRUFBMkJtQyxNQUFNZ21CLGFBQWpDLENBSkwsRUFLRTtBQUNBLFFBQUk0OUIsZUFBZWQsc0JBQW5CO0FBQ0EsV0FBT2MsWUFBUCxFQUFxQjtBQUNuQlAsK0JBQXlCcmpELEtBQXpCLEVBQWdDNGpELFlBQWhDO0FBQ0FBLHFCQUFlLG9EQUF5QkEsWUFBekIsQ0FBZjtBQUNEO0FBQ0Y7O0FBRURSLHNCQUFvQnBqRCxLQUFwQjtBQUNBOGlELDJCQUF5QkQsdUJBQ3JCLG9EQUF5QjdpRCxNQUFNeU8sU0FBL0IsQ0FEcUIsR0FFckIsSUFGSjtBQUdBLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVMrMUMsbUJBQVQsR0FBcUM7QUFDbkMsTUFBSSxDQUFDeEIsdUNBQUwsRUFBd0I7QUFDdEI7QUFDRDs7QUFFREgseUJBQXVCLElBQXZCO0FBQ0FDLDJCQUF5QixJQUF6QjtBQUNBMVMsZ0JBQWMsS0FBZDtBQUNEOztRQUdDMlMsbUIsR0FBQUEsbUI7UUFDQUcsbUQsR0FBQUEsbUQ7UUFDQXNCLG1CLEdBQUFBLG1CO1FBQ0FWLGdDLEdBQUFBLGdDO1FBQ0FFLDRCLEdBQUFBLDRCO1FBQ0FJLGdDLEdBQUFBLGdDO1FBQ0FFLGtDLEdBQUFBLGtDO1FBQ0FDLGlCLEdBQUFBLGlCOzs7Ozs7Ozs7Ozs7UUM1WmNFLG1CLEdBQUFBLG1COztBQWxCaEI7O0FBWEE7Ozs7Ozs7OztBQTZCTyxTQUFTQSxtQkFBVCxDQUNMbm5DLEtBREssRUFFTG5kLE1BRkssRUFHYTtBQUNsQjtBQUNBO0FBQ0EsU0FBTztBQUNMbWQsZ0JBREs7QUFFTG5kLGtCQUZLO0FBR0xoRixXQUFPLG9EQUE0QmdGLE1BQTVCO0FBSEYsR0FBUDtBQUtELEM7Ozs7Ozs7Ozs7Ozs7UUM2RWV1a0QsUSxHQUFBQSxRO1FBbVFBdDVCLHdCLEdBQUFBLHdCOztBQS9WaEI7O0FBQ0E7O0FBS0E7O0FBZUE7O0FBS0E7O0FBTUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUF1QkE7O0FBS0E7O0FBVUE7Ozs7QUFFQSxJQUFJdTVCLDRDQUErRCxJQUFuRSxDLENBOUdBOzs7Ozs7Ozs7QUErR0EsSUFBSXpyRCxJQUFKLEVBQWE7QUFDWHlyRCw4Q0FBNEMsSUFBSXJpQyxHQUFKLEVBQTVDO0FBQ0Q7O0FBRUQsSUFBTXNpQyxrQkFBa0IsT0FBT0MsT0FBUCxLQUFtQixVQUFuQixHQUFnQ0EsT0FBaEMsR0FBMEN2aUMsR0FBbEU7O0FBRU8sU0FBU29pQyxRQUFULENBQWtCSSxRQUFsQixFQUFtQzUwQixTQUFuQyxFQUFvRTtBQUN6RSxNQUFNL3ZCLFNBQVMrdkIsVUFBVS92QixNQUF6QjtBQUNBLE1BQUloRixRQUFRKzBCLFVBQVUvMEIsS0FBdEI7QUFDQSxNQUFJQSxVQUFVLElBQVYsSUFBa0JnRixXQUFXLElBQWpDLEVBQXVDO0FBQ3JDaEYsWUFBUSxvREFBNEJnRixNQUE1QixDQUFSO0FBQ0Q7O0FBRUQsTUFBTTRrRCxnQkFBK0I7QUFDbkN6c0MsbUJBQWVuWSxXQUFXLElBQVgsR0FBa0IsZ0NBQWlCQSxPQUFPdEMsSUFBeEIsQ0FBbEIsR0FBa0QsSUFEOUI7QUFFbkNtbkQsb0JBQWdCN3BELFVBQVUsSUFBVixHQUFpQkEsS0FBakIsR0FBeUIsRUFGTjtBQUduQ3RCLFdBQU9xMkIsVUFBVTVTLEtBSGtCO0FBSW5DMm5DLG1CQUFlLElBSm9CO0FBS25DQyx1QkFBbUIsSUFMZ0I7QUFNbkNDLHdCQUFvQixLQU5lO0FBT25DQyxlQUFXO0FBUHdCLEdBQXJDOztBQVVBLE1BQUlOLGFBQWEsSUFBYixJQUFxQkEsU0FBU2huRCxHQUFULEtBQWlCMUIsNkJBQTFDLEVBQTBEO0FBQ3hEMm9ELGtCQUFjRSxhQUFkLEdBQThCSCxTQUFTcjJDLFNBQXZDO0FBQ0FzMkMsa0JBQWNHLGlCQUFkLEdBQWtDLGdDQUFpQkosU0FBU2puRCxJQUExQixDQUFsQztBQUNBa25ELGtCQUFjSSxrQkFBZCxHQUFtQyxJQUFuQztBQUNBSixrQkFBY0ssU0FBZCxHQUEwQixJQUExQjtBQUNEOztBQUVELE1BQUk7QUFDRixpREFBaUJMLGFBQWpCO0FBQ0QsR0FGRCxDQUVFLE9BQU9wckQsQ0FBUCxFQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTByRCxlQUFXLFlBQU07QUFDZixZQUFNMXJELENBQU47QUFDRCxLQUZEO0FBR0Q7QUFDRjs7QUFFRCxJQUFNMnJELG9DQUFvQyxTQUFwQ0EsaUNBQW9DLENBQVM1a0QsT0FBVCxFQUFrQjJHLFFBQWxCLEVBQTRCO0FBQ3BFLDRDQUFnQjNHLE9BQWhCLEVBQXlCLHNCQUF6QjtBQUNBMkcsV0FBU3FILEtBQVQsR0FBaUJoTyxRQUFRc2xCLGFBQXpCO0FBQ0EzZSxXQUFTcXpCLEtBQVQsR0FBaUJoNkIsUUFBUTJRLGFBQXpCO0FBQ0FoSyxXQUFTaytDLG9CQUFUO0FBQ0E7QUFDRCxDQU5EOztBQVFBO0FBQ0EsU0FBU0MsOEJBQVQsQ0FBd0M5a0QsT0FBeEMsRUFBaUQyRyxRQUFqRCxFQUEyRDtBQUN6RCxNQUFJbk8sSUFBSixFQUFhO0FBQ1gsZ0RBQ0UsSUFERixFQUVFb3NELGlDQUZGLEVBR0UsSUFIRixFQUlFNWtELE9BSkYsRUFLRTJHLFFBTEY7QUFPQSxRQUFJLHNDQUFKLEVBQXNCO0FBQ3BCLFVBQU1vK0MsZUFBZSx3Q0FBckI7QUFDQSx3REFBd0Iva0QsT0FBeEIsRUFBaUMra0QsWUFBakM7QUFDRDtBQUNGLEdBWkQsTUFZTztBQUNMLFFBQUk7QUFDRkgsd0NBQWtDNWtELE9BQWxDLEVBQTJDMkcsUUFBM0M7QUFDRCxLQUZELENBRUUsT0FBT28rQyxZQUFQLEVBQXFCO0FBQ3JCLHdEQUF3Qi9rRCxPQUF4QixFQUFpQytrRCxZQUFqQztBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTQyxlQUFULENBQXlCaGxELE9BQXpCLEVBQXlDO0FBQ3ZDLE1BQU1xbEIsTUFBTXJsQixRQUFRcWxCLEdBQXBCO0FBQ0EsTUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLFFBQUksT0FBT0EsR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQzdCLFVBQUk3c0IsSUFBSixFQUFhO0FBQ1gsb0RBQXNCLElBQXRCLEVBQTRCNnNCLEdBQTVCLEVBQWlDLElBQWpDLEVBQXVDLElBQXZDO0FBQ0EsWUFBSSxzQ0FBSixFQUFzQjtBQUNwQixjQUFNNC9CLFdBQVcsd0NBQWpCO0FBQ0EsNERBQXdCamxELE9BQXhCLEVBQWlDaWxELFFBQWpDO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTCxZQUFJO0FBQ0Y1L0IsY0FBSSxJQUFKO0FBQ0QsU0FGRCxDQUVFLE9BQU80L0IsUUFBUCxFQUFpQjtBQUNqQiw0REFBd0JqbEQsT0FBeEIsRUFBaUNpbEQsUUFBakM7QUFDRDtBQUNGO0FBQ0YsS0FkRCxNQWNPO0FBQ0w1L0IsVUFBSXJsQixPQUFKLEdBQWMsSUFBZDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTa2xELGlCQUFULENBQTJCbGxELE9BQTNCLEVBQW9DNCtDLE9BQXBDLEVBQTZDO0FBQzNDLE1BQUlwbUQsSUFBSixFQUFhO0FBQ1gsZ0RBQXNCLElBQXRCLEVBQTRCb21ELE9BQTVCLEVBQXFDLElBQXJDO0FBQ0EsUUFBSSxzQ0FBSixFQUFzQjtBQUNwQixVQUFNemxELFFBQVEsd0NBQWQ7QUFDQSx3REFBd0I2RyxPQUF4QixFQUFpQzdHLEtBQWpDO0FBQ0Q7QUFDRixHQU5ELE1BTU87QUFDTCxRQUFJO0FBQ0Z5bEQ7QUFDRCxLQUZELENBRUUsT0FBT3psRCxLQUFQLEVBQWM7QUFDZCx3REFBd0I2RyxPQUF4QixFQUFpQzdHLEtBQWpDO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVNnc0QsOEJBQVQsQ0FDRW5sRCxPQURGLEVBRUU4UixZQUZGLEVBR1E7QUFDTixVQUFRQSxhQUFhMVUsR0FBckI7QUFDRSxTQUFLM0IsZ0NBQUw7QUFDQSxTQUFLVyx5QkFBTDtBQUNBLFNBQUtJLGtDQUFMO0FBQTBCO0FBQ3hCNG9ELDZCQUFxQnBELG9DQUFyQixFQUFzQzFDLDZCQUF0QyxFQUFvRHh0QyxZQUFwRDtBQUNBO0FBQ0Q7QUFDRCxTQUFLcFcsNkJBQUw7QUFBcUI7QUFDbkIsWUFBSW9XLGFBQWFYLFNBQWIsR0FBeUJyUSw2QkFBN0IsRUFBdUM7QUFDckMsY0FBSWQsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixnQkFBTWk1QixZQUFZajVCLFFBQVFzbEIsYUFBMUI7QUFDQSxnQkFBTXZVLFlBQVkvUSxRQUFRMlEsYUFBMUI7QUFDQSxzREFBZ0JtQixZQUFoQixFQUE4Qix5QkFBOUI7QUFDQSxnQkFBTW5MLFdBQVdtTCxhQUFhL0QsU0FBOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBSXZWLElBQUosRUFBYTtBQUNYLGtCQUNFc1osYUFBYTNVLElBQWIsS0FBc0IyVSxhQUFhcVQsV0FBbkMsSUFDQSxDQUFDa1QsaURBRkgsRUFHRTtBQUNBLHVDQUNFMXhCLFNBQVNxSCxLQUFULEtBQW1COEQsYUFBYXdULGFBRGxDLEVBRUUsc0RBQ0UsMkJBREYsR0FFRSw2REFGRixHQUdFLDhDQUhGLEdBSUUsdUJBTkosRUFPRSxnQ0FBaUJ4VCxhQUFhM1UsSUFBOUIsS0FBdUMsVUFQekM7QUFTQSx1Q0FDRXdKLFNBQVNxekIsS0FBVCxLQUFtQmxvQixhQUFhbkIsYUFEbEMsRUFFRSxzREFDRSwyQkFERixHQUVFLDZEQUZGLEdBR0UsOENBSEYsR0FJRSx1QkFOSixFQU9FLGdDQUFpQm1CLGFBQWEzVSxJQUE5QixLQUF1QyxVQVB6QztBQVNEO0FBQ0Y7QUFDRCxnQkFBTWtvRCxXQUFXMStDLFNBQVN3eUMsdUJBQVQsQ0FDZnJuQyxhQUFhcVQsV0FBYixLQUE2QnJULGFBQWEzVSxJQUExQyxHQUNJODdCLFNBREosR0FFSSxrREFBb0JubkIsYUFBYTNVLElBQWpDLEVBQXVDODdCLFNBQXZDLENBSFcsRUFJZmxvQixTQUplLENBQWpCO0FBTUEsZ0JBQUl2WSxJQUFKLEVBQWE7QUFDWCxrQkFBTThzRCxhQUFlckIseUNBQXJCO0FBR0Esa0JBQUlvQixhQUFhM3NELFNBQWIsSUFBMEIsQ0FBQzRzRCxXQUFXeGlDLEdBQVgsQ0FBZWhSLGFBQWEzVSxJQUE1QixDQUEvQixFQUFrRTtBQUNoRW1vRCwyQkFBV3ZpQyxHQUFYLENBQWVqUixhQUFhM1UsSUFBNUI7QUFDQSxtREFDRSxLQURGLEVBRUUsOERBQ0UsZ0RBSEosRUFJRSxnQ0FBaUIyVSxhQUFhM1UsSUFBOUIsQ0FKRjtBQU1EO0FBQ0Y7QUFDRHdKLHFCQUFTNCtDLG1DQUFULEdBQStDRixRQUEvQztBQUNBO0FBQ0Q7QUFDRjtBQUNEO0FBQ0Q7QUFDRCxTQUFLenBELHVCQUFMO0FBQ0EsU0FBS0UsNEJBQUw7QUFDQSxTQUFLQyx1QkFBTDtBQUNBLFNBQUtGLHlCQUFMO0FBQ0EsU0FBS2EsdUNBQUw7QUFDRTtBQUNBO0FBQ0Y7QUFBUztBQUNQLGlDQUNFLEtBREYsRUFFRSx1RUFDRSx3REFISjtBQUtEO0FBakZIO0FBbUZEOztBQUVELFNBQVMwb0Qsb0JBQVQsQ0FDRUksVUFERixFQUVFQyxRQUZGLEVBR0UzekMsWUFIRixFQUlFO0FBQ0EsTUFBTXBCLGNBQW9Eb0IsYUFBYXBCLFdBQXZFO0FBQ0EsTUFBSWQsYUFBYWMsZ0JBQWdCLElBQWhCLEdBQXVCQSxZQUFZZCxVQUFuQyxHQUFnRCxJQUFqRTtBQUNBLE1BQUlBLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkIsUUFBTUQsY0FBY0MsV0FBV08sSUFBL0I7QUFDQSxRQUFJOEIsU0FBU3RDLFdBQWI7QUFDQSxPQUFHO0FBQ0QsVUFBSSxDQUFDc0MsT0FBTzdVLEdBQVAsR0FBYW9vRCxVQUFkLE1BQThCbEcsNkJBQWxDLEVBQWdEO0FBQzlDO0FBQ0EsWUFBTVYsVUFBVTNzQyxPQUFPMnNDLE9BQXZCO0FBQ0Ezc0MsZUFBTzJzQyxPQUFQLEdBQWlCbG1ELFNBQWpCO0FBQ0EsWUFBSWttRCxZQUFZbG1ELFNBQWhCLEVBQTJCO0FBQ3pCa21EO0FBQ0Q7QUFDRjtBQUNELFVBQUksQ0FBQzNzQyxPQUFPN1UsR0FBUCxHQUFhcW9ELFFBQWQsTUFBNEJuRyw2QkFBaEMsRUFBOEM7QUFDNUM7QUFDQSxZQUFNWCxTQUFTMXNDLE9BQU8wc0MsTUFBdEI7QUFDQTFzQyxlQUFPMnNDLE9BQVAsR0FBaUJELFFBQWpCOztBQUVBLFlBQUlubUQsSUFBSixFQUFhO0FBQ1gsY0FBTW9tRCxXQUFVM3NDLE9BQU8yc0MsT0FBdkI7QUFDQSxjQUFJQSxhQUFZbG1ELFNBQVosSUFBeUIsT0FBT2ttRCxRQUFQLEtBQW1CLFVBQWhELEVBQTREO0FBQzFELGdCQUFJOEcsaUJBQUo7QUFDQSxnQkFBSTlHLGFBQVksSUFBaEIsRUFBc0I7QUFDcEI4Ryx5QkFDRSwrREFDQSxvQ0FGRjtBQUdELGFBSkQsTUFJTyxJQUFJLE9BQU85RyxTQUFRejFCLElBQWYsS0FBd0IsVUFBNUIsRUFBd0M7QUFDN0N1OEIseUJBQ0UsbUZBQ0Esc0RBREEsR0FFQSw4Q0FGQSxHQUdBLDRDQUhBLEdBSUEsMkJBSkEsR0FLQSxPQUxBLEdBTUEscUJBTkEsR0FPQSw4QkFQQSxHQVFBLHNCQVJBLEdBU0EsZ0ZBVEEsR0FVQSxnREFYRjtBQVlELGFBYk0sTUFhQTtBQUNMQSx5QkFBVyxvQkFBb0I5RyxRQUEvQjtBQUNEO0FBQ0QsK0NBQ0UsS0FERixFQUVFLHFFQUNFLGlDQUhKLEVBSUU4RyxRQUpGLEVBS0Usb0RBQTRCNXpDLFlBQTVCLENBTEY7QUFPRDtBQUNGO0FBQ0Y7QUFDREcsZUFBU0EsT0FBTzlCLElBQWhCO0FBQ0QsS0FqREQsUUFpRFM4QixXQUFXdEMsV0FqRHBCO0FBa0REO0FBQ0Y7O0FBRU0sU0FBUythLHdCQUFULENBQWtDNVksWUFBbEMsRUFBNkQ7QUFDbEVzekMsdUJBQXFCNUYsbUNBQXJCLEVBQXFDRiw2QkFBckMsRUFBbUR4dEMsWUFBbkQ7QUFDQXN6Qyx1QkFBcUI5Riw2QkFBckIsRUFBbUNHLGlDQUFuQyxFQUFpRDN0QyxZQUFqRDtBQUNEOztBQUVELFNBQVM2ekMsZ0JBQVQsQ0FDRTM3QixZQURGLEVBRUVocUIsT0FGRixFQUdFOFIsWUFIRixFQUlFbVksdUJBSkYsRUFLUTtBQUNOLFVBQVFuWSxhQUFhMVUsR0FBckI7QUFDRSxTQUFLM0IsZ0NBQUw7QUFDQSxTQUFLVyx5QkFBTDtBQUNBLFNBQUtJLGtDQUFMO0FBQTBCO0FBQ3hCNG9ELDZCQUFxQmxELGtDQUFyQixFQUFvQ3JDLGdDQUFwQyxFQUFpRC90QyxZQUFqRDtBQUNBO0FBQ0Q7QUFDRCxTQUFLcFcsNkJBQUw7QUFBcUI7QUFDbkIsWUFBTWlMLFdBQVdtTCxhQUFhL0QsU0FBOUI7QUFDQSxZQUFJK0QsYUFBYVgsU0FBYixHQUF5QjVRLDJCQUE3QixFQUFxQztBQUNuQyxjQUFJUCxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLHNEQUFnQjhSLFlBQWhCLEVBQThCLG1CQUE5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFJdFosSUFBSixFQUFhO0FBQ1gsa0JBQ0VzWixhQUFhM1UsSUFBYixLQUFzQjJVLGFBQWFxVCxXQUFuQyxJQUNBLENBQUNrVCxpREFGSCxFQUdFO0FBQ0EsdUNBQ0UxeEIsU0FBU3FILEtBQVQsS0FBbUI4RCxhQUFhd1QsYUFEbEMsRUFFRSxzREFDRSxxQkFERixHQUVFLDZEQUZGLEdBR0UsOENBSEYsR0FJRSx1QkFOSixFQU9FLGdDQUFpQnhULGFBQWEzVSxJQUE5QixLQUF1QyxVQVB6QztBQVNBLHVDQUNFd0osU0FBU3F6QixLQUFULEtBQW1CbG9CLGFBQWFuQixhQURsQyxFQUVFLHNEQUNFLHFCQURGLEdBRUUsNkRBRkYsR0FHRSw4Q0FIRixHQUlFLHVCQU5KLEVBT0UsZ0NBQWlCbUIsYUFBYTNVLElBQTlCLEtBQXVDLFVBUHpDO0FBU0Q7QUFDRjtBQUNEd0oscUJBQVN5ekMsaUJBQVQ7QUFDQTtBQUNELFdBaENELE1BZ0NPO0FBQ0wsZ0JBQU1uaEIsWUFDSm5uQixhQUFhcVQsV0FBYixLQUE2QnJULGFBQWEzVSxJQUExQyxHQUNJNkMsUUFBUXNsQixhQURaLEdBRUksa0RBQW9CeFQsYUFBYTNVLElBQWpDLEVBQXVDNkMsUUFBUXNsQixhQUEvQyxDQUhOO0FBSUEsZ0JBQU12VSxZQUFZL1EsUUFBUTJRLGFBQTFCO0FBQ0Esc0RBQWdCbUIsWUFBaEIsRUFBOEIsb0JBQTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQUl0WixJQUFKLEVBQWE7QUFDWCxrQkFDRXNaLGFBQWEzVSxJQUFiLEtBQXNCMlUsYUFBYXFULFdBQW5DLElBQ0EsQ0FBQ2tULGlEQUZILEVBR0U7QUFDQSx1Q0FDRTF4QixTQUFTcUgsS0FBVCxLQUFtQjhELGFBQWF3VCxhQURsQyxFQUVFLHNEQUNFLHNCQURGLEdBRUUsNkRBRkYsR0FHRSw4Q0FIRixHQUlFLHVCQU5KLEVBT0UsZ0NBQWlCeFQsYUFBYTNVLElBQTlCLEtBQXVDLFVBUHpDO0FBU0EsdUNBQ0V3SixTQUFTcXpCLEtBQVQsS0FBbUJsb0IsYUFBYW5CLGFBRGxDLEVBRUUsc0RBQ0Usc0JBREYsR0FFRSw2REFGRixHQUdFLDhDQUhGLEdBSUUsdUJBTkosRUFPRSxnQ0FBaUJtQixhQUFhM1UsSUFBOUIsS0FBdUMsVUFQekM7QUFTRDtBQUNGO0FBQ0R3SixxQkFBU3l5QyxrQkFBVCxDQUNFbmdCLFNBREYsRUFFRWxvQixTQUZGLEVBR0VwSyxTQUFTNCtDLG1DQUhYO0FBS0E7QUFDRDtBQUNGO0FBQ0QsWUFBTTcwQyxjQUFjb0IsYUFBYXBCLFdBQWpDO0FBQ0EsWUFBSUEsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCLGNBQUlsWSxJQUFKLEVBQWE7QUFDWCxnQkFDRXNaLGFBQWEzVSxJQUFiLEtBQXNCMlUsYUFBYXFULFdBQW5DLElBQ0EsQ0FBQ2tULGlEQUZILEVBR0U7QUFDQSxxQ0FDRTF4QixTQUFTcUgsS0FBVCxLQUFtQjhELGFBQWF3VCxhQURsQyxFQUVFLHNEQUNFLCtCQURGLEdBRUUsNkRBRkYsR0FHRSw4Q0FIRixHQUlFLHVCQU5KLEVBT0UsZ0NBQWlCeFQsYUFBYTNVLElBQTlCLEtBQXVDLFVBUHpDO0FBU0EscUNBQ0V3SixTQUFTcXpCLEtBQVQsS0FBbUJsb0IsYUFBYW5CLGFBRGxDLEVBRUUsc0RBQ0UsK0JBREYsR0FFRSw2REFGRixHQUdFLDhDQUhGLEdBSUUsdUJBTkosRUFPRSxnQ0FBaUJtQixhQUFhM1UsSUFBOUIsS0FBdUMsVUFQekM7QUFTRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsbURBQ0UyVSxZQURGLEVBRUVwQixXQUZGLEVBR0UvSixRQUhGLEVBSUVzakIsdUJBSkY7QUFNRDtBQUNEO0FBQ0Q7QUFDRCxTQUFLcnVCLHVCQUFMO0FBQWU7QUFDYixZQUFNOFUsZUFBY29CLGFBQWFwQixXQUFqQztBQUNBLFlBQUlBLGlCQUFnQixJQUFwQixFQUEwQjtBQUN4QixjQUFJL0osWUFBVyxJQUFmO0FBQ0EsY0FBSW1MLGFBQWFtQyxLQUFiLEtBQXVCLElBQTNCLEVBQWlDO0FBQy9CLG9CQUFRbkMsYUFBYW1DLEtBQWIsQ0FBbUI3VyxHQUEzQjtBQUNFLG1CQUFLdEIsNEJBQUw7QUFDRTZLLDRCQUFXLDZDQUFrQm1MLGFBQWFtQyxLQUFiLENBQW1CbEcsU0FBckMsQ0FBWDtBQUNBO0FBQ0YsbUJBQUtyUyw2QkFBTDtBQUNFaUwsNEJBQVdtTCxhQUFhbUMsS0FBYixDQUFtQmxHLFNBQTlCO0FBQ0E7QUFOSjtBQVFEO0FBQ0QsbURBQ0UrRCxZQURGLEVBRUVwQixZQUZGLEVBR0UvSixTQUhGLEVBSUVzakIsdUJBSkY7QUFNRDtBQUNEO0FBQ0Q7QUFDRCxTQUFLbnVCLDRCQUFMO0FBQW9CO0FBQ2xCLFlBQU02SyxhQUFxQm1MLGFBQWEvRCxTQUF4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUkvTixZQUFZLElBQVosSUFBb0I4UixhQUFhWCxTQUFiLEdBQXlCNVEsMkJBQWpELEVBQXlEO0FBQ3ZELGNBQU1wRCxPQUFPMlUsYUFBYTNVLElBQTFCO0FBQ0EsY0FBTTZRLFFBQVE4RCxhQUFhd1QsYUFBM0I7QUFDQSxpREFBWTNlLFVBQVosRUFBc0J4SixJQUF0QixFQUE0QjZRLEtBQTVCLEVBQW1DOEQsWUFBbkM7QUFDRDs7QUFFRDtBQUNEO0FBQ0QsU0FBSy9WLHVCQUFMO0FBQWU7QUFDYjtBQUNBO0FBQ0Q7QUFDRCxTQUFLRix5QkFBTDtBQUFpQjtBQUNmO0FBQ0E7QUFDRDtBQUNELFNBQUtRLHVCQUFMO0FBQWU7QUFDYixZQUFJcEIsc0NBQUosRUFBeUI7QUFDdkIsY0FBTThyQixXQUFXalYsYUFBYXdULGFBQWIsQ0FBMkJ5QixRQUE1Qzs7QUFFQSxjQUFJNXJCLHlDQUFKLEVBQTRCO0FBQzFCNHJCLHFCQUNFalYsYUFBYXdULGFBQWIsQ0FBMkJ3QixFQUQ3QixFQUVFOW1CLFlBQVksSUFBWixHQUFtQixPQUFuQixHQUE2QixRQUYvQixFQUdFOFIsYUFBYXlULGNBSGYsRUFJRXpULGFBQWE4VCxnQkFKZixFQUtFOVQsYUFBYTRULGVBTGYsRUFNRSx3Q0FORixFQU9Fc0UsYUFBYXlCLG9CQVBmO0FBU0QsV0FWRCxNQVVPO0FBQ0wxRSxxQkFDRWpWLGFBQWF3VCxhQUFiLENBQTJCd0IsRUFEN0IsRUFFRTltQixZQUFZLElBQVosR0FBbUIsT0FBbkIsR0FBNkIsUUFGL0IsRUFHRThSLGFBQWF5VCxjQUhmLEVBSUV6VCxhQUFhOFQsZ0JBSmYsRUFLRTlULGFBQWE0VCxlQUxmLEVBTUUsd0NBTkY7QUFRRDtBQUNGO0FBQ0Q7QUFDRDtBQUNELFNBQUtwcEIsZ0NBQUw7QUFDRTtBQUNGLFNBQUtJLHVDQUFMO0FBQ0U7QUFDRjtBQUFTO0FBQ1AsaUNBQ0UsS0FERixFQUVFLHVFQUNFLHdEQUhKO0FBS0Q7QUEvTUg7QUFpTkQ7O0FBRUQsU0FBU2twRCx1QkFBVCxDQUFpQzl6QyxZQUFqQyxFQUErQyt6QyxRQUEvQyxFQUF5RDtBQUN2RCxNQUFJQyxzQ0FBSixFQUFzQjtBQUNwQjtBQUVBLFFBQUlobUQsT0FBY2dTLFlBQWxCO0FBQ0EsV0FBTyxJQUFQLEVBQWE7QUFDWCxVQUFJaFMsS0FBSzFDLEdBQUwsS0FBYXRCLDRCQUFqQixFQUFnQztBQUM5QixZQUFNNkssV0FBVzdHLEtBQUtpTyxTQUF0QjtBQUNBLFlBQUk4M0MsUUFBSixFQUFjO0FBQ1osa0RBQWFsL0MsUUFBYjtBQUNELFNBRkQsTUFFTztBQUNMLG9EQUFlN0csS0FBS2lPLFNBQXBCLEVBQStCak8sS0FBS3dsQixhQUFwQztBQUNEO0FBQ0YsT0FQRCxNQU9PLElBQUl4bEIsS0FBSzFDLEdBQUwsS0FBYXJCLHVCQUFqQixFQUEyQjtBQUNoQyxZQUFNNEssYUFBVzdHLEtBQUtpTyxTQUF0QjtBQUNBLFlBQUk4M0MsUUFBSixFQUFjO0FBQ1osc0RBQWlCbC9DLFVBQWpCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsd0RBQW1CQSxVQUFuQixFQUE2QjdHLEtBQUt3bEIsYUFBbEM7QUFDRDtBQUNGLE9BUE0sTUFPQSxJQUNMeGxCLEtBQUsxQyxHQUFMLEtBQWFkLGdDQUFiLElBQ0F3RCxLQUFLNlEsYUFBTCxLQUF1QixJQUZsQixFQUdMO0FBQ0E7QUFFQSxZQUFNcXJCLHdCQUFnQ2w4QixLQUFLbVUsS0FBTixDQUFrQk8sT0FBdkQ7QUFDQXduQiw4QkFBc0JqOEIsTUFBdEIsR0FBK0JELElBQS9CO0FBQ0FBLGVBQU9rOEIscUJBQVA7QUFDQTtBQUNELE9BVk0sTUFVQSxJQUFJbDhCLEtBQUttVSxLQUFMLEtBQWUsSUFBbkIsRUFBeUI7QUFDOUJuVSxhQUFLbVUsS0FBTCxDQUFXbFUsTUFBWCxHQUFvQkQsSUFBcEI7QUFDQUEsZUFBT0EsS0FBS21VLEtBQVo7QUFDQTtBQUNEO0FBQ0QsVUFBSW5VLFNBQVNnUyxZQUFiLEVBQTJCO0FBQ3pCO0FBQ0Q7QUFDRCxhQUFPaFMsS0FBSzBVLE9BQUwsS0FBaUIsSUFBeEIsRUFBOEI7QUFDNUIsWUFBSTFVLEtBQUtDLE1BQUwsS0FBZ0IsSUFBaEIsSUFBd0JELEtBQUtDLE1BQUwsS0FBZ0IrUixZQUE1QyxFQUEwRDtBQUN4RDtBQUNEO0FBQ0RoUyxlQUFPQSxLQUFLQyxNQUFaO0FBQ0Q7QUFDREQsV0FBSzBVLE9BQUwsQ0FBYXpVLE1BQWIsR0FBc0JELEtBQUtDLE1BQTNCO0FBQ0FELGFBQU9BLEtBQUswVSxPQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVN1eEMsZUFBVCxDQUF5QmowQyxZQUF6QixFQUE4QztBQUM1QyxNQUFNdVQsTUFBTXZULGFBQWF1VCxHQUF6QjtBQUNBLE1BQUlBLFFBQVEsSUFBWixFQUFrQjtBQUNoQixRQUFNMWUsV0FBV21MLGFBQWEvRCxTQUE5QjtBQUNBLFFBQUlpNEMsc0JBQUo7QUFDQSxZQUFRbDBDLGFBQWExVSxHQUFyQjtBQUNFLFdBQUt0Qiw0QkFBTDtBQUNFa3FELHdCQUFnQiw2Q0FBa0JyL0MsUUFBbEIsQ0FBaEI7QUFDQTtBQUNGO0FBQ0VxL0Msd0JBQWdCci9DLFFBQWhCO0FBTEo7QUFPQSxRQUFJLE9BQU8wZSxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0JBLFVBQUkyZ0MsYUFBSjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUl4dEQsSUFBSixFQUFhO0FBQ1gsWUFBSSxDQUFDNnNCLElBQUkzZ0IsY0FBSixDQUFtQixTQUFuQixDQUFMLEVBQW9DO0FBQ2xDLDZDQUNFLEtBREYsRUFFRSw0Q0FDRSwwREFISixFQUlFLGdDQUFpQm9OLGFBQWEzVSxJQUE5QixDQUpGLEVBS0Usb0RBQTRCMlUsWUFBNUIsQ0FMRjtBQU9EO0FBQ0Y7O0FBRUR1VCxVQUFJcmxCLE9BQUosR0FBY2dtRCxhQUFkO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVNDLGVBQVQsQ0FBeUJqbUQsT0FBekIsRUFBeUM7QUFDdkMsTUFBTWttRCxhQUFhbG1ELFFBQVFxbEIsR0FBM0I7QUFDQSxNQUFJNmdDLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkIsUUFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ3BDQSxpQkFBVyxJQUFYO0FBQ0QsS0FGRCxNQUVPO0FBQ0xBLGlCQUFXbG1ELE9BQVgsR0FBcUIsSUFBckI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsU0FBU21tRCxhQUFULENBQXVCbm1ELE9BQXZCLEVBQTZDO0FBQzNDLCtDQUFnQkEsT0FBaEI7O0FBRUEsVUFBUUEsUUFBUTVDLEdBQWhCO0FBQ0UsU0FBSzNCLGdDQUFMO0FBQ0EsU0FBS1cseUJBQUw7QUFDQSxTQUFLRyw0QkFBTDtBQUNBLFNBQUtDLGtDQUFMO0FBQTBCO0FBQ3hCLFlBQU1rVSxjQUFvRDFRLFFBQVEwUSxXQUFsRTtBQUNBLFlBQUlBLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixjQUFNZCxhQUFhYyxZQUFZZCxVQUEvQjtBQUNBLGNBQUlBLGVBQWUsSUFBbkIsRUFBeUI7QUFDdkIsZ0JBQU1ELGNBQWNDLFdBQVdPLElBQS9CO0FBQ0EsZ0JBQUk4QixTQUFTdEMsV0FBYjtBQUNBLGVBQUc7QUFDRCxrQkFBTWl2QyxVQUFVM3NDLE9BQU8yc0MsT0FBdkI7QUFDQSxrQkFBSUEsWUFBWWxtRCxTQUFoQixFQUEyQjtBQUN6QndzRCxrQ0FBa0JsbEQsT0FBbEIsRUFBMkI0K0MsT0FBM0I7QUFDRDtBQUNEM3NDLHVCQUFTQSxPQUFPOUIsSUFBaEI7QUFDRCxhQU5ELFFBTVM4QixXQUFXdEMsV0FOcEI7QUFPRDtBQUNGO0FBQ0Q7QUFDRDtBQUNELFNBQUtqVSw2QkFBTDtBQUFxQjtBQUNuQnNwRCx3QkFBZ0JobEQsT0FBaEI7QUFDQSxZQUFNMkcsV0FBVzNHLFFBQVErTixTQUF6QjtBQUNBLFlBQUksT0FBT3BILFNBQVNrK0Msb0JBQWhCLEtBQXlDLFVBQTdDLEVBQXlEO0FBQ3ZEQyx5Q0FBK0I5a0QsT0FBL0IsRUFBd0MyRyxRQUF4QztBQUNEO0FBQ0Q7QUFDRDtBQUNELFNBQUs3Syw0QkFBTDtBQUFvQjtBQUNsQmtwRCx3QkFBZ0JobEQsT0FBaEI7QUFDQTtBQUNEO0FBQ0QsU0FBS25FLHlCQUFMO0FBQWlCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsWUFBSWlxRCxzQ0FBSixFQUFzQjtBQUNwQk0sZ0NBQXNCcG1ELE9BQXRCO0FBQ0QsU0FGRCxNQUVPLElBQUlxbUQseUNBQUosRUFBeUI7QUFDOUJDLCtCQUFxQnRtRCxPQUFyQjtBQUNEO0FBQ0Q7QUFDRDtBQTVDSDtBQThDRDs7QUFFRCxTQUFTdW1ELG9CQUFULENBQThCajhCLElBQTlCLEVBQWlEO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBSXhxQixPQUFjd3FCLElBQWxCO0FBQ0EsU0FBTyxJQUFQLEVBQWE7QUFDWDY3QixrQkFBY3JtRCxJQUFkO0FBQ0E7QUFDQTtBQUNBLFFBQ0VBLEtBQUttVSxLQUFMLEtBQWUsSUFBZjtBQUNBO0FBQ0E7QUFDQyxLQUFDNnhDLHNDQUFELElBQXFCaG1ELEtBQUsxQyxHQUFMLEtBQWF2Qix5QkFIbkMsQ0FERixFQUtFO0FBQ0FpRSxXQUFLbVUsS0FBTCxDQUFXbFUsTUFBWCxHQUFvQkQsSUFBcEI7QUFDQUEsYUFBT0EsS0FBS21VLEtBQVo7QUFDQTtBQUNEO0FBQ0QsUUFBSW5VLFNBQVN3cUIsSUFBYixFQUFtQjtBQUNqQjtBQUNEO0FBQ0QsV0FBT3hxQixLQUFLMFUsT0FBTCxLQUFpQixJQUF4QixFQUE4QjtBQUM1QixVQUFJMVUsS0FBS0MsTUFBTCxLQUFnQixJQUFoQixJQUF3QkQsS0FBS0MsTUFBTCxLQUFnQnVxQixJQUE1QyxFQUFrRDtBQUNoRDtBQUNEO0FBQ0R4cUIsYUFBT0EsS0FBS0MsTUFBWjtBQUNEO0FBQ0RELFNBQUswVSxPQUFMLENBQWF6VSxNQUFiLEdBQXNCRCxLQUFLQyxNQUEzQjtBQUNBRCxXQUFPQSxLQUFLMFUsT0FBWjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2d5QyxXQUFULENBQXFCeG1ELE9BQXJCLEVBQXFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsVUFBUUQsTUFBUixHQUFpQixJQUFqQjtBQUNBQyxVQUFRaVUsS0FBUixHQUFnQixJQUFoQjtBQUNBalUsVUFBUTJRLGFBQVIsR0FBd0IsSUFBeEI7QUFDQTNRLFVBQVEwUSxXQUFSLEdBQXNCLElBQXRCO0FBQ0EsTUFBTUgsWUFBWXZRLFFBQVF1USxTQUExQjtBQUNBLE1BQUlBLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEJBLGNBQVV4USxNQUFWLEdBQW1CLElBQW5CO0FBQ0F3USxjQUFVMEQsS0FBVixHQUFrQixJQUFsQjtBQUNBMUQsY0FBVUksYUFBVixHQUEwQixJQUExQjtBQUNBSixjQUFVRyxXQUFWLEdBQXdCLElBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNDFDLG9CQUFULENBQThCdG1ELE9BQTlCLEVBQThDO0FBQzVDLE1BQUksQ0FBQ3FtRCx5Q0FBTCxFQUEwQjtBQUN4QjtBQUNEOztBQUVELE1BQU1wL0IsU0FDSmpuQixRQUFRK04sU0FEVjtBQUw0QyxNQU9yQ21aLGFBUHFDLEdBT3BCRCxNQVBvQixDQU9yQ0MsYUFQcUM7O0FBUTVDLE1BQU11L0IsZ0JBQWdCLG1EQUF3QnYvQixhQUF4QixDQUF0QjtBQUNBLHNEQUF5QkEsYUFBekIsRUFBd0N1L0IsYUFBeEM7QUFDRDs7QUFFRCxTQUFTQyxlQUFULENBQXlCNTBDLFlBQXpCLEVBQThDO0FBQzVDLE1BQUksQ0FBQ3UwQyx5Q0FBTCxFQUEwQjtBQUN4QjtBQUNEOztBQUVELFVBQVF2MEMsYUFBYTFVLEdBQXJCO0FBQ0UsU0FBSzFCLDZCQUFMO0FBQXFCO0FBQ25CO0FBQ0Q7QUFDRCxTQUFLSSw0QkFBTDtBQUFvQjtBQUNsQjtBQUNEO0FBQ0QsU0FBS0MsdUJBQUw7QUFBZTtBQUNiO0FBQ0Q7QUFDRCxTQUFLSCx1QkFBTDtBQUNBLFNBQUtDLHlCQUFMO0FBQWlCO0FBQ2YsWUFBTThxRCxlQUlKNzBDLGFBQWEvRCxTQUpmO0FBRGUsWUFNUm1aLGFBTlEsR0FNMEJ5L0IsWUFOMUIsQ0FNUnovQixhQU5RO0FBQUEsWUFNT0MsZ0JBTlAsR0FNMEJ3L0IsWUFOMUIsQ0FNT3gvQixlQU5QOztBQU9mLDREQUF5QkQsYUFBekIsRUFBd0NDLGdCQUF4QztBQUNBO0FBQ0Q7QUFDRDtBQUFTO0FBQ1AsaUNBQ0UsS0FERixFQUVFLHVFQUNFLHdEQUhKO0FBS0Q7QUEzQkg7QUE2QkQ7O0FBRUQsU0FBU3kvQixrQkFBVCxDQUE0QnRuRCxLQUE1QixFQUFpRDtBQUMvQyxNQUFJeVUsU0FBU3pVLE1BQU1TLE1BQW5CO0FBQ0EsU0FBT2dVLFdBQVcsSUFBbEIsRUFBd0I7QUFDdEIsUUFBSTh5QyxhQUFhOXlDLE1BQWIsQ0FBSixFQUEwQjtBQUN4QixhQUFPQSxNQUFQO0FBQ0Q7QUFDREEsYUFBU0EsT0FBT2hVLE1BQWhCO0FBQ0Q7QUFDRCwyQkFDRSxLQURGLEVBRUUsMEVBQ0UsaUNBSEo7QUFLRDs7QUFFRCxTQUFTOG1ELFlBQVQsQ0FBc0J2bkQsS0FBdEIsRUFBNkM7QUFDM0MsU0FDRUEsTUFBTWxDLEdBQU4sS0FBY3RCLDRCQUFkLElBQ0F3RCxNQUFNbEMsR0FBTixLQUFjeEIsdUJBRGQsSUFFQTBELE1BQU1sQyxHQUFOLEtBQWN2Qix5QkFIaEI7QUFLRDs7QUFFRCxTQUFTaXJELGNBQVQsQ0FBd0J4bkQsS0FBeEIsRUFBaUQ7QUFDL0M7QUFDQTtBQUNBO0FBRUEsTUFBSVEsT0FBY1IsS0FBbEI7QUFDQXluRCxZQUFVLE9BQU8sSUFBUCxFQUFhO0FBQ3JCO0FBQ0EsV0FBT2puRCxLQUFLMFUsT0FBTCxLQUFpQixJQUF4QixFQUE4QjtBQUM1QixVQUFJMVUsS0FBS0MsTUFBTCxLQUFnQixJQUFoQixJQUF3QjhtRCxhQUFhL21ELEtBQUtDLE1BQWxCLENBQTVCLEVBQXVEO0FBQ3JEO0FBQ0E7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNERCxhQUFPQSxLQUFLQyxNQUFaO0FBQ0Q7QUFDREQsU0FBSzBVLE9BQUwsQ0FBYXpVLE1BQWIsR0FBc0JELEtBQUtDLE1BQTNCO0FBQ0FELFdBQU9BLEtBQUswVSxPQUFaO0FBQ0EsV0FDRTFVLEtBQUsxQyxHQUFMLEtBQWF0Qiw0QkFBYixJQUNBZ0UsS0FBSzFDLEdBQUwsS0FBYXJCLHVCQURiLElBRUErRCxLQUFLMUMsR0FBTCxLQUFhVCwwQ0FIZixFQUlFO0FBQ0E7QUFDQTtBQUNBLFVBQUltRCxLQUFLcVIsU0FBTCxHQUFpQjdRLDhCQUFyQixFQUFnQztBQUM5QjtBQUNBLGlCQUFTeW1ELFFBQVQ7QUFDRDtBQUNEO0FBQ0E7QUFDQSxVQUFJam5ELEtBQUttVSxLQUFMLEtBQWUsSUFBZixJQUF1Qm5VLEtBQUsxQyxHQUFMLEtBQWF2Qix5QkFBeEMsRUFBb0Q7QUFDbEQsaUJBQVNrckQsUUFBVDtBQUNELE9BRkQsTUFFTztBQUNMam5ELGFBQUttVSxLQUFMLENBQVdsVSxNQUFYLEdBQW9CRCxJQUFwQjtBQUNBQSxlQUFPQSxLQUFLbVUsS0FBWjtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFFBQUksRUFBRW5VLEtBQUtxUixTQUFMLEdBQWlCN1EsOEJBQW5CLENBQUosRUFBbUM7QUFDakM7QUFDQSxhQUFPUixLQUFLaU8sU0FBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTaTVDLGVBQVQsQ0FBeUJsMUMsWUFBekIsRUFBb0Q7QUFDbEQsTUFBSSxDQUFDZzBDLHNDQUFMLEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFNbUIsY0FBY0wsbUJBQW1COTBDLFlBQW5CLENBQXBCOztBQUVBO0FBQ0EsTUFBSWlDLGVBQUo7QUFDQSxNQUFJbXpDLG9CQUFKOztBQUVBLFVBQVFELFlBQVk3cEQsR0FBcEI7QUFDRSxTQUFLdEIsNEJBQUw7QUFDRWlZLGVBQVNrekMsWUFBWWw1QyxTQUFyQjtBQUNBbTVDLG9CQUFjLEtBQWQ7QUFDQTtBQUNGLFNBQUt0ckQsdUJBQUw7QUFDRW1ZLGVBQVNrekMsWUFBWWw1QyxTQUFaLENBQXNCbVosYUFBL0I7QUFDQWdnQyxvQkFBYyxJQUFkO0FBQ0E7QUFDRixTQUFLcnJELHlCQUFMO0FBQ0VrWSxlQUFTa3pDLFlBQVlsNUMsU0FBWixDQUFzQm1aLGFBQS9CO0FBQ0FnZ0Msb0JBQWMsSUFBZDtBQUNBO0FBQ0Y7QUFDRSwrQkFDRSxLQURGLEVBRUUscUVBQ0UsaUNBSEo7QUFkSjtBQW9CQSxNQUFJRCxZQUFZOTFDLFNBQVosR0FBd0J6USxpQ0FBNUIsRUFBMEM7QUFDeEM7QUFDQSxnREFBaUJxVCxNQUFqQjtBQUNBO0FBQ0FrekMsZ0JBQVk5MUMsU0FBWixJQUF5QixDQUFDelEsaUNBQTFCO0FBQ0Q7O0FBRUQsTUFBTXltRCxTQUFTTCxlQUFlaDFDLFlBQWYsQ0FBZjtBQUNBO0FBQ0E7QUFDQSxNQUFJaFMsT0FBY2dTLFlBQWxCO0FBQ0EsU0FBTyxJQUFQLEVBQWE7QUFDWCxRQUFJaFMsS0FBSzFDLEdBQUwsS0FBYXRCLDRCQUFiLElBQThCZ0UsS0FBSzFDLEdBQUwsS0FBYXJCLHVCQUEvQyxFQUF5RDtBQUN2RCxVQUFJb3JELE1BQUosRUFBWTtBQUNWLFlBQUlELFdBQUosRUFBaUI7QUFDZiw2REFBd0JuekMsTUFBeEIsRUFBZ0NqVSxLQUFLaU8sU0FBckMsRUFBZ0RvNUMsTUFBaEQ7QUFDRCxTQUZELE1BRU87QUFDTCxrREFBYXB6QyxNQUFiLEVBQXFCalUsS0FBS2lPLFNBQTFCLEVBQXFDbzVDLE1BQXJDO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTCxZQUFJRCxXQUFKLEVBQWlCO0FBQ2YsNERBQXVCbnpDLE1BQXZCLEVBQStCalUsS0FBS2lPLFNBQXBDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaURBQVlnRyxNQUFaLEVBQW9CalUsS0FBS2lPLFNBQXpCO0FBQ0Q7QUFDRjtBQUNGLEtBZEQsTUFjTyxJQUFJak8sS0FBSzFDLEdBQUwsS0FBYXZCLHlCQUFqQixFQUE2QjtBQUNsQztBQUNBO0FBQ0E7QUFDRCxLQUpNLE1BSUEsSUFBSWlFLEtBQUttVSxLQUFMLEtBQWUsSUFBbkIsRUFBeUI7QUFDOUJuVSxXQUFLbVUsS0FBTCxDQUFXbFUsTUFBWCxHQUFvQkQsSUFBcEI7QUFDQUEsYUFBT0EsS0FBS21VLEtBQVo7QUFDQTtBQUNEO0FBQ0QsUUFBSW5VLFNBQVNnUyxZQUFiLEVBQTJCO0FBQ3pCO0FBQ0Q7QUFDRCxXQUFPaFMsS0FBSzBVLE9BQUwsS0FBaUIsSUFBeEIsRUFBOEI7QUFDNUIsVUFBSTFVLEtBQUtDLE1BQUwsS0FBZ0IsSUFBaEIsSUFBd0JELEtBQUtDLE1BQUwsS0FBZ0IrUixZQUE1QyxFQUEwRDtBQUN4RDtBQUNEO0FBQ0RoUyxhQUFPQSxLQUFLQyxNQUFaO0FBQ0Q7QUFDREQsU0FBSzBVLE9BQUwsQ0FBYXpVLE1BQWIsR0FBc0JELEtBQUtDLE1BQTNCO0FBQ0FELFdBQU9BLEtBQUswVSxPQUFaO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNHhDLHFCQUFULENBQStCcG1ELE9BQS9CLEVBQThDO0FBQzVDO0FBRUEsTUFBSUYsT0FBY0UsT0FBbEI7O0FBRUE7QUFDQTtBQUNBLE1BQUlvbkQsdUJBQXVCLEtBQTNCOztBQUVBO0FBQ0EsTUFBSUMsc0JBQUo7QUFDQSxNQUFJQyxpQ0FBSjs7QUFFQSxTQUFPLElBQVAsRUFBYTtBQUNYLFFBQUksQ0FBQ0Ysb0JBQUwsRUFBMkI7QUFDekIsVUFBSXJ6QyxTQUFTalUsS0FBS0MsTUFBbEI7QUFDQXduRCxrQkFBWSxPQUFPLElBQVAsRUFBYTtBQUN2QixpQ0FDRXh6QyxXQUFXLElBRGIsRUFFRSxvRUFDRSx1Q0FISjtBQUtBLGdCQUFRQSxPQUFPM1csR0FBZjtBQUNFLGVBQUt0Qiw0QkFBTDtBQUNFdXJELDRCQUFnQnR6QyxPQUFPaEcsU0FBdkI7QUFDQXU1Qyx1Q0FBMkIsS0FBM0I7QUFDQSxrQkFBTUMsVUFBTjtBQUNGLGVBQUszckQsdUJBQUw7QUFDRXlyRCw0QkFBZ0J0ekMsT0FBT2hHLFNBQVAsQ0FBaUJtWixhQUFqQztBQUNBb2dDLHVDQUEyQixJQUEzQjtBQUNBLGtCQUFNQyxVQUFOO0FBQ0YsZUFBSzFyRCx5QkFBTDtBQUNFd3JELDRCQUFnQnR6QyxPQUFPaEcsU0FBUCxDQUFpQm1aLGFBQWpDO0FBQ0FvZ0MsdUNBQTJCLElBQTNCO0FBQ0Esa0JBQU1DLFVBQU47QUFaSjtBQWNBeHpDLGlCQUFTQSxPQUFPaFUsTUFBaEI7QUFDRDtBQUNEcW5ELDZCQUF1QixJQUF2QjtBQUNEOztBQUVELFFBQUl0bkQsS0FBSzFDLEdBQUwsS0FBYXRCLDRCQUFiLElBQThCZ0UsS0FBSzFDLEdBQUwsS0FBYXJCLHVCQUEvQyxFQUF5RDtBQUN2RHdxRCwyQkFBcUJ6bUQsSUFBckI7QUFDQTtBQUNBO0FBQ0EsVUFBSXduRCx3QkFBSixFQUE4QjtBQUM1Qiw0REFDSUQsYUFESixFQUVHdm5ELEtBQUtpTyxTQUZSO0FBSUQsT0FMRCxNQUtPO0FBQ0wsK0NBQ0lzNUMsYUFESixFQUVHdm5ELEtBQUtpTyxTQUZSO0FBSUQ7QUFDRDtBQUNELEtBaEJELE1BZ0JPLElBQ0wzUyxtREFDQTBFLEtBQUsxQyxHQUFMLEtBQWFULDBDQUZSLEVBR0w7QUFDQTtBQUNBLFVBQUkycUQsd0JBQUosRUFBOEI7QUFDNUIsc0VBQ0lELGFBREosRUFFR3ZuRCxLQUFLaU8sU0FGUjtBQUlELE9BTEQsTUFLTztBQUNMLHlEQUNJczVDLGFBREosRUFFR3ZuRCxLQUFLaU8sU0FGUjtBQUlEO0FBQ0YsS0FoQk0sTUFnQkEsSUFBSWpPLEtBQUsxQyxHQUFMLEtBQWF2Qix5QkFBakIsRUFBNkI7QUFDbEMsVUFBSWlFLEtBQUttVSxLQUFMLEtBQWUsSUFBbkIsRUFBeUI7QUFDdkI7QUFDQTtBQUNBb3pDLHdCQUFnQnZuRCxLQUFLaU8sU0FBTCxDQUFlbVosYUFBL0I7QUFDQW9nQyxtQ0FBMkIsSUFBM0I7QUFDQTtBQUNBeG5ELGFBQUttVSxLQUFMLENBQVdsVSxNQUFYLEdBQW9CRCxJQUFwQjtBQUNBQSxlQUFPQSxLQUFLbVUsS0FBWjtBQUNBO0FBQ0Q7QUFDRixLQVhNLE1BV0E7QUFDTGt5QyxvQkFBY3JtRCxJQUFkO0FBQ0E7QUFDQSxVQUFJQSxLQUFLbVUsS0FBTCxLQUFlLElBQW5CLEVBQXlCO0FBQ3ZCblUsYUFBS21VLEtBQUwsQ0FBV2xVLE1BQVgsR0FBb0JELElBQXBCO0FBQ0FBLGVBQU9BLEtBQUttVSxLQUFaO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsUUFBSW5VLFNBQVNFLE9BQWIsRUFBc0I7QUFDcEI7QUFDRDtBQUNELFdBQU9GLEtBQUswVSxPQUFMLEtBQWlCLElBQXhCLEVBQThCO0FBQzVCLFVBQUkxVSxLQUFLQyxNQUFMLEtBQWdCLElBQWhCLElBQXdCRCxLQUFLQyxNQUFMLEtBQWdCQyxPQUE1QyxFQUFxRDtBQUNuRDtBQUNEO0FBQ0RGLGFBQU9BLEtBQUtDLE1BQVo7QUFDQSxVQUFJRCxLQUFLMUMsR0FBTCxLQUFhdkIseUJBQWpCLEVBQTZCO0FBQzNCO0FBQ0E7QUFDQXVyRCwrQkFBdUIsS0FBdkI7QUFDRDtBQUNGO0FBQ0R0bkQsU0FBSzBVLE9BQUwsQ0FBYXpVLE1BQWIsR0FBc0JELEtBQUtDLE1BQTNCO0FBQ0FELFdBQU9BLEtBQUswVSxPQUFaO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTZ3pDLGNBQVQsQ0FBd0J4bkQsT0FBeEIsRUFBOEM7QUFDNUMsTUFBSThsRCxzQ0FBSixFQUFzQjtBQUNwQjtBQUNBO0FBQ0FNLDBCQUFzQnBtRCxPQUF0QjtBQUNELEdBSkQsTUFJTztBQUNMO0FBQ0F1bUQseUJBQXFCdm1ELE9BQXJCO0FBQ0Q7QUFDRHdtRCxjQUFZeG1ELE9BQVo7QUFDRDs7QUFFRCxTQUFTeW5ELFVBQVQsQ0FBb0J6bkQsT0FBcEIsRUFBMkM4UixZQUEzQyxFQUFzRTtBQUNwRSxNQUFJLENBQUNnMEMsc0NBQUwsRUFBdUI7QUFDckIsWUFBUWgwQyxhQUFhMVUsR0FBckI7QUFDRSxXQUFLM0IsZ0NBQUw7QUFDQSxXQUFLVyx5QkFBTDtBQUNBLFdBQUtHLDRCQUFMO0FBQ0EsV0FBS0Msa0NBQUw7QUFBMEI7QUFDeEI7QUFDQTtBQUNBNG9ELCtCQUFxQnhGLG9DQUFyQixFQUFzQ3FDLGtDQUF0QyxFQUFxRG53QyxZQUFyRDtBQUNBO0FBQ0Q7QUFUSDs7QUFZQTQwQyxvQkFBZ0I1MEMsWUFBaEI7QUFDQTtBQUNEOztBQUVELFVBQVFBLGFBQWExVSxHQUFyQjtBQUNFLFNBQUszQixnQ0FBTDtBQUNBLFNBQUtXLHlCQUFMO0FBQ0EsU0FBS0csNEJBQUw7QUFDQSxTQUFLQyxrQ0FBTDtBQUEwQjtBQUN4QjtBQUNBO0FBQ0E0b0QsNkJBQXFCeEYsb0NBQXJCLEVBQXNDcUMsa0NBQXRDLEVBQXFEbndDLFlBQXJEO0FBQ0E7QUFDRDtBQUNELFNBQUtwVyw2QkFBTDtBQUFxQjtBQUNuQjtBQUNEO0FBQ0QsU0FBS0ksNEJBQUw7QUFBb0I7QUFDbEIsWUFBTTZLLFdBQXFCbUwsYUFBYS9ELFNBQXhDO0FBQ0EsWUFBSXBILFlBQVksSUFBaEIsRUFBc0I7QUFDcEI7QUFDQSxjQUFNaTJCLFdBQVc5cUIsYUFBYXdULGFBQTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTXVYLFdBQVc3OEIsWUFBWSxJQUFaLEdBQW1CQSxRQUFRc2xCLGFBQTNCLEdBQTJDc1gsUUFBNUQ7QUFDQSxjQUFNei9CLE9BQU8yVSxhQUFhM1UsSUFBMUI7QUFDQTtBQUNBLGNBQU1zbUQsZ0JBQXVDM3hDLGFBQWFwQixXQUExRDtBQUNBb0IsdUJBQWFwQixXQUFiLEdBQTJCLElBQTNCO0FBQ0EsY0FBSSt5QyxrQkFBa0IsSUFBdEIsRUFBNEI7QUFDMUIsb0RBQ0U5OEMsUUFERixFQUVFODhDLGFBRkYsRUFHRXRtRCxJQUhGLEVBSUUwL0IsUUFKRixFQUtFRCxRQUxGLEVBTUU5cUIsWUFORjtBQVFEO0FBQ0Y7QUFDRDtBQUNEO0FBQ0QsU0FBSy9WLHVCQUFMO0FBQWU7QUFDYixpQ0FDRStWLGFBQWEvRCxTQUFiLEtBQTJCLElBRDdCLEVBRUUsb0VBQ0UsaURBSEo7QUFLQSxZQUFNbzFDLGVBQTZCcnhDLGFBQWEvRCxTQUFoRDtBQUNBLFlBQU0yNUMsVUFBa0I1MUMsYUFBYXdULGFBQXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBTXFpQyxVQUNKM25ELFlBQVksSUFBWixHQUFtQkEsUUFBUXNsQixhQUEzQixHQUEyQ29pQyxPQUQ3QztBQUVBLG9EQUFpQnZFLFlBQWpCLEVBQStCd0UsT0FBL0IsRUFBd0NELE9BQXhDO0FBQ0E7QUFDRDtBQUNELFNBQUs5ckQsdUJBQUw7QUFBZTtBQUNiO0FBQ0Q7QUFDRCxTQUFLUyx1QkFBTDtBQUFlO0FBQ2I7QUFDRDtBQUNELFNBQUtDLGdDQUFMO0FBQXdCO0FBQ3RCLFlBQUlvN0MsV0FBaUM1bEMsYUFBYW5CLGFBQWxEOztBQUVBLFlBQUlpM0Msc0JBQUo7QUFDQSxZQUFJQyxxQkFBcUIvMUMsWUFBekI7QUFDQSxZQUFJNGxDLGFBQWEsSUFBakIsRUFBdUI7QUFDckJrUSwwQkFBZ0IsS0FBaEI7QUFDRCxTQUZELE1BRU87QUFDTEEsMEJBQWdCLElBQWhCO0FBQ0FDLCtCQUFxQi8xQyxhQUFhbUMsS0FBbEM7QUFDQSxjQUFJeWpDLFNBQVNqYyxVQUFULEtBQXdCajZCLGdDQUE1QixFQUFvQztBQUNsQztBQUNBO0FBQ0E7QUFDQWsyQyxxQkFBU2pjLFVBQVQsR0FBc0IsOENBQXRCO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJb3NCLHVCQUF1QixJQUEzQixFQUFpQztBQUMvQmpDLGtDQUF3QmlDLGtCQUF4QixFQUE0Q0QsYUFBNUM7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQUFNRSxZQUFtQ2gyQyxhQUFhcEIsV0FBdEQ7QUFDQSxZQUFJbzNDLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEJoMkMsdUJBQWFwQixXQUFiLEdBQTJCLElBQTNCO0FBQ0EsY0FBSWtnQixhQUFhOWUsYUFBYS9ELFNBQTlCO0FBQ0EsY0FBSTZpQixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSx5QkFBYTllLGFBQWEvRCxTQUFiLEdBQXlCLElBQUltMkMsZUFBSixFQUF0QztBQUNEO0FBQ0Q0RCxvQkFBVXpxQyxPQUFWLENBQWtCLG9CQUFZO0FBQzVCO0FBQ0EsZ0JBQUkwcUMsUUFBUXIzQiwyQ0FBc0JoRixJQUF0QixDQUEyQixJQUEzQixFQUFpQzVaLFlBQWpDLEVBQStDNVQsUUFBL0MsQ0FBWjtBQUNBLGdCQUFJL0MseUNBQUosRUFBNEI7QUFDMUI0c0Qsc0JBQVEsNEJBQXNCQSxLQUF0QixDQUFSO0FBQ0Q7QUFDRCxnQkFBSSxDQUFDbjNCLFdBQVc5TixHQUFYLENBQWU1a0IsUUFBZixDQUFMLEVBQStCO0FBQzdCMHlCLHlCQUFXN04sR0FBWCxDQUFlN2tCLFFBQWY7QUFDQUEsdUJBQVNpckIsSUFBVCxDQUFjNCtCLEtBQWQsRUFBcUJBLEtBQXJCO0FBQ0Q7QUFDRixXQVZEO0FBV0Q7O0FBRUQ7QUFDRDtBQUNELFNBQUtyckQsdUNBQUw7QUFBK0I7QUFDN0I7QUFDRDtBQUNEO0FBQVM7QUFDUCxpQ0FDRSxLQURGLEVBRUUsdUVBQ0Usd0RBSEo7QUFLRDtBQXJISDtBQXVIRDs7QUFFRCxTQUFTc3JELHNCQUFULENBQWdDaG9ELE9BQWhDLEVBQWdEO0FBQzlDLE1BQUksQ0FBQzhsRCxzQ0FBTCxFQUF1QjtBQUNyQjtBQUNEO0FBQ0QsOENBQWlCOWxELFFBQVErTixTQUF6QjtBQUNEOztRQUdDbzNDLDhCLEdBQUFBLDhCO1FBQ0E2QyxzQixHQUFBQSxzQjtRQUNBaEIsZSxHQUFBQSxlO1FBQ0FRLGMsR0FBQUEsYztRQUNBQyxVLEdBQUFBLFU7UUFDQTlCLGdCLEdBQUFBLGdCO1FBQ0FJLGUsR0FBQUEsZTtRQUNBRSxlLEdBQUFBLGU7Ozs7Ozs7Ozs7OztRQ3p1Q2NnQyxxQixHQUFBQSxxQjtRQVdBQyxpQixHQUFBQSxpQjtBQTdCaEI7Ozs7Ozs7QUFPQSxJQUFNQyxpQkFBaUIsOEJBQXZCO0FBQ0EsSUFBTUMsaUJBQWlCLG9DQUF2QjtBQUNBLElBQU1DLGdCQUFnQiw0QkFBdEI7O0FBRU8sSUFBTUMsa0NBQWE7QUFDeEJDLFFBQU1KLGNBRGtCO0FBRXhCSyxVQUFRSixjQUZnQjtBQUd4QkssT0FBS0o7QUFIbUIsQ0FBbkI7O0FBTVA7QUFDTyxTQUFTSixxQkFBVCxDQUErQjlxRCxJQUEvQixFQUFxRDtBQUMxRCxVQUFRQSxJQUFSO0FBQ0UsU0FBSyxLQUFMO0FBQ0UsYUFBT2tyRCxhQUFQO0FBQ0YsU0FBSyxNQUFMO0FBQ0UsYUFBT0QsY0FBUDtBQUNGO0FBQ0UsYUFBT0QsY0FBUDtBQU5KO0FBUUQ7O0FBRU0sU0FBU0QsaUJBQVQsQ0FDTFEsZUFESyxFQUVMdnJELElBRkssRUFHRztBQUNSLE1BQUl1ckQsbUJBQW1CLElBQW5CLElBQTJCQSxvQkFBb0JQLGNBQW5ELEVBQW1FO0FBQ2pFO0FBQ0EsV0FBT0Ysc0JBQXNCOXFELElBQXRCLENBQVA7QUFDRDtBQUNELE1BQUl1ckQsb0JBQW9CTCxhQUFwQixJQUFxQ2xyRCxTQUFTLGVBQWxELEVBQW1FO0FBQ2pFO0FBQ0EsV0FBT2dyRCxjQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQU9PLGVBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUMzQ0Q7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyx3QkFBd0I7QUFDNUI7QUFDQUMsVUFBUSxRQUZvQjtBQUc1QkMsaUJBQWUsZUFIYTtBQUk1QixvQkFBa0IsZUFKVTtBQUs1QkMsYUFBVyxXQUxpQjtBQU01QjNpRCxVQUFRLFFBTm9CO0FBTzVCNGlELG1CQUFpQixpQkFQVztBQVE1QkMsT0FBSyxLQVJ1QjtBQVM1QkMsTUFBSSxJQVR3QjtBQVU1QkMsU0FBTyxPQVZxQjtBQVc1QkMsa0JBQWdCLGdCQVhZO0FBWTVCQyxnQkFBYyxjQVpjO0FBYTVCQyxlQUFhLGFBYmU7QUFjNUJDLGFBQVcsV0FkaUI7QUFlNUJDLFlBQVUsVUFma0I7QUFnQjVCQyxZQUFVLFVBaEJrQjtBQWlCNUJDLFdBQVMsU0FqQm1CO0FBa0I1QkMsZUFBYSxhQWxCZTtBQW1CNUJDLGVBQWEsYUFuQmU7QUFvQjVCQyxhQUFXLFdBcEJpQjtBQXFCNUJDLFdBQVMsU0FyQm1CO0FBc0I1QnpsQixXQUFTLFNBdEJtQjtBQXVCNUI5ZCxZQUFVLFVBdkJrQjtBQXdCNUJ3akMsUUFBTSxNQXhCc0I7QUF5QjVCQyxTQUFPLFdBekJxQjtBQTBCNUJDLFdBQVMsU0ExQm1CO0FBMkI1QkMsYUFBVyxXQTNCaUI7QUE0QjVCQyxRQUFNLE1BNUJzQjtBQTZCNUJDLFdBQVMsU0E3Qm1CO0FBOEI1Qm5qQyxXQUFTLFNBOUJtQjtBQStCNUJvakMsbUJBQWlCLGlCQS9CVztBQWdDNUJDLGVBQWEsYUFoQ2U7QUFpQzVCQyxZQUFVLFVBakNrQjtBQWtDNUJDLGdCQUFjLGNBbENjO0FBbUM1QkMsVUFBUSxRQW5Db0I7QUFvQzVCQyxlQUFhLGFBcENlO0FBcUM1QkMsMkJBQXlCLHlCQXJDRztBQXNDNUJDLFFBQU0sTUF0Q3NCO0FBdUM1QnhkLFlBQVUsVUF2Q2tCO0FBd0M1QjUwQixXQUFTLFNBeENtQjtBQXlDNUJxeUMsa0JBQWdCLGdCQXpDWTtBQTBDNUJDLGdCQUFjLGNBMUNjO0FBMkM1QkMsU0FBTyxPQTNDcUI7QUE0QzVCQyxPQUFLLEtBNUN1QjtBQTZDNUIveEMsWUFBVSxVQTdDa0I7QUE4QzVCZ3lDLFlBQVUsVUE5Q2tCO0FBK0M1QkMsYUFBVyxXQS9DaUI7QUFnRDVCQyxXQUFTLFNBaERtQjtBQWlENUIzc0QsT0FBSyxTQWpEdUI7QUFrRDVCNnhDLFFBQU0sTUFsRHNCO0FBbUQ1QithLGNBQVksWUFuRGdCO0FBb0Q1QkMsY0FBWSxZQXBEZ0I7QUFxRDVCQyxlQUFhLGFBckRlO0FBc0Q1QkMsa0JBQWdCLGdCQXREWTtBQXVENUJDLGNBQVksWUF2RGdCO0FBd0Q1QkMsZUFBYSxhQXhEZTtBQXlENUJDLFdBQVMsU0F6RG1CO0FBMEQ1QnJhLFVBQVEsUUExRG9CO0FBMkQ1QnBNLFVBQVEsUUEzRG9CO0FBNEQ1QjBtQixRQUFNLE1BNURzQjtBQTZENUJDLFFBQU0sTUE3RHNCO0FBOEQ1QkMsWUFBVSxVQTlEa0I7QUErRDVCQyxXQUFTLFNBL0RtQjtBQWdFNUJDLGFBQVcsV0FoRWlCO0FBaUU1QixnQkFBYyxXQWpFYztBQWtFNUJDLFFBQU0sTUFsRXNCO0FBbUU1QmpsQyxNQUFJLElBbkV3QjtBQW9FNUJrbEMsYUFBVyxXQXBFaUI7QUFxRTVCQyxhQUFXLFdBckVpQjtBQXNFNUJDLGFBQVcsV0F0RWlCO0FBdUU1QjlsQixNQUFJLElBdkV3QjtBQXdFNUIrbEIsVUFBUSxRQXhFb0I7QUF5RTVCQyxZQUFVLFVBekVrQjtBQTBFNUJDLFdBQVMsU0ExRW1CO0FBMkU1QkMsYUFBVyxXQTNFaUI7QUE0RTVCQyxZQUFVLFVBNUVrQjtBQTZFNUJDLGFBQVcsV0E3RWlCO0FBOEU1QkMsV0FBUyxTQTlFbUI7QUErRTVCQyxRQUFNLE1BL0VzQjtBQWdGNUIxcUMsU0FBTyxPQWhGcUI7QUFpRjVCMnFDLFFBQU0sTUFqRnNCO0FBa0Y1Qng0QyxRQUFNLE1BbEZzQjtBQW1GNUJ5NEMsUUFBTSxNQW5Gc0I7QUFvRjVCQyxPQUFLLEtBcEZ1QjtBQXFGNUJDLFlBQVUsVUFyRmtCO0FBc0Y1QkMsZUFBYSxhQXRGZTtBQXVGNUJDLGdCQUFjLGNBdkZjO0FBd0Y1QkMsT0FBSyxLQXhGdUI7QUF5RjVCQyxhQUFXLFdBekZpQjtBQTBGNUJDLFNBQU8sT0ExRnFCO0FBMkY1QkMsY0FBWSxZQTNGZ0I7QUE0RjVCQyxVQUFRLFFBNUZvQjtBQTZGNUJDLE9BQUssS0E3RnVCO0FBOEY1QkMsYUFBVyxXQTlGaUI7QUErRjVCQyxZQUFVLFVBL0ZrQjtBQWdHNUJDLFNBQU8sT0FoR3FCO0FBaUc1QmwwRCxRQUFNLE1BakdzQjtBQWtHNUJtMEQsWUFBVSxVQWxHa0I7QUFtRzVCQyxTQUFPLE9BbkdxQjtBQW9HNUJDLGNBQVksWUFwR2dCO0FBcUc1QkMsUUFBTSxNQXJHc0I7QUFzRzVCQyxXQUFTLFNBdEdtQjtBQXVHNUJDLFdBQVMsU0F2R21CO0FBd0c1QkMsZUFBYSxhQXhHZTtBQXlHNUJDLGVBQWEsYUF6R2U7QUEwRzVCQyxVQUFRLFFBMUdvQjtBQTJHNUJDLFdBQVMsU0EzR21CO0FBNEc1QkMsV0FBUyxTQTVHbUI7QUE2RzVCQyxjQUFZLFlBN0dnQjtBQThHNUJDLFlBQVUsVUE5R2tCO0FBK0c1QkMsa0JBQWdCLGdCQS9HWTtBQWdINUJDLE9BQUssS0FoSHVCO0FBaUg1QkMsWUFBVSxVQWpIa0I7QUFrSDVCQyxZQUFVLFVBbEhrQjtBQW1INUJDLFFBQU0sTUFuSHNCO0FBb0g1QkMsUUFBTSxNQXBIc0I7QUFxSDVCQyxXQUFTLFNBckhtQjtBQXNINUJDLFdBQVMsU0F0SG1CO0FBdUg1Qi9oQixTQUFPLE9BdkhxQjtBQXdINUJnaUIsVUFBUSxRQXhIb0I7QUF5SDVCQyxhQUFXLFdBekhpQjtBQTBINUJDLFlBQVUsVUExSGtCO0FBMkg1QkMsWUFBVSxVQTNIa0I7QUE0SDVCQyxTQUFPLE9BNUhxQjtBQTZINUI5aUMsUUFBTSxNQTdIc0I7QUE4SDVCK2lDLFNBQU8sT0E5SHFCO0FBK0g1QkMsUUFBTSxNQS9Ic0I7QUFnSTVCQyxjQUFZLFlBaElnQjtBQWlJNUJDLE9BQUssS0FqSXVCO0FBa0k1QkMsVUFBUSxRQWxJb0I7QUFtSTVCQyxXQUFTLFNBbkltQjtBQW9JNUJDLFVBQVEsUUFwSW9CO0FBcUk1QkMsU0FBTyxPQXJJcUI7QUFzSTVCQyxRQUFNLE1BdElzQjtBQXVJNUJDLFNBQU8sT0F2SXFCO0FBd0k1QkMsV0FBUyxTQXhJbUI7QUF5STVCQyxZQUFVLFVBeklrQjtBQTBJNUIvc0QsVUFBUSxRQTFJb0I7QUEySTVCZ3RELFNBQU8sT0EzSXFCO0FBNEk1Qjd5RCxRQUFNLE1BNUlzQjtBQTZJNUI4eUQsVUFBUSxRQTdJb0I7QUE4STVCcnpDLFNBQU8sT0E5SXFCO0FBK0k1QnUwQixTQUFPLE9BL0lxQjtBQWdKNUIrZSxTQUFPLE9BaEpxQjtBQWlKNUJDLFFBQU0sTUFqSnNCOztBQW1KNUI7QUFDQUMsU0FBTyxPQXBKcUI7QUFxSjVCQyxnQkFBYyxjQXJKYztBQXNKNUIsbUJBQWlCLGNBdEpXO0FBdUo1QkMsY0FBWSxZQXZKZ0I7QUF3SjVCQyxZQUFVLFVBeEprQjtBQXlKNUJDLHFCQUFtQixtQkF6SlM7QUEwSjVCLHdCQUFzQixtQkExSk07QUEySjVCQyxnQkFBYyxjQTNKYztBQTRKNUJDLGNBQVksWUE1SmdCO0FBNko1QkMsYUFBVyxXQTdKaUI7QUE4SjVCQyxjQUFZLFlBOUpnQjtBQStKNUIsaUJBQWUsWUEvSmE7QUFnSzVCQyxVQUFRLFFBaEtvQjtBQWlLNUJDLGlCQUFlLGVBakthO0FBa0s1QkMsaUJBQWUsZUFsS2E7QUFtSzVCQyxlQUFhLGFBbktlO0FBb0s1QkMsV0FBUyxTQXBLbUI7QUFxSzVCQyxpQkFBZSxlQXJLYTtBQXNLNUJDLGlCQUFlLGVBdEthO0FBdUs1QixvQkFBa0IsZUF2S1U7QUF3SzVCQyxlQUFhLGFBeEtlO0FBeUs1QkMsUUFBTSxNQXpLc0I7QUEwSzVCQyxTQUFPLE9BMUtxQjtBQTJLNUJDLFFBQU0sTUEzS3NCO0FBNEs1QkMsTUFBSSxJQTVLd0I7QUE2SzVCQyxZQUFVLFVBN0trQjtBQThLNUJDLGFBQVcsV0E5S2lCO0FBK0s1QixnQkFBYyxXQS9LYztBQWdMNUJDLFFBQU0sTUFoTHNCO0FBaUw1QkMsWUFBVSxVQWpMa0I7QUFrTDVCLGVBQWEsVUFsTGU7QUFtTDVCQyxpQkFBZSxlQW5MYTtBQW9MNUJDLFlBQVUsVUFwTGtCO0FBcUw1QixlQUFhLFVBckxlO0FBc0w1QjdrQixTQUFPLE9BdExxQjtBQXVMNUI4a0Isc0JBQW9CLG9CQXZMUTtBQXdMNUIseUJBQXVCLG9CQXhMSztBQXlMNUJDLDZCQUEyQiwyQkF6TEM7QUEwTDVCLGlDQUErQiwyQkExTEg7QUEyTDVCQyxnQkFBYyxjQTNMYztBQTRMNUIsbUJBQWlCLGNBNUxXO0FBNkw1QkMsa0JBQWdCLGdCQTdMWTtBQThMNUIscUJBQW1CLGdCQTlMUztBQStMNUJDLHFCQUFtQixtQkEvTFM7QUFnTTVCQyxvQkFBa0Isa0JBaE1VO0FBaU01Qng3QixVQUFRLFFBak1vQjtBQWtNNUJ5N0IsTUFBSSxJQWxNd0I7QUFtTTVCQyxNQUFJLElBbk13QjtBQW9NNUJ0NUQsS0FBRyxHQXBNeUI7QUFxTTVCdTVELFlBQVUsVUFyTWtCO0FBc001QkMsY0FBWSxZQXRNZ0I7QUF1TTVCQyxXQUFTLFNBdk1tQjtBQXdNNUJDLG1CQUFpQixpQkF4TVc7QUF5TTVCQyxhQUFXLFdBek1pQjtBQTBNNUJDLFdBQVMsU0ExTW1CO0FBMk01QkMsV0FBUyxTQTNNbUI7QUE0TTVCQyxvQkFBa0Isa0JBNU1VO0FBNk01Qix1QkFBcUIsa0JBN01PO0FBOE01QkMsT0FBSyxLQTlNdUI7QUErTTVCQyxNQUFJLElBL013QjtBQWdONUJDLE1BQUksSUFoTndCO0FBaU41QkMsWUFBVSxVQWpOa0I7QUFrTjVCQyxhQUFXLFdBbE5pQjtBQW1ONUJDLG9CQUFrQixrQkFuTlU7QUFvTjVCLHVCQUFxQixrQkFwTk87QUFxTjVCQyxPQUFLLEtBck51QjtBQXNONUJDLFlBQVUsVUF0TmtCO0FBdU41QkMsNkJBQTJCLDJCQXZOQztBQXdONUJDLFFBQU0sTUF4TnNCO0FBeU41QkMsZUFBYSxhQXpOZTtBQTBONUIsa0JBQWdCLGFBMU5ZO0FBMk41QkMsWUFBVSxVQTNOa0I7QUE0TjVCLGVBQWEsVUE1TmU7QUE2TjVCQyxVQUFRLFFBN05vQjtBQThONUJDLGFBQVcsV0E5TmlCO0FBK041QkMsZUFBYSxhQS9OZTtBQWdPNUJDLGdCQUFjLGNBaE9jO0FBaU81QixtQkFBaUIsY0FqT1c7QUFrTzVCQyxjQUFZLFlBbE9nQjtBQW1PNUIsaUJBQWUsWUFuT2E7QUFvTzVCQyxhQUFXLFdBcE9pQjtBQXFPNUJDLGNBQVksWUFyT2dCO0FBc081QixpQkFBZSxZQXRPYTtBQXVPNUJDLFlBQVUsVUF2T2tCO0FBd081QixlQUFhLFVBeE9lO0FBeU81QkMsa0JBQWdCLGdCQXpPWTtBQTBPNUIsc0JBQW9CLGdCQTFPUTtBQTJPNUJDLGVBQWEsYUEzT2U7QUE0TzVCLGtCQUFnQixhQTVPWTtBQTZPNUJDLGFBQVcsV0E3T2lCO0FBOE81QixnQkFBYyxXQTlPYztBQStPNUJDLGVBQWEsYUEvT2U7QUFnUDVCLGtCQUFnQixhQWhQWTtBQWlQNUJDLGNBQVksWUFqUGdCO0FBa1A1QixpQkFBZSxZQWxQYTtBQW1QNUI5N0QsVUFBUSxRQW5Qb0I7QUFvUDVCc2QsUUFBTSxNQXBQc0I7QUFxUDVCeStDLE1BQUksSUFyUHdCO0FBc1A1QkMsTUFBSSxJQXRQd0I7QUF1UDVCQyxNQUFJLElBdlB3QjtBQXdQNUJDLE1BQUksSUF4UHdCO0FBeVA1QkMsYUFBVyxXQXpQaUI7QUEwUDVCLGdCQUFjLFdBMVBjO0FBMlA1QkMsOEJBQTRCLDRCQTNQQTtBQTRQNUIsa0NBQWdDLDRCQTVQSjtBQTZQNUJDLDRCQUEwQiwwQkE3UEU7QUE4UDVCLGdDQUE4QiwwQkE5UEY7QUErUDVCQyxZQUFVLFVBL1BrQjtBQWdRNUJDLHFCQUFtQixtQkFoUVM7QUFpUTVCQyxpQkFBZSxlQWpRYTtBQWtRNUJDLFdBQVMsU0FsUW1CO0FBbVE1QkMsYUFBVyxXQW5RaUI7QUFvUTVCLGlCQUFlLFdBcFFhO0FBcVE1QkMsZ0JBQWMsY0FyUWM7QUFzUTVCLG9CQUFrQixjQXRRVTtBQXVRNUJDLGVBQWEsYUF2UWU7QUF3UTVCQyxrQkFBZ0IsZ0JBeFFZO0FBeVE1QixxQkFBbUIsZ0JBelFTO0FBMFE1QkMsT0FBSyxLQTFRdUI7QUEyUTVCQyxNQUFJLElBM1F3QjtBQTRRNUJDLFVBQVEsUUE1UW9CO0FBNlE1QkMsYUFBVyxXQTdRaUI7QUE4UTVCQyxNQUFJLElBOVF3QjtBQStRNUJDLE1BQUksSUEvUXdCO0FBZ1I1QkMsTUFBSSxJQWhSd0I7QUFpUjVCQyxNQUFJLElBalJ3QjtBQWtSNUJDLEtBQUcsR0FsUnlCO0FBbVI1QkMsZ0JBQWMsY0FuUmM7QUFvUjVCQyxvQkFBa0Isa0JBcFJVO0FBcVI1QkMsV0FBUyxTQXJSbUI7QUFzUjVCQyxhQUFXLFdBdFJpQjtBQXVSNUJDLGNBQVksWUF2UmdCO0FBd1I1QkMsWUFBVSxVQXhSa0I7QUF5UjVCQyxnQkFBYyxjQXpSYztBQTBSNUJDLGlCQUFlLGVBMVJhO0FBMlI1QixvQkFBa0IsZUEzUlU7QUE0UjVCQyxpQkFBZSxlQTVSYTtBQTZSNUIsb0JBQWtCLGVBN1JVO0FBOFI1QkMscUJBQW1CLG1CQTlSUztBQStSNUJDLFNBQU8sT0EvUnFCO0FBZ1M1QkMsYUFBVyxXQWhTaUI7QUFpUzVCLGdCQUFjLFdBalNjO0FBa1M1QkMsZ0JBQWMsY0FsU2M7QUFtUzVCQyxhQUFXLFdBblNpQjtBQW9TNUIsZ0JBQWMsV0FwU2M7QUFxUzVCQyxlQUFhLGFBclNlO0FBc1M1QixrQkFBZ0IsYUF0U1k7QUF1UzVCQyxlQUFhLGFBdlNlO0FBd1M1QkMsZUFBYSxhQXhTZTtBQXlTNUJDLFFBQU0sTUF6U3NCO0FBMFM1QkMsb0JBQWtCLGtCQTFTVTtBQTJTNUJDLGFBQVcsV0EzU2lCO0FBNFM1QkMsZ0JBQWMsY0E1U2M7QUE2UzVCbm1ELFFBQU0sTUE3U3NCO0FBOFM1Qm9tRCxjQUFZLFlBOVNnQjtBQStTNUJDLFVBQVEsUUEvU29CO0FBZ1Q1QkMsV0FBUyxTQWhUbUI7QUFpVDVCQyxZQUFVLFVBalRrQjtBQWtUNUJDLFNBQU8sT0FsVHFCO0FBbVQ1QkMsVUFBUSxRQW5Ub0I7QUFvVDVCQyxlQUFhLGFBcFRlO0FBcVQ1QkMsVUFBUSxRQXJUb0I7QUFzVDVCQyxZQUFVLFVBdFRrQjtBQXVUNUJDLG9CQUFrQixrQkF2VFU7QUF3VDVCLHVCQUFxQixrQkF4VE87QUF5VDVCQyxxQkFBbUIsbUJBelRTO0FBMFQ1Qix3QkFBc0IsbUJBMVRNO0FBMlQ1QkMsY0FBWSxZQTNUZ0I7QUE0VDVCLGlCQUFlLFlBNVRhO0FBNlQ1QkMsV0FBUyxTQTdUbUI7QUE4VDVCLGNBQVksU0E5VGdCO0FBK1Q1QkMsY0FBWSxZQS9UZ0I7QUFnVTVCQyx1QkFBcUIscUJBaFVPO0FBaVU1QkMsb0JBQWtCLGtCQWpVVTtBQWtVNUJDLGdCQUFjLGNBbFVjO0FBbVU1QkMsaUJBQWUsZUFuVWE7QUFvVTVCLG9CQUFrQixlQXBVVTtBQXFVNUJDLFVBQVEsUUFyVW9CO0FBc1U1QkMsYUFBVyxXQXRVaUI7QUF1VTVCQyxhQUFXLFdBdlVpQjtBQXdVNUJDLGFBQVcsV0F4VWlCO0FBeVU1QjU3QyxVQUFRLFFBelVvQjtBQTBVNUI2N0MsaUJBQWUsZUExVWE7QUEyVTVCQyx1QkFBcUIscUJBM1VPO0FBNFU1QkMsa0JBQWdCLGdCQTVVWTtBQTZVNUJDLFlBQVUsVUE3VWtCO0FBOFU1QkMsS0FBRyxHQTlVeUI7QUErVTVCQyxVQUFRLFFBL1VvQjtBQWdWNUJDLFFBQU0sTUFoVnNCO0FBaVY1QkMsUUFBTSxNQWpWc0I7QUFrVjVCQyxtQkFBaUIsaUJBbFZXO0FBbVY1QixzQkFBb0IsaUJBblZRO0FBb1Y1QkMsZUFBYSxhQXBWZTtBQXFWNUJDLGFBQVcsV0FyVmlCO0FBc1Y1QkMsc0JBQW9CLG9CQXRWUTtBQXVWNUJDLG9CQUFrQixrQkF2VlU7QUF3VjVCQyxZQUFVLFVBeFZrQjtBQXlWNUJDLFdBQVMsU0F6Vm1CO0FBMFY1QnB6RCxVQUFRLFFBMVZvQjtBQTJWNUJxekQsV0FBUyxTQTNWbUI7QUE0VjVCQyxVQUFRLFFBNVZvQjtBQTZWNUJDLE1BQUksSUE3VndCO0FBOFY1QkMsTUFBSSxJQTlWd0I7QUErVjVCQyxTQUFPLE9BL1ZxQjtBQWdXNUJDLFlBQVUsVUFoV2tCO0FBaVc1QkMsUUFBTSxNQWpXc0I7QUFrVzVCQyxrQkFBZ0IsZ0JBbFdZO0FBbVc1QixxQkFBbUIsZ0JBbldTO0FBb1c1QkMsU0FBTyxPQXBXcUI7QUFxVzVCQyxXQUFTLFNBcldtQjtBQXNXNUJDLG9CQUFrQixrQkF0V1U7QUF1VzVCQyxvQkFBa0Isa0JBdldVO0FBd1c1QkMsU0FBTyxPQXhXcUI7QUF5VzVCQyxnQkFBYyxjQXpXYztBQTBXNUJDLGVBQWEsYUExV2U7QUEyVzVCQyxnQkFBYyxjQTNXYztBQTRXNUJDLFNBQU8sT0E1V3FCO0FBNlc1QkMsU0FBTyxPQTdXcUI7QUE4VzVCQyxlQUFhLGFBOVdlO0FBK1c1QkMsYUFBVyxXQS9XaUI7QUFnWDVCLGdCQUFjLFdBaFhjO0FBaVg1QkMsZUFBYSxhQWpYZTtBQWtYNUIsa0JBQWdCLGFBbFhZO0FBbVg1QkMseUJBQXVCLHVCQW5YSztBQW9YNUIsNEJBQTBCLHVCQXBYRTtBQXFYNUJDLDBCQUF3Qix3QkFyWEk7QUFzWDVCLDZCQUEyQix3QkF0WEM7QUF1WDVCQyxVQUFRLFFBdlhvQjtBQXdYNUJDLFVBQVEsUUF4WG9CO0FBeVg1QkMsbUJBQWlCLGlCQXpYVztBQTBYNUIsc0JBQW9CLGlCQTFYUTtBQTJYNUJDLG9CQUFrQixrQkEzWFU7QUE0WDVCLHVCQUFxQixrQkE1WE87QUE2WDVCQyxpQkFBZSxlQTdYYTtBQThYNUIsb0JBQWtCLGVBOVhVO0FBK1g1QkMsa0JBQWdCLGdCQS9YWTtBQWdZNUIscUJBQW1CLGdCQWhZUztBQWlZNUJDLG9CQUFrQixrQkFqWVU7QUFrWTVCLHVCQUFxQixrQkFsWU87QUFtWTVCQyxlQUFhLGFBblllO0FBb1k1QixrQkFBZ0IsYUFwWVk7QUFxWTVCQyxpQkFBZSxlQXJZYTtBQXNZNUIsb0JBQWtCLGVBdFlVO0FBdVk1QkMsa0NBQWdDLGdDQXZZSjtBQXdZNUJDLDRCQUEwQiwwQkF4WUU7QUF5WTVCQyxnQkFBYyxjQXpZYztBQTBZNUJDLGtCQUFnQixnQkExWVk7QUEyWTVCQyxlQUFhLGFBM1llO0FBNFk1QkMsV0FBUyxTQTVZbUI7QUE2WTVCQyxXQUFTLFNBN1ltQjtBQThZNUJDLGNBQVksWUE5WWdCO0FBK1k1QixpQkFBZSxZQS9ZYTtBQWdaNUJDLGtCQUFnQixnQkFoWlk7QUFpWjVCLHFCQUFtQixnQkFqWlM7QUFrWjVCQyxjQUFZLFlBbFpnQjtBQW1aNUJDLGlCQUFlLGVBblphO0FBb1o1QixvQkFBa0IsZUFwWlU7QUFxWjVCcG1ELE1BQUksSUFyWndCO0FBc1o1QnFtRCxhQUFXLFdBdFppQjtBQXVaNUJDLFVBQVEsUUF2Wm9CO0FBd1o1QkMsTUFBSSxJQXhad0I7QUF5WjVCQyxNQUFJLElBelp3QjtBQTBaNUJDLHFCQUFtQixtQkExWlM7QUEyWjVCLHdCQUFzQixtQkEzWk07QUE0WjVCQyxzQkFBb0Isb0JBNVpRO0FBNlo1Qix5QkFBdUIsb0JBN1pLO0FBOFo1QkMsV0FBUyxTQTlabUI7QUErWjVCQyxlQUFhLGFBL1plO0FBZ2E1QixrQkFBZ0IsYUFoYVk7QUFpYTVCQyxnQkFBYyxjQWphYztBQWthNUIsbUJBQWlCLGNBbGFXO0FBbWE1QkMsY0FBWSxZQW5hZ0I7QUFvYTVCLGtCQUFnQixZQXBhWTtBQXFhNUJDLGdCQUFjLGNBcmFjO0FBc2E1QkMsZUFBYSxhQXRhZTtBQXVhNUIsa0JBQWdCLGFBdmFZO0FBd2E1QjluQyxVQUFRLFFBeGFvQjtBQXlhNUIrbkMsZ0JBQWMsY0F6YWM7QUEwYTVCLG1CQUFpQixjQTFhVztBQTJhNUJDLFdBQVMsU0EzYW1CO0FBNGE1QkMsWUFBVSxVQTVha0I7QUE2YTVCLGdCQUFjLFVBN2FjO0FBOGE1QkMsZUFBYSxhQTlhZTtBQSthNUIsbUJBQWlCLGFBL2FXO0FBZ2I1QkMsZUFBYSxhQWhiZTtBQWliNUIsbUJBQWlCLGFBamJXO0FBa2I1QkMsWUFBVSxVQWxia0I7QUFtYjVCLGVBQWEsVUFuYmU7QUFvYjVCQyxnQkFBYyxjQXBiYztBQXFiNUIsbUJBQWlCLGNBcmJXO0FBc2I1QkMsV0FBUyxTQXRibUI7QUF1YjVCQyxjQUFZLFlBdmJnQjtBQXdiNUJDLGNBQVksWUF4YmdCO0FBeWI1QkMsaUJBQWUsZUF6YmE7QUEwYjVCLG9CQUFrQixlQTFiVTtBQTJiNUJDLFNBQU8sT0EzYnFCO0FBNGI1QkMsVUFBUSxRQTVib0I7QUE2YjVCQyxlQUFhLGFBN2JlO0FBOGI1QixrQkFBZ0IsYUE5Ylk7QUErYjVCQyxlQUFhLGFBL2JlO0FBZ2M1QixrQkFBZ0IsYUFoY1k7QUFpYzVCQyxNQUFJLElBamN3QjtBQWtjNUJDLE1BQUksSUFsY3dCO0FBbWM1QjVqRSxLQUFHLEdBbmN5QjtBQW9jNUI2akUsb0JBQWtCLGtCQXBjVTtBQXFjNUJDLFdBQVMsU0FyY21CO0FBc2M1QixjQUFZLFNBdGNnQjtBQXVjNUJDLGdCQUFjLGNBdmNjO0FBd2M1QixtQkFBaUIsY0F4Y1c7QUF5YzVCQyxnQkFBYyxjQXpjYztBQTBjNUIsbUJBQWlCLGNBMWNXO0FBMmM1QkMsYUFBVyxXQTNjaUI7QUE0YzVCLGdCQUFjLFdBNWNjO0FBNmM1QkMsYUFBVyxXQTdjaUI7QUE4YzVCLGdCQUFjLFdBOWNjO0FBK2M1QkMsYUFBVyxXQS9jaUI7QUFnZDVCLGdCQUFjLFdBaGRjO0FBaWQ1QkMsY0FBWSxZQWpkZ0I7QUFrZDVCLGlCQUFlLFlBbGRhO0FBbWQ1QkMsYUFBVyxXQW5kaUI7QUFvZDVCLGdCQUFjLFdBcGRjO0FBcWQ1QkMsV0FBUyxTQXJkbUI7QUFzZDVCLGNBQVksU0F0ZGdCO0FBdWQ1QkMsV0FBUyxTQXZkbUI7QUF3ZDVCLGNBQVksU0F4ZGdCO0FBeWQ1QkMsU0FBTyxPQXpkcUI7QUEwZDVCLGVBQWEsVUExZGU7QUEyZDVCQyxjQUFZLFlBM2RnQjtBQTRkNUIsaUJBQWUsWUE1ZGE7QUE2ZDVCQyxZQUFVLFVBN2RrQjtBQThkNUJDLE1BQUksSUE5ZHdCO0FBK2Q1QkMsTUFBSSxJQS9kd0I7QUFnZTVCNTRCLEtBQUcsR0FoZXlCO0FBaWU1QjY0QixvQkFBa0Isa0JBamVVO0FBa2U1QkMsS0FBRyxHQWxleUI7QUFtZTVCQyxjQUFZO0FBbmVnQixDQUE5Qjs7a0JBc2VlelcscUI7Ozs7Ozs7Ozs7O0FDaGZmOzs7O0FBQ0E7Ozs7OztBQUVBLFNBQVMwVyxLQUFULEdBQWlCO0FBQUEsa0JBQ1cscUJBQVMsQ0FBVCxDQURYO0FBQUE7QUFBQSxNQUNSeDdDLEtBRFE7QUFBQSxNQUNEeTdDLFFBREM7O0FBR2YsU0FBUTtBQUFBO0FBQUE7QUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFxQno3QyxXQUFyQjtBQUFBO0FBQUEsS0FESTtBQUVKO0FBQUE7QUFBQSxRQUFRLFNBQVM7QUFBQSxpQkFBTXk3QyxTQUFTejdDLFFBQVEsQ0FBakIsQ0FBTjtBQUFBLFNBQWpCO0FBQUE7QUFBQTtBQUZJLEdBQVI7QUFNRDs7QUFFRDA3QyxtQkFBU3hoRSxNQUFULENBQWdCLDhCQUFDLEtBQUQsT0FBaEIsRUFBMkJvUSxTQUFTcXhELGNBQVQsQ0FBd0IsTUFBeEIsQ0FBM0IsRTs7Ozs7Ozs7Ozs7OztBQ1BBOzs7O0FBQ0E7O0FBUUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBTUE7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQVlBOztBQUtBOzs7O0FBQ0E7Ozs7QUEvQ0E7Ozs7Ozs7QUFpREEsSUFBTTc4RCxRQUFRO0FBQ1o4OEQsWUFBVTtBQUNSNWxFLDJCQURRO0FBRVJ3akIsbUNBRlE7QUFHUndHLCtCQUhRO0FBSVI2N0MsbUNBSlE7QUFLUkM7QUFMUSxHQURFOztBQVNaQyxzQ0FUWTtBQVVacHBELHdDQVZZO0FBV1pxcEQsZ0RBWFk7O0FBYVpDLDRDQWJZO0FBY1pDLGtDQWRZO0FBZVpDLHVCQWZZO0FBZ0JaQyxzQkFoQlk7O0FBa0JaOWUsc0NBbEJZO0FBbUJaQyxvQ0FuQlk7QUFvQlpDLGtDQXBCWTtBQXFCWkMsc0RBckJZO0FBc0JaTSwwQ0F0Qlk7QUF1QlpMLDhDQXZCWTtBQXdCWkMsOEJBeEJZO0FBeUJaQyxvQ0F6Qlk7QUEwQlpDLDRCQTFCWTtBQTJCWkMsZ0NBM0JZOztBQTZCWjNsRCxZQUFVc0IsaUNBN0JFO0FBOEJaNkosY0FBWTFKLG9DQTlCQTtBQStCWnlpRSxZQUFVeGlFLGlDQS9CRTs7QUFpQ1owUSxpQkFBZTVWLEtBQU9BLEdBQUcybkUsa0RBQVYsR0FBd0MveEQsMkJBakMzQztBQWtDWjh3QixnQkFBYzFtQyxLQUFPQSxHQUFHNG5FLGlEQUFWLEdBQXVDbGhDLDBCQWxDekM7QUFtQ1pGLGlCQUFleG1DLEtBQU9BLEdBQUc2bkUsa0RBQVYsR0FBd0NyaEMsMkJBbkMzQztBQW9DWkcsa0JBQWdCQSw0QkFwQ0o7O0FBc0NaKzlCLFdBQVNvRCxzQkF0Q0c7O0FBd0NaQywyQkFBeUJsakUsd0NBeENiO0FBeUNabWpFLHFCQUFtQmhqRSxpQ0F6Q1A7O0FBMkNab0Ysc0RBQW9EcEk7QUEzQ3hDLENBQWQ7O0FBOENBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUllLGlEQUFKLEVBQW9DO0FBQ2xDb0gsUUFBTXVFLGNBQU4sR0FBdUI3Six3Q0FBdkI7QUFDQXNGLFFBQU10RyxRQUFOLEdBQWlCbUIsaUNBQWpCO0FBQ0FtRixRQUFNNDlELHVCQUFOLEdBQWdDN25FLFNBQWhDO0FBQ0FpSyxRQUFNNjlELGlCQUFOLEdBQTBCOW5FLFNBQTFCO0FBQ0Q7O2tCQUVjaUssSzs7Ozs7Ozs7Ozs7Ozs7OFFDM0dmOzs7Ozs7O0FBT0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFFQSxJQUFNODlELGNBQWMsRUFBcEI7QUFDQSxJQUFJam9FLElBQUosRUFBYTtBQUNYcU0sU0FBT3NSLE1BQVAsQ0FBY3NxRCxXQUFkO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNqcUQsU0FBVCxDQUFtQnhJLEtBQW5CLEVBQTBCNkQsT0FBMUIsRUFBbUM0bkMsT0FBbkMsRUFBNEM7QUFDMUMsT0FBS3pyQyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxPQUFLNkQsT0FBTCxHQUFlQSxPQUFmO0FBQ0E7QUFDQSxPQUFLMGtDLElBQUwsR0FBWWtxQixXQUFaO0FBQ0E7QUFDQTtBQUNBLE9BQUtobkIsT0FBTCxHQUFlQSxXQUFXaW5CLDhCQUExQjtBQUNEOztBQUVEbHFELFVBQVV2YyxTQUFWLENBQW9COHJCLGdCQUFwQixHQUF1QyxFQUF2Qzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQXZQLFVBQVV2YyxTQUFWLENBQW9CMG1FLFFBQXBCLEdBQStCLFVBQVN2dkQsWUFBVCxFQUF1QmxCLFFBQXZCLEVBQWlDO0FBQzlELDJCQUNFLFFBQU9rQixZQUFQLHlDQUFPQSxZQUFQLE9BQXdCLFFBQXhCLElBQ0UsT0FBT0EsWUFBUCxLQUF3QixVQUQxQixJQUVFQSxnQkFBZ0IsSUFIcEIsRUFJRSxzRUFDRSxzREFMSjtBQU9BLE9BQUtxb0MsT0FBTCxDQUFhcEMsZUFBYixDQUE2QixJQUE3QixFQUFtQ2ptQyxZQUFuQyxFQUFpRGxCLFFBQWpELEVBQTJELFVBQTNEO0FBQ0QsQ0FURDs7QUFXQTs7Ozs7Ozs7Ozs7Ozs7QUFjQXNHLFVBQVV2YyxTQUFWLENBQW9CMm1FLFdBQXBCLEdBQWtDLFVBQVMxd0QsUUFBVCxFQUFtQjtBQUNuRCxPQUFLdXBDLE9BQUwsQ0FBYWxDLGtCQUFiLENBQWdDLElBQWhDLEVBQXNDcm5DLFFBQXRDLEVBQWdELGFBQWhEO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7QUFLQSxJQUFJMVgsSUFBSixFQUFhO0FBQ1gsTUFBTXFvRSxpQkFBaUI7QUFDckJsK0MsZUFBVyxDQUNULFdBRFMsRUFFVCwwRUFDRSwrQ0FITyxDQURVO0FBTXJCbStDLGtCQUFjLENBQ1osY0FEWSxFQUVaLHFEQUNFLGlEQUhVO0FBTk8sR0FBdkI7QUFZQSxNQUFNQywyQkFBMkIsU0FBM0JBLHdCQUEyQixDQUFTQyxVQUFULEVBQXFCbmhFLElBQXJCLEVBQTJCO0FBQzFEZ0YsV0FBT00sY0FBUCxDQUFzQnFSLFVBQVV2YyxTQUFoQyxFQUEyQyttRSxVQUEzQyxFQUF1RDtBQUNyRC82RCxXQUFLLGVBQVc7QUFDZCwwQ0FDRSxLQURGLEVBRUUsNkRBRkYsRUFHRXBHLEtBQUssQ0FBTCxDQUhGLEVBSUVBLEtBQUssQ0FBTCxDQUpGO0FBTUEsZUFBT25ILFNBQVA7QUFDRDtBQVRvRCxLQUF2RDtBQVdELEdBWkQ7QUFhQSxPQUFLLElBQU11b0UsTUFBWCxJQUFxQkosY0FBckIsRUFBcUM7QUFDbkMsUUFBSUEsZUFBZW44RCxjQUFmLENBQThCdThELE1BQTlCLENBQUosRUFBMkM7QUFDekNGLCtCQUF5QkUsTUFBekIsRUFBaUNKLGVBQWVJLE1BQWYsQ0FBakM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0MsY0FBVCxHQUEwQixDQUFFO0FBQzVCQSxlQUFlam5FLFNBQWYsR0FBMkJ1YyxVQUFVdmMsU0FBckM7O0FBRUE7OztBQUdBLFNBQVM0bEUsYUFBVCxDQUF1Qjd4RCxLQUF2QixFQUE4QjZELE9BQTlCLEVBQXVDNG5DLE9BQXZDLEVBQWdEO0FBQzlDLE9BQUt6ckMsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsT0FBSzZELE9BQUwsR0FBZUEsT0FBZjtBQUNBO0FBQ0EsT0FBSzBrQyxJQUFMLEdBQVlrcUIsV0FBWjtBQUNBLE9BQUtobkIsT0FBTCxHQUFlQSxXQUFXaW5CLDhCQUExQjtBQUNEOztBQUVELElBQU1TLHlCQUEwQnRCLGNBQWM1bEUsU0FBZCxHQUEwQixJQUFJaW5FLGNBQUosRUFBMUQ7QUFDQUMsdUJBQXVCMzhELFdBQXZCLEdBQXFDcTdELGFBQXJDO0FBQ0E7QUFDQWg3RCxPQUFPQyxNQUFQLENBQWNxOEQsc0JBQWQsRUFBc0MzcUQsVUFBVXZjLFNBQWhEO0FBQ0FrbkUsdUJBQXVCdnBCLG9CQUF2QixHQUE4QyxJQUE5Qzs7UUFFUXBoQyxTLEdBQUFBLFM7UUFBV3FwRCxhLEdBQUFBLGE7Ozs7Ozs7Ozs7Ozs7QUN6SW5COzs7Ozs7QUFFQSxJQUFNaDRDLDBDQUEwQyxFQUFoRCxDLENBVEE7Ozs7Ozs7QUFXQSxTQUFTdTVDLFFBQVQsQ0FBa0JDLGNBQWxCLEVBQWtDbHFCLFVBQWxDLEVBQThDO0FBQzVDLE1BQUkzK0MsSUFBSixFQUFhO0FBQ1gsUUFBTWdNLGVBQWM2OEQsZUFBZTc4RCxXQUFuQztBQUNBLFFBQU1vVCxnQkFDSHBULGlCQUFnQkEsYUFBWXZILFdBQVosSUFBMkJ1SCxhQUFZakwsSUFBdkQsQ0FBRCxJQUNBLFlBRkY7QUFHQSxRQUFNMmhDLGFBQWdCdGpCLGFBQWhCLFNBQWlDdS9CLFVBQXZDO0FBQ0EsUUFBSXR2Qix3Q0FBd0NxVCxVQUF4QyxDQUFKLEVBQXlEO0FBQ3ZEO0FBQ0Q7QUFDRCx1Q0FDRSxLQURGLEVBRUUsMkRBQ0Usb0VBREYsR0FFRSxxRUFGRixHQUdFLDREQUxKLEVBTUVpYyxVQU5GLEVBT0V2L0IsYUFQRjtBQVNBaVEsNENBQXdDcVQsVUFBeEMsSUFBc0QsSUFBdEQ7QUFDRDtBQUNGOztBQUVEOzs7QUFHQSxJQUFNd2xDLHVCQUF1QjtBQUMzQjs7Ozs7OztBQU9BLzlDLGFBQVcsbUJBQVMwK0MsY0FBVCxFQUF5QjtBQUNsQyxXQUFPLEtBQVA7QUFDRCxHQVYwQjs7QUFZM0I7Ozs7Ozs7Ozs7Ozs7OztBQWVBOXBCLHNCQUFvQiw0QkFBUzhwQixjQUFULEVBQXlCbnhELFFBQXpCLEVBQW1DaW5DLFVBQW5DLEVBQStDO0FBQ2pFaXFCLGFBQVNDLGNBQVQsRUFBeUIsYUFBekI7QUFDRCxHQTdCMEI7O0FBK0IzQjs7Ozs7Ozs7Ozs7OztBQWFBL3BCLHVCQUFxQiw2QkFDbkIrcEIsY0FEbUIsRUFFbkJDLGFBRm1CLEVBR25CcHhELFFBSG1CLEVBSW5CaW5DLFVBSm1CLEVBS25CO0FBQ0FpcUIsYUFBU0MsY0FBVCxFQUF5QixjQUF6QjtBQUNELEdBbkQwQjs7QUFxRDNCOzs7Ozs7Ozs7Ozs7QUFZQWhxQixtQkFBaUIseUJBQ2ZncUIsY0FEZSxFQUVmandELFlBRmUsRUFHZmxCLFFBSGUsRUFJZmluQyxVQUplLEVBS2Y7QUFDQWlxQixhQUFTQyxjQUFULEVBQXlCLFVBQXpCO0FBQ0Q7QUF4RTBCLENBQTdCOztrQkEyRWVYLG9COzs7Ozs7Ozs7Ozs7UUNyR0NkLFMsR0FBQUEsUzs7O0FBRGhCO0FBQ08sU0FBU0EsU0FBVCxHQUFnQztBQUNyQyxNQUFNM2YsWUFBWTtBQUNoQmpnRCxhQUFTO0FBRE8sR0FBbEI7QUFHQSxNQUFJeEgsSUFBSixFQUFhO0FBQ1hxTSxXQUFPazZDLElBQVAsQ0FBWWtCLFNBQVo7QUFDRDtBQUNELFNBQU9BLFNBQVA7QUFDRCxDLENBbkJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4UUNBQTs7Ozs7OztBQU9BOzs7O0FBQ0E7Ozs7QUFDQTs7QUFLQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTXNoQixZQUFZLEdBQWxCO0FBQ0EsSUFBTUMsZUFBZSxHQUFyQjs7QUFFQTs7Ozs7O0FBTUEsU0FBU0MsTUFBVCxDQUFnQnZxRCxHQUFoQixFQUFxQjtBQUNuQixNQUFNd3FELGNBQWMsT0FBcEI7QUFDQSxNQUFNQyxnQkFBZ0I7QUFDcEIsU0FBSyxJQURlO0FBRXBCLFNBQUs7QUFGZSxHQUF0QjtBQUlBLE1BQU1DLGdCQUFnQixDQUFDLEtBQUsxcUQsR0FBTixFQUFXNWQsT0FBWCxDQUFtQm9vRSxXQUFuQixFQUFnQyxVQUFTcDFCLEtBQVQsRUFBZ0I7QUFDcEUsV0FBT3ExQixjQUFjcjFCLEtBQWQsQ0FBUDtBQUNELEdBRnFCLENBQXRCOztBQUlBLFNBQU8sTUFBTXMxQixhQUFiO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsSUFBSUMsbUJBQW1CLEtBQXZCOztBQUVBLElBQU1DLDZCQUE2QixNQUFuQztBQUNBLFNBQVNDLHFCQUFULENBQStCaHRDLElBQS9CLEVBQXFDO0FBQ25DLFNBQU8sQ0FBQyxLQUFLQSxJQUFOLEVBQVl6N0IsT0FBWixDQUFvQndvRSwwQkFBcEIsRUFBZ0QsS0FBaEQsQ0FBUDtBQUNEOztBQUVELElBQU1FLFlBQVksRUFBbEI7QUFDQSxJQUFNQyxzQkFBc0IsRUFBNUI7QUFDQSxTQUFTQyx3QkFBVCxDQUNFQyxTQURGLEVBRUVDLFNBRkYsRUFHRUMsV0FIRixFQUlFQyxVQUpGLEVBS0U7QUFDQSxNQUFJTCxvQkFBb0J2b0UsTUFBeEIsRUFBZ0M7QUFDOUIsUUFBTTZvRSxrQkFBa0JOLG9CQUFvQnI3RCxHQUFwQixFQUF4QjtBQUNBMjdELG9CQUFnQmw4RCxNQUFoQixHQUF5Qjg3RCxTQUF6QjtBQUNBSSxvQkFBZ0JILFNBQWhCLEdBQTRCQSxTQUE1QjtBQUNBRyxvQkFBZ0Jyc0MsSUFBaEIsR0FBdUJtc0MsV0FBdkI7QUFDQUUsb0JBQWdCMXdELE9BQWhCLEdBQTBCeXdELFVBQTFCO0FBQ0FDLG9CQUFnQjErQyxLQUFoQixHQUF3QixDQUF4QjtBQUNBLFdBQU8wK0MsZUFBUDtBQUNELEdBUkQsTUFRTztBQUNMLFdBQU87QUFDTGw4RCxjQUFRODdELFNBREg7QUFFTEMsaUJBQVdBLFNBRk47QUFHTGxzQyxZQUFNbXNDLFdBSEQ7QUFJTHh3RCxlQUFTeXdELFVBSko7QUFLTHorQyxhQUFPO0FBTEYsS0FBUDtBQU9EO0FBQ0Y7O0FBRUQsU0FBUzIrQyxzQkFBVCxDQUFnQ0QsZUFBaEMsRUFBaUQ7QUFDL0NBLGtCQUFnQmw4RCxNQUFoQixHQUF5QixJQUF6QjtBQUNBazhELGtCQUFnQkgsU0FBaEIsR0FBNEIsSUFBNUI7QUFDQUcsa0JBQWdCcnNDLElBQWhCLEdBQXVCLElBQXZCO0FBQ0Fxc0Msa0JBQWdCMXdELE9BQWhCLEdBQTBCLElBQTFCO0FBQ0Ewd0Qsa0JBQWdCMStDLEtBQWhCLEdBQXdCLENBQXhCO0FBQ0EsTUFBSW8rQyxvQkFBb0J2b0UsTUFBcEIsR0FBNkJzb0UsU0FBakMsRUFBNEM7QUFDMUNDLHdCQUFvQm43RCxJQUFwQixDQUF5Qnk3RCxlQUF6QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU0UsdUJBQVQsQ0FDRW44QyxRQURGLEVBRUVvOEMsU0FGRixFQUdFeHlELFFBSEYsRUFJRXF5RCxlQUpGLEVBS0U7QUFDQSxNQUFNcGxFLGNBQWNtcEIsUUFBZCx5Q0FBY0EsUUFBZCxDQUFOOztBQUVBLE1BQUlucEIsU0FBUyxXQUFULElBQXdCQSxTQUFTLFNBQXJDLEVBQWdEO0FBQzlDO0FBQ0FtcEIsZUFBVyxJQUFYO0FBQ0Q7O0FBRUQsTUFBSXE4QyxpQkFBaUIsS0FBckI7O0FBRUEsTUFBSXI4QyxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCcThDLHFCQUFpQixJQUFqQjtBQUNELEdBRkQsTUFFTztBQUNMLFlBQVF4bEUsSUFBUjtBQUNFLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFd2xFLHlCQUFpQixJQUFqQjtBQUNBO0FBQ0YsV0FBSyxRQUFMO0FBQ0UsZ0JBQVFyOEMsU0FBUzNvQixRQUFqQjtBQUNFLGVBQUthLGdDQUFMO0FBQ0EsZUFBS2pCLCtCQUFMO0FBQ0VvbEUsNkJBQWlCLElBQWpCO0FBSEo7QUFOSjtBQVlEOztBQUVELE1BQUlBLGNBQUosRUFBb0I7QUFDbEJ6eUQsYUFDRXF5RCxlQURGLEVBRUVqOEMsUUFGRjtBQUdFO0FBQ0E7QUFDQW84QyxrQkFBYyxFQUFkLEdBQW1CbkIsWUFBWXFCLGdCQUFnQnQ4QyxRQUFoQixFQUEwQixDQUExQixDQUEvQixHQUE4RG84QyxTQUxoRTtBQU9BLFdBQU8sQ0FBUDtBQUNEOztBQUVELE1BQUl6dUQsY0FBSjtBQUNBLE1BQUk0dUQsaUJBQUo7QUFDQSxNQUFJQyxlQUFlLENBQW5CLENBeENBLENBd0NzQjtBQUN0QixNQUFNQyxpQkFDSkwsY0FBYyxFQUFkLEdBQW1CbkIsU0FBbkIsR0FBK0JtQixZQUFZbEIsWUFEN0M7O0FBR0EsTUFBSXZtRCxNQUFNMm1CLE9BQU4sQ0FBY3RiLFFBQWQsQ0FBSixFQUE2QjtBQUMzQixTQUFLLElBQUlqTixJQUFJLENBQWIsRUFBZ0JBLElBQUlpTixTQUFTNXNCLE1BQTdCLEVBQXFDMmYsR0FBckMsRUFBMEM7QUFDeENwRixjQUFRcVMsU0FBU2pOLENBQVQsQ0FBUjtBQUNBd3BELGlCQUFXRSxpQkFBaUJILGdCQUFnQjN1RCxLQUFoQixFQUF1Qm9GLENBQXZCLENBQTVCO0FBQ0F5cEQsc0JBQWdCTCx3QkFDZHh1RCxLQURjLEVBRWQ0dUQsUUFGYyxFQUdkM3lELFFBSGMsRUFJZHF5RCxlQUpjLENBQWhCO0FBTUQ7QUFDRixHQVhELE1BV087QUFDTCxRQUFNUyxhQUFhLGlDQUFjMThDLFFBQWQsQ0FBbkI7QUFDQSxRQUFJLE9BQU8wOEMsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNwQyxVQUFJeHFFLElBQUosRUFBYTtBQUNYO0FBQ0EsWUFBSXdxRSxlQUFlMThDLFNBQVMyOEMsT0FBNUIsRUFBcUM7QUFDbkMsaUNBQ0VwQixnQkFERixFQUVFLGlFQUNFLGlFQURGLEdBRUUsd0JBSko7QUFNQUEsNkJBQW1CLElBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxVQUFNbGpFLFdBQVdxa0UsV0FBVzdvRSxJQUFYLENBQWdCbXNCLFFBQWhCLENBQWpCO0FBQ0EsVUFBSXNwQyxhQUFKO0FBQ0EsVUFBSXNULEtBQUssQ0FBVDtBQUNBLGFBQU8sQ0FBQyxDQUFDdFQsT0FBT2p4RCxTQUFTd1IsSUFBVCxFQUFSLEVBQXlCZ3pELElBQWpDLEVBQXVDO0FBQ3JDbHZELGdCQUFRMjdDLEtBQUtoekMsS0FBYjtBQUNBaW1ELG1CQUFXRSxpQkFBaUJILGdCQUFnQjN1RCxLQUFoQixFQUF1Qml2RCxJQUF2QixDQUE1QjtBQUNBSix3QkFBZ0JMLHdCQUNkeHVELEtBRGMsRUFFZDR1RCxRQUZjLEVBR2QzeUQsUUFIYyxFQUlkcXlELGVBSmMsQ0FBaEI7QUFNRDtBQUNGLEtBM0JELE1BMkJPLElBQUlwbEUsU0FBUyxRQUFiLEVBQXVCO0FBQzVCLFVBQUl1b0QsV0FBVyxFQUFmO0FBQ0EsVUFBSWx0RCxJQUFKLEVBQWE7QUFDWGt0RCxtQkFDRSxvRUFDQSxVQURBLEdBRUFuckQsaUNBQXVCRyxnQkFBdkIsRUFIRjtBQUlEO0FBQ0QsVUFBTTBvRSxpQkFBaUIsS0FBSzk4QyxRQUE1QjtBQUNBLCtCQUNFLEtBREYsRUFFRSx1REFGRixFQUdFODhDLG1CQUFtQixpQkFBbkIsR0FDSSx1QkFBdUJ2K0QsT0FBTzRoQixJQUFQLENBQVlILFFBQVosRUFBc0JvaEIsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBdkIsR0FBMEQsR0FEOUQsR0FFSTA3QixjQUxOLEVBTUUxZCxRQU5GO0FBUUQ7QUFDRjs7QUFFRCxTQUFPb2QsWUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFNBQVNPLG1CQUFULENBQTZCLzhDLFFBQTdCLEVBQXVDcFcsUUFBdkMsRUFBaURxeUQsZUFBakQsRUFBa0U7QUFDaEUsTUFBSWo4QyxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFdBQU8sQ0FBUDtBQUNEOztBQUVELFNBQU9tOEMsd0JBQXdCbjhDLFFBQXhCLEVBQWtDLEVBQWxDLEVBQXNDcFcsUUFBdEMsRUFBZ0RxeUQsZUFBaEQsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU0ssZUFBVCxDQUF5QlUsU0FBekIsRUFBb0NsK0MsS0FBcEMsRUFBMkM7QUFDekM7QUFDQTtBQUNBLE1BQ0UsUUFBT2srQyxTQUFQLHlDQUFPQSxTQUFQLE9BQXFCLFFBQXJCLElBQ0FBLGNBQWMsSUFEZCxJQUVBQSxVQUFVcHNELEdBQVYsSUFBaUIsSUFIbkIsRUFJRTtBQUNBO0FBQ0EsV0FBT3VxRCxPQUFPNkIsVUFBVXBzRCxHQUFqQixDQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQU9rTyxNQUFNNVgsUUFBTixDQUFlLEVBQWYsQ0FBUDtBQUNEOztBQUVELFNBQVMrMUQsa0JBQVQsQ0FBNEJwd0IsV0FBNUIsRUFBeUNsL0IsS0FBekMsRUFBZ0QxYSxJQUFoRCxFQUFzRDtBQUFBLE1BQzdDMjhCLElBRDZDLEdBQzVCaWQsV0FENEIsQ0FDN0NqZCxJQUQ2QztBQUFBLE1BQ3ZDcmtCLE9BRHVDLEdBQzVCc2hDLFdBRDRCLENBQ3ZDdGhDLE9BRHVDOztBQUVwRHFrQixPQUFLLzdCLElBQUwsQ0FBVTBYLE9BQVYsRUFBbUJvQyxLQUFuQixFQUEwQmsvQixZQUFZdHZCLEtBQVosRUFBMUI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUEsU0FBUzIvQyxlQUFULENBQXlCbDlDLFFBQXpCLEVBQW1DbTlDLFdBQW5DLEVBQWdEQyxjQUFoRCxFQUFnRTtBQUM5RCxNQUFJcDlDLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsV0FBT0EsUUFBUDtBQUNEO0FBQ0QsTUFBTWk4QyxrQkFBa0JMLHlCQUN0QixJQURzQixFQUV0QixJQUZzQixFQUd0QnVCLFdBSHNCLEVBSXRCQyxjQUpzQixDQUF4QjtBQU1BTCxzQkFBb0IvOEMsUUFBcEIsRUFBOEJpOUMsa0JBQTlCLEVBQWtEaEIsZUFBbEQ7QUFDQUMseUJBQXVCRCxlQUF2QjtBQUNEOztBQUVELFNBQVNvQix5QkFBVCxDQUFtQ3h3QixXQUFuQyxFQUFnRGwvQixLQUFoRCxFQUF1RDJ2RCxRQUF2RCxFQUFpRTtBQUFBLE1BQ3hEdjlELE1BRHdELEdBQ3BCOHNDLFdBRG9CLENBQ3hEOXNDLE1BRHdEO0FBQUEsTUFDaEQrN0QsU0FEZ0QsR0FDcEJqdkIsV0FEb0IsQ0FDaERpdkIsU0FEZ0Q7QUFBQSxNQUNyQ2xzQyxJQURxQyxHQUNwQmlkLFdBRG9CLENBQ3JDamQsSUFEcUM7QUFBQSxNQUMvQnJrQixPQUQrQixHQUNwQnNoQyxXQURvQixDQUMvQnRoQyxPQUQrQjs7O0FBRy9ELE1BQUlneUQsY0FBYzN0QyxLQUFLLzdCLElBQUwsQ0FBVTBYLE9BQVYsRUFBbUJvQyxLQUFuQixFQUEwQmsvQixZQUFZdHZCLEtBQVosRUFBMUIsQ0FBbEI7QUFDQSxNQUFJNUksTUFBTTJtQixPQUFOLENBQWNpaUMsV0FBZCxDQUFKLEVBQWdDO0FBQzlCQyxpQ0FBNkJELFdBQTdCLEVBQTBDeDlELE1BQTFDLEVBQWtEdTlELFFBQWxELEVBQTREO0FBQUEsYUFBSzdxRSxDQUFMO0FBQUEsS0FBNUQ7QUFDRCxHQUZELE1BRU8sSUFBSThxRSxlQUFlLElBQW5CLEVBQXlCO0FBQzlCLFFBQUksa0NBQWVBLFdBQWYsQ0FBSixFQUFpQztBQUMvQkEsb0JBQWMsc0NBQ1pBLFdBRFk7QUFFWjtBQUNBO0FBQ0F6QixtQkFDR3lCLFlBQVkzc0QsR0FBWixLQUFvQixDQUFDakQsS0FBRCxJQUFVQSxNQUFNaUQsR0FBTixLQUFjMnNELFlBQVkzc0QsR0FBeEQsSUFDRzZxRCxzQkFBc0I4QixZQUFZM3NELEdBQWxDLElBQXlDLEdBRDVDLEdBRUcsRUFITixJQUlFMHNELFFBUlUsQ0FBZDtBQVVEO0FBQ0R2OUQsV0FBT1MsSUFBUCxDQUFZKzhELFdBQVo7QUFDRDtBQUNGOztBQUVELFNBQVNDLDRCQUFULENBQXNDeDlDLFFBQXRDLEVBQWdEa2hCLEtBQWhELEVBQXVEMXFCLE1BQXZELEVBQStEb1osSUFBL0QsRUFBcUVya0IsT0FBckUsRUFBOEU7QUFDNUUsTUFBSWt5RCxnQkFBZ0IsRUFBcEI7QUFDQSxNQUFJam5ELFVBQVUsSUFBZCxFQUFvQjtBQUNsQmluRCxvQkFBZ0JoQyxzQkFBc0JqbEQsTUFBdEIsSUFBZ0MsR0FBaEQ7QUFDRDtBQUNELE1BQU15bEQsa0JBQWtCTCx5QkFDdEIxNkIsS0FEc0IsRUFFdEJ1OEIsYUFGc0IsRUFHdEI3dEMsSUFIc0IsRUFJdEJya0IsT0FKc0IsQ0FBeEI7QUFNQXd4RCxzQkFBb0IvOEMsUUFBcEIsRUFBOEJxOUMseUJBQTlCLEVBQXlEcEIsZUFBekQ7QUFDQUMseUJBQXVCRCxlQUF2QjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7O0FBYUEsU0FBU3lCLFdBQVQsQ0FBcUIxOUMsUUFBckIsRUFBK0I0UCxJQUEvQixFQUFxQ3JrQixPQUFyQyxFQUE4QztBQUM1QyxNQUFJeVUsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixXQUFPQSxRQUFQO0FBQ0Q7QUFDRCxNQUFNamdCLFNBQVMsRUFBZjtBQUNBeTlELCtCQUE2Qng5QyxRQUE3QixFQUF1Q2pnQixNQUF2QyxFQUErQyxJQUEvQyxFQUFxRDZ2QixJQUFyRCxFQUEyRHJrQixPQUEzRDtBQUNBLFNBQU94TCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVM0OUQsYUFBVCxDQUF1QjM5QyxRQUF2QixFQUFpQztBQUMvQixTQUFPKzhDLG9CQUFvQi84QyxRQUFwQixFQUE4QjtBQUFBLFdBQU0sSUFBTjtBQUFBLEdBQTlCLEVBQTBDLElBQTFDLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU281QyxPQUFULENBQWlCcDVDLFFBQWpCLEVBQTJCO0FBQ3pCLE1BQU1qZ0IsU0FBUyxFQUFmO0FBQ0F5OUQsK0JBQTZCeDlDLFFBQTdCLEVBQXVDamdCLE1BQXZDLEVBQStDLElBQS9DLEVBQXFEO0FBQUEsV0FBUzROLEtBQVQ7QUFBQSxHQUFyRDtBQUNBLFNBQU81TixNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBUzY5RCxTQUFULENBQW1CNTlDLFFBQW5CLEVBQTZCO0FBQzNCLDJCQUNFLGtDQUFlQSxRQUFmLENBREYsRUFFRSx1RUFGRjtBQUlBLFNBQU9BLFFBQVA7QUFDRDs7UUFHb0JqSixPLEdBQW5CbW1ELGU7UUFDZTNwRSxHLEdBQWZtcUUsVztRQUNpQm5nRCxLLEdBQWpCb2dELGE7UUFDYXRFLEksR0FBYnVFLFM7UUFDQXhFLE8sR0FBQUEsTzs7Ozs7OztBQzlZRjs7Ozs7O0FBTWE7QUFDYjs7QUFDQSxJQUFJeUUsd0JBQXdCdC9ELE9BQU9zL0QscUJBQW5DO0FBQ0EsSUFBSXovRCxpQkFBaUJHLE9BQU81SyxTQUFQLENBQWlCeUssY0FBdEM7QUFDQSxJQUFJMC9ELG1CQUFtQnYvRCxPQUFPNUssU0FBUCxDQUFpQm9xRSxvQkFBeEM7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQnArRCxHQUFsQixFQUF1QjtBQUN0QixLQUFJQSxRQUFRLElBQVIsSUFBZ0JBLFFBQVF4TixTQUE1QixFQUF1QztBQUN0QyxRQUFNLElBQUk2ckUsU0FBSixDQUFjLHVEQUFkLENBQU47QUFDQTs7QUFFRCxRQUFPMS9ELE9BQU9xQixHQUFQLENBQVA7QUFDQTs7QUFFRCxTQUFTcytELGVBQVQsR0FBMkI7QUFDMUIsS0FBSTtBQUNILE1BQUksQ0FBQzMvRCxPQUFPQyxNQUFaLEVBQW9CO0FBQ25CLFVBQU8sS0FBUDtBQUNBOztBQUVEOztBQUVBO0FBQ0EsTUFBSTIvRCxRQUFRLElBQUlDLE1BQUosQ0FBVyxLQUFYLENBQVosQ0FSRyxDQVE2QjtBQUNoQ0QsUUFBTSxDQUFOLElBQVcsSUFBWDtBQUNBLE1BQUk1L0QsT0FBTzgvRCxtQkFBUCxDQUEyQkYsS0FBM0IsRUFBa0MsQ0FBbEMsTUFBeUMsR0FBN0MsRUFBa0Q7QUFDakQsVUFBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQSxNQUFJRyxRQUFRLEVBQVo7QUFDQSxPQUFLLElBQUl2ckQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEVBQXBCLEVBQXdCQSxHQUF4QixFQUE2QjtBQUM1QnVyRCxTQUFNLE1BQU1GLE9BQU9HLFlBQVAsQ0FBb0J4ckQsQ0FBcEIsQ0FBWixJQUFzQ0EsQ0FBdEM7QUFDQTtBQUNELE1BQUl5ckQsU0FBU2pnRSxPQUFPOC9ELG1CQUFQLENBQTJCQyxLQUEzQixFQUFrQy9xRSxHQUFsQyxDQUFzQyxVQUFVb2lELENBQVYsRUFBYTtBQUMvRCxVQUFPMm9CLE1BQU0zb0IsQ0FBTixDQUFQO0FBQ0EsR0FGWSxDQUFiO0FBR0EsTUFBSTZvQixPQUFPcDlCLElBQVAsQ0FBWSxFQUFaLE1BQW9CLFlBQXhCLEVBQXNDO0FBQ3JDLFVBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0EsTUFBSXE5QixRQUFRLEVBQVo7QUFDQSx5QkFBdUJDLEtBQXZCLENBQTZCLEVBQTdCLEVBQWlDM25ELE9BQWpDLENBQXlDLFVBQVU0bkQsTUFBVixFQUFrQjtBQUMxREYsU0FBTUUsTUFBTixJQUFnQkEsTUFBaEI7QUFDQSxHQUZEO0FBR0EsTUFBSXBnRSxPQUFPNGhCLElBQVAsQ0FBWTVoQixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQmlnRSxLQUFsQixDQUFaLEVBQXNDcjlCLElBQXRDLENBQTJDLEVBQTNDLE1BQ0Ysc0JBREYsRUFDMEI7QUFDekIsVUFBTyxLQUFQO0FBQ0E7O0FBRUQsU0FBTyxJQUFQO0FBQ0EsRUFyQ0QsQ0FxQ0UsT0FBT25sQixHQUFQLEVBQVk7QUFDYjtBQUNBLFNBQU8sS0FBUDtBQUNBO0FBQ0Q7O0FBRURsSyxPQUFPQyxPQUFQLEdBQWlCa3NELG9CQUFvQjMvRCxPQUFPQyxNQUEzQixHQUFvQyxVQUFVOUIsTUFBVixFQUFrQnZELE1BQWxCLEVBQTBCO0FBQzlFLEtBQUlzVyxJQUFKO0FBQ0EsS0FBSUMsS0FBS3N1RCxTQUFTdGhFLE1BQVQsQ0FBVDtBQUNBLEtBQUlraUUsT0FBSjs7QUFFQSxNQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSXgvRCxVQUFVak0sTUFBOUIsRUFBc0N5ckUsR0FBdEMsRUFBMkM7QUFDMUNwdkQsU0FBT2xSLE9BQU9jLFVBQVV3L0QsQ0FBVixDQUFQLENBQVA7O0FBRUEsT0FBSyxJQUFJanVELEdBQVQsSUFBZ0JuQixJQUFoQixFQUFzQjtBQUNyQixPQUFJclIsZUFBZXZLLElBQWYsQ0FBb0I0YixJQUFwQixFQUEwQm1CLEdBQTFCLENBQUosRUFBb0M7QUFDbkNsQixPQUFHa0IsR0FBSCxJQUFVbkIsS0FBS21CLEdBQUwsQ0FBVjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSWl0RCxxQkFBSixFQUEyQjtBQUMxQmUsYUFBVWYsc0JBQXNCcHVELElBQXRCLENBQVY7QUFDQSxRQUFLLElBQUlzRCxJQUFJLENBQWIsRUFBZ0JBLElBQUk2ckQsUUFBUXhyRSxNQUE1QixFQUFvQzJmLEdBQXBDLEVBQXlDO0FBQ3hDLFFBQUkrcUQsaUJBQWlCanFFLElBQWpCLENBQXNCNGIsSUFBdEIsRUFBNEJtdkQsUUFBUTdyRCxDQUFSLENBQTVCLENBQUosRUFBNkM7QUFDNUNyRCxRQUFHa3ZELFFBQVE3ckQsQ0FBUixDQUFILElBQWlCdEQsS0FBS212RCxRQUFRN3JELENBQVIsQ0FBTCxDQUFqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFFBQU9yRCxFQUFQO0FBQ0EsQ0F6QkQsQzs7Ozs7Ozs7Ozs7Ozs7OFFDaEVBOzs7Ozs7OztBQVFBOztBQUVBOztBQUVBO0FBQ0EsSUFBSThaLG9CQUFvQixDQUF4QjtBQUNBLElBQUlDLHVCQUF1QixDQUEzQjtBQUNBLElBQUlwRSxpQkFBaUIsQ0FBckI7QUFDQSxJQUFJcUUsY0FBYyxDQUFsQjtBQUNBLElBQUlDLGVBQWUsQ0FBbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSW0xQyxvQkFBb0IsVUFBeEI7O0FBRUE7QUFDQSxJQUFJQyw2QkFBNkIsQ0FBQyxDQUFsQztBQUNBO0FBQ0EsSUFBSUMseUJBQXlCLEdBQTdCO0FBQ0EsSUFBSUMsMEJBQTBCLElBQTlCO0FBQ0EsSUFBSUMsdUJBQXVCLEtBQTNCO0FBQ0E7QUFDQSxJQUFJQyxnQkFBZ0JMLGlCQUFwQjs7QUFFQTtBQUNBLElBQUlNLG9CQUFvQixJQUF4Qjs7QUFFQSxJQUFJQyxvQkFBb0IsS0FBeEI7QUFDQTtBQUNBLElBQUlDLG9CQUFvQixLQUF4Qjs7QUFFQSxJQUFJQyx1QkFBdUJsNkMsY0FBM0I7QUFDQSxJQUFJbTZDLHdCQUF3QixDQUFDLENBQTdCO0FBQ0EsSUFBSUMsd0JBQXdCLENBQUMsQ0FBN0I7O0FBRUE7QUFDQSxJQUFJQyxzQkFBc0IsS0FBMUI7O0FBRUEsSUFBSUMsMEJBQTBCLEtBQTlCOztBQUVBLElBQUlDLDBCQUNGLFFBQU9ybEQsV0FBUCx5Q0FBT0EsV0FBUCxPQUF1QixRQUF2QixJQUFtQyxPQUFPQSxZQUFZcmQsR0FBbkIsS0FBMkIsVUFEaEU7O0FBR0EsU0FBUzJpRSw2QkFBVCxHQUF5QztBQUN2QyxNQUFJSCxtQkFBSixFQUF5QjtBQUN2QjtBQUNBO0FBQ0Q7QUFDRDtBQUNBLE1BQUlqa0UsaUJBQWlCMmpFLGtCQUFrQjNqRSxjQUF2QztBQUNBLE1BQUksQ0FBQ2trRSx1QkFBTCxFQUE4QjtBQUM1QkEsOEJBQTBCLElBQTFCO0FBQ0QsR0FGRCxNQUVPO0FBQ0w7QUFDQUc7QUFDRDtBQUNEQyx1QkFBb0JDLFNBQXBCLEVBQStCdmtFLGNBQS9CO0FBQ0Q7O0FBRUQsU0FBU3drRSxrQkFBVCxHQUE4QjtBQUM1QixNQUFJQyxjQUFjZCxpQkFBbEI7O0FBRUE7QUFDQTtBQUNBLE1BQUl2MUQsT0FBT3UxRCxrQkFBa0J2MUQsSUFBN0I7QUFDQSxNQUFJdTFELHNCQUFzQnYxRCxJQUExQixFQUFnQztBQUM5QjtBQUNBdTFELHdCQUFvQixJQUFwQjtBQUNBdjFELFdBQU8sSUFBUDtBQUNELEdBSkQsTUFJTztBQUNMLFFBQUlzMkQsbUJBQW1CZixrQkFBa0JnQixRQUF6QztBQUNBaEIsd0JBQW9CZSxpQkFBaUJ0MkQsSUFBakIsR0FBd0JBLElBQTVDO0FBQ0FBLFNBQUt1MkQsUUFBTCxHQUFnQkQsZ0JBQWhCO0FBQ0Q7O0FBRURELGNBQVlyMkQsSUFBWixHQUFtQnEyRCxZQUFZRSxRQUFaLEdBQXVCLElBQTFDOztBQUVBO0FBQ0EsTUFBSXgyRCxXQUFXczJELFlBQVl0MkQsUUFBM0I7QUFDQSxNQUFJbk8saUJBQWlCeWtFLFlBQVl6a0UsY0FBakM7QUFDQSxNQUFJOHRCLGdCQUFnQjIyQyxZQUFZMzJDLGFBQWhDO0FBQ0EsTUFBSTgyQyx3QkFBd0JkLG9CQUE1QjtBQUNBLE1BQUllLHlCQUF5QmIscUJBQTdCO0FBQ0FGLHlCQUF1QmgyQyxhQUF2QjtBQUNBazJDLDBCQUF3QmhrRSxjQUF4QjtBQUNBLE1BQUk4a0Usb0JBQUo7QUFDQSxNQUFJO0FBQ0ZBLDJCQUF1QjMyRCxVQUF2QjtBQUNELEdBRkQsU0FFVTtBQUNSMjFELDJCQUF1QmMscUJBQXZCO0FBQ0FaLDRCQUF3QmEsc0JBQXhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUksT0FBT0Msb0JBQVAsS0FBZ0MsVUFBcEMsRUFBZ0Q7QUFDOUMsUUFBSUMsbUJBQWlDO0FBQ25DNTJELGdCQUFVMjJELG9CQUR5QjtBQUVuQ2gzQyxrQ0FGbUM7QUFHbkM5dEIsb0NBSG1DO0FBSW5Db08sWUFBTSxJQUo2QjtBQUtuQ3UyRCxnQkFBVTtBQUx5QixLQUFyQzs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUloQixzQkFBc0IsSUFBMUIsRUFBZ0M7QUFDOUI7QUFDQUEsMEJBQW9Cb0IsaUJBQWlCMzJELElBQWpCLEdBQXdCMjJELGlCQUFpQkosUUFBakIsR0FBNEJJLGdCQUF4RTtBQUNELEtBSEQsTUFHTztBQUNMLFVBQUlDLHdCQUF3QixJQUE1QjtBQUNBLFVBQUlqbkUsT0FBTzRsRSxpQkFBWDtBQUNBLFNBQUc7QUFDRCxZQUFJNWxFLEtBQUtpQyxjQUFMLElBQXVCQSxjQUEzQixFQUEyQztBQUN6QztBQUNBO0FBQ0FnbEUsa0NBQXdCam5FLElBQXhCO0FBQ0E7QUFDRDtBQUNEQSxlQUFPQSxLQUFLcVEsSUFBWjtBQUNELE9BUkQsUUFRU3JRLFNBQVM0bEUsaUJBUmxCOztBQVVBLFVBQUlxQiwwQkFBMEIsSUFBOUIsRUFBb0M7QUFDbEM7QUFDQTtBQUNBQSxnQ0FBd0JyQixpQkFBeEI7QUFDRCxPQUpELE1BSU8sSUFBSXFCLDBCQUEwQnJCLGlCQUE5QixFQUFpRDtBQUN0RDtBQUNBQSw0QkFBb0JvQixnQkFBcEI7QUFDQVg7QUFDRDs7QUFFRCxVQUFJTyxXQUFXSyxzQkFBc0JMLFFBQXJDO0FBQ0FBLGVBQVN2MkQsSUFBVCxHQUFnQjQyRCxzQkFBc0JMLFFBQXRCLEdBQWlDSSxnQkFBakQ7QUFDQUEsdUJBQWlCMzJELElBQWpCLEdBQXdCNDJELHFCQUF4QjtBQUNBRCx1QkFBaUJKLFFBQWpCLEdBQTRCQSxRQUE1QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTTSxrQkFBVCxHQUE4QjtBQUM1QjtBQUNFO0FBQ0FsQiw0QkFBMEIsQ0FBQyxDQUEzQixJQUNBSixzQkFBc0IsSUFEdEIsSUFFQUEsa0JBQWtCNzFDLGFBQWxCLEtBQW9DQyxpQkFKdEMsRUFLRTtBQUNBazJDLDBCQUFzQixJQUF0QjtBQUNBLFFBQUk7QUFDRixTQUFHO0FBQ0RPO0FBQ0QsT0FGRDtBQUdFO0FBQ0FiLDRCQUFzQixJQUF0QixJQUNBQSxrQkFBa0I3MUMsYUFBbEIsS0FBb0NDLGlCQUx0QztBQU9ELEtBUkQsU0FRVTtBQUNSazJDLDRCQUFzQixLQUF0QjtBQUNBLFVBQUlOLHNCQUFzQixJQUExQixFQUFnQztBQUM5QjtBQUNBUztBQUNELE9BSEQsTUFHTztBQUNMRixrQ0FBMEIsS0FBMUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTSyxTQUFULENBQW1CanBDLFVBQW5CLEVBQStCO0FBQzdCOztBQUVBLE1BQUloaUMsbURBQTRCdXFFLGlCQUFoQyxFQUFtRDtBQUNqRDtBQUNEOztBQUVESSx3QkFBc0IsSUFBdEI7QUFDQSxNQUFNaUIscUJBQXFCdEIsaUJBQTNCO0FBQ0FBLHNCQUFvQnRvQyxVQUFwQjtBQUNBLE1BQUk7QUFDRixRQUFJQSxVQUFKLEVBQWdCO0FBQ2Q7QUFDQSxhQUNFcW9DLHNCQUFzQixJQUF0QixJQUNBLEVBQUVycUUsbURBQTRCdXFFLGlCQUE5QixDQUZGLEVBR0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUl4akUsY0FBYzhrRSxnQkFBbEI7QUFDQSxZQUFJeEIsa0JBQWtCM2pFLGNBQWxCLElBQW9DSyxXQUF4QyxFQUFxRDtBQUNuRCxhQUFHO0FBQ0Rta0U7QUFDRCxXQUZELFFBR0ViLHNCQUFzQixJQUF0QixJQUNBQSxrQkFBa0IzakUsY0FBbEIsSUFBb0NLLFdBRHBDLElBRUEsRUFBRS9HLG1EQUE0QnVxRSxpQkFBOUIsQ0FMRjtBQU9BO0FBQ0Q7QUFDRDtBQUNEO0FBQ0YsS0F2QkQsTUF1Qk87QUFDTDtBQUNBLFVBQUlGLHNCQUFzQixJQUExQixFQUFnQztBQUM5QixXQUFHO0FBQ0QsY0FBSXJxRSxtREFBNEJ1cUUsaUJBQWhDLEVBQW1EO0FBQ2pEO0FBQ0Q7QUFDRFc7QUFDRCxTQUxELFFBS1NiLHNCQUFzQixJQUF0QixJQUE4QixDQUFDeUIsbUJBTHhDO0FBTUQ7QUFDRjtBQUNGLEdBbkNELFNBbUNVO0FBQ1JuQiwwQkFBc0IsS0FBdEI7QUFDQUwsd0JBQW9Cc0Isa0JBQXBCO0FBQ0EsUUFBSXZCLHNCQUFzQixJQUExQixFQUFnQztBQUM5QjtBQUNBUztBQUNELEtBSEQsTUFHTztBQUNMRixnQ0FBMEIsS0FBMUI7QUFDRDtBQUNEO0FBQ0FlO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTejhCLHdCQUFULENBQWtDMWEsYUFBbEMsRUFBaUR1M0MsWUFBakQsRUFBK0Q7QUFDN0QsVUFBUXYzQyxhQUFSO0FBQ0UsU0FBS0MsaUJBQUw7QUFDQSxTQUFLQyxvQkFBTDtBQUNBLFNBQUtwRSxjQUFMO0FBQ0EsU0FBS3FFLFdBQUw7QUFDQSxTQUFLQyxZQUFMO0FBQ0U7QUFDRjtBQUNFSixzQkFBZ0JsRSxjQUFoQjtBQVJKOztBQVdBLE1BQUlnN0Msd0JBQXdCZCxvQkFBNUI7QUFDQSxNQUFJd0IseUJBQXlCdkIscUJBQTdCO0FBQ0FELHlCQUF1QmgyQyxhQUF2QjtBQUNBaTJDLDBCQUF3Qm9CLGdCQUF4Qjs7QUFFQSxNQUFJO0FBQ0YsV0FBT0UsY0FBUDtBQUNELEdBRkQsU0FFVTtBQUNSdkIsMkJBQXVCYyxxQkFBdkI7QUFDQWIsNEJBQXdCdUIsc0JBQXhCOztBQUVBO0FBQ0FMO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTeDhCLGFBQVQsQ0FBdUI0OEIsWUFBdkIsRUFBcUM7QUFDbkMsTUFBSXYzQyxzQkFBSjtBQUNBLFVBQVFnMkMsb0JBQVI7QUFDRSxTQUFLLzFDLGlCQUFMO0FBQ0EsU0FBS0Msb0JBQUw7QUFDQSxTQUFLcEUsY0FBTDtBQUNFO0FBQ0FrRSxzQkFBZ0JsRSxjQUFoQjtBQUNBO0FBQ0Y7QUFDRTtBQUNBa0Usc0JBQWdCZzJDLG9CQUFoQjtBQUNBO0FBVko7O0FBYUEsTUFBSWMsd0JBQXdCZCxvQkFBNUI7QUFDQSxNQUFJd0IseUJBQXlCdkIscUJBQTdCO0FBQ0FELHlCQUF1QmgyQyxhQUF2QjtBQUNBaTJDLDBCQUF3Qm9CLGdCQUF4Qjs7QUFFQSxNQUFJO0FBQ0YsV0FBT0UsY0FBUDtBQUNELEdBRkQsU0FFVTtBQUNSdkIsMkJBQXVCYyxxQkFBdkI7QUFDQWIsNEJBQXdCdUIsc0JBQXhCOztBQUVBO0FBQ0FMO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTdjhCLHFCQUFULENBQStCdjZCLFFBQS9CLEVBQXlDO0FBQ3ZDLE1BQUlvM0Qsc0JBQXNCekIsb0JBQTFCO0FBQ0EsU0FBTyxZQUFXO0FBQ2hCO0FBQ0EsUUFBSWMsd0JBQXdCZCxvQkFBNUI7QUFDQSxRQUFJd0IseUJBQXlCdkIscUJBQTdCO0FBQ0FELDJCQUF1QnlCLG1CQUF2QjtBQUNBeEIsNEJBQXdCb0IsZ0JBQXhCOztBQUVBLFFBQUk7QUFDRixhQUFPaDNELFNBQVNoVyxLQUFULENBQWUsSUFBZixFQUFxQnlMLFNBQXJCLENBQVA7QUFDRCxLQUZELFNBRVU7QUFDUmtnRSw2QkFBdUJjLHFCQUF2QjtBQUNBYiw4QkFBd0J1QixzQkFBeEI7QUFDQUw7QUFDRDtBQUNGLEdBZEQ7QUFlRDs7QUFFRCxTQUFTMThCLHlCQUFULENBQW1DcDZCLFFBQW5DLEVBQTZDcTNELGtCQUE3QyxFQUFpRTtBQUMvRCxNQUFJQyxZQUNGMUIsMEJBQTBCLENBQUMsQ0FBM0IsR0FBK0JBLHFCQUEvQixHQUF1RG9CLGdCQUR6RDs7QUFHQSxNQUFJbmxFLGNBQUo7QUFDQSxNQUNFLFFBQU93bEUsa0JBQVAseUNBQU9BLGtCQUFQLE9BQThCLFFBQTlCLElBQ0FBLHVCQUF1QixJQUR2QixJQUVBLE9BQU9BLG1CQUFtQmwxQyxPQUExQixLQUFzQyxRQUh4QyxFQUlFO0FBQ0E7QUFDQXR3QixxQkFBaUJ5bEUsWUFBWUQsbUJBQW1CbDFDLE9BQWhEO0FBQ0QsR0FQRCxNQU9PO0FBQ0wsWUFBUXd6QyxvQkFBUjtBQUNFLFdBQUsvMUMsaUJBQUw7QUFDRS90Qix5QkFBaUJ5bEUsWUFBWW5DLDBCQUE3QjtBQUNBO0FBQ0YsV0FBS3QxQyxvQkFBTDtBQUNFaHVCLHlCQUFpQnlsRSxZQUFZbEMsc0JBQTdCO0FBQ0E7QUFDRixXQUFLcjFDLFlBQUw7QUFDRWx1Qix5QkFBaUJ5bEUsWUFBWS9CLGFBQTdCO0FBQ0E7QUFDRixXQUFLejFDLFdBQUw7QUFDRWp1Qix5QkFBaUJ5bEUsWUFBWWhDLG9CQUE3QjtBQUNBO0FBQ0YsV0FBSzc1QyxjQUFMO0FBQ0E7QUFDRTVwQix5QkFBaUJ5bEUsWUFBWWpDLHVCQUE3QjtBQWZKO0FBaUJEOztBQUVELE1BQUlrQyxVQUFVO0FBQ1p2M0Qsc0JBRFk7QUFFWjJmLG1CQUFlZzJDLG9CQUZIO0FBR1o5akUsa0NBSFk7QUFJWm9PLFVBQU0sSUFKTTtBQUtadTJELGNBQVU7QUFMRSxHQUFkOztBQVFBO0FBQ0E7QUFDQTtBQUNBLE1BQUloQixzQkFBc0IsSUFBMUIsRUFBZ0M7QUFDOUI7QUFDQUEsd0JBQW9CK0IsUUFBUXQzRCxJQUFSLEdBQWVzM0QsUUFBUWYsUUFBUixHQUFtQmUsT0FBdEQ7QUFDQXRCO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsUUFBSWgyRCxPQUFPLElBQVg7QUFDQSxRQUFJclEsT0FBTzRsRSxpQkFBWDtBQUNBLE9BQUc7QUFDRCxVQUFJNWxFLEtBQUtpQyxjQUFMLEdBQXNCQSxjQUExQixFQUEwQztBQUN4QztBQUNBb08sZUFBT3JRLElBQVA7QUFDQTtBQUNEO0FBQ0RBLGFBQU9BLEtBQUtxUSxJQUFaO0FBQ0QsS0FQRCxRQU9TclEsU0FBUzRsRSxpQkFQbEI7O0FBU0EsUUFBSXYxRCxTQUFTLElBQWIsRUFBbUI7QUFDakI7QUFDQTtBQUNBQSxhQUFPdTFELGlCQUFQO0FBQ0QsS0FKRCxNQUlPLElBQUl2MUQsU0FBU3UxRCxpQkFBYixFQUFnQztBQUNyQztBQUNBQSwwQkFBb0IrQixPQUFwQjtBQUNBdEI7QUFDRDs7QUFFRCxRQUFJTyxXQUFXdjJELEtBQUt1MkQsUUFBcEI7QUFDQUEsYUFBU3YyRCxJQUFULEdBQWdCQSxLQUFLdTJELFFBQUwsR0FBZ0JlLE9BQWhDO0FBQ0FBLFlBQVF0M0QsSUFBUixHQUFlQSxJQUFmO0FBQ0FzM0QsWUFBUWYsUUFBUixHQUFtQkEsUUFBbkI7QUFDRDs7QUFFRCxTQUFPZSxPQUFQO0FBQ0Q7O0FBRUQsU0FBUzk4Qix1QkFBVCxHQUFtQztBQUNqQ2k3QixzQkFBb0IsSUFBcEI7QUFDRDs7QUFFRCxTQUFTaDdCLDBCQUFULEdBQXNDO0FBQ3BDZzdCLHNCQUFvQixLQUFwQjtBQUNBLE1BQUlGLHNCQUFzQixJQUExQixFQUFnQztBQUM5QlM7QUFDRDtBQUNGOztBQUVELFNBQVN6N0IsNkJBQVQsR0FBeUM7QUFDdkMsU0FBT2c3QixpQkFBUDtBQUNEOztBQUVELFNBQVN2N0IsdUJBQVQsQ0FBaUN1OUIsWUFBakMsRUFBK0M7QUFDN0MsTUFBSXYzRCxPQUFPdTNELGFBQWF2M0QsSUFBeEI7QUFDQSxNQUFJQSxTQUFTLElBQWIsRUFBbUI7QUFDakI7QUFDQTtBQUNEOztBQUVELE1BQUlBLFNBQVN1M0QsWUFBYixFQUEyQjtBQUN6QjtBQUNBaEMsd0JBQW9CLElBQXBCO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQSxRQUFJZ0MsaUJBQWlCaEMsaUJBQXJCLEVBQXdDO0FBQ3RDQSwwQkFBb0J2MUQsSUFBcEI7QUFDRDtBQUNELFFBQUl1MkQsV0FBV2dCLGFBQWFoQixRQUE1QjtBQUNBQSxhQUFTdjJELElBQVQsR0FBZ0JBLElBQWhCO0FBQ0FBLFNBQUt1MkQsUUFBTCxHQUFnQkEsUUFBaEI7QUFDRDs7QUFFRGdCLGVBQWF2M0QsSUFBYixHQUFvQnUzRCxhQUFhaEIsUUFBYixHQUF3QixJQUE1QztBQUNEOztBQUVELFNBQVM3N0IsZ0NBQVQsR0FBNEM7QUFDMUMsU0FBT2c3QixvQkFBUDtBQUNEOztBQUVELFNBQVN6N0Isb0JBQVQsR0FBZ0M7QUFDOUIsU0FDRSxDQUFDdTdCLGlCQUFELEtBQ0VELHNCQUFzQixJQUF0QixJQUNBQSxrQkFBa0IzakUsY0FBbEIsR0FBbUNna0UscUJBRHBDLElBRUNvQixtQkFIRixDQURGO0FBTUQ7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSVEsWUFBWXBrRSxJQUFoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlxa0Usa0JBQWtCLE9BQU9qakIsVUFBUCxLQUFzQixVQUF0QixHQUFtQ0EsVUFBbkMsR0FBZ0Rqc0QsU0FBdEU7QUFDQSxJQUFJbXZFLG9CQUNGLE9BQU9DLFlBQVAsS0FBd0IsVUFBeEIsR0FBcUNBLFlBQXJDLEdBQW9EcHZFLFNBRHREOztBQUdBO0FBQ0E7QUFDQSxJQUFJcXZFLDZCQUNGLE9BQU9DLHFCQUFQLEtBQWlDLFVBQWpDLEdBQ0lBLHFCQURKLEdBRUl0dkUsU0FITjtBQUlBLElBQUl1dkUsNEJBQ0YsT0FBT0Msb0JBQVAsS0FBZ0MsVUFBaEMsR0FBNkNBLG9CQUE3QyxHQUFvRXh2RSxTQUR0RTs7QUFHQSxJQUFJd3VFLGNBQUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlpQiwwQkFBMEIsR0FBOUI7QUFDQSxJQUFJQyxLQUFKO0FBQ0EsSUFBSUMsWUFBSjtBQUNBLElBQUlDLG1DQUFtQyxTQUFuQ0EsZ0NBQW1DLENBQVNwNEQsUUFBVCxFQUFtQjtBQUN4RDtBQUNBazRELFVBQVFMLDJCQUEyQixVQUFTbjhCLFNBQVQsRUFBb0I7QUFDckQ7QUFDQWk4QixzQkFBa0JRLFlBQWxCO0FBQ0FuNEQsYUFBUzA3QixTQUFUO0FBQ0QsR0FKTyxDQUFSO0FBS0F5OEIsaUJBQWVULGdCQUFnQixZQUFXO0FBQ3hDO0FBQ0FLLDhCQUEwQkcsS0FBMUI7QUFDQWw0RCxhQUFTZzNELGdCQUFUO0FBQ0QsR0FKYyxFQUlaaUIsdUJBSlksQ0FBZjtBQUtELENBWkQ7O0FBY0EsSUFBSWpDLHVCQUFKLEVBQTZCO0FBQzNCLE1BQUlxQyxjQUFjMW5ELFdBQWxCO0FBQ0EsVUFxT2tCd3BCLFlBck9sQixvQkFBaUIsMEJBQVc7QUFDMUIsV0FBT2srQixZQUFZL2tFLEdBQVosRUFBUDtBQUNELEdBRkQ7QUFHRCxDQUxELE1BS087QUFDTCxVQWlPa0I2bUMsWUFqT2xCLG9CQUFpQiwwQkFBVztBQUMxQixXQUFPczlCLFVBQVVua0UsR0FBVixFQUFQO0FBQ0QsR0FGRDtBQUdEOztBQUVELElBQUk2aUUsb0JBQUo7QUFDQSxJQUFJRCxrQkFBSjtBQUNBLElBQUllLGlCQUFKOztBQUVBLElBQUlxQixjQUFjLElBQWxCO0FBQ0EsSUFBSSxPQUFPdDZELE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDakNzNkQsZ0JBQWN0NkQsTUFBZDtBQUNELENBRkQsTUFFTyxJQUFJLE9BQU91NkQsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUN4Q0QsZ0JBQWNDLE1BQWQ7QUFDRDs7QUFFRCxJQUFJRCxlQUFlQSxZQUFZRSxVQUEvQixFQUEyQztBQUN6QztBQUNBLE1BQUlDLGFBQWFILFlBQVlFLFVBQTdCO0FBQ0FyQyx5QkFBc0JzQyxXQUFXLENBQVgsQ0FBdEI7QUFDQXZDLHVCQUFxQnVDLFdBQVcsQ0FBWCxDQUFyQjtBQUNBeEIsc0JBQW9Cd0IsV0FBVyxDQUFYLENBQXBCO0FBQ0EsVUEyTWtCdCtCLFlBM01sQixvQkFBaUJzK0IsV0FBVyxDQUFYLENBQWpCO0FBQ0QsQ0FQRCxNQU9PO0FBQ0w7QUFDQTtBQUNBLE9BQU96NkQsTUFBUCxLQUFrQixXQUFsQjtBQUNBO0FBQ0EsT0FBTzA2RCxjQUFQLEtBQTBCLFVBTHJCLEVBTUw7QUFDQTtBQUNBO0FBQ0EsTUFBSUMsWUFBWSxJQUFoQjtBQUNBLE1BQUlDLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBU3pyQyxVQUFULEVBQXFCO0FBQ3hDLFFBQUl3ckMsY0FBYyxJQUFsQixFQUF3QjtBQUN0QixVQUFJO0FBQ0ZBLGtCQUFVeHJDLFVBQVY7QUFDRCxPQUZELFNBRVU7QUFDUndyQyxvQkFBWSxJQUFaO0FBQ0Q7QUFDRjtBQUNGLEdBUkQ7QUFTQXhDLHlCQUFzQiw2QkFBU3Y1QixFQUFULEVBQWFockMsRUFBYixFQUFpQjtBQUNyQyxRQUFJK21FLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEI7QUFDQWxrQixpQkFBVzBoQixvQkFBWCxFQUFnQyxDQUFoQyxFQUFtQ3Y1QixFQUFuQztBQUNELEtBSEQsTUFHTztBQUNMKzdCLGtCQUFZLzdCLEVBQVo7QUFDQTZYLGlCQUFXbWtCLGNBQVgsRUFBMkIsQ0FBM0IsRUFBOEIsS0FBOUI7QUFDRDtBQUNGLEdBUkQ7QUFTQTFDLHVCQUFxQiw4QkFBVztBQUM5QnlDLGdCQUFZLElBQVo7QUFDRCxHQUZEO0FBR0ExQixzQkFBb0IsNkJBQVc7QUFDN0IsV0FBTyxLQUFQO0FBQ0QsR0FGRDtBQUdELENBbENNLE1Ba0NBO0FBQ0wsTUFBSSxPQUFPeHRFLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbEM7QUFDQSxRQUFJLE9BQU9vdUUsMEJBQVAsS0FBc0MsVUFBMUMsRUFBc0Q7QUFDcERwdUUsY0FBUVIsS0FBUixDQUNFLHlEQUNFLDRCQURGLEdBRUUsMkRBSEo7QUFLRDtBQUNELFFBQUksT0FBTzh1RSx5QkFBUCxLQUFxQyxVQUF6QyxFQUFxRDtBQUNuRHR1RSxjQUFRUixLQUFSLENBQ0Usd0RBQ0UsNEJBREYsR0FFRSwyREFISjtBQUtEO0FBQ0Y7O0FBRUQsTUFBSTR2RSx3QkFBd0IsSUFBNUI7QUFDQSxNQUFJQywwQkFBMEIsS0FBOUI7QUFDQSxNQUFJQyxjQUFjLENBQUMsQ0FBbkI7O0FBRUEsTUFBSUMsNEJBQTRCLEtBQWhDOztBQUVBLE1BQUlDLHlCQUF5QixLQUE3Qjs7QUFFQSxNQUFJQyxnQkFBZ0IsQ0FBcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQyxvQkFBb0IsRUFBeEI7QUFDQSxNQUFJQyxrQkFBa0IsRUFBdEI7O0FBRUFuQyxzQkFBb0IsNkJBQVc7QUFDN0IsV0FBT2lDLGlCQUFpQmxDLGdCQUF4QjtBQUNELEdBRkQ7O0FBSUE7QUFDQSxNQUFJcUMsVUFBVSxJQUFJWCxjQUFKLEVBQWQ7QUFDQSxNQUFJWSxPQUFPRCxRQUFRRSxLQUFuQjtBQUNBRixVQUFRRyxLQUFSLENBQWNDLFNBQWQsR0FBMEIsVUFBU3JtRSxLQUFULEVBQWdCO0FBQ3hDMGxFLDhCQUEwQixLQUExQjs7QUFFQSxRQUFJWSx3QkFBd0JiLHFCQUE1QjtBQUNBLFFBQUljLGtCQUFrQlosV0FBdEI7QUFDQUYsNEJBQXdCLElBQXhCO0FBQ0FFLGtCQUFjLENBQUMsQ0FBZjs7QUFFQSxRQUFJN21FLGNBQWM4a0UsZ0JBQWxCOztBQUVBLFFBQUk3cEMsYUFBYSxLQUFqQjtBQUNBLFFBQUkrckMsZ0JBQWdCaG5FLFdBQWhCLElBQStCLENBQW5DLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQSxVQUFJeW5FLG9CQUFvQixDQUFDLENBQXJCLElBQTBCQSxtQkFBbUJ6bkUsV0FBakQsRUFBOEQ7QUFDNUQ7QUFDQTtBQUNBaTdCLHFCQUFhLElBQWI7QUFDRCxPQUpELE1BSU87QUFDTDtBQUNBLFlBQUksQ0FBQzZyQyx5QkFBTCxFQUFnQztBQUM5QjtBQUNBQSxzQ0FBNEIsSUFBNUI7QUFDQVosMkNBQWlDd0IsYUFBakM7QUFDRDtBQUNEO0FBQ0FmLGdDQUF3QmEscUJBQXhCO0FBQ0FYLHNCQUFjWSxlQUFkO0FBQ0E7QUFDRDtBQUNGOztBQUVELFFBQUlELDBCQUEwQixJQUE5QixFQUFvQztBQUNsQ1QsK0JBQXlCLElBQXpCO0FBQ0EsVUFBSTtBQUNGUyw4QkFBc0J2c0MsVUFBdEI7QUFDRCxPQUZELFNBRVU7QUFDUjhyQyxpQ0FBeUIsS0FBekI7QUFDRDtBQUNGO0FBQ0YsR0F4Q0Q7O0FBMENBLE1BQUlXLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBU0MsT0FBVCxFQUFrQjtBQUNwQyxRQUFJaEIsMEJBQTBCLElBQTlCLEVBQW9DO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQVQsdUNBQWlDd0IsYUFBakM7QUFDRCxLQVZELE1BVU87QUFDTDtBQUNBWixrQ0FBNEIsS0FBNUI7QUFDQTtBQUNEOztBQUVELFFBQUljLGdCQUFnQkQsVUFBVVgsYUFBVixHQUEwQkUsZUFBOUM7QUFDQSxRQUNFVSxnQkFBZ0JWLGVBQWhCLElBQ0FELG9CQUFvQkMsZUFGdEIsRUFHRTtBQUNBLFVBQUlVLGdCQUFnQixDQUFwQixFQUF1QjtBQUNyQjtBQUNBO0FBQ0FBLHdCQUFnQixDQUFoQjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQVYsd0JBQ0VVLGdCQUFnQlgsaUJBQWhCLEdBQW9DQSxpQkFBcEMsR0FBd0RXLGFBRDFEO0FBRUQsS0FsQkQsTUFrQk87QUFDTFgsMEJBQW9CVyxhQUFwQjtBQUNEO0FBQ0RaLG9CQUFnQlcsVUFBVVQsZUFBMUI7QUFDQSxRQUFJLENBQUNOLHVCQUFMLEVBQThCO0FBQzVCQSxnQ0FBMEIsSUFBMUI7QUFDQVEsV0FBS1MsV0FBTCxDQUFpQnZ4RSxTQUFqQjtBQUNEO0FBQ0YsR0E1Q0Q7O0FBOENBMnRFLHlCQUFzQiw4QkFBU24yRCxRQUFULEVBQW1CZzZELGVBQW5CLEVBQW9DO0FBQ3hEbkIsNEJBQXdCNzRELFFBQXhCO0FBQ0ErNEQsa0JBQWNpQixlQUFkO0FBQ0EsUUFBSWYsMEJBQTBCZSxrQkFBa0IsQ0FBaEQsRUFBbUQ7QUFDakQ7QUFDQVYsV0FBS1MsV0FBTCxDQUFpQnZ4RSxTQUFqQjtBQUNELEtBSEQsTUFHTyxJQUFJLENBQUN3d0UseUJBQUwsRUFBZ0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsa0NBQTRCLElBQTVCO0FBQ0FaLHVDQUFpQ3dCLGFBQWpDO0FBQ0Q7QUFDRixHQWREOztBQWdCQTFELHVCQUFxQiw4QkFBVztBQUM5QjJDLDRCQUF3QixJQUF4QjtBQUNBQyw4QkFBMEIsS0FBMUI7QUFDQUMsa0JBQWMsQ0FBQyxDQUFmO0FBQ0QsR0FKRDtBQUtEOztRQUdzQmtCLDBCLEdBQXJCcjZDLGlCO1FBQ3dCczZDLDZCLEdBQXhCcjZDLG9CO1FBQ2tCczZDLHVCLEdBQWxCMStDLGM7UUFDZ0IyK0MscUIsR0FBaEJyNkMsWTtRQUNlczZDLG9CLEdBQWZ2NkMsVztRQUNBdWEsd0IsR0FBQUEsd0I7UUFDQUMsYSxHQUFBQSxhO1FBQ0FGLHlCLEdBQUFBLHlCO1FBQ0FILHVCLEdBQUFBLHVCO1FBQ0FNLHFCLEdBQUFBLHFCO1FBQ0FJLGdDLEdBQUFBLGdDO1FBQ0FULG9CLEdBQUFBLG9CO1FBQ0FRLDBCLEdBQUFBLDBCO1FBQ0FELHVCLEdBQUFBLHVCO1FBQ0FELDZCLEdBQUFBLDZCO1FBQ2tCTCxZLEdBQWxCNjhCLGM7Ozs7Ozs7Ozs7OztBQzF0QkYsSUFBSXNELENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLeHdFLFNBQVMsYUFBVCxHQUFMLElBQWtDLENBQUMsR0FBRXl3RSxJQUFILEVBQVMsTUFBVCxDQUF0QztBQUNBLENBSEQsQ0FHRSxPQUFNeHhFLENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxRQUFPaVYsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFyQixFQUNDczhELElBQUl0OEQsTUFBSjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQW1LLE9BQU9DLE9BQVAsR0FBaUJreUQsQ0FBakIsQzs7Ozs7Ozs7Ozs7O0FDcEJBOzs7Ozs7OztBQVFPLElBQU1udkUsOERBQTJCLEtBQWpDLEM7Ozs7Ozs7Ozs7OztRQ1dTNnZDLGtCLEdBQUFBLGtCO1FBaUJBRSxvQixHQUFBQSxvQjs7QUF6QmhCOztBQUNBOztBQUVBLElBQUlzL0IsY0FBZ0MsSUFBcEMsQyxDQWRBOzs7Ozs7Ozs7QUFlQSxJQUFJdnZFLHlDQUFKLEVBQTRCO0FBQzFCdXZFLGdCQUFjLElBQUk5b0QsR0FBSixFQUFkO0FBQ0Q7O0FBRU0sU0FBU3NwQixrQkFBVCxDQUE0Qi9lLFVBQTVCLEVBQTBEO0FBQy9ELE1BQUloeEIseUNBQUosRUFBNEI7QUFDMUJ1dkUsZ0JBQVkzbkQsR0FBWixDQUFnQm9KLFVBQWhCOztBQUVBLFFBQUl1K0MsWUFBWXIrQyxJQUFaLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCRCwrQkFBZ0Jwc0IsT0FBaEIsR0FBMEI7QUFDeEJrdEIsZ0ZBRHdCO0FBRXhCMmUsZ0RBRndCO0FBR3hCSyxzQ0FId0I7QUFJeEJsYix3Q0FKd0I7QUFLeEIzQyxvQ0FMd0I7QUFNeEI1QjtBQU53QixPQUExQjtBQVFEO0FBQ0Y7QUFDRjs7QUFFTSxTQUFTMmUsb0JBQVQsQ0FBOEJqZixVQUE5QixFQUE0RDtBQUNqRSxNQUFJaHhCLHlDQUFKLEVBQTRCO0FBQzFCdXZFLGdCQUFZMzlDLE1BQVosQ0FBbUJaLFVBQW5COztBQUVBLFFBQUl1K0MsWUFBWXIrQyxJQUFaLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCRCwrQkFBZ0Jwc0IsT0FBaEIsR0FBMEIsSUFBMUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBUzZyQyxtQkFBVCxDQUE2QjdlLFdBQTdCLEVBQTZEO0FBQzNELE1BQUkyOUMsZ0JBQWdCLEtBQXBCO0FBQ0EsTUFBSTkwQyxjQUFjLElBQWxCOztBQUVBNjBDLGNBQVlydEQsT0FBWixDQUFvQixzQkFBYztBQUNoQyxRQUFJO0FBQ0Y4TyxpQkFBVzBmLG1CQUFYLENBQStCN2UsV0FBL0I7QUFDRCxLQUZELENBRUUsT0FBTzd6QixLQUFQLEVBQWM7QUFDZCxVQUFJLENBQUN3eEUsYUFBTCxFQUFvQjtBQUNsQkEsd0JBQWdCLElBQWhCO0FBQ0E5MEMsc0JBQWMxOEIsS0FBZDtBQUNEO0FBQ0Y7QUFDRixHQVREOztBQVdBLE1BQUl3eEUsYUFBSixFQUFtQjtBQUNqQixVQUFNOTBDLFdBQU47QUFDRDtBQUNGOztBQUVELFNBQVMzSSxtQ0FBVCxDQUE2Q0YsV0FBN0MsRUFBNkU7QUFDM0UsTUFBSTI5QyxnQkFBZ0IsS0FBcEI7QUFDQSxNQUFJOTBDLGNBQWMsSUFBbEI7O0FBRUE2MEMsY0FBWXJ0RCxPQUFaLENBQW9CLHNCQUFjO0FBQ2hDLFFBQUk7QUFDRjhPLGlCQUFXZSxtQ0FBWCxDQUErQ0YsV0FBL0M7QUFDRCxLQUZELENBRUUsT0FBTzd6QixLQUFQLEVBQWM7QUFDZCxVQUFJLENBQUN3eEUsYUFBTCxFQUFvQjtBQUNsQkEsd0JBQWdCLElBQWhCO0FBQ0E5MEMsc0JBQWMxOEIsS0FBZDtBQUNEO0FBQ0Y7QUFDRixHQVREOztBQVdBLE1BQUl3eEUsYUFBSixFQUFtQjtBQUNqQixVQUFNOTBDLFdBQU47QUFDRDtBQUNGOztBQUVELFNBQVM3RSxlQUFULENBQ0U1QyxZQURGLEVBRUU5QixRQUZGLEVBR1E7QUFDTixNQUFJcStDLGdCQUFnQixLQUFwQjtBQUNBLE1BQUk5MEMsY0FBYyxJQUFsQjs7QUFFQTYwQyxjQUFZcnRELE9BQVosQ0FBb0Isc0JBQWM7QUFDaEMsUUFBSTtBQUNGOE8saUJBQVc2RSxlQUFYLENBQTJCNUMsWUFBM0IsRUFBeUM5QixRQUF6QztBQUNELEtBRkQsQ0FFRSxPQUFPbnpCLEtBQVAsRUFBYztBQUNkLFVBQUksQ0FBQ3d4RSxhQUFMLEVBQW9CO0FBQ2xCQSx3QkFBZ0IsSUFBaEI7QUFDQTkwQyxzQkFBYzE4QixLQUFkO0FBQ0Q7QUFDRjtBQUNGLEdBVEQ7O0FBV0EsTUFBSXd4RSxhQUFKLEVBQW1CO0FBQ2pCLFVBQU05MEMsV0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3hILGFBQVQsQ0FBdUJELFlBQXZCLEVBQXVEOUIsUUFBdkQsRUFBK0U7QUFDN0UsTUFBSXErQyxnQkFBZ0IsS0FBcEI7QUFDQSxNQUFJOTBDLGNBQWMsSUFBbEI7O0FBRUE2MEMsY0FBWXJ0RCxPQUFaLENBQW9CLHNCQUFjO0FBQ2hDLFFBQUk7QUFDRjhPLGlCQUFXa0MsYUFBWCxDQUF5QkQsWUFBekIsRUFBdUM5QixRQUF2QztBQUNELEtBRkQsQ0FFRSxPQUFPbnpCLEtBQVAsRUFBYztBQUNkLFVBQUksQ0FBQ3d4RSxhQUFMLEVBQW9CO0FBQ2xCQSx3QkFBZ0IsSUFBaEI7QUFDQTkwQyxzQkFBYzE4QixLQUFkO0FBQ0Q7QUFDRjtBQUNGLEdBVEQ7O0FBV0EsTUFBSXd4RSxhQUFKLEVBQW1CO0FBQ2pCLFVBQU05MEMsV0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3BKLGFBQVQsQ0FBdUIyQixZQUF2QixFQUF1RDlCLFFBQXZELEVBQStFO0FBQzdFLE1BQUlxK0MsZ0JBQWdCLEtBQXBCO0FBQ0EsTUFBSTkwQyxjQUFjLElBQWxCOztBQUVBNjBDLGNBQVlydEQsT0FBWixDQUFvQixzQkFBYztBQUNoQyxRQUFJO0FBQ0Y4TyxpQkFBV00sYUFBWCxDQUF5QjJCLFlBQXpCLEVBQXVDOUIsUUFBdkM7QUFDRCxLQUZELENBRUUsT0FBT256QixLQUFQLEVBQWM7QUFDZCxVQUFJLENBQUN3eEUsYUFBTCxFQUFvQjtBQUNsQkEsd0JBQWdCLElBQWhCO0FBQ0E5MEMsc0JBQWMxOEIsS0FBZDtBQUNEO0FBQ0Y7QUFDRixHQVREOztBQVdBLE1BQUl3eEUsYUFBSixFQUFtQjtBQUNqQixVQUFNOTBDLFdBQU47QUFDRDtBQUNGOztBQUVELFNBQVNxVyxjQUFULENBQ0U5ZCxZQURGLEVBRUU5QixRQUZGLEVBR1E7QUFDTixNQUFJcStDLGdCQUFnQixLQUFwQjtBQUNBLE1BQUk5MEMsY0FBYyxJQUFsQjs7QUFFQTYwQyxjQUFZcnRELE9BQVosQ0FBb0Isc0JBQWM7QUFDaEMsUUFBSTtBQUNGOE8saUJBQVcrZixjQUFYLENBQTBCOWQsWUFBMUIsRUFBd0M5QixRQUF4QztBQUNELEtBRkQsQ0FFRSxPQUFPbnpCLEtBQVAsRUFBYztBQUNkLFVBQUksQ0FBQ3d4RSxhQUFMLEVBQW9CO0FBQ2xCQSx3QkFBZ0IsSUFBaEI7QUFDQTkwQyxzQkFBYzE4QixLQUFkO0FBQ0Q7QUFDRjtBQUNGLEdBVEQ7O0FBV0EsTUFBSXd4RSxhQUFKLEVBQW1CO0FBQ2pCLFVBQU05MEMsV0FBTjtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7O1FDMUplaXFDLGEsR0FBQUEsYTs7QUFQaEI7O0FBSUE7Ozs7QUFDQTs7Ozs7O0FBRU8sU0FBU0EsYUFBVCxDQUNMcHBDLFlBREssRUFFTG5rQixvQkFGSyxFQUdZO0FBQ2pCLE1BQUlBLHlCQUF5QjdaLFNBQTdCLEVBQXdDO0FBQ3RDNlosMkJBQXVCLElBQXZCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsUUFBSS9aLElBQUosRUFBYTtBQUNYLHlDQUNFK1oseUJBQXlCLElBQXpCLElBQ0UsT0FBT0Esb0JBQVAsS0FBZ0MsVUFGcEMsRUFHRSxrRUFDRSxnQ0FKSixFQUtFQSxvQkFMRjtBQU9EO0FBQ0Y7O0FBRUQsTUFBTVYsVUFBMkI7QUFDL0JsVSxjQUFVQyxnQ0FEcUI7QUFFL0JpVywyQkFBdUJ0QixvQkFGUTtBQUcvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FjLG1CQUFlcWpCLFlBUmdCO0FBUy9CbmpCLG9CQUFnQm1qQixZQVRlO0FBVS9CO0FBQ0E7QUFDQWswQyxrQkFBYyxDQVppQjtBQWEvQjtBQUNBQyxjQUFXLElBZG9CO0FBZS9CM3RDLGNBQVc7QUFmb0IsR0FBakM7O0FBa0JBcnJCLFVBQVFnNUQsUUFBUixHQUFtQjtBQUNqQmx0RSxjQUFVRSxpQ0FETztBQUVqQnNWLGNBQVV0QjtBQUZPLEdBQW5COztBQUtBLE1BQUlpNUQsNENBQTRDLEtBQWhEO0FBQ0EsTUFBSUMsc0NBQXNDLEtBQTFDOztBQUVBLE1BQUl2eUUsSUFBSixFQUFhO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBTTBrQyxXQUFXO0FBQ2Z2L0IsZ0JBQVVDLGdDQURLO0FBRWZ1VixnQkFBVXRCLE9BRks7QUFHZmdDLDZCQUF1QmhDLFFBQVFnQztBQUhoQixLQUFqQjtBQUtBO0FBQ0FoUCxXQUFPbW1FLGdCQUFQLENBQXdCOXRDLFFBQXhCLEVBQWtDO0FBQ2hDMnRDLGdCQUFVO0FBQ1I1a0UsV0FEUSxpQkFDRjtBQUNKLGNBQUksQ0FBQzhrRSxtQ0FBTCxFQUEwQztBQUN4Q0Esa0RBQXNDLElBQXRDO0FBQ0EsbUNBQ0UsS0FERixFQUVFLG1GQUNFLDRFQUhKO0FBS0Q7QUFDRCxpQkFBT2w1RCxRQUFRZzVELFFBQWY7QUFDRCxTQVhPO0FBWVI3a0UsV0FaUSxlQVlKaWxFLFNBWkksRUFZTztBQUNicDVELGtCQUFRZzVELFFBQVIsR0FBbUJJLFNBQW5CO0FBQ0Q7QUFkTyxPQURzQjtBQWlCaEM1M0QscUJBQWU7QUFDYnBOLFdBRGEsaUJBQ1A7QUFDSixpQkFBTzRMLFFBQVF3QixhQUFmO0FBQ0QsU0FIWTtBQUlick4sV0FKYSxlQUlUcU4sYUFKUyxFQUlNO0FBQ2pCeEIsa0JBQVF3QixhQUFSLEdBQXdCQSxhQUF4QjtBQUNEO0FBTlksT0FqQmlCO0FBeUJoQ0Usc0JBQWdCO0FBQ2R0TixXQURjLGlCQUNSO0FBQ0osaUJBQU80TCxRQUFRMEIsY0FBZjtBQUNELFNBSGE7QUFJZHZOLFdBSmMsZUFJVnVOLGNBSlUsRUFJTTtBQUNsQjFCLGtCQUFRMEIsY0FBUixHQUF5QkEsY0FBekI7QUFDRDtBQU5hLE9BekJnQjtBQWlDaENxM0Qsb0JBQWM7QUFDWjNrRSxXQURZLGlCQUNOO0FBQ0osaUJBQU80TCxRQUFRKzRELFlBQWY7QUFDRCxTQUhXO0FBSVo1a0UsV0FKWSxlQUlSNGtFLFlBSlEsRUFJTTtBQUNoQi80RCxrQkFBUSs0RCxZQUFSLEdBQXVCQSxZQUF2QjtBQUNEO0FBTlcsT0FqQ2tCO0FBeUNoQzF0QyxnQkFBVTtBQUNSajNCLFdBRFEsaUJBQ0Y7QUFDSixjQUFJLENBQUM2a0UseUNBQUwsRUFBZ0Q7QUFDOUNBLHdEQUE0QyxJQUE1QztBQUNBLG1DQUNFLEtBREYsRUFFRSxtRkFDRSw0RUFISjtBQUtEO0FBQ0QsaUJBQU9qNUQsUUFBUXFyQixRQUFmO0FBQ0Q7QUFYTztBQXpDc0IsS0FBbEM7QUF1REE7QUFDQXJyQixZQUFRcXJCLFFBQVIsR0FBbUJBLFFBQW5CO0FBQ0QsR0FuRUQsTUFtRU87QUFDTHJyQixZQUFRcXJCLFFBQVIsR0FBbUJyckIsT0FBbkI7QUFDRDs7QUFFRCxNQUFJclosSUFBSixFQUFhO0FBQ1hxWixZQUFReUIsZ0JBQVIsR0FBMkIsSUFBM0I7QUFDQXpCLFlBQVEyQixpQkFBUixHQUE0QixJQUE1QjtBQUNEOztBQUVELFNBQU8zQixPQUFQO0FBQ0QsQyxDQXpJRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQ1lnQm11RCxJLEdBQUFBLEk7O0FBSGhCOztBQUNBOzs7Ozs7QUFFTyxTQUFTQSxJQUFULENBQW9CM3dDLElBQXBCLEVBQWtFO0FBQ3ZFLE1BQUk2N0MsV0FBVztBQUNidnRFLGNBQVVNLDZCQURHO0FBRWJtckMsV0FBTy9aLElBRk07QUFHYjtBQUNBeVAsYUFBUyxDQUFDLENBSkc7QUFLYkMsYUFBUztBQUxJLEdBQWY7O0FBUUEsTUFBSXZtQyxJQUFKLEVBQWE7QUFDWDtBQUNBLFFBQUl3dEIscUJBQUo7QUFDQSxRQUFJMFMsa0JBQUo7QUFDQTd6QixXQUFPbW1FLGdCQUFQLENBQXdCRSxRQUF4QixFQUFrQztBQUNoQ2xsRCxvQkFBYztBQUNaamdCLHNCQUFjLElBREY7QUFFWkUsV0FGWSxpQkFFTjtBQUNKLGlCQUFPK2YsWUFBUDtBQUNELFNBSlc7QUFLWmhnQixXQUxZLGVBS1JtbEUsZUFMUSxFQUtTO0FBQ25CLGlDQUNFLEtBREYsRUFFRSxzRUFDRSxtRUFERixHQUVFLHVEQUpKO0FBTUFubEQseUJBQWVtbEQsZUFBZjtBQUNBO0FBQ0F0bUUsaUJBQU9NLGNBQVAsQ0FBc0IrbEUsUUFBdEIsRUFBZ0MsY0FBaEMsRUFBZ0Q7QUFDOUM1cUMsd0JBQVk7QUFEa0MsV0FBaEQ7QUFHRDtBQWpCVyxPQURrQjtBQW9CaEM1SCxpQkFBVztBQUNUM3lCLHNCQUFjLElBREw7QUFFVEUsV0FGUyxpQkFFSDtBQUNKLGlCQUFPeXlCLFNBQVA7QUFDRCxTQUpRO0FBS1QxeUIsV0FMUyxlQUtMb2xFLFlBTEssRUFLUztBQUNoQixpQ0FDRSxLQURGLEVBRUUsbUVBQ0UsbUVBREYsR0FFRSx1REFKSjtBQU1BMXlDLHNCQUFZMHlDLFlBQVo7QUFDQTtBQUNBdm1FLGlCQUFPTSxjQUFQLENBQXNCK2xFLFFBQXRCLEVBQWdDLFdBQWhDLEVBQTZDO0FBQzNDNXFDLHdCQUFZO0FBRCtCLFdBQTdDO0FBR0Q7QUFqQlE7QUFwQnFCLEtBQWxDO0FBd0NEOztBQUVELFNBQU80cUMsUUFBUDtBQUNELEMsQ0FwRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4UUNBQTs7Ozs7OztrQkFXd0JuTCxVOztBQUp4Qjs7QUFFQTs7Ozs7O0FBRWUsU0FBU0EsVUFBVCxDQUNiaGlFLE1BRGEsRUFFYjtBQUNBLE1BQUl2RixJQUFKLEVBQWE7QUFDWCxRQUFJdUYsVUFBVSxJQUFWLElBQWtCQSxPQUFPSixRQUFQLEtBQW9CSyw2QkFBMUMsRUFBMkQ7QUFDekQseUNBQ0UsS0FERixFQUVFLGlFQUNFLG1EQURGLEdBRUUsd0JBSko7QUFNRCxLQVBELE1BT08sSUFBSSxPQUFPRCxNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQ3ZDLHlDQUNFLEtBREYsRUFFRSx5REFGRixFQUdFQSxXQUFXLElBQVgsR0FBa0IsTUFBbEIsVUFBa0NBLE1BQWxDLHlDQUFrQ0EsTUFBbEMsQ0FIRjtBQUtELEtBTk0sTUFNQTtBQUNMO0FBQ0U7QUFDQUEsYUFBT3JFLE1BQVAsS0FBa0IsQ0FBbEIsSUFBdUJxRSxPQUFPckUsTUFBUCxLQUFrQixDQUYzQyxFQUdFLDhFQUhGLEVBSUVxRSxPQUFPckUsTUFBUCxLQUFrQixDQUFsQixHQUNJLDBDQURKLEdBRUksNkNBTk47QUFRRDs7QUFFRCxRQUFJcUUsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCLHlDQUNFQSxPQUFPaW9CLFlBQVAsSUFBdUIsSUFBdkIsSUFBK0Jqb0IsT0FBTzI2QixTQUFQLElBQW9CLElBRHJELEVBRUUsMkVBQ0UsOENBSEo7QUFLRDtBQUNGOztBQUVELFNBQU87QUFDTC82QixjQUFVRyxvQ0FETDtBQUVMQztBQUZLLEdBQVA7QUFJRCxDOzs7Ozs7Ozs7Ozs7OzhRQ3BERDs7Ozs7OztrQkFZd0JraUUsSTs7QUFMeEI7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRWUsU0FBU0EsSUFBVCxDQUNiOWlFLElBRGEsRUFFYjA3QixPQUZhLEVBR2I7QUFDQSxNQUFJcmdDLElBQUosRUFBYTtBQUNYLFFBQUksQ0FBQyxrQ0FBbUIyRSxJQUFuQixDQUFMLEVBQStCO0FBQzdCLHlDQUNFLEtBREYsRUFFRSwyREFDRSxjQUhKLEVBSUVBLFNBQVMsSUFBVCxHQUFnQixNQUFoQixVQUFnQ0EsSUFBaEMseUNBQWdDQSxJQUFoQyxDQUpGO0FBTUQ7QUFDRjtBQUNELFNBQU87QUFDTFEsY0FBVUssNkJBREw7QUFFTGIsY0FGSztBQUdMMDdCLGFBQVNBLFlBQVluZ0MsU0FBWixHQUF3QixJQUF4QixHQUErQm1nQztBQUhuQyxHQUFQO0FBS0QsQzs7Ozs7Ozs7Ozs7O1FDTmV1b0IsVSxHQUFBQSxVO1FBMENBTyxRLEdBQUFBLFE7UUFLQUYsVSxHQUFBQSxVO1FBU0FDLE0sR0FBQUEsTTtRQUtBTCxTLEdBQUFBLFM7UUFRQUUsZSxHQUFBQSxlO1FBUUFKLFcsR0FBQUEsVztRQVFBSyxPLEdBQUFBLE87UUFRQUYsbUIsR0FBQUEsbUI7UUFTQU0sYSxHQUFBQSxhOztBQXJIaEI7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFiQTs7Ozs7Ozs7O0FBZUEsU0FBU3lwQixpQkFBVCxHQUE2QjtBQUMzQixNQUFNQyxhQUFhaGtELGlDQUF1QnRuQixPQUExQztBQUNBLDJCQUNFc3JFLGVBQWUsSUFEakIsRUFFRSx1RUFDRSx5Q0FISjtBQUtBLFNBQU9BLFVBQVA7QUFDRDs7QUFFTSxTQUFTbHFCLFVBQVQsQ0FDTG1xQixPQURLLEVBRUxwdUMscUJBRkssRUFHTDtBQUNBLE1BQU1tdUMsYUFBYUQsbUJBQW5CO0FBQ0EsTUFBSTd5RSxJQUFKLEVBQWE7QUFDWCwyQkFDRTJrQywwQkFBMEJ6a0MsU0FENUIsRUFFRSx5REFDRSw2Q0FERixHQUVFLG1CQUpKLEVBS0V5a0MscUJBTEYsRUFNRSxPQUFPQSxxQkFBUCxLQUFpQyxRQUFqQyxJQUE2Q2xpQixNQUFNMm1CLE9BQU4sQ0FBY2o4QixVQUFVLENBQVYsQ0FBZCxDQUE3QyxHQUNJLDZDQUNBLGdEQURBLEdBRUEsNENBSEosR0FJSSxFQVZOOztBQWFBO0FBQ0EsUUFBSzRsRSxPQUFELENBQWVwNEQsUUFBZixLQUE0QnphLFNBQWhDLEVBQTJDO0FBQ3pDLFVBQU04eUUsY0FBZUQsT0FBRCxDQUFlcDRELFFBQW5DO0FBQ0E7QUFDQTtBQUNBLFVBQUlxNEQsWUFBWXR1QyxRQUFaLEtBQXlCcXVDLE9BQTdCLEVBQXNDO0FBQ3BDLCtCQUNFLEtBREYsRUFFRSx3RkFDRSxzRkFISjtBQUtELE9BTkQsTUFNTyxJQUFJQyxZQUFZWCxRQUFaLEtBQXlCVSxPQUE3QixFQUFzQztBQUMzQywrQkFDRSxLQURGLEVBRUUsNERBQ0UsbURBSEo7QUFLRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPRCxXQUFXbHFCLFVBQVgsQ0FBc0JtcUIsT0FBdEIsRUFBK0JwdUMscUJBQS9CLENBQVA7QUFDRDs7QUFFTSxTQUFTd2tCLFFBQVQsQ0FBcUI1RCxZQUFyQixFQUFrRDtBQUN2RCxNQUFNdXRCLGFBQWFELG1CQUFuQjtBQUNBLFNBQU9DLFdBQVczcEIsUUFBWCxDQUFvQjVELFlBQXBCLENBQVA7QUFDRDs7QUFFTSxTQUFTMEQsVUFBVCxDQUNMN0QsT0FESyxFQUVMQyxVQUZLLEVBR0xDLElBSEssRUFJTDtBQUNBLE1BQU13dEIsYUFBYUQsbUJBQW5CO0FBQ0EsU0FBT0MsV0FBVzdwQixVQUFYLENBQXNCN0QsT0FBdEIsRUFBK0JDLFVBQS9CLEVBQTJDQyxJQUEzQyxDQUFQO0FBQ0Q7O0FBRU0sU0FBUzRELE1BQVQsQ0FBbUJuUyxZQUFuQixFQUFrRDtBQUN2RCxNQUFNKzdCLGFBQWFELG1CQUFuQjtBQUNBLFNBQU9DLFdBQVc1cEIsTUFBWCxDQUFrQm5TLFlBQWxCLENBQVA7QUFDRDs7QUFFTSxTQUFTOFIsU0FBVCxDQUNMMUMsTUFESyxFQUVMOHNCLE1BRkssRUFHTDtBQUNBLE1BQU1ILGFBQWFELG1CQUFuQjtBQUNBLFNBQU9DLFdBQVdqcUIsU0FBWCxDQUFxQjFDLE1BQXJCLEVBQTZCOHNCLE1BQTdCLENBQVA7QUFDRDs7QUFFTSxTQUFTbHFCLGVBQVQsQ0FDTDVDLE1BREssRUFFTDhzQixNQUZLLEVBR0w7QUFDQSxNQUFNSCxhQUFhRCxtQkFBbkI7QUFDQSxTQUFPQyxXQUFXL3BCLGVBQVgsQ0FBMkI1QyxNQUEzQixFQUFtQzhzQixNQUFuQyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU3RxQixXQUFULENBQ0xqeEMsUUFESyxFQUVMdTdELE1BRkssRUFHTDtBQUNBLE1BQU1ILGFBQWFELG1CQUFuQjtBQUNBLFNBQU9DLFdBQVducUIsV0FBWCxDQUF1Qmp4QyxRQUF2QixFQUFpQ3U3RCxNQUFqQyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU2pxQixPQUFULENBQ0w3QyxNQURLLEVBRUw4c0IsTUFGSyxFQUdMO0FBQ0EsTUFBTUgsYUFBYUQsbUJBQW5CO0FBQ0EsU0FBT0MsV0FBVzlwQixPQUFYLENBQW1CN0MsTUFBbkIsRUFBMkI4c0IsTUFBM0IsQ0FBUDtBQUNEOztBQUVNLFNBQVNucUIsbUJBQVQsQ0FDTGo4QixHQURLLEVBRUxzNUIsTUFGSyxFQUdMOHNCLE1BSEssRUFJQztBQUNOLE1BQU1ILGFBQWFELG1CQUFuQjtBQUNBLFNBQU9DLFdBQVdocUIsbUJBQVgsQ0FBK0JqOEIsR0FBL0IsRUFBb0NzNUIsTUFBcEMsRUFBNEM4c0IsTUFBNUMsQ0FBUDtBQUNEOztBQUVNLFNBQVM3cEIsYUFBVCxDQUF1QmhsQyxLQUF2QixFQUFtQzBqQyxXQUFuQyxFQUFzRTtBQUMzRSxNQUFJOW5ELElBQUosRUFBYTtBQUNYLFFBQU04eUUsYUFBYUQsbUJBQW5CO0FBQ0EsV0FBT0MsV0FBVzFwQixhQUFYLENBQXlCaGxDLEtBQXpCLEVBQWdDMGpDLFdBQWhDLENBQVA7QUFDRDtBQUNGLEM7Ozs7Ozs7Ozs7Ozs7OFFDcElEOzs7Ozs7O0FBT0E7Ozs7Ozs7UUE4UGdCNmYsMkIsR0FBQUEsMkI7UUE0RUFFLDJCLEdBQUFBLDJCO1FBd0JBRCwwQixHQUFBQSwwQjs7QUEzVmhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQU9BOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUlBLElBQUlzTCxzQ0FBSjs7QUFFQSxJQUFJbHpFLElBQUosRUFBYTtBQUNYa3pFLGtDQUFnQyxLQUFoQztBQUNEOztBQUVELFNBQVNDLDJCQUFULEdBQXVDO0FBQ3JDLE1BQUlwa0QsNEJBQWtCdm5CLE9BQXRCLEVBQStCO0FBQzdCLFFBQU16RyxPQUFPLGdDQUFpQmd1Qiw0QkFBa0J2bkIsT0FBbEIsQ0FBMEI3QyxJQUEzQyxDQUFiO0FBQ0EsUUFBSTVELElBQUosRUFBVTtBQUNSLGFBQU8scUNBQXFDQSxJQUFyQyxHQUE0QyxJQUFuRDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLEVBQVA7QUFDRDs7QUFFRCxTQUFTcXlFLDBCQUFULENBQW9DQyxZQUFwQyxFQUFrRDtBQUNoRCxNQUNFQSxpQkFBaUIsSUFBakIsSUFDQUEsaUJBQWlCbnpFLFNBRGpCLElBRUFtekUsYUFBYXZzQyxRQUFiLEtBQTBCNW1DLFNBSDVCLEVBSUU7QUFDQSxRQUFNK0csU0FBU29zRSxhQUFhdnNDLFFBQTVCO0FBQ0EsUUFBTWxFLFdBQVczN0IsT0FBTzI3QixRQUFQLENBQWdCOWhDLE9BQWhCLENBQXdCLFdBQXhCLEVBQXFDLEVBQXJDLENBQWpCO0FBQ0EsUUFBTStoQyxhQUFhNTdCLE9BQU80N0IsVUFBMUI7QUFDQSxXQUFPLDRCQUE0QkQsUUFBNUIsR0FBdUMsR0FBdkMsR0FBNkNDLFVBQTdDLEdBQTBELEdBQWpFO0FBQ0Q7QUFDRCxTQUFPLEVBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxJQUFNeXdDLHdCQUF3QixFQUE5Qjs7QUFFQSxTQUFTQyw0QkFBVCxDQUFzQ2hwQixVQUF0QyxFQUFrRDtBQUNoRCxNQUFJbGpELE9BQU84ckUsNkJBQVg7O0FBRUEsTUFBSSxDQUFDOXJFLElBQUwsRUFBVztBQUNULFFBQU1tc0UsYUFDSixPQUFPanBCLFVBQVAsS0FBc0IsUUFBdEIsR0FDSUEsVUFESixHQUVJQSxXQUFXOWxELFdBQVgsSUFBMEI4bEQsV0FBV3hwRCxJQUgzQztBQUlBLFFBQUl5eUUsVUFBSixFQUFnQjtBQUNkbnNFLDZEQUFxRG1zRSxVQUFyRDtBQUNEO0FBQ0Y7QUFDRCxTQUFPbnNFLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxTQUFTb3NFLG1CQUFULENBQTZCdmxELE9BQTdCLEVBQXNDcThCLFVBQXRDLEVBQWtEO0FBQ2hELE1BQUksQ0FBQ3I4QixRQUFRMlosTUFBVCxJQUFtQjNaLFFBQVEyWixNQUFSLENBQWU2ckMsU0FBbEMsSUFBK0N4bEQsUUFBUXhQLEdBQVIsSUFBZSxJQUFsRSxFQUF3RTtBQUN0RTtBQUNEO0FBQ0R3UCxVQUFRMlosTUFBUixDQUFlNnJDLFNBQWYsR0FBMkIsSUFBM0I7O0FBRUEsTUFBTUMsNEJBQTRCSiw2QkFBNkJocEIsVUFBN0IsQ0FBbEM7QUFDQSxNQUFJK29CLHNCQUFzQksseUJBQXRCLENBQUosRUFBc0Q7QUFDcEQ7QUFDRDtBQUNETCx3QkFBc0JLLHlCQUF0QixJQUFtRCxJQUFuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQyxhQUFhLEVBQWpCO0FBQ0EsTUFDRTFsRCxXQUNBQSxRQUFRQyxNQURSLElBRUFELFFBQVFDLE1BQVIsS0FBbUJZLDRCQUFrQnZuQixPQUh2QyxFQUlFO0FBQ0E7QUFDQW9zRSxrREFBNEMsZ0NBQzFDMWxELFFBQVFDLE1BQVIsQ0FBZXhwQixJQUQyQixDQUE1QztBQUdEOztBQUVELDZEQUE4QnVwQixPQUE5QjtBQUNBLE1BQUlsdUIsSUFBSixFQUFhO0FBQ1gsMkJBQ0UsS0FERixFQUVFLDBEQUNFLGlFQUhKLEVBSUUyekUseUJBSkYsRUFLRUMsVUFMRjtBQU9EO0FBQ0QsNkRBQThCLElBQTlCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVNDLGlCQUFULENBQTJCdnNFLElBQTNCLEVBQWlDaWpELFVBQWpDLEVBQTZDO0FBQzNDLE1BQUksUUFBT2pqRCxJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQXBCLEVBQThCO0FBQzVCO0FBQ0Q7QUFDRCxNQUFJbWIsTUFBTTJtQixPQUFOLENBQWM5aEMsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFNBQUssSUFBSXVaLElBQUksQ0FBYixFQUFnQkEsSUFBSXZaLEtBQUtwRyxNQUF6QixFQUFpQzJmLEdBQWpDLEVBQXNDO0FBQ3BDLFVBQU1wRixRQUFRblUsS0FBS3VaLENBQUwsQ0FBZDtBQUNBLFVBQUksa0NBQWVwRixLQUFmLENBQUosRUFBMkI7QUFDekJnNEQsNEJBQW9CaDRELEtBQXBCLEVBQTJCOHVDLFVBQTNCO0FBQ0Q7QUFDRjtBQUNGLEdBUEQsTUFPTyxJQUFJLGtDQUFlampELElBQWYsQ0FBSixFQUEwQjtBQUMvQjtBQUNBLFFBQUlBLEtBQUt1Z0MsTUFBVCxFQUFpQjtBQUNmdmdDLFdBQUt1Z0MsTUFBTCxDQUFZNnJDLFNBQVosR0FBd0IsSUFBeEI7QUFDRDtBQUNGLEdBTE0sTUFLQSxJQUFJcHNFLElBQUosRUFBVTtBQUNmLFFBQU1rakUsYUFBYSxpQ0FBY2xqRSxJQUFkLENBQW5CO0FBQ0EsUUFBSSxPQUFPa2pFLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDcEM7QUFDQTtBQUNBLFVBQUlBLGVBQWVsakUsS0FBS21qRSxPQUF4QixFQUFpQztBQUMvQixZQUFNdGtFLFdBQVdxa0UsV0FBVzdvRSxJQUFYLENBQWdCMkYsSUFBaEIsQ0FBakI7QUFDQSxZQUFJOHZELGFBQUo7QUFDQSxlQUFPLENBQUMsQ0FBQ0EsT0FBT2p4RCxTQUFTd1IsSUFBVCxFQUFSLEVBQXlCZ3pELElBQWpDLEVBQXVDO0FBQ3JDLGNBQUksa0NBQWV2VCxLQUFLaHpDLEtBQXBCLENBQUosRUFBZ0M7QUFDOUJxdkQsZ0NBQW9CcmMsS0FBS2h6QyxLQUF6QixFQUFnQ21tQyxVQUFoQztBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O0FBTUEsU0FBU3VwQixpQkFBVCxDQUEyQjVsRCxPQUEzQixFQUFvQztBQUNsQyxNQUFNdnBCLE9BQU91cEIsUUFBUXZwQixJQUFyQjtBQUNBLE1BQUlBLFNBQVMsSUFBVCxJQUFpQkEsU0FBU3pFLFNBQTFCLElBQXVDLE9BQU95RSxJQUFQLEtBQWdCLFFBQTNELEVBQXFFO0FBQ25FO0FBQ0Q7QUFDRCxNQUFNNUQsT0FBTyxnQ0FBaUI0RCxJQUFqQixDQUFiO0FBQ0EsTUFBSXU3QixrQkFBSjtBQUNBLE1BQUksT0FBT3Y3QixJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCdTdCLGdCQUFZdjdCLEtBQUt1N0IsU0FBakI7QUFDRCxHQUZELE1BRU8sSUFDTCxRQUFPdjdCLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsS0FDQ0EsS0FBS1EsUUFBTCxLQUFrQkcsb0NBQWxCO0FBQ0M7QUFDQTtBQUNBWCxPQUFLUSxRQUFMLEtBQWtCSyw2QkFKcEIsQ0FESyxFQU1MO0FBQ0EwNkIsZ0JBQVl2N0IsS0FBS3U3QixTQUFqQjtBQUNELEdBUk0sTUFRQTtBQUNMO0FBQ0Q7QUFDRCxNQUFJQSxTQUFKLEVBQWU7QUFDYiwrREFBOEJoUyxPQUE5QjtBQUNBLGtDQUNFZ1MsU0FERixFQUVFaFMsUUFBUTFZLEtBRlYsRUFHRSxNQUhGLEVBSUV6VSxJQUpGLEVBS0VnQixpQ0FBdUJHLGdCQUx6QjtBQU9BLCtEQUE4QixJQUE5QjtBQUNELEdBVkQsTUFVTyxJQUFJeUMsS0FBS292RSxTQUFMLEtBQW1CN3pFLFNBQW5CLElBQWdDLENBQUNnekUsNkJBQXJDLEVBQW9FO0FBQ3pFQSxvQ0FBZ0MsSUFBaEM7QUFDQSx1Q0FDRSxLQURGLEVBRUUscUdBRkYsRUFHRW55RSxRQUFRLFNBSFY7QUFLRDtBQUNELE1BQUksT0FBTzRELEtBQUtnN0MsZUFBWixLQUFnQyxVQUFwQyxFQUFnRDtBQUM5Qyx1Q0FDRWg3QyxLQUFLZzdDLGVBQUwsQ0FBcUJGLG9CQUR2QixFQUVFLCtEQUNFLGtFQUhKO0FBS0Q7QUFDRjs7QUFFRDs7OztBQUlBLFNBQVN1MEIscUJBQVQsQ0FBK0JDLFFBQS9CLEVBQXlDO0FBQ3ZDLDZEQUE4QkEsUUFBOUI7O0FBRUEsTUFBTWhtRCxPQUFPNWhCLE9BQU80aEIsSUFBUCxDQUFZZ21ELFNBQVN6K0QsS0FBckIsQ0FBYjtBQUNBLE9BQUssSUFBSXFMLElBQUksQ0FBYixFQUFnQkEsSUFBSW9OLEtBQUsvc0IsTUFBekIsRUFBaUMyZixHQUFqQyxFQUFzQztBQUNwQyxRQUFNbkMsTUFBTXVQLEtBQUtwTixDQUFMLENBQVo7QUFDQSxRQUFJbkMsUUFBUSxVQUFSLElBQXNCQSxRQUFRLEtBQWxDLEVBQXlDO0FBQ3ZDLDZCQUNFLEtBREYsRUFFRSxxREFDRSwwREFISixFQUlFQSxHQUpGO0FBTUE7QUFDRDtBQUNGOztBQUVELE1BQUl1MUQsU0FBU3BuRCxHQUFULEtBQWlCLElBQXJCLEVBQTJCO0FBQ3pCLDJCQUFRLEtBQVIsRUFBZSx1REFBZjtBQUNEOztBQUVELDZEQUE4QixJQUE5QjtBQUNEOztBQUVNLFNBQVM4NkMsMkJBQVQsQ0FBcUNoakUsSUFBckMsRUFBMkM2USxLQUEzQyxFQUFrRHNZLFFBQWxELEVBQTREO0FBQ2pFLE1BQU1vbUQsWUFBWSxrQ0FBbUJ2dkUsSUFBbkIsQ0FBbEI7O0FBRUE7QUFDQTtBQUNBLE1BQUksQ0FBQ3V2RSxTQUFMLEVBQWdCO0FBQ2QsUUFBSTdzRSxPQUFPLEVBQVg7QUFDQSxRQUNFMUMsU0FBU3pFLFNBQVQsSUFDQyxRQUFPeUUsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFoQixJQUNDQSxTQUFTLElBRFYsSUFFQzBILE9BQU80aEIsSUFBUCxDQUFZdHBCLElBQVosRUFBa0J6RCxNQUFsQixLQUE2QixDQUpqQyxFQUtFO0FBQ0FtRyxjQUNFLCtEQUNBLHdFQUZGO0FBR0Q7O0FBRUQsUUFBTXNzQyxhQUFheS9CLDJCQUEyQjU5RCxLQUEzQixDQUFuQjtBQUNBLFFBQUltK0IsVUFBSixFQUFnQjtBQUNkdHNDLGNBQVFzc0MsVUFBUjtBQUNELEtBRkQsTUFFTztBQUNMdHNDLGNBQVE4ckUsNkJBQVI7QUFDRDs7QUFFRCxRQUFJZ0IsbUJBQUo7QUFDQSxRQUFJeHZFLFNBQVMsSUFBYixFQUFtQjtBQUNqQnd2RSxtQkFBYSxNQUFiO0FBQ0QsS0FGRCxNQUVPLElBQUkxeEQsTUFBTTJtQixPQUFOLENBQWN6a0MsSUFBZCxDQUFKLEVBQXlCO0FBQzlCd3ZFLG1CQUFhLE9BQWI7QUFDRCxLQUZNLE1BRUEsSUFBSXh2RSxTQUFTekUsU0FBVCxJQUFzQnlFLEtBQUtRLFFBQUwsS0FBa0JhLGdDQUE1QyxFQUFnRTtBQUNyRW11RSwwQkFBaUIsZ0NBQWlCeHZFLEtBQUtBLElBQXRCLEtBQStCLFNBQWhEO0FBQ0EwQyxhQUNFLG9FQURGO0FBRUQsS0FKTSxNQUlBO0FBQ0w4c0UsMEJBQW9CeHZFLElBQXBCLHlDQUFvQkEsSUFBcEI7QUFDRDs7QUFFRCwyQkFDRSxLQURGLEVBRUUsb0VBQ0UsMERBREYsR0FFRSw0QkFKSixFQUtFd3ZFLFVBTEYsRUFNRTlzRSxJQU5GO0FBUUQ7O0FBRUQsTUFBTTZtQixVQUFVdFksNEJBQWNsVSxLQUFkLENBQW9CLElBQXBCLEVBQTBCeUwsU0FBMUIsQ0FBaEI7O0FBRUE7QUFDQTtBQUNBLE1BQUkrZ0IsV0FBVyxJQUFmLEVBQXFCO0FBQ25CLFdBQU9BLE9BQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSWdtRCxTQUFKLEVBQWU7QUFDYixTQUFLLElBQUlyekQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMVQsVUFBVWpNLE1BQTlCLEVBQXNDMmYsR0FBdEMsRUFBMkM7QUFDekNnekQsd0JBQWtCMW1FLFVBQVUwVCxDQUFWLENBQWxCLEVBQWdDbGMsSUFBaEM7QUFDRDtBQUNGOztBQUVELE1BQUlBLFNBQVNHLGlDQUFiLEVBQWtDO0FBQ2hDa3ZFLDBCQUFzQjlsRCxPQUF0QjtBQUNELEdBRkQsTUFFTztBQUNMNGxELHNCQUFrQjVsRCxPQUFsQjtBQUNEOztBQUVELFNBQU9BLE9BQVA7QUFDRDs7QUFFTSxTQUFTMjVDLDJCQUFULENBQXFDbGpFLElBQXJDLEVBQTJDO0FBQ2hELE1BQU15dkUsbUJBQW1Cek0sNEJBQTRCejBDLElBQTVCLENBQWlDLElBQWpDLEVBQXVDdnVCLElBQXZDLENBQXpCO0FBQ0F5dkUsbUJBQWlCenZFLElBQWpCLEdBQXdCQSxJQUF4QjtBQUNBO0FBQ0EsTUFBSTNFLElBQUosRUFBYTtBQUNYcU0sV0FBT00sY0FBUCxDQUFzQnluRSxnQkFBdEIsRUFBd0MsTUFBeEMsRUFBZ0Q7QUFDOUN0c0Msa0JBQVksS0FEa0M7QUFFOUNyNkIsV0FBSyxlQUFXO0FBQ2QsMENBQ0UsS0FERixFQUVFLDJEQUNFLHFDQUhKO0FBS0FwQixlQUFPTSxjQUFQLENBQXNCLElBQXRCLEVBQTRCLE1BQTVCLEVBQW9DO0FBQ2xDeVgsaUJBQU96ZjtBQUQyQixTQUFwQztBQUdBLGVBQU9BLElBQVA7QUFDRDtBQVo2QyxLQUFoRDtBQWNEOztBQUVELFNBQU95dkUsZ0JBQVA7QUFDRDs7QUFFTSxTQUFTeE0sMEJBQVQsQ0FBb0MxNUMsT0FBcEMsRUFBNkMxWSxLQUE3QyxFQUFvRHNZLFFBQXBELEVBQThEO0FBQ25FLE1BQU11YSxhQUFhM0IsMkJBQWFobEMsS0FBYixDQUFtQixJQUFuQixFQUF5QnlMLFNBQXpCLENBQW5CO0FBQ0EsT0FBSyxJQUFJMFQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMVQsVUFBVWpNLE1BQTlCLEVBQXNDMmYsR0FBdEMsRUFBMkM7QUFDekNnekQsc0JBQWtCMW1FLFVBQVUwVCxDQUFWLENBQWxCLEVBQWdDd25CLFdBQVcxakMsSUFBM0M7QUFDRDtBQUNEbXZFLG9CQUFrQnpyQyxVQUFsQjtBQUNBLFNBQU9BLFVBQVA7QUFDRCxDOzs7Ozs7Ozs7QUNoWEQ7QUFDQSxJQUFJcE0sVUFBVXBjLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSXUwRCxnQkFBSjtBQUNBLElBQUlDLGtCQUFKOztBQUVBLFNBQVNDLGdCQUFULEdBQTRCO0FBQ3hCLFVBQU0sSUFBSXAwRSxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIO0FBQ0QsU0FBU3EwRSxtQkFBVCxHQUFnQztBQUM1QixVQUFNLElBQUlyMEUsS0FBSixDQUFVLG1DQUFWLENBQU47QUFDSDtBQUNBLGFBQVk7QUFDVCxRQUFJO0FBQ0EsWUFBSSxPQUFPZ3NELFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDbENrb0IsK0JBQW1CbG9CLFVBQW5CO0FBQ0gsU0FGRCxNQUVPO0FBQ0hrb0IsK0JBQW1CRSxnQkFBbkI7QUFDSDtBQUNKLEtBTkQsQ0FNRSxPQUFPOXpFLENBQVAsRUFBVTtBQUNSNHpFLDJCQUFtQkUsZ0JBQW5CO0FBQ0g7QUFDRCxRQUFJO0FBQ0EsWUFBSSxPQUFPakYsWUFBUCxLQUF3QixVQUE1QixFQUF3QztBQUNwQ2dGLGlDQUFxQmhGLFlBQXJCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hnRixpQ0FBcUJFLG1CQUFyQjtBQUNIO0FBQ0osS0FORCxDQU1FLE9BQU8vekUsQ0FBUCxFQUFVO0FBQ1I2ekUsNkJBQXFCRSxtQkFBckI7QUFDSDtBQUNKLENBbkJBLEdBQUQ7QUFvQkEsU0FBU0MsVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUI7QUFDckIsUUFBSUwscUJBQXFCbG9CLFVBQXpCLEVBQXFDO0FBQ2pDO0FBQ0EsZUFBT0EsV0FBV3VvQixHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNEO0FBQ0EsUUFBSSxDQUFDTCxxQkFBcUJFLGdCQUFyQixJQUF5QyxDQUFDRixnQkFBM0MsS0FBZ0Vsb0IsVUFBcEUsRUFBZ0Y7QUFDNUVrb0IsMkJBQW1CbG9CLFVBQW5CO0FBQ0EsZUFBT0EsV0FBV3VvQixHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNELFFBQUk7QUFDQTtBQUNBLGVBQU9MLGlCQUFpQkssR0FBakIsRUFBc0IsQ0FBdEIsQ0FBUDtBQUNILEtBSEQsQ0FHRSxPQUFNajBFLENBQU4sRUFBUTtBQUNOLFlBQUk7QUFDQTtBQUNBLG1CQUFPNHpFLGlCQUFpQjF5RSxJQUFqQixDQUFzQixJQUF0QixFQUE0Qit5RSxHQUE1QixFQUFpQyxDQUFqQyxDQUFQO0FBQ0gsU0FIRCxDQUdFLE9BQU1qMEUsQ0FBTixFQUFRO0FBQ047QUFDQSxtQkFBTzR6RSxpQkFBaUIxeUUsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEIreUUsR0FBNUIsRUFBaUMsQ0FBakMsQ0FBUDtBQUNIO0FBQ0o7QUFHSjtBQUNELFNBQVNDLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDO0FBQzdCLFFBQUlOLHVCQUF1QmhGLFlBQTNCLEVBQXlDO0FBQ3JDO0FBQ0EsZUFBT0EsYUFBYXNGLE1BQWIsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxRQUFJLENBQUNOLHVCQUF1QkUsbUJBQXZCLElBQThDLENBQUNGLGtCQUFoRCxLQUF1RWhGLFlBQTNFLEVBQXlGO0FBQ3JGZ0YsNkJBQXFCaEYsWUFBckI7QUFDQSxlQUFPQSxhQUFhc0YsTUFBYixDQUFQO0FBQ0g7QUFDRCxRQUFJO0FBQ0E7QUFDQSxlQUFPTixtQkFBbUJNLE1BQW5CLENBQVA7QUFDSCxLQUhELENBR0UsT0FBT24wRSxDQUFQLEVBQVM7QUFDUCxZQUFJO0FBQ0E7QUFDQSxtQkFBTzZ6RSxtQkFBbUIzeUUsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJpekUsTUFBOUIsQ0FBUDtBQUNILFNBSEQsQ0FHRSxPQUFPbjBFLENBQVAsRUFBUztBQUNQO0FBQ0E7QUFDQSxtQkFBTzZ6RSxtQkFBbUIzeUUsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJpekUsTUFBOUIsQ0FBUDtBQUNIO0FBQ0o7QUFJSjtBQUNELElBQUk5OUQsUUFBUSxFQUFaO0FBQ0EsSUFBSSs5RCxXQUFXLEtBQWY7QUFDQSxJQUFJcjlELFlBQUo7QUFDQSxJQUFJczlELGFBQWEsQ0FBQyxDQUFsQjs7QUFFQSxTQUFTQyxlQUFULEdBQTJCO0FBQ3ZCLFFBQUksQ0FBQ0YsUUFBRCxJQUFhLENBQUNyOUQsWUFBbEIsRUFBZ0M7QUFDNUI7QUFDSDtBQUNEcTlELGVBQVcsS0FBWDtBQUNBLFFBQUlyOUQsYUFBYXRXLE1BQWpCLEVBQXlCO0FBQ3JCNFYsZ0JBQVFVLGFBQWEyOEIsTUFBYixDQUFvQnI5QixLQUFwQixDQUFSO0FBQ0gsS0FGRCxNQUVPO0FBQ0hnK0QscUJBQWEsQ0FBQyxDQUFkO0FBQ0g7QUFDRCxRQUFJaCtELE1BQU01VixNQUFWLEVBQWtCO0FBQ2Q4ekU7QUFDSDtBQUNKOztBQUVELFNBQVNBLFVBQVQsR0FBc0I7QUFDbEIsUUFBSUgsUUFBSixFQUFjO0FBQ1Y7QUFDSDtBQUNELFFBQUloN0MsVUFBVTQ2QyxXQUFXTSxlQUFYLENBQWQ7QUFDQUYsZUFBVyxJQUFYOztBQUVBLFFBQUlJLE1BQU1uK0QsTUFBTTVWLE1BQWhCO0FBQ0EsV0FBTSt6RSxHQUFOLEVBQVc7QUFDUHo5RCx1QkFBZVYsS0FBZjtBQUNBQSxnQkFBUSxFQUFSO0FBQ0EsZUFBTyxFQUFFZytELFVBQUYsR0FBZUcsR0FBdEIsRUFBMkI7QUFDdkIsZ0JBQUl6OUQsWUFBSixFQUFrQjtBQUNkQSw2QkFBYXM5RCxVQUFiLEVBQXlCSSxHQUF6QjtBQUNIO0FBQ0o7QUFDREoscUJBQWEsQ0FBQyxDQUFkO0FBQ0FHLGNBQU1uK0QsTUFBTTVWLE1BQVo7QUFDSDtBQUNEc1csbUJBQWUsSUFBZjtBQUNBcTlELGVBQVcsS0FBWDtBQUNBRixvQkFBZ0I5NkMsT0FBaEI7QUFDSDs7QUFFRG9DLFFBQVFrNUMsUUFBUixHQUFtQixVQUFVVCxHQUFWLEVBQWU7QUFDOUIsUUFBSTl6RSxPQUFPLElBQUk2aEIsS0FBSixDQUFVdFYsVUFBVWpNLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBLFFBQUlpTSxVQUFVak0sTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QixhQUFLLElBQUkyZixJQUFJLENBQWIsRUFBZ0JBLElBQUkxVCxVQUFVak0sTUFBOUIsRUFBc0MyZixHQUF0QyxFQUEyQztBQUN2Q2pnQixpQkFBS2lnQixJQUFJLENBQVQsSUFBYzFULFVBQVUwVCxDQUFWLENBQWQ7QUFDSDtBQUNKO0FBQ0QvSixVQUFNeEksSUFBTixDQUFXLElBQUk4bUUsSUFBSixDQUFTVixHQUFULEVBQWM5ekUsSUFBZCxDQUFYO0FBQ0EsUUFBSWtXLE1BQU01VixNQUFOLEtBQWlCLENBQWpCLElBQXNCLENBQUMyekUsUUFBM0IsRUFBcUM7QUFDakNKLG1CQUFXTyxVQUFYO0FBQ0g7QUFDSixDQVhEOztBQWFBO0FBQ0EsU0FBU0ksSUFBVCxDQUFjVixHQUFkLEVBQW1CMWxDLEtBQW5CLEVBQTBCO0FBQ3RCLFNBQUswbEMsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBSzFsQyxLQUFMLEdBQWFBLEtBQWI7QUFDSDtBQUNEb21DLEtBQUszekUsU0FBTCxDQUFleXpFLEdBQWYsR0FBcUIsWUFBWTtBQUM3QixTQUFLUixHQUFMLENBQVNoekUsS0FBVCxDQUFlLElBQWYsRUFBcUIsS0FBS3N0QyxLQUExQjtBQUNILENBRkQ7QUFHQS9TLFFBQVF1N0IsS0FBUixHQUFnQixTQUFoQjtBQUNBdjdCLFFBQVFvNUMsT0FBUixHQUFrQixJQUFsQjtBQUNBcDVDLFFBQVFDLEdBQVIsR0FBYyxFQUFkO0FBQ0FELFFBQVFxNUMsSUFBUixHQUFlLEVBQWY7QUFDQXI1QyxRQUFReW9DLE9BQVIsR0FBa0IsRUFBbEIsQyxDQUFzQjtBQUN0QnpvQyxRQUFRczVDLFFBQVIsR0FBbUIsRUFBbkI7O0FBRUEsU0FBU0MsSUFBVCxHQUFnQixDQUFFOztBQUVsQnY1QyxRQUFRdzVDLEVBQVIsR0FBYUQsSUFBYjtBQUNBdjVDLFFBQVF5NUMsV0FBUixHQUFzQkYsSUFBdEI7QUFDQXY1QyxRQUFRMDVDLElBQVIsR0FBZUgsSUFBZjtBQUNBdjVDLFFBQVEyNUMsR0FBUixHQUFjSixJQUFkO0FBQ0F2NUMsUUFBUTQ1QyxjQUFSLEdBQXlCTCxJQUF6QjtBQUNBdjVDLFFBQVE2NUMsa0JBQVIsR0FBNkJOLElBQTdCO0FBQ0F2NUMsUUFBUTg1QyxJQUFSLEdBQWVQLElBQWY7QUFDQXY1QyxRQUFRKzVDLGVBQVIsR0FBMEJSLElBQTFCO0FBQ0F2NUMsUUFBUWc2QyxtQkFBUixHQUE4QlQsSUFBOUI7O0FBRUF2NUMsUUFBUWk2QyxTQUFSLEdBQW9CLFVBQVVuMUUsSUFBVixFQUFnQjtBQUFFLFdBQU8sRUFBUDtBQUFXLENBQWpEOztBQUVBazdCLFFBQVFrNkMsT0FBUixHQUFrQixVQUFVcDFFLElBQVYsRUFBZ0I7QUFDOUIsVUFBTSxJQUFJWixLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNILENBRkQ7O0FBSUE4N0IsUUFBUW02QyxHQUFSLEdBQWMsWUFBWTtBQUFFLFdBQU8sR0FBUDtBQUFZLENBQXhDO0FBQ0FuNkMsUUFBUW82QyxLQUFSLEdBQWdCLFVBQVU5akIsR0FBVixFQUFlO0FBQzNCLFVBQU0sSUFBSXB5RCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7QUFHQTg3QixRQUFRcTZDLEtBQVIsR0FBZ0IsWUFBVztBQUFFLFdBQU8sQ0FBUDtBQUFXLENBQXhDLEM7Ozs7Ozs7QUN2TEE7Ozs7Ozs7QUFPYTs7QUFFYixJQUFJbDZDLHVCQUF1Qiw4Q0FBM0I7O0FBRUF2YyxPQUFPQyxPQUFQLEdBQWlCc2Msb0JBQWpCLEM7Ozs7Ozs7QUNYQTs7Ozs7Ozs7O0FBU2E7O0FBRWIsSUFBTTJxQyxXQUFXMXFDLG1CQUFPQSxDQUFDLEdBQVIsQ0FBakI7O0FBRUE7QUFDQTtBQUNBeGMsT0FBT0MsT0FBUCxHQUFpQmluRCxTQUFTaG5ELE9BQVQsSUFBb0JnbkQsUUFBckMsQzs7Ozs7Ozs7Ozs7OztBQ0VBOztBQUNBOztBQUVBOztBQWtCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFLQTs7QUFJQTs7QUFDQTs7QUFJQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7QUFNQTs7QUFDQTs7QUFDQTs7QUFNQTs7OztBQXBFQTtBQUNBO0FBcUVBLElBQU1oNEMsb0JBQW9CL3NCLCtCQUFxQitzQixpQkFBL0MsQyxDQWhGQTs7Ozs7Ozs7O0FBa0ZBLElBQUl3bkQsK0JBQUo7QUFDQSxJQUFJajRCLDhCQUFKO0FBQ0EsSUFBSWs0QixtQ0FBbUMsS0FBdkM7O0FBRUEsSUFBSXgyRSxJQUFKLEVBQWE7QUFDWCxNQUNFLE9BQU9zc0IsR0FBUCxLQUFlLFVBQWY7QUFDQTtBQUNBQSxNQUFJN3FCLFNBQUosSUFBaUIsSUFGakIsSUFHQSxPQUFPNnFCLElBQUk3cUIsU0FBSixDQUFjb2pCLE9BQXJCLEtBQWlDLFVBSGpDLElBSUEsT0FBT3VFLEdBQVAsS0FBZSxVQUpmO0FBS0E7QUFDQUEsTUFBSTNuQixTQUFKLElBQWlCLElBTmpCLElBT0EsT0FBTzJuQixJQUFJM25CLFNBQUosQ0FBYzJwQixLQUFyQixLQUErQixVQVAvQixJQVFBLE9BQU9oQyxJQUFJM25CLFNBQUosQ0FBY29qQixPQUFyQixLQUFpQyxVQVRuQyxFQVVFO0FBQ0EsdUNBQ0UsS0FERixFQUVFLDRFQUNFLDJEQUhKO0FBS0Q7O0FBRUQweEQsMkJBQXlCLGdDQUFDRSxTQUFELEVBQTZCO0FBQ3BELFFBQUlBLFVBQVVDLG1CQUFWLElBQWlDRCxVQUFVaGhDLFFBQVYsS0FBdUJyaEMsMEJBQTVELEVBQTBFO0FBQ3hFLFVBQU11aUUsZUFBZSwyQ0FDbkJGLFVBQVVDLG1CQUFWLENBQThCRSxhQUE5QixDQUE0Q3B2RSxPQUR6QixDQUFyQjtBQUdBLFVBQUltdkUsWUFBSixFQUFrQjtBQUNoQiwyQ0FDRUEsYUFBYXRoRSxVQUFiLEtBQTRCb2hFLFNBRDlCLEVBRUUsbUVBQ0UseURBREYsR0FFRSxpREFGRixHQUdFLHVEQUxKO0FBT0Q7QUFDRjs7QUFFRCxRQUFNSSw0QkFBNEIsQ0FBQyxDQUFDSixVQUFVQyxtQkFBOUM7QUFDQSxRQUFNSSxTQUFTQywrQkFBK0JOLFNBQS9CLENBQWY7QUFDQSxRQUFNTyx1QkFBdUIsQ0FBQyxFQUFFRixVQUFVLGdEQUFvQkEsTUFBcEIsQ0FBWixDQUE5Qjs7QUFFQSx1Q0FDRSxDQUFDRSxvQkFBRCxJQUF5QkgseUJBRDNCLEVBRUUsb0VBQ0Usa0VBREYsR0FFRSxtRUFGRixHQUdFLG1FQUxKOztBQVFBLHVDQUNFSixVQUFVaGhDLFFBQVYsS0FBdUJ2aEMsMEJBQXZCLElBQ0UsQ0FBR3VpRSxTQUFGLENBQTRCM3BDLE9BRC9CLElBRUkycEMsU0FBRixDQUE0QjNwQyxPQUE1QixDQUFvQzduQixXQUFwQyxPQUFzRCxNQUgxRCxFQUlFLG1FQUNFLHVFQURGLEdBRUUsMERBRkYsR0FHRSx3RUFIRixHQUlFLGVBUko7QUFVRCxHQXRDRDs7QUF3Q0FxNUIsMEJBQXdCLCtCQUFTNW1DLFFBQVQsRUFBMEJpbkMsVUFBMUIsRUFBOEM7QUFDcEUsdUNBQ0VqbkMsYUFBYSxJQUFiLElBQXFCLE9BQU9BLFFBQVAsS0FBb0IsVUFEM0MsRUFFRSxxRUFDRSxpQ0FISixFQUlFaW5DLFVBSkYsRUFLRWpuQyxRQUxGO0FBT0QsR0FSRDtBQVNEOztBQUVELHdEQUF5QnkrQix5Q0FBekI7O0FBeUNBLFNBQVM4Z0MsVUFBVCxDQUFvQm5sRCxJQUFwQixFQUFxQztBQUNuQyxNQUFNdm9CLGlCQUFpQiwyQ0FBdkI7QUFDQSxPQUFLNnhCLGVBQUwsR0FBdUI3eEIsY0FBdkI7QUFDQSxPQUFLMnRFLEtBQUwsR0FBYXBsRCxJQUFiO0FBQ0EsT0FBS3FsRCxLQUFMLEdBQWEsSUFBYjtBQUNBLE9BQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxPQUFLQyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0EsT0FBS0MsWUFBTCxHQUFvQixLQUFwQjtBQUNBLE9BQUtDLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxPQUFLbDhDLE1BQUwsR0FBYyxJQUFkO0FBQ0Q7QUFDRDQ3QyxXQUFXeDFFLFNBQVgsQ0FBcUI4RCxNQUFyQixHQUE4QixVQUFTdW9CLFFBQVQsRUFBa0M7QUFDOUQsMkJBQ0UsS0FBS3VOLE1BRFAsRUFFRSw2REFGRjtBQUlBLE9BQUtpOEMsWUFBTCxHQUFvQixJQUFwQjtBQUNBLE9BQUtDLFNBQUwsR0FBaUJ6cEQsUUFBakI7QUFDQSxNQUFNMHBELGVBQWUsS0FBS04sS0FBTCxDQUFXTixhQUFoQztBQUNBLE1BQU1ydEUsaUJBQWlCLEtBQUs2eEIsZUFBNUI7QUFDQSxNQUFNcThDLE9BQU8sSUFBSUMsU0FBSixFQUFiO0FBQ0EsK0NBQ0U1cEQsUUFERixFQUVFMHBELFlBRkYsRUFHRSxJQUhGLEVBSUVqdUUsY0FKRixFQUtFa3VFLEtBQUtFLFNBTFA7QUFPQSxTQUFPRixJQUFQO0FBQ0QsQ0FsQkQ7QUFtQkFSLFdBQVd4MUUsU0FBWCxDQUFxQmt2QixJQUFyQixHQUE0QixVQUFTaUcsVUFBVCxFQUFrQztBQUM1RCxNQUFJLEtBQUt5Z0QsWUFBVCxFQUF1QjtBQUNyQnpnRDtBQUNBO0FBQ0Q7QUFDRCxNQUFJZ2hELFlBQVksS0FBS1IsVUFBckI7QUFDQSxNQUFJUSxjQUFjLElBQWxCLEVBQXdCO0FBQ3RCQSxnQkFBWSxLQUFLUixVQUFMLEdBQWtCLEVBQTlCO0FBQ0Q7QUFDRFEsWUFBVXRwRSxJQUFWLENBQWVzb0IsVUFBZjtBQUNELENBVkQ7QUFXQXFnRCxXQUFXeDFFLFNBQVgsQ0FBcUJvMkUsTUFBckIsR0FBOEIsWUFBVztBQUN2QyxNQUFNTCxlQUFlLEtBQUtOLEtBQUwsQ0FBV04sYUFBaEM7QUFDQSxNQUFJejdDLGFBQWFxOEMsYUFBYXI4QyxVQUE5QjtBQUNBLDJCQUNFLEtBQUtFLE1BQUwsSUFBZUYsZUFBZSxJQURoQyxFQUVFLHFEQUZGOztBQUtBLE1BQUksQ0FBQyxLQUFLbThDLFlBQVYsRUFBd0I7QUFDdEI7QUFDQSxTQUFLSCxLQUFMLEdBQWEsSUFBYjtBQUNBLFNBQUs5N0MsTUFBTCxHQUFjLEtBQWQ7QUFDQTtBQUNEOztBQUVELE1BQUk5eEIsaUJBQWlCLEtBQUs2eEIsZUFBMUI7O0FBRUE7QUFDQSxNQUFJRCxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFFBQUksS0FBS204QyxZQUFULEVBQXVCO0FBQ3JCL3RFLHVCQUFpQixLQUFLNnhCLGVBQUwsR0FBdUJELFdBQVdDLGVBQW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFLNzFCLE1BQUwsQ0FBWSxLQUFLZ3lFLFNBQWpCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJckosV0FBVyxJQUFmO0FBQ0EsUUFBSW56QyxRQUFRSSxVQUFaO0FBQ0EsV0FBT0osVUFBVSxJQUFqQixFQUF1QjtBQUNyQm16QyxpQkFBV256QyxLQUFYO0FBQ0FBLGNBQVFBLE1BQU1vOEMsS0FBZDtBQUNEO0FBQ0QsNkJBQ0VqSixhQUFhLElBRGYsRUFFRSxxREFGRjtBQUlBQSxhQUFTaUosS0FBVCxHQUFpQnA4QyxNQUFNbzhDLEtBQXZCOztBQUVBO0FBQ0EsU0FBS0EsS0FBTCxHQUFhaDhDLFVBQWI7QUFDQUEsaUJBQWFxOEMsYUFBYXI4QyxVQUFiLEdBQTBCLElBQXZDO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFLRSxNQUFMLEdBQWMsS0FBZDtBQUNBLHlCQUFVbThDLFlBQVYsRUFBd0JqdUUsY0FBeEI7O0FBRUE7QUFDQSxNQUFNb08sT0FBTyxLQUFLdy9ELEtBQWxCO0FBQ0EsT0FBS0EsS0FBTCxHQUFhLElBQWI7QUFDQWg4QyxlQUFhcThDLGFBQWFyOEMsVUFBYixHQUEwQnhqQixJQUF2Qzs7QUFFQTtBQUNBLE1BQUl3akIsZUFBZSxJQUFmLElBQXVCQSxXQUFXbThDLFlBQXRDLEVBQW9EO0FBQ2xEbjhDLGVBQVc1MUIsTUFBWCxDQUFrQjQxQixXQUFXbzhDLFNBQTdCO0FBQ0Q7QUFDRixDQTlERDtBQStEQU4sV0FBV3gxRSxTQUFYLENBQXFCdTVCLFdBQXJCLEdBQW1DLFlBQVc7QUFDNUMsTUFBSSxLQUFLcThDLFlBQVQsRUFBdUI7QUFDckI7QUFDRDtBQUNELE9BQUtBLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxNQUFNTyxZQUFZLEtBQUtSLFVBQXZCO0FBQ0EsTUFBSVEsY0FBYyxJQUFsQixFQUF3QjtBQUN0QjtBQUNEO0FBQ0Q7QUFDQSxPQUFLLElBQUkvMkQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJKzJELFVBQVUxMkUsTUFBOUIsRUFBc0MyZixHQUF0QyxFQUEyQztBQUN6QyxRQUFNbkosWUFBV2tnRSxVQUFVLzJELENBQVYsQ0FBakI7QUFDQW5KO0FBQ0Q7QUFDRixDQWREOztBQXVCQSxTQUFTZ2dFLFNBQVQsR0FBcUI7QUFDbkIsT0FBS04sVUFBTCxHQUFrQixJQUFsQjtBQUNBLE9BQUtVLFVBQUwsR0FBa0IsS0FBbEI7QUFDQTtBQUNBO0FBQ0EsT0FBS0gsU0FBTCxHQUFpQixLQUFLQSxTQUFMLENBQWV6a0QsSUFBZixDQUFvQixJQUFwQixDQUFqQjtBQUNEO0FBQ0R3a0QsVUFBVWoyRSxTQUFWLENBQW9Ca3ZCLElBQXBCLEdBQTJCLFVBQVMrQyxRQUFULEVBQXNDO0FBQy9ELE1BQUksS0FBS29rRCxVQUFULEVBQXFCO0FBQ25CcGtEO0FBQ0E7QUFDRDtBQUNELE1BQUlra0QsWUFBWSxLQUFLUixVQUFyQjtBQUNBLE1BQUlRLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEJBLGdCQUFZLEtBQUtSLFVBQUwsR0FBa0IsRUFBOUI7QUFDRDtBQUNEUSxZQUFVdHBFLElBQVYsQ0FBZW9sQixRQUFmO0FBQ0QsQ0FWRDtBQVdBZ2tELFVBQVVqMkUsU0FBVixDQUFvQmsyRSxTQUFwQixHQUFnQyxZQUFpQjtBQUMvQyxNQUFJLEtBQUtHLFVBQVQsRUFBcUI7QUFDbkI7QUFDRDtBQUNELE9BQUtBLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxNQUFNRixZQUFZLEtBQUtSLFVBQXZCO0FBQ0EsTUFBSVEsY0FBYyxJQUFsQixFQUF3QjtBQUN0QjtBQUNEO0FBQ0Q7QUFDQSxPQUFLLElBQUkvMkQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJKzJELFVBQVUxMkUsTUFBOUIsRUFBc0MyZixHQUF0QyxFQUEyQztBQUN6QyxRQUFNbkosYUFBV2tnRSxVQUFVLzJELENBQVYsQ0FBakI7QUFDQSw2QkFDRSxPQUFPbkosVUFBUCxLQUFvQixVQUR0QixFQUVFLHVFQUNFLGNBSEosRUFJRUEsVUFKRjtBQU1BQTtBQUNEO0FBQ0YsQ0FwQkQ7O0FBc0JBLFNBQVNxZ0UsU0FBVCxDQUNFdEIsU0FERixFQUVFaHBELFlBRkYsRUFHRW9VLE9BSEYsRUFJRTtBQUNBLE1BQU0vUCxPQUFPLDZCQUFnQjJrRCxTQUFoQixFQUEyQmhwRCxZQUEzQixFQUF5Q29VLE9BQXpDLENBQWI7QUFDQSxPQUFLKzBDLGFBQUwsR0FBcUI5a0QsSUFBckI7QUFDRDtBQUNEaW1ELFVBQVV0MkUsU0FBVixDQUFvQjhELE1BQXBCLEdBQTZCLFVBQzNCdW9CLFFBRDJCLEVBRTNCcFcsUUFGMkIsRUFHckI7QUFDTixNQUFNb2EsT0FBTyxLQUFLOGtELGFBQWxCO0FBQ0EsTUFBTWEsT0FBTyxJQUFJQyxTQUFKLEVBQWI7QUFDQWhnRSxhQUFXQSxhQUFheFgsU0FBYixHQUF5QixJQUF6QixHQUFnQ3dYLFFBQTNDO0FBQ0EsTUFBSTFYLElBQUosRUFBYTtBQUNYcytDLDBCQUFzQjVtQyxRQUF0QixFQUFnQyxRQUFoQztBQUNEO0FBQ0QsTUFBSUEsYUFBYSxJQUFqQixFQUF1QjtBQUNyQisvRCxTQUFLOW1ELElBQUwsQ0FBVWpaLFFBQVY7QUFDRDtBQUNELCtCQUFnQm9XLFFBQWhCLEVBQTBCZ0UsSUFBMUIsRUFBZ0MsSUFBaEMsRUFBc0MybEQsS0FBS0UsU0FBM0M7QUFDQSxTQUFPRixJQUFQO0FBQ0QsQ0FmRDtBQWdCQU0sVUFBVXQyRSxTQUFWLENBQW9CdTJFLE9BQXBCLEdBQThCLFVBQVN0Z0UsUUFBVCxFQUF1QztBQUNuRSxNQUFNb2EsT0FBTyxLQUFLOGtELGFBQWxCO0FBQ0EsTUFBTWEsT0FBTyxJQUFJQyxTQUFKLEVBQWI7QUFDQWhnRSxhQUFXQSxhQUFheFgsU0FBYixHQUF5QixJQUF6QixHQUFnQ3dYLFFBQTNDO0FBQ0EsTUFBSTFYLElBQUosRUFBYTtBQUNYcytDLDBCQUFzQjVtQyxRQUF0QixFQUFnQyxRQUFoQztBQUNEO0FBQ0QsTUFBSUEsYUFBYSxJQUFqQixFQUF1QjtBQUNyQisvRCxTQUFLOW1ELElBQUwsQ0FBVWpaLFFBQVY7QUFDRDtBQUNELCtCQUFnQixJQUFoQixFQUFzQm9hLElBQXRCLEVBQTRCLElBQTVCLEVBQWtDMmxELEtBQUtFLFNBQXZDO0FBQ0EsU0FBT0YsSUFBUDtBQUNELENBWkQ7QUFhQU0sVUFBVXQyRSxTQUFWLENBQW9CdzJFLGlDQUFwQixHQUF3RCxVQUN0REMsZUFEc0QsRUFFdERwcUQsUUFGc0QsRUFHdERwVyxRQUhzRCxFQUloRDtBQUNOLE1BQU1vYSxPQUFPLEtBQUs4a0QsYUFBbEI7QUFDQSxNQUFNYSxPQUFPLElBQUlDLFNBQUosRUFBYjtBQUNBaGdFLGFBQVdBLGFBQWF4WCxTQUFiLEdBQXlCLElBQXpCLEdBQWdDd1gsUUFBM0M7QUFDQSxNQUFJMVgsSUFBSixFQUFhO0FBQ1hzK0MsMEJBQXNCNW1DLFFBQXRCLEVBQWdDLFFBQWhDO0FBQ0Q7QUFDRCxNQUFJQSxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCKy9ELFNBQUs5bUQsSUFBTCxDQUFValosUUFBVjtBQUNEO0FBQ0QsK0JBQWdCb1csUUFBaEIsRUFBMEJnRSxJQUExQixFQUFnQ29tRCxlQUFoQyxFQUFpRFQsS0FBS0UsU0FBdEQ7QUFDQSxTQUFPRixJQUFQO0FBQ0QsQ0FoQkQ7QUFpQkFNLFVBQVV0MkUsU0FBVixDQUFvQjAyRSxXQUFwQixHQUFrQyxZQUFrQjtBQUNsRCxNQUFNcDlDLFFBQVEsSUFBSWs4QyxVQUFKLENBQWUsSUFBZixDQUFkO0FBQ0EsTUFBTTF0RSxpQkFBaUJ3eEIsTUFBTUssZUFBN0I7O0FBRUEsTUFBTW84QyxlQUFlLEtBQUtaLGFBQTFCO0FBQ0EsTUFBTXo3QyxhQUFhcThDLGFBQWFyOEMsVUFBaEM7QUFDQSxNQUFJQSxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCcThDLGlCQUFhcjhDLFVBQWIsR0FBMEJKLEtBQTFCO0FBQ0FBLFVBQU1vOEMsS0FBTixHQUFjLElBQWQ7QUFDRCxHQUhELE1BR087QUFDTDtBQUNBLFFBQUlpQixjQUFjLElBQWxCO0FBQ0EsUUFBSUMsZUFBZWw5QyxVQUFuQjtBQUNBLFdBQ0VrOUMsaUJBQWlCLElBQWpCLElBQ0FBLGFBQWFqOUMsZUFBYixJQUFnQzd4QixjQUZsQyxFQUdFO0FBQ0E2dUUsb0JBQWNDLFlBQWQ7QUFDQUEscUJBQWVBLGFBQWFsQixLQUE1QjtBQUNEO0FBQ0RwOEMsVUFBTW84QyxLQUFOLEdBQWNrQixZQUFkO0FBQ0EsUUFBSUQsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCQSxrQkFBWWpCLEtBQVosR0FBb0JwOEMsS0FBcEI7QUFDRDtBQUNGOztBQUVELFNBQU9BLEtBQVA7QUFDRCxDQTNCRDs7QUE2QkE7Ozs7Ozs7QUFPQSxTQUFTdTlDLGdCQUFULENBQTBCaHhFLElBQTFCLEVBQWdDO0FBQzlCLFNBQU8sQ0FBQyxFQUNOQSxTQUNDQSxLQUFLbXVDLFFBQUwsS0FBa0J2aEMsMEJBQWxCLElBQ0M1TSxLQUFLbXVDLFFBQUwsS0FBa0JwaEMsMkJBRG5CLElBRUMvTSxLQUFLbXVDLFFBQUwsS0FBa0JuaEMsb0NBRm5CLElBR0VoTixLQUFLbXVDLFFBQUwsS0FBa0JyaEMsMEJBQWxCLElBQ0M5TSxLQUFLaXhFLFNBQUwsS0FBbUIsOEJBTHZCLENBRE0sQ0FBUjtBQVFEOztBQUVELFNBQVN4Qiw4QkFBVCxDQUF3Q04sU0FBeEMsRUFBd0Q7QUFDdEQsTUFBSSxDQUFDQSxTQUFMLEVBQWdCO0FBQ2QsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSUEsVUFBVWhoQyxRQUFWLEtBQXVCcGhDLDJCQUEzQixFQUEwQztBQUN4QyxXQUFPb2lFLFVBQVUrQixlQUFqQjtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8vQixVQUFVZ0MsVUFBakI7QUFDRDtBQUNGOztBQUVELFNBQVNDLGlDQUFULENBQTJDakMsU0FBM0MsRUFBc0Q7QUFDcEQsTUFBTWtDLGNBQWM1QiwrQkFBK0JOLFNBQS9CLENBQXBCO0FBQ0EsU0FBTyxDQUFDLEVBQ05rQyxlQUNBQSxZQUFZbGpDLFFBQVosS0FBeUJ2aEMsMEJBRHpCLElBRUF5a0UsWUFBWXRnQyxZQUFaLENBQXlCMTBCLGdDQUF6QixDQUhNLENBQVI7QUFLRDs7QUFFRCxxREFDRTJYLHNCQURGLEVBRUVJLDBCQUZGLEVBR0VDLCtCQUhGOztBQU1BLElBQUlpOUMsd0JBQXdCLEtBQTVCOztBQUVBLFNBQVNDLGdDQUFULENBQ0VwQyxTQURGLEVBRUVxQyxZQUZGLEVBR1E7QUFDTixNQUFNQyxnQkFDSkQsZ0JBQWdCSixrQ0FBa0NqQyxTQUFsQyxDQURsQjtBQUVBO0FBQ0EsTUFBSSxDQUFDc0MsYUFBTCxFQUFvQjtBQUNsQixRQUFJQyxTQUFTLEtBQWI7QUFDQSxRQUFJQyxvQkFBSjtBQUNBLFdBQVFBLGNBQWN4QyxVQUFVeUMsU0FBaEMsRUFBNEM7QUFDMUMsVUFBSWw1RSxJQUFKLEVBQWE7QUFDWCxZQUNFLENBQUNnNUUsTUFBRCxJQUNBQyxZQUFZeGpDLFFBQVosS0FBeUJ2aEMsMEJBRHpCLElBRUMra0UsV0FBRCxDQUFtQjVnQyxZQUFuQixDQUFnQzEwQixnQ0FBaEMsQ0FIRixFQUlFO0FBQ0FxMUQsbUJBQVMsSUFBVDtBQUNBLDZDQUNFLEtBREYsRUFFRSxtRUFDRSwrREFERixHQUVFLHFEQUpKO0FBTUQ7QUFDRjtBQUNEdkMsZ0JBQVUwQyxXQUFWLENBQXNCRixXQUF0QjtBQUNEO0FBQ0Y7QUFDRCxNQUFJajVFLElBQUosRUFBYTtBQUNYLFFBQUkrNEUsaUJBQWlCLENBQUNELFlBQWxCLElBQWtDLENBQUNGLHFCQUF2QyxFQUE4RDtBQUM1REEsOEJBQXdCLElBQXhCO0FBQ0Esd0NBQ0UsS0FERixFQUVFLDJFQUNFLHFFQURGLEdBRUUseUVBSko7QUFNRDtBQUNGO0FBQ0Q7QUFDQSxNQUFNbnJELGVBQWUsS0FBckI7QUFDQSxTQUFPLElBQUlzcUQsU0FBSixDQUFjdEIsU0FBZCxFQUF5QmhwRCxZQUF6QixFQUF1Q3NyRCxhQUF2QyxDQUFQO0FBQ0Q7O0FBRUQsU0FBU0ssZ0NBQVQsQ0FDRWxCLGVBREYsRUFFRXBxRCxRQUZGLEVBR0Uyb0QsU0FIRixFQUlFcUMsWUFKRixFQUtFcGhFLFFBTEYsRUFNRTtBQUNBLE1BQUkxWCxJQUFKLEVBQWE7QUFDWHUyRSwyQkFBdUJFLFNBQXZCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUkza0QsT0FBYzJrRCxVQUFVQyxtQkFBNUI7QUFDQSxNQUFJLENBQUM1a0QsSUFBTCxFQUFXO0FBQ1Q7QUFDQUEsV0FBTzJrRCxVQUFVQyxtQkFBVixHQUFnQ21DLGlDQUNyQ3BDLFNBRHFDLEVBRXJDcUMsWUFGcUMsQ0FBdkM7QUFJQSxRQUFJLE9BQU9waEUsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQyxVQUFNMmhFLG1CQUFtQjNoRSxRQUF6QjtBQUNBQSxpQkFBVyxvQkFBVztBQUNwQixZQUFNdkosV0FBVyxtQ0FBc0IyakIsS0FBSzhrRCxhQUEzQixDQUFqQjtBQUNBeUMseUJBQWlCMTNFLElBQWpCLENBQXNCd00sUUFBdEI7QUFDRCxPQUhEO0FBSUQ7QUFDRDtBQUNBLGtDQUFpQixZQUFNO0FBQ3JCLFVBQUkrcEUsbUJBQW1CLElBQXZCLEVBQTZCO0FBQzNCcG1ELGFBQUttbUQsaUNBQUwsQ0FDRUMsZUFERixFQUVFcHFELFFBRkYsRUFHRXBXLFFBSEY7QUFLRCxPQU5ELE1BTU87QUFDTG9hLGFBQUt2c0IsTUFBTCxDQUFZdW9CLFFBQVosRUFBc0JwVyxRQUF0QjtBQUNEO0FBQ0YsS0FWRDtBQVdELEdBekJELE1BeUJPO0FBQ0wsUUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDLFVBQU0yaEUsb0JBQW1CM2hFLFFBQXpCO0FBQ0FBLGlCQUFXLG9CQUFXO0FBQ3BCLFlBQU12SixXQUFXLG1DQUFzQjJqQixLQUFLOGtELGFBQTNCLENBQWpCO0FBQ0F5QywwQkFBaUIxM0UsSUFBakIsQ0FBc0J3TSxRQUF0QjtBQUNELE9BSEQ7QUFJRDtBQUNEO0FBQ0EsUUFBSStwRSxtQkFBbUIsSUFBdkIsRUFBNkI7QUFDM0JwbUQsV0FBS21tRCxpQ0FBTCxDQUNFQyxlQURGLEVBRUVwcUQsUUFGRixFQUdFcFcsUUFIRjtBQUtELEtBTkQsTUFNTztBQUNMb2EsV0FBS3ZzQixNQUFMLENBQVl1b0IsUUFBWixFQUFzQnBXLFFBQXRCO0FBQ0Q7QUFDRjtBQUNELFNBQU8sbUNBQXNCb2EsS0FBSzhrRCxhQUEzQixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzBDLFlBQVQsQ0FDRXhyRCxRQURGLEVBRUUyb0QsU0FGRixFQUlFO0FBQUEsTUFEQS8zRCxHQUNBLHVFQURlLElBQ2Y7O0FBQ0EsMkJBQ0U0NUQsaUJBQWlCN0IsU0FBakIsQ0FERixFQUVFLHdDQUZGO0FBSUE7QUFDQSxTQUFPLCtCQUFpQjNvRCxRQUFqQixFQUEyQjJvRCxTQUEzQixFQUFzQyxJQUF0QyxFQUE0Qy8zRCxHQUE1QyxDQUFQO0FBQ0Q7O0FBRUQsSUFBTXFvRCxXQUFtQjtBQUN2QnVTLDRCQUR1Qjs7QUFHdkJDLGFBSHVCLHVCQUlyQkMsa0JBSnFCLEVBS0U7QUFDdkIsUUFBSXg1RSxJQUFKLEVBQWE7QUFDWCxVQUFJK0csUUFBU2dvQixrQkFBa0J2bkIsT0FBL0I7QUFDQSxVQUFJVCxVQUFVLElBQVYsSUFBa0JBLE1BQU13TyxTQUFOLEtBQW9CLElBQTFDLEVBQWdEO0FBQzlDLFlBQU1ra0UsMEJBQ0oxeUUsTUFBTXdPLFNBQU4sQ0FBZ0Jta0Usd0JBRGxCO0FBRUEsMkNBQ0VELHVCQURGLEVBRUUsc0RBQ0UsbUVBREYsR0FFRSxvRUFGRixHQUdFLGlFQUhGLEdBSUUsNkJBTkosRUFPRSxnQ0FBaUIxeUUsTUFBTXBDLElBQXZCLEtBQWdDLGFBUGxDO0FBU0FvQyxjQUFNd08sU0FBTixDQUFnQm1rRSx3QkFBaEIsR0FBMkMsSUFBM0M7QUFDRDtBQUNGO0FBQ0QsUUFBSUYsc0JBQXNCLElBQTFCLEVBQWdDO0FBQzlCLGFBQU8sSUFBUDtBQUNEO0FBQ0QsUUFBS0Esa0JBQUQsQ0FBMEIvakMsUUFBMUIsS0FBdUN2aEMsMEJBQTNDLEVBQXlEO0FBQ3ZELGFBQVFzbEUsa0JBQVI7QUFDRDtBQUNELFFBQUl4NUUsSUFBSixFQUFhO0FBQ1gsYUFBTyx5Q0FBNEJ3NUUsa0JBQTVCLEVBQWdELGFBQWhELENBQVA7QUFDRDtBQUNELFdBQU8sOEJBQWlCQSxrQkFBakIsQ0FBUDtBQUNELEdBakNzQjtBQW1DdkIzM0MsU0FuQ3VCLG1CQW1DZjNULE9BbkNlLEVBbUNNdW9ELFNBbkNOLEVBbUMrQi8rRCxRQW5DL0IsRUFtQ29EO0FBQ3pFLDZCQUNFNGdFLGlCQUFpQjdCLFNBQWpCLENBREYsRUFFRSx3Q0FGRjtBQUlBLFFBQUl6MkUsSUFBSixFQUFhO0FBQ1gseUNBQ0UsQ0FBQ3kyRSxVQUFVa0Qsa0NBRGIsRUFFRSwyRUFDRSxrREFERixHQUVFLDhFQUpKLEVBS0U1MkUsb0RBQWlDLFlBQWpDLEdBQWdELHFCQUxsRDtBQU9EO0FBQ0Q7QUFDQSxXQUFPcTJFLGlDQUNMLElBREssRUFFTGxyRCxPQUZLLEVBR0x1b0QsU0FISyxFQUlMLElBSkssRUFLTC8rRCxRQUxLLENBQVA7QUFPRCxHQXpEc0I7QUEyRHZCblMsUUEzRHVCLGtCQTREckIyb0IsT0E1RHFCLEVBNkRyQnVvRCxTQTdEcUIsRUE4RHJCLytELFFBOURxQixFQStEckI7QUFDQSw2QkFDRTRnRSxpQkFBaUI3QixTQUFqQixDQURGLEVBRUUsd0NBRkY7QUFJQSxRQUFJejJFLElBQUosRUFBYTtBQUNYLHlDQUNFLENBQUN5MkUsVUFBVWtELGtDQURiLEVBRUUsMEVBQ0Usa0RBREYsR0FFRSw0Q0FKSixFQUtFNTJFLG9EQUFpQyxZQUFqQyxHQUFnRCxxQkFMbEQ7QUFPRDtBQUNELFdBQU9xMkUsaUNBQ0wsSUFESyxFQUVMbHJELE9BRkssRUFHTHVvRCxTQUhLLEVBSUwsS0FKSyxFQUtMLytELFFBTEssQ0FBUDtBQU9ELEdBcEZzQjtBQXNGdkJraUUscUNBdEZ1QiwrQ0F1RnJCMUIsZUF2RnFCLEVBd0ZyQmhxRCxPQXhGcUIsRUF5RnJCMnJELGFBekZxQixFQTBGckJuaUUsUUExRnFCLEVBMkZyQjtBQUNBLDZCQUNFNGdFLGlCQUFpQnVCLGFBQWpCLENBREYsRUFFRSx3Q0FGRjtBQUlBLDZCQUNFM0IsbUJBQW1CLElBQW5CLElBQTJCLDJCQUFZQSxlQUFaLENBRDdCLEVBRUUsaURBRkY7QUFJQSxXQUFPa0IsaUNBQ0xsQixlQURLLEVBRUxocUQsT0FGSyxFQUdMMnJELGFBSEssRUFJTCxLQUpLLEVBS0xuaUUsUUFMSyxDQUFQO0FBT0QsR0EzR3NCO0FBNkd2Qm9pRSx3QkE3R3VCLGtDQTZHQXJELFNBN0dBLEVBNkd5QjtBQUM5Qyw2QkFDRTZCLGlCQUFpQjdCLFNBQWpCLENBREYsRUFFRSxxRUFGRjs7QUFLQSxRQUFJejJFLElBQUosRUFBYTtBQUNYLHlDQUNFLENBQUN5MkUsVUFBVWtELGtDQURiLEVBRUUsMEZBQ0Usc0ZBSEosRUFJRTUyRSxvREFBaUMsWUFBakMsR0FBZ0QscUJBSmxEO0FBTUQ7O0FBRUQsUUFBSTB6RSxVQUFVQyxtQkFBZCxFQUFtQztBQUNqQyxVQUFJMTJFLElBQUosRUFBYTtBQUNYLFlBQU04MkUsU0FBU0MsK0JBQStCTixTQUEvQixDQUFmO0FBQ0EsWUFBTXNELDJCQUEyQmpELFVBQVUsQ0FBQyxnREFBb0JBLE1BQXBCLENBQTVDO0FBQ0EsMkNBQ0UsQ0FBQ2lELHdCQURILEVBRUUscUVBQ0Usd0NBSEo7QUFLRDs7QUFFRDtBQUNBLG9DQUFpQixZQUFNO0FBQ3JCWCx5Q0FBaUMsSUFBakMsRUFBdUMsSUFBdkMsRUFBNkMzQyxTQUE3QyxFQUF3RCxLQUF4RCxFQUErRCxZQUFNO0FBQ25FQSxvQkFBVUMsbUJBQVYsR0FBZ0MsSUFBaEM7QUFDRCxTQUZEO0FBR0QsT0FKRDtBQUtBO0FBQ0E7QUFDQSxhQUFPLElBQVA7QUFDRCxLQXBCRCxNQW9CTztBQUNMLFVBQUkxMkUsSUFBSixFQUFhO0FBQ1gsWUFBTTgyRSxVQUFTQywrQkFBK0JOLFNBQS9CLENBQWY7QUFDQSxZQUFNTyx1QkFBdUIsQ0FBQyxFQUFFRixXQUFVLGdEQUFvQkEsT0FBcEIsQ0FBWixDQUE5Qjs7QUFFQTtBQUNBLFlBQU1rRCx1QkFDSnZELFVBQVVoaEMsUUFBVixLQUF1QnZoQywwQkFBdkIsSUFDQW9rRSxpQkFBaUI3QixVQUFVcGhFLFVBQTNCLENBREEsSUFFQSxDQUFDLENBQUNvaEUsVUFBVXBoRSxVQUFWLENBQXFCcWhFLG1CQUh6Qjs7QUFLQSwyQ0FDRSxDQUFDTSxvQkFESCxFQUVFLHFFQUNFLDREQUhKLEVBSUVnRCx1QkFDSSxtRUFDQSxtQkFGSixHQUdJLDZEQUNBLDZDQVJOO0FBVUQ7O0FBRUQsYUFBTyxLQUFQO0FBQ0Q7QUFDRixHQXpLc0I7OztBQTJLdkI7QUFDQTtBQUNBQyx1QkE3S3VCLG1DQTZLUTtBQUM3QixRQUFJLENBQUN6RCxnQ0FBTCxFQUF1QztBQUNyQ0EseUNBQW1DLElBQW5DO0FBQ0Esd0NBQ0UsS0FERixFQUVFLHFFQUNFLDREQURGLEdBRUUsOERBRkYsR0FHRSxxQ0FMSjtBQU9EO0FBQ0QsV0FBTzhDLHdDQUFQO0FBQ0QsR0F6THNCOzs7QUEyTHZCWSwyQkFBeUI1K0Msc0JBM0xGOztBQTZMdkI2K0MsK0JBQTZCeitDLDBCQTdMTjs7QUErTHZCRCxhQUFXQSxpQkEvTFk7O0FBaU12QjIrQyx1QkFBcUJDLFVBak1FO0FBa012QkMsNEJBQTBCMStDLHVCQWxNSDs7QUFvTXZCeHhCLHNEQUFvRDtBQUNsRDtBQUNBO0FBQ0Ftd0UsWUFBUSxDQUNOOWxFLDBDQURNLEVBRU5DLDBDQUZNLEVBR05DLG1EQUhNLEVBSU42bEUsMEJBQXdCNzVELHdCQUpsQixFQUtOa0IsNkNBTE0sRUFNTnpGLDhDQU5NLEVBT05HLDRDQVBNLEVBUU53dEIsNkNBUk0sRUFTTkUsOENBVE0sRUFVTmdRLG9DQVZNLEVBV05oNkIsZ0NBWE07QUFIMEM7QUFwTTdCLENBQXpCOztBQTJOQSxTQUFTbzZELFVBQVQsQ0FBb0I1RCxTQUFwQixFQUE2Q2dFLE9BQTdDLEVBQStFO0FBQzdFLE1BQU1qMkUsZUFBZXpCLG9EQUNqQixZQURpQixHQUVqQixxQkFGSjtBQUdBLDJCQUNFdTFFLGlCQUFpQjdCLFNBQWpCLENBREYsRUFFRSxpREFGRixFQUdFanlFLFlBSEY7QUFLQSxNQUFJeEUsSUFBSixFQUFhO0FBQ1gsdUNBQ0UsQ0FBQ3kyRSxVQUFVQyxtQkFEYixFQUVFLHNFQUNFLHFEQUhKLEVBSUUzekUsb0RBQWlDLFlBQWpDLEdBQWdELHFCQUpsRDtBQU1BMHpFLGNBQVVrRCxrQ0FBVixHQUErQyxJQUEvQztBQUNEO0FBQ0QsTUFBTTkzQyxVQUFVNDRDLFdBQVcsSUFBWCxJQUFtQkEsUUFBUTU0QyxPQUFSLEtBQW9CLElBQXZEO0FBQ0EsU0FBTyxJQUFJazJDLFNBQUosQ0FBY3RCLFNBQWQsRUFBeUIsSUFBekIsRUFBK0I1MEMsT0FBL0IsQ0FBUDtBQUNEOztBQUVELElBQUk5K0IsaURBQUosRUFBb0M7QUFDbENna0UsV0FBU3NULFVBQVQsR0FBc0JBLFVBQXRCO0FBQ0F0VCxXQUFTcVQsbUJBQVQsR0FBK0JsNkUsU0FBL0I7QUFDRDs7QUFFRCxJQUFNdzZFLGdCQUFnQixnQ0FBbUI7QUFDdkNDLDJCQUF5Qm5tRSxpREFEYztBQUV2Q29tRSxjQUFZNTZFLEtBQU9BLEdBQUcsQ0FBVixHQUFjLENBRmE7QUFHdkMwa0UsV0FBU29ELHNCQUg4QjtBQUl2QytTLHVCQUFxQjtBQUprQixDQUFuQixDQUF0Qjs7QUFPQSxJQUFJNzZFLElBQUosRUFBYTtBQUNYLE1BQUksQ0FBQzA2RSxhQUFELElBQWtCamxFLCtCQUFsQixJQUErQkMsT0FBT29sRSxHQUFQLEtBQWVwbEUsT0FBT2t5QixJQUF6RCxFQUErRDtBQUM3RDtBQUNBLFFBQ0dtekMsVUFBVUMsU0FBVixDQUFvQng1RCxPQUFwQixDQUE0QixRQUE1QixJQUF3QyxDQUFDLENBQXpDLElBQ0N1NUQsVUFBVUMsU0FBVixDQUFvQng1RCxPQUFwQixDQUE0QixNQUE1QixNQUF3QyxDQUFDLENBRDNDLElBRUF1NUQsVUFBVUMsU0FBVixDQUFvQng1RCxPQUFwQixDQUE0QixTQUE1QixJQUF5QyxDQUFDLENBSDVDLEVBSUU7QUFDQSxVQUFNeTVELFdBQVd2bEUsT0FBT2luQixRQUFQLENBQWdCcytDLFFBQWpDO0FBQ0E7QUFDQSxVQUFJLG1CQUFtQmgzRCxJQUFuQixDQUF3QmczRCxRQUF4QixDQUFKLEVBQXVDO0FBQ3JDOTVFLGdCQUFRa0csSUFBUixDQUNFLG1DQUNFLHVDQURGLEdBRUUsOEJBRkYsSUFHRzR6RSxhQUFhLE9BQWIsR0FDRyx1RUFDQSxrQ0FGSCxHQUdHLEVBTk4sQ0FERixFQVFFLGtCQVJGO0FBVUQ7QUFDRjtBQUNGO0FBQ0Y7O2tCQUVjbFUsUTs7Ozs7Ozs7O0FDbjNCZjs7OztBQUNBOzs7Ozs7QUFWQTs7Ozs7Ozs7O0FBWUEseUJBQ0U1OEQsZUFERixFQUVFLDBEQUNFLDRDQUhKLEU7Ozs7Ozs7OztBQ0xBOztBQUNBOztBQUVBOztBQUtBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7OztBQUdBcXdFLDBCQUF3Qjk1RCxzQkFBeEIsQ0FBK0N3NkQsNkJBQS9DLEUsQ0F6QkE7Ozs7Ozs7QUEwQkEsd0NBQ0V2bUUsbURBREYsRUFFRUYsMENBRkYsRUFHRUMsMENBSEY7O0FBTUE7Ozs7QUFJQThsRSwwQkFBd0I3NUQsd0JBQXhCLENBQWlEO0FBQy9DdzVCLHFCQUFtQkEsMkJBRDRCO0FBRS9DZ2hDLHlCQUF1QkEsK0JBRndCO0FBRy9DQyxxQkFBbUJBLDJCQUg0QjtBQUkvQ0MscUJBQW1CQSwyQkFKNEI7QUFLL0NDLDBCQUF3QkE7QUFMdUIsQ0FBakQsRTs7Ozs7Ozs7Ozs7Ozs4UUNwQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7QUFFQSxJQUFJMzlDLDRCQUE0QixtQ0FDOUI1OEIsSUFEOEIsRUFFOUIyOEIsSUFGOEIsRUFHOUJya0IsT0FIOEIsRUFJOUJoWixDQUo4QixFQUs5QkMsQ0FMOEIsRUFNOUJDLENBTjhCLEVBTzlCQyxDQVA4QixFQVE5QkMsQ0FSOEIsRUFTOUJDLENBVDhCLEVBVTlCO0FBQ0EsTUFBTTY2RSxXQUFXOTRELE1BQU1oaEIsU0FBTixDQUFnQndULEtBQWhCLENBQXNCdFQsSUFBdEIsQ0FBMkJ3TCxTQUEzQixFQUFzQyxDQUF0QyxDQUFqQjtBQUNBLE1BQUk7QUFDRnV3QixTQUFLaDhCLEtBQUwsQ0FBVzJYLE9BQVgsRUFBb0JraUUsUUFBcEI7QUFDRCxHQUZELENBRUUsT0FBTzU2RSxLQUFQLEVBQWM7QUFDZCxTQUFLODhCLE9BQUwsQ0FBYTk4QixLQUFiO0FBQ0Q7QUFDRixDQWpCRDs7QUFtQkEsSUFBSVgsSUFBSixFQUFhO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUNFLE9BQU8wVixNQUFQLEtBQWtCLFdBQWxCLElBQ0EsT0FBT0EsT0FBT3VrQyxhQUFkLEtBQWdDLFVBRGhDLElBRUEsT0FBT3RrQyxRQUFQLEtBQW9CLFdBRnBCLElBR0EsT0FBT0EsU0FBUzZsRSxXQUFoQixLQUFnQyxVQUpsQyxFQUtFO0FBQ0EsUUFBTUMsV0FBVzlsRSxTQUFTQyxhQUFULENBQXVCLE9BQXZCLENBQWpCOztBQUVBLFFBQU04bEUsMkJBQTJCLFNBQTNCQSx3QkFBMkIsQ0FDL0IzNkUsSUFEK0IsRUFFL0IyOEIsSUFGK0IsRUFHL0Jya0IsT0FIK0IsRUFJL0JoWixDQUorQixFQUsvQkMsQ0FMK0IsRUFNL0JDLENBTitCLEVBTy9CQyxDQVArQixFQVEvQkMsQ0FSK0IsRUFTL0JDLENBVCtCLEVBVS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFDRSxPQUFPaVYsUUFBUCxLQUFvQixXQUR0QixFQUVFLDhFQUNFLHdFQURGLEdBRUUsOEVBRkYsR0FHRSwyRUFIRixHQUlFLHdFQUpGLEdBS0UseUVBTEYsR0FNRSxxQkFSSjtBQVVBLFVBQU1nbUUsTUFBTWhtRSxTQUFTNmxFLFdBQVQsQ0FBcUIsT0FBckIsQ0FBWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJdnBELFdBQVcsSUFBZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFJMnBELGNBQWNsbUUsT0FBTzVLLEtBQXpCOztBQUVBO0FBQ0E7QUFDQSxVQUFNK3dFLHdCQUF3Qnh2RSxPQUFPKzZCLHdCQUFQLENBQzVCMXhCLE1BRDRCLEVBRTVCLE9BRjRCLENBQTlCOztBQUtBO0FBQ0E7QUFDQTtBQUNBLFVBQU02bEUsV0FBVzk0RCxNQUFNaGhCLFNBQU4sQ0FBZ0J3VCxLQUFoQixDQUFzQnRULElBQXRCLENBQTJCd0wsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBakI7QUFDQSxlQUFTaU0sWUFBVCxHQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBcWlFLGlCQUFTSyxtQkFBVCxDQUE2QkMsT0FBN0IsRUFBc0MzaUUsWUFBdEMsRUFBb0QsS0FBcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUNFLE9BQU8xRCxPQUFPNUssS0FBZCxLQUF3QixXQUF4QixJQUNBNEssT0FBT3hKLGNBQVAsQ0FBc0IsT0FBdEIsQ0FGRixFQUdFO0FBQ0F3SixpQkFBTzVLLEtBQVAsR0FBZTh3RSxXQUFmO0FBQ0Q7O0FBRURsK0MsYUFBS2g4QixLQUFMLENBQVcyWCxPQUFYLEVBQW9Ca2lFLFFBQXBCO0FBQ0F0cEQsbUJBQVcsS0FBWDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJdHhCLGNBQUo7QUFDQTtBQUNBLFVBQUlxN0UsY0FBYyxLQUFsQjtBQUNBLFVBQUlDLHFCQUFxQixLQUF6Qjs7QUFFQSxlQUFTQyxpQkFBVCxDQUEyQnB4RSxLQUEzQixFQUFrQztBQUNoQ25LLGdCQUFRbUssTUFBTW5LLEtBQWQ7QUFDQXE3RSxzQkFBYyxJQUFkO0FBQ0EsWUFBSXI3RSxVQUFVLElBQVYsSUFBa0JtSyxNQUFNcXhFLEtBQU4sS0FBZ0IsQ0FBbEMsSUFBdUNyeEUsTUFBTXN4RSxNQUFOLEtBQWlCLENBQTVELEVBQStEO0FBQzdESCwrQkFBcUIsSUFBckI7QUFDRDtBQUNELFlBQUlueEUsTUFBTUcsZ0JBQVYsRUFBNEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsY0FBSXRLLFNBQVMsSUFBVCxJQUFpQixRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQXRDLEVBQWdEO0FBQzlDLGdCQUFJO0FBQ0ZBLG9CQUFNbXdCLGdCQUFOLEdBQXlCLElBQXpCO0FBQ0QsYUFGRCxDQUVFLE9BQU9DLEtBQVAsRUFBYztBQUNkO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxVQUFNZ3JELHNCQUFtQmg3RSxPQUFPQSxJQUFQLEdBQWMsdUJBQWpDLENBQU47O0FBRUE7QUFDQTJVLGFBQU8ybUUsZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUNILGlCQUFqQztBQUNBVCxlQUFTWSxnQkFBVCxDQUEwQk4sT0FBMUIsRUFBbUMzaUUsWUFBbkMsRUFBaUQsS0FBakQ7O0FBRUE7QUFDQTtBQUNBdWlFLFVBQUlXLFNBQUosQ0FBY1AsT0FBZCxFQUF1QixLQUF2QixFQUE4QixLQUE5QjtBQUNBTixlQUFTeGhDLGFBQVQsQ0FBdUIwaEMsR0FBdkI7O0FBRUEsVUFBSUUscUJBQUosRUFBMkI7QUFDekJ4dkUsZUFBT00sY0FBUCxDQUFzQitJLE1BQXRCLEVBQThCLE9BQTlCLEVBQXVDbW1FLHFCQUF2QztBQUNEOztBQUVELFVBQUk1cEQsUUFBSixFQUFjO0FBQ1osWUFBSSxDQUFDK3BELFdBQUwsRUFBa0I7QUFDaEI7QUFDQXI3RSxrQkFBUSxJQUFJUixLQUFKLENBQ04sa0VBQ0UsMERBREYsR0FFRSwyREFGRixHQUdFLDREQUhGLEdBSUUsK0RBSkYsR0FLRSw2REFMRixHQU1FLGdFQU5GLEdBT0UscURBUkksQ0FBUjtBQVVELFNBWkQsTUFZTyxJQUFJODdFLGtCQUFKLEVBQXdCO0FBQzdCdDdFLGtCQUFRLElBQUlSLEtBQUosQ0FDTixtRUFDRSwwQ0FERixHQUVFLGlFQUhJLENBQVI7QUFLRDtBQUNELGFBQUtzOUIsT0FBTCxDQUFhOThCLEtBQWI7QUFDRDs7QUFFRDtBQUNBK1UsYUFBT29tRSxtQkFBUCxDQUEyQixPQUEzQixFQUFvQ0ksaUJBQXBDO0FBQ0QsS0F0SkQ7O0FBd0pBditDLGdDQUE0Qis5Qyx3QkFBNUI7QUFDRDtBQUNGOztrQkFFYy85Qyx5Qjs7Ozs7Ozs7Ozs7Ozs4UUN4TmY7Ozs7Ozs7QUFTQTs7QUFDQTs7QUFFQTs7QUFZQTs7QUFLQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNNCtDLGVBQWUsQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxFQUFaLENBQXJCLEMsQ0FBc0M7QUFDdEMsSUFBTUMsZ0JBQWdCLEdBQXRCOztBQUVBLElBQU1DLHlCQUF5QmhuRSxtQ0FBYSxzQkFBc0JDLE1BQWxFOztBQUVBLElBQUlnbkUsZUFBZSxJQUFuQjtBQUNBLElBQUlqbkUsbUNBQWEsa0JBQWtCRSxRQUFuQyxFQUE2QztBQUMzQyttRSxpQkFBZS9tRSxTQUFTK21FLFlBQXhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBTUMsdUJBQ0psbkUsbUNBQWEsZUFBZUMsTUFBNUIsSUFBc0MsQ0FBQ2duRSxZQUR6Qzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFNRSw2QkFDSm5uRSxvQ0FDQyxDQUFDZ25FLHNCQUFELElBQ0VDLGdCQUFnQkEsZUFBZSxDQUEvQixJQUFvQ0EsZ0JBQWdCLEVBRnZELENBREY7O0FBS0EsSUFBTUcsZ0JBQWdCLEVBQXRCO0FBQ0EsSUFBTUMsZ0JBQWdCNVEsT0FBT0csWUFBUCxDQUFvQndRLGFBQXBCLENBQXRCOztBQUVBO0FBQ0EsSUFBTW43RCxhQUFhO0FBQ2pCcTdELGVBQWE7QUFDWHBnRSw2QkFBeUI7QUFDdkI4K0IsZUFBUyxlQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRGQ7QUFLWHY1QixrQkFBYyxDQUNaMVMsMENBRFksRUFFWjBCLG9DQUZZLEVBR1prQyxxQ0FIWSxFQUladEIsZ0NBSlk7QUFMSCxHQURJO0FBYWpCaXJFLGtCQUFnQjtBQUNkcmdFLDZCQUF5QjtBQUN2QjgrQixlQUFTLGtCQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRFg7QUFLZHY1QixrQkFBYyxDQUNaalQsK0JBRFksRUFFWk8sMENBRlksRUFHWnlCLG1DQUhZLEVBSVpDLG9DQUpZLEVBS1pDLGlDQUxZLEVBTVpNLHFDQU5ZO0FBTEEsR0FiQztBQTJCakJ1ckUsb0JBQWtCO0FBQ2hCdGdFLDZCQUF5QjtBQUN2QjgrQixlQUFTLG9CQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRFQ7QUFLaEJ2NUIsa0JBQWMsQ0FDWmpULCtCQURZLEVBRVpRLDRDQUZZLEVBR1p3QixtQ0FIWSxFQUlaQyxvQ0FKWSxFQUtaQyxpQ0FMWSxFQU1aTSxxQ0FOWTtBQUxFLEdBM0JEO0FBeUNqQndyRSxxQkFBbUI7QUFDakJ2Z0UsNkJBQXlCO0FBQ3ZCOCtCLGVBQVMscUJBRGM7QUFFdkJDLGdCQUFVO0FBRmEsS0FEUjtBQUtqQnY1QixrQkFBYyxDQUNaalQsK0JBRFksRUFFWlMsNkNBRlksRUFHWnVCLG1DQUhZLEVBSVpDLG9DQUpZLEVBS1pDLGlDQUxZLEVBTVpNLHFDQU5ZO0FBTEc7QUF6Q0YsQ0FBbkI7O0FBeURBO0FBQ0EsSUFBSXlyRSxtQkFBbUIsS0FBdkI7O0FBRUE7Ozs7O0FBS0EsU0FBU0MsaUJBQVQsQ0FBMkI1eEUsV0FBM0IsRUFBd0M7QUFDdEMsU0FDRSxDQUFDQSxZQUFZc2EsT0FBWixJQUF1QnRhLFlBQVl3YSxNQUFuQyxJQUE2Q3hhLFlBQVl5YSxPQUExRDtBQUNBO0FBQ0EsSUFBRXphLFlBQVlzYSxPQUFaLElBQXVCdGEsWUFBWXdhLE1BQXJDLENBSEY7QUFLRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU3EzRCx1QkFBVCxDQUFpQ3BwRSxZQUFqQyxFQUErQztBQUM3QyxVQUFRQSxZQUFSO0FBQ0UsU0FBS3ZFLDRDQUFMO0FBQ0UsYUFBT2dTLFdBQVd1N0QsZ0JBQWxCO0FBQ0YsU0FBS3h0RSwwQ0FBTDtBQUNFLGFBQU9pUyxXQUFXczdELGNBQWxCO0FBQ0YsU0FBS3J0RSw2Q0FBTDtBQUNFLGFBQU8rUixXQUFXdzdELGlCQUFsQjtBQU5KO0FBUUQ7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU0ksMEJBQVQsQ0FBb0NycEUsWUFBcEMsRUFBa0R6SSxXQUFsRCxFQUErRDtBQUM3RCxTQUFPeUksaUJBQWlCL0MsbUNBQWpCLElBQWlDMUYsWUFBWXdpQyxPQUFaLEtBQXdCd3VDLGFBQWhFO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTZSx3QkFBVCxDQUFrQ3RwRSxZQUFsQyxFQUFnRHpJLFdBQWhELEVBQTZEO0FBQzNELFVBQVF5SSxZQUFSO0FBQ0UsU0FBSzdDLGlDQUFMO0FBQ0U7QUFDQSxhQUFPbXJFLGFBQWEvNkQsT0FBYixDQUFxQmhXLFlBQVl3aUMsT0FBakMsTUFBOEMsQ0FBQyxDQUF0RDtBQUNGLFNBQUs5OEIsbUNBQUw7QUFDRTtBQUNBO0FBQ0EsYUFBTzFGLFlBQVl3aUMsT0FBWixLQUF3Qnd1QyxhQUEvQjtBQUNGLFNBQUtyckUsb0NBQUw7QUFDQSxTQUFLTyxxQ0FBTDtBQUNBLFNBQUt4QywrQkFBTDtBQUNFO0FBQ0EsYUFBTyxJQUFQO0FBQ0Y7QUFDRSxhQUFPLEtBQVA7QUFkSjtBQWdCRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU3N1RSxzQkFBVCxDQUFnQ2h5RSxXQUFoQyxFQUE2QztBQUMzQyxNQUFNcWIsU0FBU3JiLFlBQVlxYixNQUEzQjtBQUNBLE1BQUksUUFBT0EsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QixVQUFVQSxNQUE1QyxFQUFvRDtBQUNsRCxXQUFPQSxPQUFPc3JDLElBQWQ7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUEsU0FBU3NyQixnQkFBVCxDQUEwQmp5RSxXQUExQixFQUF1QztBQUNyQyxTQUFPQSxZQUFZa3lFLE1BQVosS0FBdUIsSUFBOUI7QUFDRDs7QUFFRDtBQUNBLElBQUlDLGNBQWMsS0FBbEI7O0FBRUE7OztBQUdBLFNBQVNDLHVCQUFULENBQ0UzcEUsWUFERixFQUVFMUksVUFGRixFQUdFQyxXQUhGLEVBSUVDLGlCQUpGLEVBS0U7QUFDQSxNQUFJb3lFLGtCQUFKO0FBQ0EsTUFBSUMscUJBQUo7O0FBRUEsTUFBSXJCLHNCQUFKLEVBQTRCO0FBQzFCb0IsZ0JBQVlSLHdCQUF3QnBwRSxZQUF4QixDQUFaO0FBQ0QsR0FGRCxNQUVPLElBQUksQ0FBQzBwRSxXQUFMLEVBQWtCO0FBQ3ZCLFFBQUlMLDJCQUEyQnJwRSxZQUEzQixFQUF5Q3pJLFdBQXpDLENBQUosRUFBMkQ7QUFDekRxeUUsa0JBQVluOEQsV0FBV3U3RCxnQkFBdkI7QUFDRDtBQUNGLEdBSk0sTUFJQSxJQUFJTSx5QkFBeUJ0cEUsWUFBekIsRUFBdUN6SSxXQUF2QyxDQUFKLEVBQXlEO0FBQzlEcXlFLGdCQUFZbjhELFdBQVdzN0QsY0FBdkI7QUFDRDs7QUFFRCxNQUFJLENBQUNhLFNBQUwsRUFBZ0I7QUFDZCxXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJakIsOEJBQThCLENBQUNhLGlCQUFpQmp5RSxXQUFqQixDQUFuQyxFQUFrRTtBQUNoRTtBQUNBO0FBQ0EsUUFBSSxDQUFDbXlFLFdBQUQsSUFBZ0JFLGNBQWNuOEQsV0FBV3U3RCxnQkFBN0MsRUFBK0Q7QUFDN0RVLG9CQUFjLDBDQUFtQ2x5RSxpQkFBbkMsQ0FBZDtBQUNELEtBRkQsTUFFTyxJQUFJb3lFLGNBQWNuOEQsV0FBV3M3RCxjQUE3QixFQUE2QztBQUNsRCxVQUFJVyxXQUFKLEVBQWlCO0FBQ2ZHLHVCQUFlLHdDQUFmO0FBQ0Q7QUFDRjtBQUNGOztBQUVELE1BQU1oekUsUUFBUWl6RSxvQ0FBMEJ4dkUsU0FBMUIsQ0FDWnN2RSxTQURZLEVBRVp0eUUsVUFGWSxFQUdaQyxXQUhZLEVBSVpDLGlCQUpZLENBQWQ7O0FBT0EsTUFBSXF5RSxZQUFKLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDQWh6RSxVQUFNcW5ELElBQU4sR0FBYTJyQixZQUFiO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsUUFBTUUsYUFBYVIsdUJBQXVCaHlFLFdBQXZCLENBQW5CO0FBQ0EsUUFBSXd5RSxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCbHpFLFlBQU1xbkQsSUFBTixHQUFhNnJCLFVBQWI7QUFDRDtBQUNGOztBQUVELHNEQUE2Qmx6RSxLQUE3QjtBQUNBLFNBQU9BLEtBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFTbXpFLHlCQUFULENBQW1DaHFFLFlBQW5DLEVBQStEekksV0FBL0QsRUFBNEU7QUFDMUUsVUFBUXlJLFlBQVI7QUFDRSxTQUFLeEUsMENBQUw7QUFDRSxhQUFPK3RFLHVCQUF1Qmh5RSxXQUF2QixDQUFQO0FBQ0YsU0FBSzJGLG9DQUFMO0FBQ0U7Ozs7Ozs7Ozs7Ozs7O0FBY0EsVUFBTStzRSxRQUFRMXlFLFlBQVkweUUsS0FBMUI7QUFDQSxVQUFJQSxVQUFVckIsYUFBZCxFQUE2QjtBQUMzQixlQUFPLElBQVA7QUFDRDs7QUFFRE0seUJBQW1CLElBQW5CO0FBQ0EsYUFBT0wsYUFBUDs7QUFFRixTQUFLenBFLHFDQUFMO0FBQ0U7QUFDQSxVQUFNOHFFLFFBQVEzeUUsWUFBWTJtRCxJQUExQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFJZ3NCLFVBQVVyQixhQUFWLElBQTJCSyxnQkFBL0IsRUFBaUQ7QUFDL0MsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsYUFBT2dCLEtBQVA7O0FBRUY7QUFDRTtBQUNBLGFBQU8sSUFBUDtBQXpDSjtBQTJDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTQywyQkFBVCxDQUFxQ25xRSxZQUFyQyxFQUFpRXpJLFdBQWpFLEVBQThFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSW15RSxXQUFKLEVBQWlCO0FBQ2YsUUFDRTFwRSxpQkFBaUJ4RSwwQ0FBakIsSUFDQyxDQUFDZ3RFLHNCQUFELElBQ0NjLHlCQUF5QnRwRSxZQUF6QixFQUF1Q3pJLFdBQXZDLENBSEosRUFJRTtBQUNBLFVBQU0yeUUsUUFBUSx3Q0FBZDtBQUNBO0FBQ0FSLG9CQUFjLEtBQWQ7QUFDQSxhQUFPUSxLQUFQO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxVQUFRbHFFLFlBQVI7QUFDRSxTQUFLbEMsZ0NBQUw7QUFDRTtBQUNBO0FBQ0EsYUFBTyxJQUFQO0FBQ0YsU0FBS1osb0NBQUw7QUFDRTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxVQUFJLENBQUNpc0Usa0JBQWtCNXhFLFdBQWxCLENBQUwsRUFBcUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSUEsWUFBWTZ5RSxJQUFaLElBQW9CN3lFLFlBQVk2eUUsSUFBWixDQUFpQm45RSxNQUFqQixHQUEwQixDQUFsRCxFQUFxRDtBQUNuRCxpQkFBT3NLLFlBQVk2eUUsSUFBbkI7QUFDRCxTQUZELE1BRU8sSUFBSTd5RSxZQUFZMHlFLEtBQWhCLEVBQXVCO0FBQzVCLGlCQUFPaFMsT0FBT0csWUFBUCxDQUFvQjdnRSxZQUFZMHlFLEtBQWhDLENBQVA7QUFDRDtBQUNGO0FBQ0QsYUFBTyxJQUFQO0FBQ0YsU0FBS3p1RSwwQ0FBTDtBQUNFLGFBQU9tdEUsOEJBQThCLENBQUNhLGlCQUFpQmp5RSxXQUFqQixDQUEvQixHQUNILElBREcsR0FFSEEsWUFBWTJtRCxJQUZoQjtBQUdGO0FBQ0UsYUFBTyxJQUFQO0FBekNKO0FBMkNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTbXNCLHVCQUFULENBQ0VycUUsWUFERixFQUVFMUksVUFGRixFQUdFQyxXQUhGLEVBSUVDLGlCQUpGLEVBS0U7QUFDQSxNQUFJMHlFLGNBQUo7O0FBRUEsTUFBSXhCLG9CQUFKLEVBQTBCO0FBQ3hCd0IsWUFBUUYsMEJBQTBCaHFFLFlBQTFCLEVBQXdDekksV0FBeEMsQ0FBUjtBQUNELEdBRkQsTUFFTztBQUNMMnlFLFlBQVFDLDRCQUE0Qm5xRSxZQUE1QixFQUEwQ3pJLFdBQTFDLENBQVI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSSxDQUFDMnlFLEtBQUwsRUFBWTtBQUNWLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQU1yekUsUUFBUXl6RSw4QkFBb0Jod0UsU0FBcEIsQ0FDWm1ULFdBQVdxN0QsV0FEQyxFQUVaeHhFLFVBRlksRUFHWkMsV0FIWSxFQUlaQyxpQkFKWSxDQUFkOztBQU9BWCxRQUFNcW5ELElBQU4sR0FBYWdzQixLQUFiO0FBQ0Esc0RBQTZCcnpFLEtBQTdCO0FBQ0EsU0FBT0EsS0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsSUFBTXd3RSx5QkFBeUI7QUFDN0I1NUQsY0FBWUEsVUFEaUI7O0FBRzdCZCxpQkFBZSx1QkFDYjNNLFlBRGEsRUFFYjFJLFVBRmEsRUFHYkMsV0FIYSxFQUliQyxpQkFKYSxFQUtiO0FBQ0EsUUFBTSt5RSxjQUFjWix3QkFDbEIzcEUsWUFEa0IsRUFFbEIxSSxVQUZrQixFQUdsQkMsV0FIa0IsRUFJbEJDLGlCQUprQixDQUFwQjs7QUFPQSxRQUFNc3hFLGNBQWN1Qix3QkFDbEJycUUsWUFEa0IsRUFFbEIxSSxVQUZrQixFQUdsQkMsV0FIa0IsRUFJbEJDLGlCQUprQixDQUFwQjs7QUFPQSxRQUFJK3lFLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixhQUFPekIsV0FBUDtBQUNEOztBQUVELFFBQUlBLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixhQUFPeUIsV0FBUDtBQUNEOztBQUVELFdBQU8sQ0FBQ0EsV0FBRCxFQUFjekIsV0FBZCxDQUFQO0FBQ0Q7QUFoQzRCLENBQS9COztrQkFtQ2V6QixzQjs7Ozs7Ozs7Ozs7O1FDcGRDbUQsdUIsR0FBQUEsdUI7UUFxQ0FDLFUsR0FBQUEsVTtRQWFBQyxpQixHQUFBQSxpQjtRQU9BQyxnQixHQUFBQSxnQjtRQXNCQUMsa0IsR0FBQUEsa0I7O0FBcEdoQjs7QUFFQSxTQUFTQyxTQUFULENBQW1CeHBFLElBQW5CLEVBQXlCO0FBQ3ZCLEtBQUc7QUFDREEsV0FBT0EsS0FBSy9OLE1BQVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0QsR0FQRCxRQU9TK04sUUFBUUEsS0FBSzFRLEdBQUwsS0FBYXRCLDRCQVA5QjtBQVFBLE1BQUlnUyxJQUFKLEVBQVU7QUFDUixXQUFPQSxJQUFQO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQXhCQTs7Ozs7OztBQTRCTyxTQUFTbXBFLHVCQUFULENBQWlDTSxLQUFqQyxFQUF3Q0MsS0FBeEMsRUFBK0M7QUFDcEQsTUFBSUMsU0FBUyxDQUFiO0FBQ0EsT0FBSyxJQUFJQyxRQUFRSCxLQUFqQixFQUF3QkcsS0FBeEIsRUFBK0JBLFFBQVFKLFVBQVVJLEtBQVYsQ0FBdkMsRUFBeUQ7QUFDdkREO0FBQ0Q7QUFDRCxNQUFJRSxTQUFTLENBQWI7QUFDQSxPQUFLLElBQUlDLFFBQVFKLEtBQWpCLEVBQXdCSSxLQUF4QixFQUErQkEsUUFBUU4sVUFBVU0sS0FBVixDQUF2QyxFQUF5RDtBQUN2REQ7QUFDRDs7QUFFRDtBQUNBLFNBQU9GLFNBQVNFLE1BQVQsR0FBa0IsQ0FBekIsRUFBNEI7QUFDMUJKLFlBQVFELFVBQVVDLEtBQVYsQ0FBUjtBQUNBRTtBQUNEOztBQUVEO0FBQ0EsU0FBT0UsU0FBU0YsTUFBVCxHQUFrQixDQUF6QixFQUE0QjtBQUMxQkQsWUFBUUYsVUFBVUUsS0FBVixDQUFSO0FBQ0FHO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJRSxRQUFRSixNQUFaO0FBQ0EsU0FBT0ksT0FBUCxFQUFnQjtBQUNkLFFBQUlOLFVBQVVDLEtBQVYsSUFBbUJELFVBQVVDLE1BQU1qbkUsU0FBdkMsRUFBa0Q7QUFDaEQsYUFBT2duRSxLQUFQO0FBQ0Q7QUFDREEsWUFBUUQsVUFBVUMsS0FBVixDQUFSO0FBQ0FDLFlBQVFGLFVBQVVFLEtBQVYsQ0FBUjtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7OztBQUdPLFNBQVNOLFVBQVQsQ0FBb0JLLEtBQXBCLEVBQTJCQyxLQUEzQixFQUFrQztBQUN2QyxTQUFPQSxLQUFQLEVBQWM7QUFDWixRQUFJRCxVQUFVQyxLQUFWLElBQW1CRCxVQUFVQyxNQUFNam5FLFNBQXZDLEVBQWtEO0FBQ2hELGFBQU8sSUFBUDtBQUNEO0FBQ0RpbkUsWUFBUUYsVUFBVUUsS0FBVixDQUFSO0FBQ0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDs7O0FBR08sU0FBU0wsaUJBQVQsQ0FBMkJycEUsSUFBM0IsRUFBaUM7QUFDdEMsU0FBT3dwRSxVQUFVeHBFLElBQVYsQ0FBUDtBQUNEOztBQUVEOzs7QUFHTyxTQUFTc3BFLGdCQUFULENBQTBCdHBFLElBQTFCLEVBQWdDc2pCLEVBQWhDLEVBQW9Da0csR0FBcEMsRUFBeUM7QUFDOUMsTUFBTThVLE9BQU8sRUFBYjtBQUNBLFNBQU90K0IsSUFBUCxFQUFhO0FBQ1hzK0IsU0FBS3RsQyxJQUFMLENBQVVnSCxJQUFWO0FBQ0FBLFdBQU93cEUsVUFBVXhwRSxJQUFWLENBQVA7QUFDRDtBQUNELE1BQUl1TCxVQUFKO0FBQ0EsT0FBS0EsSUFBSSt5QixLQUFLMXlDLE1BQWQsRUFBc0IyZixNQUFNLENBQTVCLEdBQWlDO0FBQy9CK1gsT0FBR2diLEtBQUsveUIsQ0FBTCxDQUFILEVBQVksVUFBWixFQUF3QmllLEdBQXhCO0FBQ0Q7QUFDRCxPQUFLamUsSUFBSSxDQUFULEVBQVlBLElBQUkreUIsS0FBSzF5QyxNQUFyQixFQUE2QjJmLEdBQTdCLEVBQWtDO0FBQ2hDK1gsT0FBR2diLEtBQUsveUIsQ0FBTCxDQUFILEVBQVksU0FBWixFQUF1QmllLEdBQXZCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztBQU9PLFNBQVMrL0Msa0JBQVQsQ0FBNEJ0aEUsSUFBNUIsRUFBa0NDLEVBQWxDLEVBQXNDb2IsRUFBdEMsRUFBMEMwbUQsT0FBMUMsRUFBbURDLEtBQW5ELEVBQTBEO0FBQy9ELE1BQU1DLFNBQVNqaUUsUUFBUUMsRUFBUixHQUFhaWhFLHdCQUF3QmxoRSxJQUF4QixFQUE4QkMsRUFBOUIsQ0FBYixHQUFpRCxJQUFoRTtBQUNBLE1BQU1paUUsV0FBVyxFQUFqQjtBQUNBLFNBQU8sSUFBUCxFQUFhO0FBQ1gsUUFBSSxDQUFDbGlFLElBQUwsRUFBVztBQUNUO0FBQ0Q7QUFDRCxRQUFJQSxTQUFTaWlFLE1BQWIsRUFBcUI7QUFDbkI7QUFDRDtBQUNELFFBQU16bkUsWUFBWXdGLEtBQUt4RixTQUF2QjtBQUNBLFFBQUlBLGNBQWMsSUFBZCxJQUFzQkEsY0FBY3luRSxNQUF4QyxFQUFnRDtBQUM5QztBQUNEO0FBQ0RDLGFBQVNueEUsSUFBVCxDQUFjaVAsSUFBZDtBQUNBQSxXQUFPdWhFLFVBQVV2aEUsSUFBVixDQUFQO0FBQ0Q7QUFDRCxNQUFNbWlFLFNBQVMsRUFBZjtBQUNBLFNBQU8sSUFBUCxFQUFhO0FBQ1gsUUFBSSxDQUFDbGlFLEVBQUwsRUFBUztBQUNQO0FBQ0Q7QUFDRCxRQUFJQSxPQUFPZ2lFLE1BQVgsRUFBbUI7QUFDakI7QUFDRDtBQUNELFFBQU16bkUsYUFBWXlGLEdBQUd6RixTQUFyQjtBQUNBLFFBQUlBLGVBQWMsSUFBZCxJQUFzQkEsZUFBY3luRSxNQUF4QyxFQUFnRDtBQUM5QztBQUNEO0FBQ0RFLFdBQU9weEUsSUFBUCxDQUFZa1AsRUFBWjtBQUNBQSxTQUFLc2hFLFVBQVV0aEUsRUFBVixDQUFMO0FBQ0Q7QUFDRCxPQUFLLElBQUlxRCxJQUFJLENBQWIsRUFBZ0JBLElBQUk0K0QsU0FBU3YrRSxNQUE3QixFQUFxQzJmLEdBQXJDLEVBQTBDO0FBQ3hDK1gsT0FBRzZtRCxTQUFTNStELENBQVQsQ0FBSCxFQUFnQixTQUFoQixFQUEyQnkrRCxPQUEzQjtBQUNEO0FBQ0QsT0FBSyxJQUFJeitELEtBQUk2K0QsT0FBT3grRSxNQUFwQixFQUE0QjJmLE9BQU0sQ0FBbEMsR0FBdUM7QUFDckMrWCxPQUFHOG1ELE9BQU83K0QsRUFBUCxDQUFILEVBQWMsVUFBZCxFQUEwQjArRCxLQUExQjtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7O1FDdkhlSSxpQyxHQUFBQSxpQztRQU1BQyxpQyxHQUFBQSxpQzs7O0FBVmhCO0FBQ0E7QUFDQTs7QUF4QkE7Ozs7Ozs7OztBQTBCTyxTQUFTRCxpQ0FBVCxDQUNMMXJFLFlBREssRUFFaUI7QUFDdEIsU0FBT0EsWUFBUDtBQUNEOztBQUVNLFNBQVMyckUsaUNBQVQsQ0FDTDNyRSxZQURLLEVBRUc7QUFDUixTQUFPQSxZQUFQO0FBQ0QsQzs7Ozs7Ozs7Ozs7OztBQzdCRDs7QUFFQTs7Ozs7OztBQU9BLFNBQVM0ckUsYUFBVCxDQUF1QkMsU0FBdkIsRUFBa0NuK0QsU0FBbEMsRUFBNkM7QUFDM0MsTUFBTW8rRCxXQUFXLEVBQWpCOztBQUVBQSxXQUFTRCxVQUFVejlELFdBQVYsRUFBVCxJQUFvQ1YsVUFBVVUsV0FBVixFQUFwQztBQUNBMDlELFdBQVMsV0FBV0QsU0FBcEIsSUFBaUMsV0FBV24rRCxTQUE1QztBQUNBbytELFdBQVMsUUFBUUQsU0FBakIsSUFBOEIsUUFBUW4rRCxTQUF0Qzs7QUFFQSxTQUFPbytELFFBQVA7QUFDRDs7QUFFRDs7O0FBMUJBOzs7Ozs7O0FBNkJBLElBQU1DLGlCQUFpQjtBQUNyQkMsZ0JBQWNKLGNBQWMsV0FBZCxFQUEyQixjQUEzQixDQURPO0FBRXJCSyxzQkFBb0JMLGNBQWMsV0FBZCxFQUEyQixvQkFBM0IsQ0FGQztBQUdyQk0sa0JBQWdCTixjQUFjLFdBQWQsRUFBMkIsZ0JBQTNCLENBSEs7QUFJckJPLGlCQUFlUCxjQUFjLFlBQWQsRUFBNEIsZUFBNUI7QUFKTSxDQUF2Qjs7QUFPQTs7O0FBR0EsSUFBTVEscUJBQXFCLEVBQTNCOztBQUVBOzs7QUFHQSxJQUFJaHBCLFFBQVEsRUFBWjs7QUFFQTs7O0FBR0EsSUFBSTVoRCwrQkFBSixFQUFlO0FBQ2I0aEQsVUFBUTFoRCxTQUFTQyxhQUFULENBQXVCLEtBQXZCLEVBQThCeWhELEtBQXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSSxFQUFFLG9CQUFvQjNoRCxNQUF0QixDQUFKLEVBQW1DO0FBQ2pDLFdBQU9zcUUsZUFBZUMsWUFBZixDQUE0QkssU0FBbkM7QUFDQSxXQUFPTixlQUFlRSxrQkFBZixDQUFrQ0ksU0FBekM7QUFDQSxXQUFPTixlQUFlRyxjQUFmLENBQThCRyxTQUFyQztBQUNEOztBQUVEO0FBQ0EsTUFBSSxFQUFFLHFCQUFxQjVxRSxNQUF2QixDQUFKLEVBQW9DO0FBQ2xDLFdBQU9zcUUsZUFBZUksYUFBZixDQUE2QkcsVUFBcEM7QUFDRDtBQUNGOztBQUVEOzs7Ozs7QUFNQSxTQUFTQywwQkFBVCxDQUFvQzcrRCxTQUFwQyxFQUErQztBQUM3QyxNQUFJMCtELG1CQUFtQjErRCxTQUFuQixDQUFKLEVBQW1DO0FBQ2pDLFdBQU8wK0QsbUJBQW1CMStELFNBQW5CLENBQVA7QUFDRCxHQUZELE1BRU8sSUFBSSxDQUFDcStELGVBQWVyK0QsU0FBZixDQUFMLEVBQWdDO0FBQ3JDLFdBQU9BLFNBQVA7QUFDRDs7QUFFRCxNQUFNOCtELFlBQVlULGVBQWVyK0QsU0FBZixDQUFsQjs7QUFFQSxPQUFLLElBQU1tK0QsU0FBWCxJQUF3QlcsU0FBeEIsRUFBbUM7QUFDakMsUUFBSUEsVUFBVXYwRSxjQUFWLENBQXlCNHpFLFNBQXpCLEtBQXVDQSxhQUFhem9CLEtBQXhELEVBQStEO0FBQzdELGFBQVFncEIsbUJBQW1CMStELFNBQW5CLElBQWdDOCtELFVBQVVYLFNBQVYsQ0FBeEM7QUFDRDtBQUNGOztBQUVELFNBQU9uK0QsU0FBUDtBQUNEOztrQkFFYzYrRCwwQjs7Ozs7Ozs7Ozs7O1FDckVDRSxVLEdBQUFBLFU7UUFNQWgwQyxLLEdBQUFBLEs7UUFNQWkwQyxPLEdBQUFBLE87UUE4QkFDLE8sR0FBQUEsTztBQWpFaEI7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7O0FBWUEsSUFBSTl1RCxPQUFPLElBQVg7QUFDQSxJQUFJK3VELFlBQVksSUFBaEI7QUFDQSxJQUFJQyxlQUFlLElBQW5COztBQUVPLFNBQVNKLFVBQVQsQ0FBb0JqMUUsaUJBQXBCLEVBQXVDO0FBQzVDcW1CLFNBQU9ybUIsaUJBQVA7QUFDQW8xRSxjQUFZRCxTQUFaO0FBQ0EsU0FBTyxJQUFQO0FBQ0Q7O0FBRU0sU0FBU2wwQyxLQUFULEdBQWlCO0FBQ3RCNWEsU0FBTyxJQUFQO0FBQ0ErdUQsY0FBWSxJQUFaO0FBQ0FDLGlCQUFlLElBQWY7QUFDRDs7QUFFTSxTQUFTSCxPQUFULEdBQW1CO0FBQ3hCLE1BQUlHLFlBQUosRUFBa0I7QUFDaEIsV0FBT0EsWUFBUDtBQUNEOztBQUVELE1BQUkzcEIsY0FBSjtBQUNBLE1BQU00cEIsYUFBYUYsU0FBbkI7QUFDQSxNQUFNRyxjQUFjRCxXQUFXNy9FLE1BQS9CO0FBQ0EsTUFBSTI1RCxZQUFKO0FBQ0EsTUFBTW9tQixXQUFXTCxTQUFqQjtBQUNBLE1BQU1NLFlBQVlELFNBQVMvL0UsTUFBM0I7O0FBRUEsT0FBS2kyRCxRQUFRLENBQWIsRUFBZ0JBLFFBQVE2cEIsV0FBeEIsRUFBcUM3cEIsT0FBckMsRUFBOEM7QUFDNUMsUUFBSTRwQixXQUFXNXBCLEtBQVgsTUFBc0I4cEIsU0FBUzlwQixLQUFULENBQTFCLEVBQTJDO0FBQ3pDO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNZ3FCLFNBQVNILGNBQWM3cEIsS0FBN0I7QUFDQSxPQUFLMEQsTUFBTSxDQUFYLEVBQWNBLE9BQU9zbUIsTUFBckIsRUFBNkJ0bUIsS0FBN0IsRUFBb0M7QUFDbEMsUUFBSWttQixXQUFXQyxjQUFjbm1CLEdBQXpCLE1BQWtDb21CLFNBQVNDLFlBQVlybUIsR0FBckIsQ0FBdEMsRUFBaUU7QUFDL0Q7QUFDRDtBQUNGOztBQUVELE1BQU11bUIsWUFBWXZtQixNQUFNLENBQU4sR0FBVSxJQUFJQSxHQUFkLEdBQW9CMzZELFNBQXRDO0FBQ0E0Z0YsaUJBQWVHLFNBQVNoc0UsS0FBVCxDQUFla2lELEtBQWYsRUFBc0JpcUIsU0FBdEIsQ0FBZjtBQUNBLFNBQU9OLFlBQVA7QUFDRDs7QUFFTSxTQUFTRixPQUFULEdBQW1CO0FBQ3hCLE1BQUksV0FBVzl1RCxJQUFmLEVBQXFCO0FBQ25CLFdBQU9BLEtBQUsxTixLQUFaO0FBQ0Q7QUFDRCxTQUFPME4sS0FBS3E1QixXQUFaO0FBQ0QsQzs7Ozs7Ozs7Ozs7OztBQy9ERDs7Ozs7O0FBRUE7Ozs7QUFJQSxJQUFNNHlCLDRCQUE0QjF5RSx5QkFBZTBCLE1BQWYsQ0FBc0I7QUFDdERvbEQsUUFBTTtBQURnRCxDQUF0QixDQUFsQyxDLENBYkE7Ozs7Ozs7a0JBaUJlNHJCLHlCOzs7Ozs7Ozs7Ozs7O0FDVmY7Ozs7OztBQUVBOzs7OztBQUtBLElBQU1RLHNCQUFzQmx6RSx5QkFBZTBCLE1BQWYsQ0FBc0I7QUFDaERvbEQsUUFBTTtBQUQwQyxDQUF0QixDQUE1QixDLENBZEE7Ozs7Ozs7a0JBa0Jlb3NCLG1COzs7Ozs7Ozs7Ozs7O0FDWGY7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUVBOztBQVVBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQTlCQTs7Ozs7OztBQWdDQSxJQUFNNzhELGFBQWE7QUFDakIyL0QsVUFBUTtBQUNOMWtFLDZCQUF5QjtBQUN2QjgrQixlQUFTLFVBRGM7QUFFdkJDLGdCQUFVO0FBRmEsS0FEbkI7QUFLTnY1QixrQkFBYyxDQUNaalQsK0JBRFksRUFFWkksaUNBRlksRUFHWkMsZ0NBSFksRUFJWnVCLGdDQUpZLEVBS1pFLGdDQUxZLEVBTVpFLG1DQU5ZLEVBT1pFLGlDQVBZLEVBUVo2QiwyQ0FSWTtBQUxSO0FBRFMsQ0FBbkI7O0FBbUJBLFNBQVNxdUUsOEJBQVQsQ0FBd0Noc0UsSUFBeEMsRUFBOEM5SixXQUE5QyxFQUEyRGhCLE1BQTNELEVBQW1FO0FBQ2pFLE1BQU1NLFFBQVFPLHlCQUFla0QsU0FBZixDQUNabVQsV0FBVzIvRCxNQURDLEVBRVovckUsSUFGWSxFQUdaOUosV0FIWSxFQUlaaEIsTUFKWSxDQUFkO0FBTUFNLFFBQU1uRyxJQUFOLEdBQWEsUUFBYjtBQUNBO0FBQ0EscURBQW9CNkYsTUFBcEI7QUFDQSxzREFBNkJNLEtBQTdCO0FBQ0EsU0FBT0EsS0FBUDtBQUNEO0FBQ0Q7OztBQUdBLElBQUlpdEMsZ0JBQWdCLElBQXBCO0FBQ0EsSUFBSXdwQyxvQkFBb0IsSUFBeEI7O0FBRUE7OztBQUdBLFNBQVNDLG9CQUFULENBQThCbDJDLElBQTlCLEVBQW9DO0FBQ2xDLE1BQU1DLFdBQVdELEtBQUtDLFFBQUwsSUFBaUJELEtBQUtDLFFBQUwsQ0FBY2xwQixXQUFkLEVBQWxDO0FBQ0EsU0FDRWtwQixhQUFhLFFBQWIsSUFBMEJBLGFBQWEsT0FBYixJQUF3QkQsS0FBSzNtQyxJQUFMLEtBQWMsTUFEbEU7QUFHRDs7QUFFRCxTQUFTODhFLHlCQUFULENBQW1DajJFLFdBQW5DLEVBQWdEO0FBQzlDLE1BQU1WLFFBQVF3MkUsK0JBQ1pDLGlCQURZLEVBRVovMUUsV0FGWSxFQUdaLDhCQUFlQSxXQUFmLENBSFksQ0FBZDs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQWVrMkUsZUFBZixFQUFnQzUyRSxLQUFoQztBQUNEOztBQUVELFNBQVM0MkUsZUFBVCxDQUF5QjUyRSxLQUF6QixFQUFnQztBQUM5Qix3Q0FBaUJBLEtBQWpCO0FBQ0Q7O0FBRUQsU0FBUzYyRSxxQkFBVCxDQUErQnAyRSxVQUEvQixFQUEyQztBQUN6QyxNQUFNcTJFLGFBQWEsZ0RBQW9CcjJFLFVBQXBCLENBQW5CO0FBQ0EsTUFBSSw4Q0FBcUJxMkUsVUFBckIsQ0FBSixFQUFzQztBQUNwQyxXQUFPcjJFLFVBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNzMkUsMkJBQVQsQ0FBcUM1dEUsWUFBckMsRUFBbUQxSSxVQUFuRCxFQUErRDtBQUM3RCxNQUFJMEksaUJBQWlCM0UsaUNBQXJCLEVBQWlDO0FBQy9CLFdBQU8vRCxVQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7O0FBR0EsSUFBSXUyRSx3QkFBd0IsS0FBNUI7QUFDQSxJQUFJcnNFLCtCQUFKLEVBQWU7QUFDYjtBQUNBO0FBQ0Fxc0UsMEJBQ0UsZ0NBQWlCLE9BQWpCLE1BQ0MsQ0FBQ25zRSxTQUFTK21FLFlBQVYsSUFBMEIvbUUsU0FBUyttRSxZQUFULEdBQXdCLENBRG5ELENBREY7QUFHRDs7QUFFRDs7Ozs7QUFLQSxTQUFTcUYsMkJBQVQsQ0FBcUN2M0UsTUFBckMsRUFBNkNlLFVBQTdDLEVBQXlEO0FBQ3ZEd3NDLGtCQUFnQnZ0QyxNQUFoQjtBQUNBKzJFLHNCQUFvQmgyRSxVQUFwQjtBQUNBd3NDLGdCQUFjaXFDLFdBQWQsQ0FBMEIsa0JBQTFCLEVBQThDQyxvQkFBOUM7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVNDLDBCQUFULEdBQXNDO0FBQ3BDLE1BQUksQ0FBQ25xQyxhQUFMLEVBQW9CO0FBQ2xCO0FBQ0Q7QUFDREEsZ0JBQWNvcUMsV0FBZCxDQUEwQixrQkFBMUIsRUFBOENGLG9CQUE5QztBQUNBbHFDLGtCQUFnQixJQUFoQjtBQUNBd3BDLHNCQUFvQixJQUFwQjtBQUNEOztBQUVEOzs7O0FBSUEsU0FBU1Usb0JBQVQsQ0FBOEJ6MkUsV0FBOUIsRUFBMkM7QUFDekMsTUFBSUEsWUFBWW9aLFlBQVosS0FBNkIsT0FBakMsRUFBMEM7QUFDeEM7QUFDRDtBQUNELE1BQUkrOEQsc0JBQXNCSixpQkFBdEIsQ0FBSixFQUE4QztBQUM1Q0UsOEJBQTBCajJFLFdBQTFCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNDJFLGlDQUFULENBQTJDbnVFLFlBQTNDLEVBQXlEekosTUFBekQsRUFBaUVlLFVBQWpFLEVBQTZFO0FBQzNFLE1BQUkwSSxpQkFBaUJuRCxnQ0FBckIsRUFBZ0M7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQW94RTtBQUNBSCxnQ0FBNEJ2M0UsTUFBNUIsRUFBb0NlLFVBQXBDO0FBQ0QsR0FiRCxNQWFPLElBQUkwSSxpQkFBaUIvRSwrQkFBckIsRUFBK0I7QUFDcENnekU7QUFDRDtBQUNGOztBQUVEO0FBQ0EsU0FBU0csa0NBQVQsQ0FBNENwdUUsWUFBNUMsRUFBMEQxSSxVQUExRCxFQUFzRTtBQUNwRSxNQUNFMEksaUJBQWlCaEIsMkNBQWpCLElBQ0FnQixpQkFBaUI3QyxpQ0FEakIsSUFFQTZDLGlCQUFpQi9DLG1DQUhuQixFQUlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPeXdFLHNCQUFzQkosaUJBQXRCLENBQVA7QUFDRDtBQUNGOztBQUVEOzs7QUFHQSxTQUFTZSxtQkFBVCxDQUE2QmgzQyxJQUE3QixFQUFtQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxNQUFNQyxXQUFXRCxLQUFLQyxRQUF0QjtBQUNBLFNBQ0VBLFlBQ0FBLFNBQVNscEIsV0FBVCxPQUEyQixPQUQzQixLQUVDaXBCLEtBQUszbUMsSUFBTCxLQUFjLFVBQWQsSUFBNEIybUMsS0FBSzNtQyxJQUFMLEtBQWMsT0FGM0MsQ0FERjtBQUtEOztBQUVELFNBQVM0OUUsMEJBQVQsQ0FBb0N0dUUsWUFBcEMsRUFBa0QxSSxVQUFsRCxFQUE4RDtBQUM1RCxNQUFJMEksaUJBQWlCMUUsZ0NBQXJCLEVBQWdDO0FBQzlCLFdBQU9veUUsc0JBQXNCcDJFLFVBQXRCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNpM0Usa0NBQVQsQ0FBNEN2dUUsWUFBNUMsRUFBMEQxSSxVQUExRCxFQUFzRTtBQUNwRSxNQUFJMEksaUJBQWlCakQsZ0NBQWpCLElBQThCaUQsaUJBQWlCM0UsaUNBQW5ELEVBQStEO0FBQzdELFdBQU9xeUUsc0JBQXNCcDJFLFVBQXRCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNrM0UseUJBQVQsQ0FBbUNuN0UsSUFBbkMsRUFBeUM7QUFDdkMsTUFBSWs2QixRQUFRbDZCLEtBQUt1dkMsYUFBakI7O0FBRUEsTUFBSSxDQUFDclYsS0FBRCxJQUFVLENBQUNBLE1BQU13VixVQUFqQixJQUErQjF2QyxLQUFLM0MsSUFBTCxLQUFjLFFBQWpELEVBQTJEO0FBQ3pEO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDN0IsK0NBQUwsRUFBbUM7QUFDakM7QUFDQSx3Q0FBZ0J3RSxJQUFoQixFQUFzQixRQUF0QixFQUFnQ0EsS0FBSzhjLEtBQXJDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OztBQVVBLElBQU1nM0Qsb0JBQW9CO0FBQ3hCMTVELGNBQVlBLFVBRFk7O0FBR3hCZ2hFLDBCQUF3QloscUJBSEE7O0FBS3hCbGhFLGlCQUFlLHVCQUNiM00sWUFEYSxFQUViMUksVUFGYSxFQUdiQyxXQUhhLEVBSWJDLGlCQUphLEVBS2I7QUFDQSxRQUFNbTJFLGFBQWFyMkUsYUFBYSxnREFBb0JBLFVBQXBCLENBQWIsR0FBK0NtSyxNQUFsRTs7QUFFQSxRQUFJaXRFLDBCQUFKO0FBQUEsUUFBdUJDLHdCQUF2QjtBQUNBLFFBQUlwQixxQkFBcUJJLFVBQXJCLENBQUosRUFBc0M7QUFDcENlLDBCQUFvQmQsMkJBQXBCO0FBQ0QsS0FGRCxNQUVPLElBQUksa0NBQW1CRCxVQUFuQixDQUFKLEVBQW9DO0FBQ3pDLFVBQUlFLHFCQUFKLEVBQTJCO0FBQ3pCYSw0QkFBb0JILGtDQUFwQjtBQUNELE9BRkQsTUFFTztBQUNMRyw0QkFBb0JOLGtDQUFwQjtBQUNBTywwQkFBa0JSLGlDQUFsQjtBQUNEO0FBQ0YsS0FQTSxNQU9BLElBQUlFLG9CQUFvQlYsVUFBcEIsQ0FBSixFQUFxQztBQUMxQ2UsMEJBQW9CSiwwQkFBcEI7QUFDRDs7QUFFRCxRQUFJSSxpQkFBSixFQUF1QjtBQUNyQixVQUFNcnRFLE9BQU9xdEUsa0JBQWtCMXVFLFlBQWxCLEVBQWdDMUksVUFBaEMsQ0FBYjtBQUNBLFVBQUkrSixJQUFKLEVBQVU7QUFDUixZQUFNeEssUUFBUXcyRSwrQkFDWmhzRSxJQURZLEVBRVo5SixXQUZZLEVBR1pDLGlCQUhZLENBQWQ7QUFLQSxlQUFPWCxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJODNFLGVBQUosRUFBcUI7QUFDbkJBLHNCQUFnQjN1RSxZQUFoQixFQUE4QjJ0RSxVQUE5QixFQUEwQ3IyRSxVQUExQztBQUNEOztBQUVEO0FBQ0EsUUFBSTBJLGlCQUFpQi9FLCtCQUFyQixFQUErQjtBQUM3QnV6RSxnQ0FBMEJiLFVBQTFCO0FBQ0Q7QUFDRjtBQS9DdUIsQ0FBMUI7O2tCQWtEZXhHLGlCOzs7Ozs7Ozs7Ozs7QUNuVGY7Ozs7Ozs7QUFPQTs7Ozs7Ozs7O0FBU0EsSUFBTUYsc0JBQXNCLENBQzFCLHNCQUQwQixFQUUxQixtQkFGMEIsRUFHMUIsdUJBSDBCLEVBSTFCLG1CQUowQixFQUsxQixtQkFMMEIsRUFNMUIsd0JBTjBCLENBQTVCOztrQkFTZUEsbUI7Ozs7Ozs7Ozs7Ozs7QUNsQmY7O0FBRUE7O0FBTUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBS0EsSUFBTXg1RCxhQUFhO0FBQ2pCbWhFLGNBQVk7QUFDVm5tRSxzQkFBa0IsY0FEUjtBQUVWeUYsa0JBQWMsQ0FBQ3ZRLG9DQUFELEVBQWdCQyxxQ0FBaEI7QUFGSixHQURLO0FBS2pCaXhFLGNBQVk7QUFDVnBtRSxzQkFBa0IsY0FEUjtBQUVWeUYsa0JBQWMsQ0FBQ3ZRLG9DQUFELEVBQWdCQyxxQ0FBaEI7QUFGSixHQUxLO0FBU2pCa3hFLGdCQUFjO0FBQ1pybUUsc0JBQWtCLGdCQUROO0FBRVp5RixrQkFBYyxDQUFDM1Asc0NBQUQsRUFBa0JDLHVDQUFsQjtBQUZGLEdBVEc7QUFhakJ1d0UsZ0JBQWM7QUFDWnRtRSxzQkFBa0IsZ0JBRE47QUFFWnlGLGtCQUFjLENBQUMzUCxzQ0FBRCxFQUFrQkMsdUNBQWxCO0FBRkY7QUFiRyxDQUFuQixDLENBdEJBOzs7Ozs7O0FBeUNBLElBQU0wb0Usd0JBQXdCO0FBQzVCejVELGNBQVlBLFVBRGdCOztBQUc1Qjs7Ozs7OztBQU9BZCxpQkFBZSx1QkFDYjNNLFlBRGEsRUFFYjFJLFVBRmEsRUFHYkMsV0FIYSxFQUliQyxpQkFKYSxFQUtiO0FBQ0EsUUFBTXczRSxjQUNKaHZFLGlCQUFpQnBDLHFDQUFqQixJQUFtQ29DLGlCQUFpQnhCLHVDQUR0RDtBQUVBLFFBQU15d0UsYUFDSmp2RSxpQkFBaUJyQyxvQ0FBakIsSUFBa0NxQyxpQkFBaUJ6QixzQ0FEckQ7O0FBR0EsUUFBSXl3RSxnQkFBZ0J6M0UsWUFBWThhLGFBQVosSUFBNkI5YSxZQUFZK2EsV0FBekQsQ0FBSixFQUEyRTtBQUN6RSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJLENBQUMyOEQsVUFBRCxJQUFlLENBQUNELFdBQXBCLEVBQWlDO0FBQy9CO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSUUsWUFBSjtBQUNBLFFBQUkxM0Usa0JBQWtCaUssTUFBbEIsS0FBNkJqSyxpQkFBakMsRUFBb0Q7QUFDbEQ7QUFDQTAzRSxZQUFNMTNFLGlCQUFOO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQSxVQUFNNndDLE1BQU03d0Msa0JBQWtCcXNDLGFBQTlCO0FBQ0EsVUFBSXdFLEdBQUosRUFBUztBQUNQNm1DLGNBQU03bUMsSUFBSThtQyxXQUFKLElBQW1COW1DLElBQUkrbUMsWUFBN0I7QUFDRCxPQUZELE1BRU87QUFDTEYsY0FBTXp0RSxNQUFOO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJNkgsYUFBSjtBQUNBLFFBQUlDLFdBQUo7QUFDQSxRQUFJMGxFLFVBQUosRUFBZ0I7QUFDZDNsRSxhQUFPaFMsVUFBUDtBQUNBLFVBQU0rM0UsVUFBVTkzRSxZQUFZOGEsYUFBWixJQUE2QjlhLFlBQVlpYixTQUF6RDtBQUNBakosV0FBSzhsRSxVQUFVLHVEQUEyQkEsT0FBM0IsQ0FBVixHQUFnRCxJQUFyRDtBQUNELEtBSkQsTUFJTztBQUNMO0FBQ0EvbEUsYUFBTyxJQUFQO0FBQ0FDLFdBQUtqUyxVQUFMO0FBQ0Q7O0FBRUQsUUFBSWdTLFNBQVNDLEVBQWIsRUFBaUI7QUFDZjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUkrbEUsdUJBQUo7QUFBQSxRQUFvQkMsdUJBQXBCO0FBQUEsUUFBb0NDLHVCQUFwQztBQUFBLFFBQW9EQyx3QkFBcEQ7O0FBRUEsUUFBSXp2RSxpQkFBaUJyQyxvQ0FBakIsSUFBa0NxQyxpQkFBaUJwQyxxQ0FBdkQsRUFBdUU7QUFDckUweEUsdUJBQWlCaitELDZCQUFqQjtBQUNBaytELHVCQUFpQjloRSxXQUFXb2hFLFVBQTVCO0FBQ0FXLHVCQUFpQi9oRSxXQUFXbWhFLFVBQTVCO0FBQ0FhLHdCQUFrQixPQUFsQjtBQUNELEtBTEQsTUFLTyxJQUNMenZFLGlCQUFpQnpCLHNDQUFqQixJQUNBeUIsaUJBQWlCeEIsdUNBRlosRUFHTDtBQUNBOHdFLHVCQUFpQjlxQywrQkFBakI7QUFDQStxQyx1QkFBaUI5aEUsV0FBV3NoRSxZQUE1QjtBQUNBUyx1QkFBaUIvaEUsV0FBV3FoRSxZQUE1QjtBQUNBVyx3QkFBa0IsU0FBbEI7QUFDRDs7QUFFRCxRQUFNQyxXQUFXcG1FLFFBQVEsSUFBUixHQUFlNGxFLEdBQWYsR0FBcUIsZ0RBQW9CNWxFLElBQXBCLENBQXRDO0FBQ0EsUUFBTXFtRSxTQUFTcG1FLE1BQU0sSUFBTixHQUFhMmxFLEdBQWIsR0FBbUIsZ0RBQW9CM2xFLEVBQXBCLENBQWxDOztBQUVBLFFBQU1ILFFBQVFrbUUsZUFBZWgxRSxTQUFmLENBQ1ppMUUsY0FEWSxFQUVaam1FLElBRlksRUFHWi9SLFdBSFksRUFJWkMsaUJBSlksQ0FBZDtBQU1BNFIsVUFBTTFZLElBQU4sR0FBYSsrRSxrQkFBa0IsT0FBL0I7QUFDQXJtRSxVQUFNN1MsTUFBTixHQUFlbTVFLFFBQWY7QUFDQXRtRSxVQUFNaUosYUFBTixHQUFzQnM5RCxNQUF0Qjs7QUFFQSxRQUFNdG1FLFFBQVFpbUUsZUFBZWgxRSxTQUFmLENBQ1prMUUsY0FEWSxFQUVaam1FLEVBRlksRUFHWmhTLFdBSFksRUFJWkMsaUJBSlksQ0FBZDtBQU1BNlIsVUFBTTNZLElBQU4sR0FBYSsrRSxrQkFBa0IsT0FBL0I7QUFDQXBtRSxVQUFNOVMsTUFBTixHQUFlbzVFLE1BQWY7QUFDQXRtRSxVQUFNZ0osYUFBTixHQUFzQnE5RCxRQUF0Qjs7QUFFQSwwREFBK0J0bUUsS0FBL0IsRUFBc0NDLEtBQXRDLEVBQTZDQyxJQUE3QyxFQUFtREMsRUFBbkQ7O0FBRUEsV0FBTyxDQUFDSCxLQUFELEVBQVFDLEtBQVIsQ0FBUDtBQUNEO0FBeEcyQixDQUE5Qjs7a0JBMkdlNjlELHFCOzs7Ozs7Ozs7Ozs7O0FDN0lmOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQVdBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxJQUFNMEksMkJBQ0pwdUUsbUNBQWEsa0JBQWtCRSxRQUEvQixJQUEyQ0EsU0FBUyttRSxZQUFULElBQXlCLEVBRHRFLEMsQ0E5QkE7Ozs7Ozs7QUFpQ0EsSUFBTWg3RCxhQUFhO0FBQ2pCb2lFLFVBQVE7QUFDTm5uRSw2QkFBeUI7QUFDdkI4K0IsZUFBUyxVQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRG5CO0FBS052NUIsa0JBQWMsQ0FDWmpULCtCQURZLEVBRVpVLHVDQUZZLEVBR1pNLG1DQUhZLEVBSVpZLGdDQUpZLEVBS1pJLG1DQUxZLEVBTVpFLGlDQU5ZLEVBT1pNLHFDQVBZLEVBUVpJLG1DQVJZLEVBU1ptQiwyQ0FUWTtBQUxSO0FBRFMsQ0FBbkI7O0FBb0JBLElBQUk4a0MsZ0JBQWdCLElBQXBCO0FBQ0EsSUFBSXdwQyxvQkFBb0IsSUFBeEI7QUFDQSxJQUFJd0MsZ0JBQWdCLElBQXBCO0FBQ0EsSUFBSUMsWUFBWSxLQUFoQjs7QUFFQTs7Ozs7Ozs7O0FBU0EsU0FBU0MsWUFBVCxDQUFzQjM4RSxJQUF0QixFQUE0QjtBQUMxQixNQUFJLG9CQUFvQkEsSUFBcEIsSUFBNEIsbURBQXlCQSxJQUF6QixDQUFoQyxFQUFnRTtBQUM5RCxXQUFPO0FBQ0w2dkQsYUFBTzd2RCxLQUFLNDhFLGNBRFA7QUFFTHJwQixXQUFLdnpELEtBQUs2OEU7QUFGTCxLQUFQO0FBSUQsR0FMRCxNQUtPO0FBQ0wsUUFBTWhCLE1BQ0g3N0UsS0FBS3d3QyxhQUFMLElBQXNCeHdDLEtBQUt3d0MsYUFBTCxDQUFtQnNyQyxXQUExQyxJQUEwRDF0RSxNQUQ1RDtBQUVBLFFBQU0wdUUsWUFBWWpCLElBQUljLFlBQUosRUFBbEI7QUFDQSxXQUFPO0FBQ0xJLGtCQUFZRCxVQUFVQyxVQURqQjtBQUVMQyxvQkFBY0YsVUFBVUUsWUFGbkI7QUFHTEMsaUJBQVdILFVBQVVHLFNBSGhCO0FBSUxDLG1CQUFhSixVQUFVSTtBQUpsQixLQUFQO0FBTUQ7QUFDRjs7QUFFRDs7Ozs7O0FBTUEsU0FBU0Msc0JBQVQsQ0FBZ0NDLFdBQWhDLEVBQTZDO0FBQzNDLFNBQU9BLFlBQVlodkUsTUFBWixLQUF1Qmd2RSxXQUF2QixHQUNIQSxZQUFZL3VFLFFBRFQsR0FFSCt1RSxZQUFZanZDLFFBQVosS0FBeUJwaEMsMkJBQXpCLEdBQ0Vxd0UsV0FERixHQUVFQSxZQUFZNXNDLGFBSmxCO0FBS0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTNnNDLG9CQUFULENBQThCbjVFLFdBQTlCLEVBQTJDQyxpQkFBM0MsRUFBOEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNNndDLE1BQU1tb0MsdUJBQXVCaDVFLGlCQUF2QixDQUFaOztBQUVBLE1BQ0V1NEUsYUFDQWpzQyxpQkFBaUIsSUFEakIsSUFFQUEsa0JBQWtCLGdDQUFpQnVFLEdBQWpCLENBSHBCLEVBSUU7QUFDQSxXQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQU1zb0MsbUJBQW1CWCxhQUFhbHNDLGFBQWIsQ0FBekI7QUFDQSxNQUFJLENBQUNnc0MsYUFBRCxJQUFrQixDQUFDLDRCQUFhQSxhQUFiLEVBQTRCYSxnQkFBNUIsQ0FBdkIsRUFBc0U7QUFDcEViLG9CQUFnQmEsZ0JBQWhCOztBQUVBLFFBQU10M0MsaUJBQWlCamlDLHlCQUFla0QsU0FBZixDQUNyQm1ULFdBQVdvaUUsTUFEVSxFQUVyQnZDLGlCQUZxQixFQUdyQi8xRSxXQUhxQixFQUlyQkMsaUJBSnFCLENBQXZCOztBQU9BNmhDLG1CQUFlM29DLElBQWYsR0FBc0IsUUFBdEI7QUFDQTJvQyxtQkFBZTlpQyxNQUFmLEdBQXdCdXRDLGFBQXhCOztBQUVBLHdEQUE2QnpLLGNBQTdCOztBQUVBLFdBQU9BLGNBQVA7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjQSxJQUFNK3RDLG9CQUFvQjtBQUN4QjM1RCxjQUFZQSxVQURZOztBQUd4QmQsaUJBQWUsdUJBQ2IzTSxZQURhLEVBRWIxSSxVQUZhLEVBR2JDLFdBSGEsRUFJYkMsaUJBSmEsRUFLYjtBQUNBLFFBQU02d0MsTUFBTW1vQyx1QkFBdUJoNUUsaUJBQXZCLENBQVo7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDNndDLEdBQUQsSUFBUSxDQUFDLDREQUE2QixVQUE3QixFQUF5Q0EsR0FBekMsQ0FBYixFQUE0RDtBQUMxRCxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFNc2xDLGFBQWFyMkUsYUFBYSxnREFBb0JBLFVBQXBCLENBQWIsR0FBK0NtSyxNQUFsRTs7QUFFQSxZQUFRekIsWUFBUjtBQUNFO0FBQ0EsV0FBS25ELGdDQUFMO0FBQ0UsWUFDRSxrQ0FBbUI4d0UsVUFBbkIsS0FDQUEsV0FBV2lELGVBQVgsS0FBK0IsTUFGakMsRUFHRTtBQUNBOXNDLDBCQUFnQjZwQyxVQUFoQjtBQUNBTCw4QkFBb0JoMkUsVUFBcEI7QUFDQXc0RSwwQkFBZ0IsSUFBaEI7QUFDRDtBQUNEO0FBQ0YsV0FBSzcwRSwrQkFBTDtBQUNFNm9DLHdCQUFnQixJQUFoQjtBQUNBd3BDLDRCQUFvQixJQUFwQjtBQUNBd0Msd0JBQWdCLElBQWhCO0FBQ0E7QUFDRjtBQUNBO0FBQ0EsV0FBS3J5RSxxQ0FBTDtBQUNFc3lFLG9CQUFZLElBQVo7QUFDQTtBQUNGLFdBQUtwMEUsdUNBQUw7QUFDQSxXQUFLa0MsbUNBQUw7QUFDQSxXQUFLNUIsbUNBQUw7QUFDRTh6RSxvQkFBWSxLQUFaO0FBQ0EsZUFBT1cscUJBQXFCbjVFLFdBQXJCLEVBQWtDQyxpQkFBbEMsQ0FBUDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUt3SCwyQ0FBTDtBQUNFLFlBQUk0d0Usd0JBQUosRUFBOEI7QUFDNUI7QUFDRDtBQUNIO0FBQ0EsV0FBSzN5RSxtQ0FBTDtBQUNBLFdBQUtFLGlDQUFMO0FBQ0UsZUFBT3V6RSxxQkFBcUJuNUUsV0FBckIsRUFBa0NDLGlCQUFsQyxDQUFQO0FBM0NKOztBQThDQSxXQUFPLElBQVA7QUFDRDtBQWpFdUIsQ0FBMUI7O2tCQW9FZTR2RSxpQjs7Ozs7Ozs7Ozs7O1FDdEtDeUosYyxHQUFBQSxjO1FBSUEzNkQsUyxHQUFBQSxTO1FBaUNBNDZELDZCLEdBQUFBLDZCO1FBOEhBQyxvQixHQUFBQSxvQjtRQWlDQUMsaUMsR0FBQUEsaUM7O0FBdFBoQjs7OztBQUNBOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQU9BOzs7O0FBeEJBOzs7Ozs7Ozs7QUEwQkEsSUFBTWwyRCxvQkFBb0Ivc0IsK0JBQXFCK3NCLGlCQUEvQzs7QUFFQSxJQUFNbTJELFdBQVcsQ0FBakI7QUFDQSxJQUFNQyxVQUFVLENBQWhCO0FBQ0EsSUFBTUMsWUFBWSxDQUFsQjs7QUFFQSxTQUFTQyxrQkFBVCxDQUE0QnYrRSxLQUE1QixFQUFrRDtBQUNoRCxNQUFJUSxPQUFPUixLQUFYO0FBQ0EsTUFBSSxDQUFDQSxNQUFNaVIsU0FBWCxFQUFzQjtBQUNwQjtBQUNBO0FBQ0EsUUFBSSxDQUFDelEsS0FBS3FSLFNBQUwsR0FBaUI3USw4QkFBbEIsTUFBaUNGLDZCQUFyQyxFQUErQztBQUM3QyxhQUFPczlFLFFBQVA7QUFDRDtBQUNELFdBQU81OUUsS0FBS0MsTUFBWixFQUFvQjtBQUNsQkQsYUFBT0EsS0FBS0MsTUFBWjtBQUNBLFVBQUksQ0FBQ0QsS0FBS3FSLFNBQUwsR0FBaUI3USw4QkFBbEIsTUFBaUNGLDZCQUFyQyxFQUErQztBQUM3QyxlQUFPczlFLFFBQVA7QUFDRDtBQUNGO0FBQ0YsR0FaRCxNQVlPO0FBQ0wsV0FBTzU5RSxLQUFLQyxNQUFaLEVBQW9CO0FBQ2xCRCxhQUFPQSxLQUFLQyxNQUFaO0FBQ0Q7QUFDRjtBQUNELE1BQUlELEtBQUsxQyxHQUFMLEtBQWF4Qix1QkFBakIsRUFBMkI7QUFDekI7QUFDQTtBQUNBLFdBQU8raEYsT0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFNBQU9DLFNBQVA7QUFDRDs7QUFFTSxTQUFTTixjQUFULENBQXdCaCtFLEtBQXhCLEVBQStDO0FBQ3BELFNBQU91K0UsbUJBQW1CditFLEtBQW5CLE1BQThCcStFLE9BQXJDO0FBQ0Q7O0FBRU0sU0FBU2g3RCxTQUFULENBQW1CMmdELFNBQW5CLEVBQWtFO0FBQ3ZFLE1BQUk5cUUsSUFBSixFQUFhO0FBQ1gsUUFBTStHLFFBQVNnb0Isa0JBQWtCdm5CLE9BQWpDO0FBQ0EsUUFBSVQsVUFBVSxJQUFWLElBQWtCQSxNQUFNbkMsR0FBTixLQUFjMUIsNkJBQXBDLEVBQW9EO0FBQ2xELFVBQU1vaUYsYUFBb0J2K0UsS0FBMUI7QUFDQSxVQUFNb0gsV0FBV20zRSxXQUFXL3ZFLFNBQTVCO0FBQ0EseUNBQ0VwSCxTQUFTdXJFLHdCQURYLEVBRUUsNkRBQ0UsbUVBREYsR0FFRSxvRUFGRixHQUdFLGlFQUhGLEdBSUUsNkJBTkosRUFPRSxnQ0FBaUI0TCxXQUFXM2dGLElBQTVCLEtBQXFDLGFBUHZDO0FBU0F3SixlQUFTdXJFLHdCQUFULEdBQW9DLElBQXBDO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNNXlFLFFBQWdCLDJCQUFZZ2tFLFNBQVosQ0FBdEI7QUFDQSxNQUFJLENBQUNoa0UsS0FBTCxFQUFZO0FBQ1YsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFPdStFLG1CQUFtQnYrRSxLQUFuQixNQUE4QnErRSxPQUFyQztBQUNEOztBQUVELFNBQVNJLGVBQVQsQ0FBeUJ6K0UsS0FBekIsRUFBZ0M7QUFDOUIsMkJBQ0V1K0UsbUJBQW1CditFLEtBQW5CLE1BQThCcStFLE9BRGhDLEVBRUUsZ0RBRkY7QUFJRDs7QUFFTSxTQUFTSiw2QkFBVCxDQUF1Q2orRSxLQUF2QyxFQUFtRTtBQUN4RSxNQUFJaVIsWUFBWWpSLE1BQU1pUixTQUF0QjtBQUNBLE1BQUksQ0FBQ0EsU0FBTCxFQUFnQjtBQUNkO0FBQ0EsUUFBTXlwQixRQUFRNmpELG1CQUFtQnYrRSxLQUFuQixDQUFkO0FBQ0EsNkJBQ0UwNkIsVUFBVTRqRCxTQURaLEVBRUUsZ0RBRkY7QUFJQSxRQUFJNWpELFVBQVUwakQsUUFBZCxFQUF3QjtBQUN0QixhQUFPLElBQVA7QUFDRDtBQUNELFdBQU9wK0UsS0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBSXpHLElBQUl5RyxLQUFSO0FBQ0EsTUFBSXhHLElBQUl5WCxTQUFSO0FBQ0EsU0FBTyxJQUFQLEVBQWE7QUFDWCxRQUFJeXRFLFVBQVVubEYsRUFBRWtILE1BQWhCO0FBQ0EsUUFBSWsrRSxVQUFVRCxVQUFVQSxRQUFRenRFLFNBQWxCLEdBQThCLElBQTVDO0FBQ0EsUUFBSSxDQUFDeXRFLE9BQUQsSUFBWSxDQUFDQyxPQUFqQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBSUQsUUFBUS9wRSxLQUFSLEtBQWtCZ3FFLFFBQVFocUUsS0FBOUIsRUFBcUM7QUFDbkMsVUFBSUEsUUFBUStwRSxRQUFRL3BFLEtBQXBCO0FBQ0EsYUFBT0EsS0FBUCxFQUFjO0FBQ1osWUFBSUEsVUFBVXBiLENBQWQsRUFBaUI7QUFDZjtBQUNBa2xGLDBCQUFnQkMsT0FBaEI7QUFDQSxpQkFBTzErRSxLQUFQO0FBQ0Q7QUFDRCxZQUFJMlUsVUFBVW5iLENBQWQsRUFBaUI7QUFDZjtBQUNBaWxGLDBCQUFnQkMsT0FBaEI7QUFDQSxpQkFBT3p0RSxTQUFQO0FBQ0Q7QUFDRDBELGdCQUFRQSxNQUFNTyxPQUFkO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsK0JBQVUsS0FBVixFQUFpQixnREFBakI7QUFDRDs7QUFFRCxRQUFJM2IsRUFBRWtILE1BQUYsS0FBYWpILEVBQUVpSCxNQUFuQixFQUEyQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBbEgsVUFBSW1sRixPQUFKO0FBQ0FsbEYsVUFBSW1sRixPQUFKO0FBQ0QsS0FQRCxNQU9PO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUlDLGVBQWUsS0FBbkI7QUFDQSxVQUFJanFFLFNBQVErcEUsUUFBUS9wRSxLQUFwQjtBQUNBLGFBQU9BLE1BQVAsRUFBYztBQUNaLFlBQUlBLFdBQVVwYixDQUFkLEVBQWlCO0FBQ2ZxbEYseUJBQWUsSUFBZjtBQUNBcmxGLGNBQUltbEYsT0FBSjtBQUNBbGxGLGNBQUltbEYsT0FBSjtBQUNBO0FBQ0Q7QUFDRCxZQUFJaHFFLFdBQVVuYixDQUFkLEVBQWlCO0FBQ2ZvbEYseUJBQWUsSUFBZjtBQUNBcGxGLGNBQUlrbEYsT0FBSjtBQUNBbmxGLGNBQUlvbEYsT0FBSjtBQUNBO0FBQ0Q7QUFDRGhxRSxpQkFBUUEsT0FBTU8sT0FBZDtBQUNEO0FBQ0QsVUFBSSxDQUFDMHBFLFlBQUwsRUFBbUI7QUFDakI7QUFDQWpxRSxpQkFBUWdxRSxRQUFRaHFFLEtBQWhCO0FBQ0EsZUFBT0EsTUFBUCxFQUFjO0FBQ1osY0FBSUEsV0FBVXBiLENBQWQsRUFBaUI7QUFDZnFsRiwyQkFBZSxJQUFmO0FBQ0FybEYsZ0JBQUlvbEYsT0FBSjtBQUNBbmxGLGdCQUFJa2xGLE9BQUo7QUFDQTtBQUNEO0FBQ0QsY0FBSS9wRSxXQUFVbmIsQ0FBZCxFQUFpQjtBQUNmb2xGLDJCQUFlLElBQWY7QUFDQXBsRixnQkFBSW1sRixPQUFKO0FBQ0FwbEYsZ0JBQUltbEYsT0FBSjtBQUNBO0FBQ0Q7QUFDRC9wRSxtQkFBUUEsT0FBTU8sT0FBZDtBQUNEO0FBQ0QsaUNBQ0UwcEUsWUFERixFQUVFLG9FQUNFLCtEQUhKO0FBS0Q7QUFDRjs7QUFFRCw2QkFDRXJsRixFQUFFMFgsU0FBRixLQUFnQnpYLENBRGxCLEVBRUUsNkRBQ0Usc0VBSEo7QUFLRDtBQUNEO0FBQ0E7QUFDQSwyQkFDRUQsRUFBRXVFLEdBQUYsS0FBVXhCLHVCQURaLEVBRUUsZ0RBRkY7QUFJQSxNQUFJL0MsRUFBRWtWLFNBQUYsQ0FBWS9OLE9BQVosS0FBd0JuSCxDQUE1QixFQUErQjtBQUM3QjtBQUNBLFdBQU95RyxLQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQU9pUixTQUFQO0FBQ0Q7O0FBRU0sU0FBU2l0RSxvQkFBVCxDQUE4QnpwRSxNQUE5QixFQUEyRDtBQUNoRSxNQUFNc3pDLGdCQUFnQmsyQiw4QkFBOEJ4cEUsTUFBOUIsQ0FBdEI7QUFDQSxNQUFJLENBQUNzekMsYUFBTCxFQUFvQjtBQUNsQixXQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUl2bkQsT0FBY3VuRCxhQUFsQjtBQUNBLFNBQU8sSUFBUCxFQUFhO0FBQ1gsUUFBSXZuRCxLQUFLMUMsR0FBTCxLQUFhdEIsNEJBQWIsSUFBOEJnRSxLQUFLMUMsR0FBTCxLQUFhckIsdUJBQS9DLEVBQXlEO0FBQ3ZELGFBQU8rRCxJQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUlBLEtBQUttVSxLQUFULEVBQWdCO0FBQ3JCblUsV0FBS21VLEtBQUwsQ0FBV2xVLE1BQVgsR0FBb0JELElBQXBCO0FBQ0FBLGFBQU9BLEtBQUttVSxLQUFaO0FBQ0E7QUFDRDtBQUNELFFBQUluVSxTQUFTdW5ELGFBQWIsRUFBNEI7QUFDMUIsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxXQUFPLENBQUN2bkQsS0FBSzBVLE9BQWIsRUFBc0I7QUFDcEIsVUFBSSxDQUFDMVUsS0FBS0MsTUFBTixJQUFnQkQsS0FBS0MsTUFBTCxLQUFnQnNuRCxhQUFwQyxFQUFtRDtBQUNqRCxlQUFPLElBQVA7QUFDRDtBQUNEdm5ELGFBQU9BLEtBQUtDLE1BQVo7QUFDRDtBQUNERCxTQUFLMFUsT0FBTCxDQUFhelUsTUFBYixHQUFzQkQsS0FBS0MsTUFBM0I7QUFDQUQsV0FBT0EsS0FBSzBVLE9BQVo7QUFDRDtBQUNEO0FBQ0E7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTaXBFLGlDQUFULENBQTJDMXBFLE1BQTNDLEVBQXdFO0FBQzdFLE1BQU1zekMsZ0JBQWdCazJCLDhCQUE4QnhwRSxNQUE5QixDQUF0QjtBQUNBLE1BQUksQ0FBQ3N6QyxhQUFMLEVBQW9CO0FBQ2xCLFdBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0EsTUFBSXZuRCxPQUFjdW5ELGFBQWxCO0FBQ0EsU0FBTyxJQUFQLEVBQWE7QUFDWCxRQUFJdm5ELEtBQUsxQyxHQUFMLEtBQWF0Qiw0QkFBYixJQUE4QmdFLEtBQUsxQyxHQUFMLEtBQWFyQix1QkFBL0MsRUFBeUQ7QUFDdkQsYUFBTytELElBQVA7QUFDRCxLQUZELE1BRU8sSUFBSUEsS0FBS21VLEtBQUwsSUFBY25VLEtBQUsxQyxHQUFMLEtBQWF2Qix5QkFBL0IsRUFBMkM7QUFDaERpRSxXQUFLbVUsS0FBTCxDQUFXbFUsTUFBWCxHQUFvQkQsSUFBcEI7QUFDQUEsYUFBT0EsS0FBS21VLEtBQVo7QUFDQTtBQUNEO0FBQ0QsUUFBSW5VLFNBQVN1bkQsYUFBYixFQUE0QjtBQUMxQixhQUFPLElBQVA7QUFDRDtBQUNELFdBQU8sQ0FBQ3ZuRCxLQUFLMFUsT0FBYixFQUFzQjtBQUNwQixVQUFJLENBQUMxVSxLQUFLQyxNQUFOLElBQWdCRCxLQUFLQyxNQUFMLEtBQWdCc25ELGFBQXBDLEVBQW1EO0FBQ2pELGVBQU8sSUFBUDtBQUNEO0FBQ0R2bkQsYUFBT0EsS0FBS0MsTUFBWjtBQUNEO0FBQ0RELFNBQUswVSxPQUFMLENBQWF6VSxNQUFiLEdBQXNCRCxLQUFLQyxNQUEzQjtBQUNBRCxXQUFPQSxLQUFLMFUsT0FBWjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFNBQU8sSUFBUDtBQUNELEM7Ozs7Ozs7Ozs7OztRQ3ZSZTJwRSxzQixHQUFBQSxzQjtRQVFBQyx1QixHQUFBQSx1QjtBQWpCaEI7Ozs7Ozs7OztBQVNPLFNBQVNELHNCQUFULENBQ0x6M0QsT0FESyxFQUVMMnZELFNBRkssRUFHTGhoRSxRQUhLLEVBSUM7QUFDTnFSLFVBQVFtdUQsZ0JBQVIsQ0FBeUJ3QixTQUF6QixFQUFvQ2hoRSxRQUFwQyxFQUE4QyxLQUE5QztBQUNEOztBQUVNLFNBQVMrb0UsdUJBQVQsQ0FDTDEzRCxPQURLLEVBRUwydkQsU0FGSyxFQUdMaGhFLFFBSEssRUFJQztBQUNOcVIsVUFBUW11RCxnQkFBUixDQUF5QndCLFNBQXpCLEVBQW9DaGhFLFFBQXBDLEVBQThDLElBQTlDO0FBQ0QsQzs7Ozs7Ozs7Ozs7OztBQ2hCRDs7Ozs7O0FBRUE7Ozs7O0FBS0EsSUFBTW8vQiwwQkFBMEI1d0MseUJBQWUwQixNQUFmLENBQXNCO0FBQ3BEODRFLGlCQUFlLElBRHFDO0FBRXBEdDBDLGVBQWEsSUFGdUM7QUFHcER1MEMsaUJBQWU7QUFIcUMsQ0FBdEIsQ0FBaEMsQyxDQWRBOzs7Ozs7O2tCQW9CZTdwQyx1Qjs7Ozs7Ozs7Ozs7OztBQ2JmOzs7Ozs7QUFFQTs7OztBQUlBLElBQU1HLDBCQUEwQi93Qyx5QkFBZTBCLE1BQWYsQ0FBc0I7QUFDcERnNUUsaUJBQWUsdUJBQVNqN0UsS0FBVCxFQUFnQjtBQUM3QixXQUFPLG1CQUFtQkEsS0FBbkIsR0FDSEEsTUFBTWk3RSxhQURILEdBRUhyd0UsT0FBT3F3RSxhQUZYO0FBR0Q7QUFMbUQsQ0FBdEIsQ0FBaEMsQyxDQWJBOzs7Ozs7O2tCQXFCZTNwQyx1Qjs7Ozs7Ozs7Ozs7OztBQ2RmOzs7Ozs7QUFFQTs7OztBQUlBLElBQU1OLHNCQUFzQnYyQiwyQkFBaUJ4WSxNQUFqQixDQUF3QjtBQUNsRHVaLGlCQUFlO0FBRG1DLENBQXhCLENBQTVCLEMsQ0FiQTs7Ozs7OztrQkFpQmV3MUIsbUI7Ozs7Ozs7Ozs7Ozs7QUNWZjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7QUFaQTs7Ozs7OztBQWdCQSxJQUFNRCx5QkFBeUJ0MkIsMkJBQWlCeFksTUFBakIsQ0FBd0I7QUFDckQyUixPQUFLc25FLHFCQURnRDtBQUVyRHJwRCxZQUFVLElBRjJDO0FBR3JEN1csV0FBUyxJQUg0QztBQUlyREMsWUFBVSxJQUoyQztBQUtyREMsVUFBUSxJQUw2QztBQU1yREMsV0FBUyxJQU40QztBQU9yRGdnRSxVQUFRLElBUDZDO0FBUXJEdkksVUFBUSxJQVI2QztBQVNyRHgzRCxvQkFBa0JDLCtCQVRtQztBQVVyRDtBQUNBNG5CLFlBQVUsa0JBQVNqakMsS0FBVCxFQUFnQjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFJQSxNQUFNbkcsSUFBTixLQUFlLFVBQW5CLEVBQStCO0FBQzdCLGFBQU8sZ0NBQWlCbUcsS0FBakIsQ0FBUDtBQUNEO0FBQ0QsV0FBTyxDQUFQO0FBQ0QsR0FyQm9EO0FBc0JyRGtqQyxXQUFTLGlCQUFTbGpDLEtBQVQsRUFBZ0I7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUlBLE1BQU1uRyxJQUFOLEtBQWUsU0FBZixJQUE0Qm1HLE1BQU1uRyxJQUFOLEtBQWUsT0FBL0MsRUFBd0Q7QUFDdEQsYUFBT21HLE1BQU1rakMsT0FBYjtBQUNEO0FBQ0QsV0FBTyxDQUFQO0FBQ0QsR0FsQ29EO0FBbUNyRGt3QyxTQUFPLGVBQVNwekUsS0FBVCxFQUFnQjtBQUNyQjtBQUNBO0FBQ0EsUUFBSUEsTUFBTW5HLElBQU4sS0FBZSxVQUFuQixFQUErQjtBQUM3QixhQUFPLGdDQUFpQm1HLEtBQWpCLENBQVA7QUFDRDtBQUNELFFBQUlBLE1BQU1uRyxJQUFOLEtBQWUsU0FBZixJQUE0Qm1HLE1BQU1uRyxJQUFOLEtBQWUsT0FBL0MsRUFBd0Q7QUFDdEQsYUFBT21HLE1BQU1rakMsT0FBYjtBQUNEO0FBQ0QsV0FBTyxDQUFQO0FBQ0Q7QUE3Q29ELENBQXhCLENBQS9COztrQkFnRGU2TixzQjs7Ozs7Ozs7Ozs7OztBQ3ZEZjs7Ozs7O0FBRUE7Ozs7QUFJQSxJQUFNcXFDLGVBQWU7QUFDbkJDLE9BQUssUUFEYztBQUVuQkMsWUFBVSxHQUZTO0FBR25CQyxRQUFNLFdBSGE7QUFJbkJDLE1BQUksU0FKZTtBQUtuQkMsU0FBTyxZQUxZO0FBTW5CQyxRQUFNLFdBTmE7QUFPbkJDLE9BQUssUUFQYztBQVFuQkMsT0FBSyxJQVJjO0FBU25CQyxRQUFNLGFBVGE7QUFVbkJDLFFBQU0sYUFWYTtBQVduQkMsVUFBUSxZQVhXO0FBWW5CQyxtQkFBaUI7QUFaRSxDQUFyQjs7QUFlQTs7Ozs7QUE5QkE7Ozs7Ozs7OztBQW1DQSxJQUFNQyxpQkFBaUI7QUFDckIsT0FBSyxXQURnQjtBQUVyQixPQUFLLEtBRmdCO0FBR3JCLFFBQU0sT0FIZTtBQUlyQixRQUFNLE9BSmU7QUFLckIsUUFBTSxPQUxlO0FBTXJCLFFBQU0sU0FOZTtBQU9yQixRQUFNLEtBUGU7QUFRckIsUUFBTSxPQVJlO0FBU3JCLFFBQU0sVUFUZTtBQVVyQixRQUFNLFFBVmU7QUFXckIsUUFBTSxHQVhlO0FBWXJCLFFBQU0sUUFaZTtBQWFyQixRQUFNLFVBYmU7QUFjckIsUUFBTSxLQWRlO0FBZXJCLFFBQU0sTUFmZTtBQWdCckIsUUFBTSxXQWhCZTtBQWlCckIsUUFBTSxTQWpCZTtBQWtCckIsUUFBTSxZQWxCZTtBQW1CckIsUUFBTSxXQW5CZTtBQW9CckIsUUFBTSxRQXBCZTtBQXFCckIsUUFBTSxRQXJCZTtBQXNCckIsU0FBTyxJQXRCYztBQXVCckIsU0FBTyxJQXZCYztBQXdCckIsU0FBTyxJQXhCYztBQXlCckIsU0FBTyxJQXpCYztBQTBCckIsU0FBTyxJQTFCYztBQTJCckIsU0FBTyxJQTNCYztBQTRCckIsU0FBTyxJQTVCYztBQTZCckIsU0FBTyxJQTdCYztBQThCckIsU0FBTyxJQTlCYztBQStCckIsU0FBTyxLQS9CYztBQWdDckIsU0FBTyxLQWhDYztBQWlDckIsU0FBTyxLQWpDYztBQWtDckIsU0FBTyxTQWxDYztBQW1DckIsU0FBTyxZQW5DYztBQW9DckIsU0FBTztBQXBDYyxDQUF2Qjs7QUF1Q0E7Ozs7QUFJQSxTQUFTZixXQUFULENBQXFCeDZFLFdBQXJCLEVBQXlEO0FBQ3ZELE1BQUlBLFlBQVlrVCxHQUFoQixFQUFxQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFNQSxNQUFNd25FLGFBQWExNkUsWUFBWWtULEdBQXpCLEtBQWlDbFQsWUFBWWtULEdBQXpEO0FBQ0EsUUFBSUEsUUFBUSxjQUFaLEVBQTRCO0FBQzFCLGFBQU9BLEdBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0EsTUFBSWxULFlBQVk3RyxJQUFaLEtBQXFCLFVBQXpCLEVBQXFDO0FBQ25DLFFBQU1vcEMsV0FBVyxnQ0FBaUJ2aUMsV0FBakIsQ0FBakI7O0FBRUE7QUFDQTtBQUNBLFdBQU91aUMsYUFBYSxFQUFiLEdBQWtCLE9BQWxCLEdBQTRCbStCLE9BQU9HLFlBQVAsQ0FBb0J0K0IsUUFBcEIsQ0FBbkM7QUFDRDtBQUNELE1BQUl2aUMsWUFBWTdHLElBQVosS0FBcUIsU0FBckIsSUFBa0M2RyxZQUFZN0csSUFBWixLQUFxQixPQUEzRCxFQUFvRTtBQUNsRTtBQUNBO0FBQ0EsV0FBT29pRixlQUFldjdFLFlBQVl3aUMsT0FBM0IsS0FBdUMsY0FBOUM7QUFDRDtBQUNELFNBQU8sRUFBUDtBQUNEOztrQkFFY2c0QyxXOzs7Ozs7Ozs7Ozs7O0FDcEdmOzs7Ozs7QUFFQTs7OztBQUlBLElBQU1qcUMscUJBQXFCejJCLDhCQUFvQnZZLE1BQXBCLENBQTJCO0FBQ3BEaTZFLGdCQUFjO0FBRHNDLENBQTNCLENBQTNCLEMsQ0FiQTs7Ozs7OztrQkFpQmVqckMsa0I7Ozs7Ozs7Ozs7Ozs7QUNWZjs7OztBQUNBOzs7Ozs7QUFFQTs7OztBQVZBOzs7Ozs7O0FBY0EsSUFBTUMsc0JBQXNCejJCLDJCQUFpQnhZLE1BQWpCLENBQXdCO0FBQ2xEazZFLFdBQVMsSUFEeUM7QUFFbERDLGlCQUFlLElBRm1DO0FBR2xEQyxrQkFBZ0IsSUFIa0M7QUFJbERuaEUsVUFBUSxJQUowQztBQUtsREMsV0FBUyxJQUx5QztBQU1sREgsV0FBUyxJQU55QztBQU9sREMsWUFBVSxJQVB3QztBQVFsREcsb0JBQWtCQztBQVJnQyxDQUF4QixDQUE1Qjs7a0JBV2U2MUIsbUI7Ozs7Ozs7Ozs7Ozs7QUNsQmY7Ozs7OztBQUVBOzs7OztBQUtBLElBQU1FLDJCQUEyQjd3Qyx5QkFBZTBCLE1BQWYsQ0FBc0I7QUFDckQ2WCxnQkFBYyxJQUR1QztBQUVyRDJzQixlQUFhLElBRndDO0FBR3JEdTBDLGlCQUFlO0FBSHNDLENBQXRCLENBQWpDLEMsQ0FkQTs7Ozs7OztrQkFvQmU1cEMsd0I7Ozs7Ozs7Ozs7Ozs7QUNiZjs7Ozs7O0FBRUE7Ozs7QUFJQSxJQUFNQyxzQkFBc0I3MkIsOEJBQW9CdlksTUFBcEIsQ0FBMkI7QUFDckRxNkUsUUFEcUQsa0JBQzlDdDhFLEtBRDhDLEVBQ3ZDO0FBQ1osV0FBTyxZQUFZQSxLQUFaLEdBQ0hBLE1BQU1zOEUsTUFESCxHQUVIO0FBQ0EscUJBQWlCdDhFLEtBQWpCLEdBQ0UsQ0FBQ0EsTUFBTXU4RSxXQURULEdBRUUsQ0FMTjtBQU1ELEdBUm9EO0FBU3JEQyxRQVRxRCxrQkFTOUN4OEUsS0FUOEMsRUFTdkM7QUFDWixXQUFPLFlBQVlBLEtBQVosR0FDSEEsTUFBTXc4RSxNQURILEdBRUg7QUFDQSxxQkFBaUJ4OEUsS0FBakIsR0FDRSxDQUFDQSxNQUFNeThFLFdBRFQsR0FFRTtBQUNBLG9CQUFnQno4RSxLQUFoQixHQUNFLENBQUNBLE1BQU0wOEUsVUFEVCxHQUVFLENBUlI7QUFTRCxHQW5Cb0Q7O0FBb0JyREMsVUFBUSxJQXBCNkM7O0FBc0JyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxhQUFXO0FBMUIwQyxDQUEzQixDQUE1QixDLENBYkE7Ozs7Ozs7a0JBMENldnJDLG1COzs7Ozs7Ozs7Ozs7UUM0QkN3ckMsd0IsR0FBQUEsd0I7UUFlQUMsdUIsR0FBQUEsdUI7UUFlQUMsZ0IsR0FBQUEsZ0I7UUEyQ0E1RCxZLEdBQUFBLFk7UUF1QkE2RCxZLEdBQUFBLFk7O0FBL0poQjs7OztBQUVBOztBQUNBOzs7O0FBRUEsU0FBU0MsVUFBVCxDQUFvQnpnRixJQUFwQixFQUEwQjtBQUN4QixTQUFPQSxRQUFRQSxLQUFLbXVDLFFBQUwsS0FBa0J0aEMsdUJBQWpDO0FBQ0QsQyxDQWREOzs7Ozs7O0FBZ0JBLFNBQVM2ekUsWUFBVCxDQUFzQkMsU0FBdEIsRUFBaUNDLFNBQWpDLEVBQTRDO0FBQzFDLE1BQUksQ0FBQ0QsU0FBRCxJQUFjLENBQUNDLFNBQW5CLEVBQThCO0FBQzVCLFdBQU8sS0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJRCxjQUFjQyxTQUFsQixFQUE2QjtBQUNsQyxXQUFPLElBQVA7QUFDRCxHQUZNLE1BRUEsSUFBSUgsV0FBV0UsU0FBWCxDQUFKLEVBQTJCO0FBQ2hDLFdBQU8sS0FBUDtBQUNELEdBRk0sTUFFQSxJQUFJRixXQUFXRyxTQUFYLENBQUosRUFBMkI7QUFDaEMsV0FBT0YsYUFBYUMsU0FBYixFQUF3QkMsVUFBVTd5RSxVQUFsQyxDQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUksY0FBYzR5RSxTQUFsQixFQUE2QjtBQUNsQyxXQUFPQSxVQUFVRSxRQUFWLENBQW1CRCxTQUFuQixDQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUlELFVBQVVHLHVCQUFkLEVBQXVDO0FBQzVDLFdBQU8sQ0FBQyxFQUFFSCxVQUFVRyx1QkFBVixDQUFrQ0YsU0FBbEMsSUFBK0MsRUFBakQsQ0FBUjtBQUNELEdBRk0sTUFFQTtBQUNMLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0csWUFBVCxDQUFzQi9nRixJQUF0QixFQUE0QjtBQUMxQixTQUNFQSxRQUNBQSxLQUFLd3dDLGFBREwsSUFFQWt3QyxhQUFhMWdGLEtBQUt3d0MsYUFBTCxDQUFtQjBnQyxlQUFoQyxFQUFpRGx4RSxJQUFqRCxDQUhGO0FBS0Q7O0FBRUQsU0FBU2doRixvQkFBVCxHQUFnQztBQUM5QixNQUFJbkYsTUFBTXp0RSxNQUFWO0FBQ0EsTUFBSXdZLFVBQVUsaUNBQWQ7QUFDQSxTQUFPQSxtQkFBbUJpMUQsSUFBSW9GLGlCQUE5QixFQUFpRDtBQUMvQztBQUNBO0FBQ0EsUUFBSTtBQUNGcEYsWUFBTWoxRCxRQUFRczZELGVBQVIsQ0FBd0JwRixXQUE5QjtBQUNELEtBRkQsQ0FFRSxPQUFPM2lGLENBQVAsRUFBVTtBQUNWLGFBQU95dEIsT0FBUDtBQUNEO0FBQ0RBLGNBQVUsZ0NBQWlCaTFELElBQUl4dEUsUUFBckIsQ0FBVjtBQUNEO0FBQ0QsU0FBT3VZLE9BQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BOzs7OztBQUtPLFNBQVN5NUQsd0JBQVQsQ0FBa0NyOEMsSUFBbEMsRUFBd0M7QUFDN0MsTUFBTUMsV0FBV0QsUUFBUUEsS0FBS0MsUUFBYixJQUF5QkQsS0FBS0MsUUFBTCxDQUFjbHBCLFdBQWQsRUFBMUM7QUFDQSxTQUNFa3BCLGFBQ0VBLGFBQWEsT0FBYixLQUNDRCxLQUFLM21DLElBQUwsS0FBYyxNQUFkLElBQ0MybUMsS0FBSzNtQyxJQUFMLEtBQWMsUUFEZixJQUVDMm1DLEtBQUszbUMsSUFBTCxLQUFjLEtBRmYsSUFHQzJtQyxLQUFLM21DLElBQUwsS0FBYyxLQUhmLElBSUMybUMsS0FBSzNtQyxJQUFMLEtBQWMsVUFMaEIsQ0FBRCxJQU1DNG1DLGFBQWEsVUFOZCxJQU9DRCxLQUFLdTVDLGVBQUwsS0FBeUIsTUFSM0IsQ0FERjtBQVdEOztBQUVNLFNBQVMrQyx1QkFBVCxHQUFtQztBQUN4QyxNQUFNYSxjQUFjSCxzQkFBcEI7QUFDQSxTQUFPO0FBQ0xHLGlCQUFhQSxXQURSO0FBRUxDLG9CQUFnQmYseUJBQXlCYyxXQUF6QixJQUNaeEUsYUFBYXdFLFdBQWIsQ0FEWSxHQUVaO0FBSkMsR0FBUDtBQU1EOztBQUVEOzs7OztBQUtPLFNBQVNaLGdCQUFULENBQTBCYyx5QkFBMUIsRUFBcUQ7QUFDMUQsTUFBTUMsaUJBQWlCTixzQkFBdkI7QUFDQSxNQUFNTyxtQkFBbUJGLDBCQUEwQkYsV0FBbkQ7QUFDQSxNQUFNSyxzQkFBc0JILDBCQUEwQkQsY0FBdEQ7QUFDQSxNQUFJRSxtQkFBbUJDLGdCQUFuQixJQUF1Q1IsYUFBYVEsZ0JBQWIsQ0FBM0MsRUFBMkU7QUFDekUsUUFDRUMsd0JBQXdCLElBQXhCLElBQ0FuQix5QkFBeUJrQixnQkFBekIsQ0FGRixFQUdFO0FBQ0FmLG1CQUFhZSxnQkFBYixFQUErQkMsbUJBQS9CO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFNdHVDLFlBQVksRUFBbEI7QUFDQSxRQUFJSSxXQUFXaXVDLGdCQUFmO0FBQ0EsV0FBUWp1QyxXQUFXQSxTQUFTdmxDLFVBQTVCLEVBQXlDO0FBQ3ZDLFVBQUl1bEMsU0FBU25GLFFBQVQsS0FBc0J2aEMsMEJBQTFCLEVBQXdDO0FBQ3RDc21DLGtCQUFVbHNDLElBQVYsQ0FBZTtBQUNiNGYsbUJBQVMwc0IsUUFESTtBQUVibXVDLGdCQUFNbnVDLFNBQVNvdUMsVUFGRjtBQUdibE8sZUFBS2xnQyxTQUFTcXVDO0FBSEQsU0FBZjtBQUtEO0FBQ0Y7O0FBRUQsUUFBSSxPQUFPSixpQkFBaUJLLEtBQXhCLEtBQWtDLFVBQXRDLEVBQWtEO0FBQ2hETCx1QkFBaUJLLEtBQWpCO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJcm9FLElBQUksQ0FBYixFQUFnQkEsSUFBSTI1QixVQUFVdDVDLE1BQTlCLEVBQXNDMmYsR0FBdEMsRUFBMkM7QUFDekMsVUFBTXhaLE9BQU9tekMsVUFBVTM1QixDQUFWLENBQWI7QUFDQXhaLFdBQUs2bUIsT0FBTCxDQUFhODZELFVBQWIsR0FBMEIzaEYsS0FBSzBoRixJQUEvQjtBQUNBMWhGLFdBQUs2bUIsT0FBTCxDQUFhKzZELFNBQWIsR0FBeUI1aEYsS0FBS3l6RSxHQUE5QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O0FBTU8sU0FBU21KLFlBQVQsQ0FBc0JrRixLQUF0QixFQUE2QjtBQUNsQyxNQUFJL0Usa0JBQUo7O0FBRUEsTUFBSSxvQkFBb0IrRSxLQUF4QixFQUErQjtBQUM3QjtBQUNBL0UsZ0JBQVk7QUFDVmp0QixhQUFPZ3lCLE1BQU1qRixjQURIO0FBRVZycEIsV0FBS3N1QixNQUFNaEY7QUFGRCxLQUFaO0FBSUQsR0FORCxNQU1PO0FBQ0w7QUFDQUMsZ0JBQVksbUNBQVcrRSxLQUFYLENBQVo7QUFDRDs7QUFFRCxTQUFPL0UsYUFBYSxFQUFDanRCLE9BQU8sQ0FBUixFQUFXMEQsS0FBSyxDQUFoQixFQUFwQjtBQUNEOztBQUVEOzs7Ozs7QUFNTyxTQUFTaXRCLFlBQVQsQ0FBc0JxQixLQUF0QixFQUE2QkMsT0FBN0IsRUFBc0M7QUFBQSxNQUN0Q2p5QixLQURzQyxHQUN4Qml5QixPQUR3QixDQUN0Q2p5QixLQURzQztBQUFBLE1BQy9CMEQsR0FEK0IsR0FDeEJ1dUIsT0FEd0IsQ0FDL0J2dUIsR0FEK0I7O0FBRTNDLE1BQUlBLFFBQVEzNkQsU0FBWixFQUF1QjtBQUNyQjI2RCxVQUFNMUQsS0FBTjtBQUNEOztBQUVELE1BQUksb0JBQW9CZ3lCLEtBQXhCLEVBQStCO0FBQzdCQSxVQUFNakYsY0FBTixHQUF1Qi9zQixLQUF2QjtBQUNBZ3lCLFVBQU1oRixZQUFOLEdBQXFCcnZFLEtBQUtnZ0QsR0FBTCxDQUFTK0YsR0FBVCxFQUFjc3VCLE1BQU0va0UsS0FBTixDQUFZbGpCLE1BQTFCLENBQXJCO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsdUNBQVdpb0YsS0FBWCxFQUFrQkMsT0FBbEI7QUFDRDtBQUNGLEM7Ozs7Ozs7Ozs7OztRQ3BLZUMsVSxHQUFBQSxVO1FBNkNBQywwQixHQUFBQSwwQjtRQTZGQUMsVSxHQUFBQSxVOztBQWpKaEI7Ozs7QUFDQTs7OztBQUVBOzs7O0FBVkE7Ozs7Ozs7QUFjTyxTQUFTRixVQUFULENBQW9CcEIsU0FBcEIsRUFBK0I7QUFBQSxNQUM3Qm53QyxhQUQ2QixHQUNabXdDLFNBRFksQ0FDN0Jud0MsYUFENkI7O0FBRXBDLE1BQU1xckMsTUFBT3JyQyxpQkFBaUJBLGNBQWNzckMsV0FBaEMsSUFBZ0QxdEUsTUFBNUQ7QUFDQSxNQUFNMHVFLFlBQVlqQixJQUFJYyxZQUFKLElBQW9CZCxJQUFJYyxZQUFKLEVBQXRDOztBQUVBLE1BQUksQ0FBQ0csU0FBRCxJQUFjQSxVQUFVb0YsVUFBVixLQUF5QixDQUEzQyxFQUE4QztBQUM1QyxXQUFPLElBQVA7QUFDRDs7QUFQbUMsTUFTN0JuRixVQVQ2QixHQVN1QkQsU0FUdkIsQ0FTN0JDLFVBVDZCO0FBQUEsTUFTakJDLFlBVGlCLEdBU3VCRixTQVR2QixDQVNqQkUsWUFUaUI7QUFBQSxNQVNIQyxTQVRHLEdBU3VCSCxTQVR2QixDQVNIRyxTQVRHO0FBQUEsTUFTUUMsV0FUUixHQVN1QkosU0FUdkIsQ0FTUUksV0FUUjs7QUFXcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBSTtBQUNGO0FBQ0FILGVBQVc1dUMsUUFBWDtBQUNBOHVDLGNBQVU5dUMsUUFBVjtBQUNBO0FBQ0QsR0FMRCxDQUtFLE9BQU9oMUMsQ0FBUCxFQUFVO0FBQ1YsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBTzZvRiwyQkFDTHJCLFNBREssRUFFTDVELFVBRkssRUFHTEMsWUFISyxFQUlMQyxTQUpLLEVBS0xDLFdBTEssQ0FBUDtBQU9EOztBQUVEOzs7Ozs7Ozs7QUFTTyxTQUFTOEUsMEJBQVQsQ0FDTHJCLFNBREssRUFFTDVELFVBRkssRUFHTEMsWUFISyxFQUlMQyxTQUpLLEVBS0xDLFdBTEssRUFNTDtBQUNBLE1BQUl0akYsU0FBUyxDQUFiO0FBQ0EsTUFBSWkyRCxRQUFRLENBQUMsQ0FBYjtBQUNBLE1BQUkwRCxNQUFNLENBQUMsQ0FBWDtBQUNBLE1BQUk0dUIsb0JBQW9CLENBQXhCO0FBQ0EsTUFBSUMsbUJBQW1CLENBQXZCO0FBQ0EsTUFBSXBpRixPQUFPMmdGLFNBQVg7QUFDQSxNQUFJNXlFLGFBQWEsSUFBakI7O0FBRUFzMEUsU0FBTyxPQUFPLElBQVAsRUFBYTtBQUNsQixRQUFJaHlFLE9BQU8sSUFBWDs7QUFFQSxXQUFPLElBQVAsRUFBYTtBQUNYLFVBQ0VyUSxTQUFTKzhFLFVBQVQsS0FDQ0MsaUJBQWlCLENBQWpCLElBQXNCaDlFLEtBQUttdUMsUUFBTCxLQUFrQnRoQyx1QkFEekMsQ0FERixFQUdFO0FBQ0FnakQsZ0JBQVFqMkQsU0FBU29qRixZQUFqQjtBQUNEO0FBQ0QsVUFDRWg5RSxTQUFTaTlFLFNBQVQsS0FDQ0MsZ0JBQWdCLENBQWhCLElBQXFCbDlFLEtBQUttdUMsUUFBTCxLQUFrQnRoQyx1QkFEeEMsQ0FERixFQUdFO0FBQ0EwbUQsY0FBTTM1RCxTQUFTc2pGLFdBQWY7QUFDRDs7QUFFRCxVQUFJbDlFLEtBQUttdUMsUUFBTCxLQUFrQnRoQyx1QkFBdEIsRUFBaUM7QUFDL0JqVCxrQkFBVW9HLEtBQUtpeEUsU0FBTCxDQUFlcjNFLE1BQXpCO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDeVcsT0FBT3JRLEtBQUtteEUsVUFBYixNQUE2QixJQUFqQyxFQUF1QztBQUNyQztBQUNEO0FBQ0Q7QUFDQXBqRSxtQkFBYS9OLElBQWI7QUFDQUEsYUFBT3FRLElBQVA7QUFDRDs7QUFFRCxXQUFPLElBQVAsRUFBYTtBQUNYLFVBQUlyUSxTQUFTMmdGLFNBQWIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNMEIsS0FBTjtBQUNEO0FBQ0QsVUFBSXQwRSxlQUFlZ3ZFLFVBQWYsSUFBNkIsRUFBRW9GLGlCQUFGLEtBQXdCbkYsWUFBekQsRUFBdUU7QUFDckVudEIsZ0JBQVFqMkQsTUFBUjtBQUNEO0FBQ0QsVUFBSW1VLGVBQWVrdkUsU0FBZixJQUE0QixFQUFFbUYsZ0JBQUYsS0FBdUJsRixXQUF2RCxFQUFvRTtBQUNsRTNwQixjQUFNMzVELE1BQU47QUFDRDtBQUNELFVBQUksQ0FBQ3lXLE9BQU9yUSxLQUFLc2lGLFdBQWIsTUFBOEIsSUFBbEMsRUFBd0M7QUFDdEM7QUFDRDtBQUNEdGlGLGFBQU8rTixVQUFQO0FBQ0FBLG1CQUFhL04sS0FBSytOLFVBQWxCO0FBQ0Q7O0FBRUQ7QUFDQS9OLFdBQU9xUSxJQUFQO0FBQ0Q7O0FBRUQsTUFBSXcvQyxVQUFVLENBQUMsQ0FBWCxJQUFnQjBELFFBQVEsQ0FBQyxDQUE3QixFQUFnQztBQUM5QjtBQUNBO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBTztBQUNMMUQsV0FBT0EsS0FERjtBQUVMMEQsU0FBS0E7QUFGQSxHQUFQO0FBSUQ7O0FBRUQ7Ozs7Ozs7Ozs7OztBQVlPLFNBQVMwdUIsVUFBVCxDQUFvQmppRixJQUFwQixFQUEwQjhoRixPQUExQixFQUFtQztBQUN4QyxNQUFNOXNDLE1BQU1oMUMsS0FBS3d3QyxhQUFMLElBQXNCbmlDLFFBQWxDO0FBQ0EsTUFBTXd0RSxNQUFPN21DLE9BQU9BLElBQUk4bUMsV0FBWixJQUE0QjF0RSxNQUF4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFJLENBQUN5dEUsSUFBSWMsWUFBVCxFQUF1QjtBQUNyQjtBQUNEOztBQUVELE1BQU1HLFlBQVlqQixJQUFJYyxZQUFKLEVBQWxCO0FBQ0EsTUFBTS9pRixTQUFTb0csS0FBSzZqRCxXQUFMLENBQWlCanFELE1BQWhDO0FBQ0EsTUFBSWkyRCxRQUFRcmlELEtBQUtnZ0QsR0FBTCxDQUFTczBCLFFBQVFqeUIsS0FBakIsRUFBd0JqMkQsTUFBeEIsQ0FBWjtBQUNBLE1BQUkyNUQsTUFBTXV1QixRQUFRdnVCLEdBQVIsS0FBZ0IzNkQsU0FBaEIsR0FBNEJpM0QsS0FBNUIsR0FBb0NyaUQsS0FBS2dnRCxHQUFMLENBQVNzMEIsUUFBUXZ1QixHQUFqQixFQUFzQjM1RCxNQUF0QixDQUE5Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBSSxDQUFDa2pGLFVBQVVyM0UsTUFBWCxJQUFxQm9xRCxRQUFRMEQsR0FBakMsRUFBc0M7QUFDcEMsUUFBSWd2QixPQUFPaHZCLEdBQVg7QUFDQUEsVUFBTTFELEtBQU47QUFDQUEsWUFBUTB5QixJQUFSO0FBQ0Q7O0FBRUQsTUFBTUMsY0FBYyx5Q0FBMEJ4aUYsSUFBMUIsRUFBZ0M2dkQsS0FBaEMsQ0FBcEI7QUFDQSxNQUFNNHlCLFlBQVkseUNBQTBCemlGLElBQTFCLEVBQWdDdXpELEdBQWhDLENBQWxCOztBQUVBLE1BQUlpdkIsZUFBZUMsU0FBbkIsRUFBOEI7QUFDNUIsUUFDRTNGLFVBQVVvRixVQUFWLEtBQXlCLENBQXpCLElBQ0FwRixVQUFVQyxVQUFWLEtBQXlCeUYsWUFBWXhpRixJQURyQyxJQUVBODhFLFVBQVVFLFlBQVYsS0FBMkJ3RixZQUFZaHJCLE1BRnZDLElBR0FzbEIsVUFBVUcsU0FBVixLQUF3QndGLFVBQVV6aUYsSUFIbEMsSUFJQTg4RSxVQUFVSSxXQUFWLEtBQTBCdUYsVUFBVWpyQixNQUx0QyxFQU1FO0FBQ0E7QUFDRDtBQUNELFFBQU05cEIsUUFBUXNILElBQUkwdEMsV0FBSixFQUFkO0FBQ0FoMUMsVUFBTWkxQyxRQUFOLENBQWVILFlBQVl4aUYsSUFBM0IsRUFBaUN3aUYsWUFBWWhyQixNQUE3QztBQUNBc2xCLGNBQVU4RixlQUFWOztBQUVBLFFBQUkveUIsUUFBUTBELEdBQVosRUFBaUI7QUFDZnVwQixnQkFBVStGLFFBQVYsQ0FBbUJuMUMsS0FBbkI7QUFDQW92QyxnQkFBVXIzRSxNQUFWLENBQWlCZzlFLFVBQVV6aUYsSUFBM0IsRUFBaUN5aUYsVUFBVWpyQixNQUEzQztBQUNELEtBSEQsTUFHTztBQUNMOXBCLFlBQU1vMUMsTUFBTixDQUFhTCxVQUFVemlGLElBQXZCLEVBQTZCeWlGLFVBQVVqckIsTUFBdkM7QUFDQXNsQixnQkFBVStGLFFBQVYsQ0FBbUJuMUMsS0FBbkI7QUFDRDtBQUNGO0FBQ0YsQzs7Ozs7Ozs7Ozs7OztBQ2hNRDs7QUFFQTs7Ozs7O0FBTUEsU0FBU3ExQyxXQUFULENBQXFCL2lGLElBQXJCLEVBQTJCO0FBQ3pCLFNBQU9BLFFBQVFBLEtBQUtteEUsVUFBcEIsRUFBZ0M7QUFDOUJueEUsV0FBT0EsS0FBS214RSxVQUFaO0FBQ0Q7QUFDRCxTQUFPbnhFLElBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQXhCQTs7Ozs7Ozs7O0FBK0JBLFNBQVNnakYsY0FBVCxDQUF3QmhqRixJQUF4QixFQUE4QjtBQUM1QixTQUFPQSxJQUFQLEVBQWE7QUFDWCxRQUFJQSxLQUFLc2lGLFdBQVQsRUFBc0I7QUFDcEIsYUFBT3RpRixLQUFLc2lGLFdBQVo7QUFDRDtBQUNEdGlGLFdBQU9BLEtBQUsrTixVQUFaO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztBQU9BLFNBQVNrMUUseUJBQVQsQ0FBbUN6NEQsSUFBbkMsRUFBa0RndEMsTUFBbEQsRUFBMkU7QUFDekUsTUFBSXgzRCxPQUFPK2lGLFlBQVl2NEQsSUFBWixDQUFYO0FBQ0EsTUFBSTA0RCxZQUFZLENBQWhCO0FBQ0EsTUFBSUMsVUFBVSxDQUFkOztBQUVBLFNBQU9uakYsSUFBUCxFQUFhO0FBQ1gsUUFBSUEsS0FBS211QyxRQUFMLEtBQWtCdGhDLHVCQUF0QixFQUFpQztBQUMvQnMyRSxnQkFBVUQsWUFBWWxqRixLQUFLNmpELFdBQUwsQ0FBaUJqcUQsTUFBdkM7O0FBRUEsVUFBSXNwRixhQUFhMXJCLE1BQWIsSUFBdUIyckIsV0FBVzNyQixNQUF0QyxFQUE4QztBQUM1QyxlQUFPO0FBQ0x4M0QsZ0JBQU1BLElBREQ7QUFFTHczRCxrQkFBUUEsU0FBUzByQjtBQUZaLFNBQVA7QUFJRDs7QUFFREEsa0JBQVlDLE9BQVo7QUFDRDs7QUFFRG5qRixXQUFPK2lGLFlBQVlDLGVBQWVoakYsSUFBZixDQUFaLENBQVA7QUFDRDtBQUNGOztrQkFFY2lqRix5Qjs7Ozs7Ozs7Ozs7Ozs7O0FDNURmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHOzs7Ozs7Ozs7Ozs7OztrUUNWQTs7Ozs7Ozs7O1FBaUtnQkcsK0IsR0FBQUEsK0I7UUFpSEFDLGUsR0FBQUEsZTtRQVFBQyxlLEdBQUFBLGU7UUFnQ0FDLHFCLEdBQUFBLHFCO1FBbUJBQyw2QixHQUFBQSw2QjtRQWdEQUMsa0IsR0FBQUEsa0I7O0FBeldoQjs7QUFJQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQUNBOztBQU1BOztBQUNBOztBQUNBOztBQWlCQTs7QUFDQTs7OztBQUNBOztBQUtBOztBQUNBOzs7O0FBSUE7QUFDQTtBQWdCQSxJQUFJQyxrQ0FBSjtBQUNBLElBQUlDLHlDQUFKOztBQUVBLElBQUlqckYsSUFBSixFQUFhO0FBQ1hnckYsOEJBQTRCLEtBQTVCO0FBQ0FDLHFDQUFtQyxFQUFuQztBQUNEOztBQUVELFNBQVNDLG9CQUFULENBQ0VoVCxlQURGLEVBRVU7QUFDUixNQUFJLENBQUNBLGVBQUwsRUFBc0I7QUFDcEIsV0FBT3g2RCxxQ0FBUDtBQUNEOztBQUVELE1BQU01VyxRQUFRLDJCQUFZb3hFLGVBQVosQ0FBZDtBQUNBLE1BQU1oNUQsZ0JBQWdCLG1EQUEyQnBZLEtBQTNCLENBQXRCOztBQUVBLE1BQUlBLE1BQU1sQyxHQUFOLEtBQWMxQiw2QkFBbEIsRUFBa0M7QUFDaEMsUUFBTThhLFlBQVlsWCxNQUFNbkMsSUFBeEI7QUFDQSxRQUFJLDBDQUF3QnFaLFNBQXhCLENBQUosRUFBd0M7QUFDdEMsYUFBTyw0Q0FBb0JsWCxLQUFwQixFQUEyQmtYLFNBQTNCLEVBQXNDa0IsYUFBdEMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBT0EsYUFBUDtBQUNEOztBQUVELFNBQVNpc0Usa0JBQVQsQ0FDRTNqRixPQURGLEVBRUUwbUIsT0FGRixFQUdFM2tCLGNBSEYsRUFJRW1PLFFBSkYsRUFLRTtBQUNBLE1BQUkxWCxJQUFKLEVBQWE7QUFDWCxRQUNFdXZCLDZCQUEyQixRQUEzQixJQUNBNjdELCtCQUE2QixJQUQ3QixJQUVBLENBQUNKLHlCQUhILEVBSUU7QUFDQUEsa0NBQTRCLElBQTVCO0FBQ0EseUNBQ0UsS0FERixFQUVFLGtFQUNFLGtFQURGLEdBRUUsaUVBRkYsR0FHRSxnQ0FMSixFQU1FLGdDQUFpQkksMkJBQXlCem1GLElBQTFDLEtBQW1ELFNBTnJEO0FBUUQ7QUFDRjs7QUFFRCxNQUFNbVQsU0FBUyxvQ0FBYXZPLGNBQWIsQ0FBZjtBQUNBO0FBQ0E7QUFDQXVPLFNBQU9MLE9BQVAsR0FBaUIsRUFBQ3lXLGdCQUFELEVBQWpCOztBQUVBeFcsYUFBV0EsYUFBYXhYLFNBQWIsR0FBeUIsSUFBekIsR0FBZ0N3WCxRQUEzQztBQUNBLE1BQUlBLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsdUNBQ0UsT0FBT0EsUUFBUCxLQUFvQixVQUR0QixFQUVFLHlFQUNFLGlDQUhKLEVBSUVBLFFBSkY7QUFNQUksV0FBT0osUUFBUCxHQUFrQkEsUUFBbEI7QUFDRDs7QUFFRDtBQUNBLHVDQUFjbFEsT0FBZCxFQUF1QnNRLE1BQXZCO0FBQ0EseUNBQWF0USxPQUFiLEVBQXNCK0IsY0FBdEI7O0FBRUEsU0FBT0EsY0FBUDtBQUNEOztBQUVNLFNBQVNtaEYsK0JBQVQsQ0FDTHg4RCxPQURLLEVBRUx1b0QsU0FGSyxFQUdMeUIsZUFISyxFQUlMM3VFLGNBSkssRUFLTG1PLFFBTEssRUFNTDtBQUNBO0FBQ0EsTUFBTWxRLFVBQVVpdkUsVUFBVWp2RSxPQUExQjs7QUFFQSxNQUFJeEgsSUFBSixFQUFhO0FBQ1gsUUFBSW96QixvQ0FBMEJDLFNBQTlCLEVBQXlDO0FBQ3ZDLFVBQUk3ckIsUUFBUXVRLFNBQVIsS0FBc0IsSUFBMUIsRUFBZ0M7QUFDOUJxYiw0Q0FBMEJDLFNBQTFCLENBQW9DZzRELGdCQUFwQyxDQUFxRDVVLFNBQXJEO0FBQ0QsT0FGRCxNQUVPLElBQUl2b0QsWUFBWSxJQUFoQixFQUFzQjtBQUMzQmtGLDRDQUEwQkMsU0FBMUIsQ0FBb0NpNEQsa0JBQXBDLENBQXVEN1UsU0FBdkQ7QUFDRCxPQUZNLE1BRUE7QUFDTHJqRCw0Q0FBMEJDLFNBQTFCLENBQW9DazRELGlCQUFwQyxDQUFzRDlVLFNBQXREO0FBQ0Q7QUFDRjtBQUNGOztBQUVELE1BQU1wOUQsVUFBVTZ4RSxxQkFBcUJoVCxlQUFyQixDQUFoQjtBQUNBLE1BQUl6QixVQUFVcDlELE9BQVYsS0FBc0IsSUFBMUIsRUFBZ0M7QUFDOUJvOUQsY0FBVXA5RCxPQUFWLEdBQW9CQSxPQUFwQjtBQUNELEdBRkQsTUFFTztBQUNMbzlELGNBQVUvMEMsY0FBVixHQUEyQnJvQixPQUEzQjtBQUNEOztBQUVELFNBQU84eEUsbUJBQW1CM2pGLE9BQW5CLEVBQTRCMG1CLE9BQTVCLEVBQXFDM2tCLGNBQXJDLEVBQXFEbU8sUUFBckQsQ0FBUDtBQUNEOztBQUVELFNBQVM4ekUsZ0JBQVQsQ0FBMEIxZ0IsU0FBMUIsRUFBb0U7QUFDbEUsTUFBTWhrRSxRQUFRLDJCQUFZZ2tFLFNBQVosQ0FBZDtBQUNBLE1BQUloa0UsVUFBVTVHLFNBQWQsRUFBeUI7QUFDdkIsUUFBSSxPQUFPNHFFLFVBQVV2bEUsTUFBakIsS0FBNEIsVUFBaEMsRUFBNEM7QUFDMUMsK0JBQVUsS0FBVixFQUFpQixnREFBakI7QUFDRCxLQUZELE1BRU87QUFDTCwrQkFDRSxLQURGLEVBRUUsdURBRkYsRUFHRThHLE9BQU80aEIsSUFBUCxDQUFZNjhDLFNBQVosQ0FIRjtBQUtEO0FBQ0Y7QUFDRCxNQUFNMmdCLFlBQVksc0NBQXFCM2tGLEtBQXJCLENBQWxCO0FBQ0EsTUFBSTJrRixjQUFjLElBQWxCLEVBQXdCO0FBQ3RCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsU0FBT0EsVUFBVWwyRSxTQUFqQjtBQUNEOztBQUVELFNBQVNtMkUsMkJBQVQsQ0FDRTVnQixTQURGLEVBRUV0QyxVQUZGLEVBR3lCO0FBQ3ZCLE1BQUl4b0UsSUFBSixFQUFhO0FBQ1gsUUFBTThHLFFBQVEsMkJBQVlna0UsU0FBWixDQUFkO0FBQ0EsUUFBSWhrRSxVQUFVNUcsU0FBZCxFQUF5QjtBQUN2QixVQUFJLE9BQU80cUUsVUFBVXZsRSxNQUFqQixLQUE0QixVQUFoQyxFQUE0QztBQUMxQyxpQ0FBVSxLQUFWLEVBQWlCLGdEQUFqQjtBQUNELE9BRkQsTUFFTztBQUNMLGlDQUNFLEtBREYsRUFFRSx1REFGRixFQUdFOEcsT0FBTzRoQixJQUFQLENBQVk2OEMsU0FBWixDQUhGO0FBS0Q7QUFDRjtBQUNELFFBQU0yZ0IsWUFBWSxzQ0FBcUIza0YsS0FBckIsQ0FBbEI7QUFDQSxRQUFJMmtGLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEIsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxRQUFJQSxVQUFVaHpFLElBQVYsR0FBaUI5SiwyQkFBckIsRUFBaUM7QUFDL0IsVUFBTXlRLGdCQUFnQixnQ0FBaUJ0WSxNQUFNbkMsSUFBdkIsS0FBZ0MsV0FBdEQ7QUFDQSxVQUFJLENBQUNzbUYsaUNBQWlDN3JFLGFBQWpDLENBQUwsRUFBc0Q7QUFDcEQ2ckUseUNBQWlDN3JFLGFBQWpDLElBQWtELElBQWxEO0FBQ0EsWUFBSXRZLE1BQU0yUixJQUFOLEdBQWE5SiwyQkFBakIsRUFBNkI7QUFDM0IsNkNBQ0UsS0FERixFQUVFLHFDQUNFLDhEQURGLEdBRUUsbUVBRkYsR0FHRSxNQUhGLEdBSUUsOENBSkYsR0FLRSw2Q0FQSixFQVFFNjVELFVBUkYsRUFTRUEsVUFURixFQVVFcHBELGFBVkYsRUFXRSxvREFBNEJxc0UsU0FBNUIsQ0FYRjtBQWFELFNBZEQsTUFjTztBQUNMLDZDQUNFLEtBREYsRUFFRSxxQ0FDRSxxRUFERixHQUVFLG1FQUZGLEdBR0UsTUFIRixHQUlFLDhDQUpGLEdBS0UsNkNBUEosRUFRRWpqQixVQVJGLEVBU0VBLFVBVEYsRUFVRXBwRCxhQVZGLEVBV0Usb0RBQTRCcXNFLFNBQTVCLENBWEY7QUFhRDtBQUNGO0FBQ0Y7QUFDRCxXQUFPQSxVQUFVbDJFLFNBQWpCO0FBQ0Q7QUFDRCxTQUFPaTJFLGlCQUFpQjFnQixTQUFqQixDQUFQO0FBQ0Q7O0FBRU0sU0FBUzZmLGVBQVQsQ0FDTGo4RCxhQURLLEVBRUxqQixZQUZLLEVBR0xvVSxPQUhLLEVBSU87QUFDWixTQUFPLHFDQUFnQm5ULGFBQWhCLEVBQStCakIsWUFBL0IsRUFBNkNvVSxPQUE3QyxDQUFQO0FBQ0Q7O0FBRU0sU0FBUytvRCxlQUFULENBQ0wxOEQsT0FESyxFQUVMdW9ELFNBRkssRUFHTHlCLGVBSEssRUFJTHhnRSxRQUpLLEVBS1c7QUFDaEIsTUFBTWxRLFVBQVVpdkUsVUFBVWp2RSxPQUExQjtBQUNBLE1BQU1vQyxjQUFjLDhDQUFwQjtBQUNBLE1BQU1MLGlCQUFpQixvREFBMEJLLFdBQTFCLEVBQXVDcEMsT0FBdkMsQ0FBdkI7QUFDQSxTQUFPa2pGLGdDQUNMeDhELE9BREssRUFFTHVvRCxTQUZLLEVBR0x5QixlQUhLLEVBSUwzdUUsY0FKSyxFQUtMbU8sUUFMSyxDQUFQO0FBT0Q7O1FBR0N1aUIsUyxHQUFBQSw4QjtRQUNBNUgsVyxHQUFBQSxnQztRQUNBOEUsNEIsR0FBQUEsaUQ7UUFDQW1FLGMsR0FBQUEsbUM7UUFDQUUsZ0IsR0FBQUEscUM7UUFDQUssZSxHQUFBQSxvQztRQUNBbEQsVyxHQUFBQSxnQztRQUNBK0Msa0IsR0FBQUEsdUM7UUFDQUMsdUIsR0FBQUEsNEM7UUFDQUMsZSxHQUFBQSxvQztRQUNBSCxTLEdBQUFBLDhCO0FBR0ssU0FBU292RCxxQkFBVCxDQUNMcFUsU0FESyxFQUU4QztBQUNuRCxNQUFNa1YsaUJBQWlCbFYsVUFBVWp2RSxPQUFqQztBQUNBLE1BQUksQ0FBQ21rRixlQUFlbHdFLEtBQXBCLEVBQTJCO0FBQ3pCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsVUFBUWt3RSxlQUFlbHdFLEtBQWYsQ0FBcUI3VyxHQUE3QjtBQUNFLFNBQUt0Qiw0QkFBTDtBQUNFLGFBQU8sNkNBQWtCcW9GLGVBQWVsd0UsS0FBZixDQUFxQmxHLFNBQXZDLENBQVA7QUFDRjtBQUNFLGFBQU9vMkUsZUFBZWx3RSxLQUFmLENBQXFCbEcsU0FBNUI7QUFKSjtBQU1EOztRQUVPaTJFLGdCLEdBQUFBLGdCO1FBRUFFLDJCLEdBQUFBLDJCO0FBRUQsU0FBU1osNkJBQVQsQ0FDTGhrRixLQURLLEVBRWtCO0FBQ3ZCLE1BQU0ya0YsWUFBWSxtREFBa0Mza0YsS0FBbEMsQ0FBbEI7QUFDQSxNQUFJMmtGLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEIsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFPQSxVQUFVbDJFLFNBQWpCO0FBQ0Q7O0FBRUQsSUFBSXEyRSxnQkFBZ0IsSUFBcEI7O0FBRUEsSUFBSTVyRixJQUFKLEVBQWE7QUFDWCxNQUFNNnJGLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FDdEJDLEdBRHNCLEVBRXRCbDRDLElBRnNCLEVBR3RCbTRDLEdBSHNCLEVBSXRCM25FLEtBSnNCLEVBS25CO0FBQ0gsUUFBSTJuRSxPQUFPbjRDLEtBQUsxeUMsTUFBaEIsRUFBd0I7QUFDdEIsYUFBT2tqQixLQUFQO0FBQ0Q7QUFDRCxRQUFNMUYsTUFBTWsxQixLQUFLbTRDLEdBQUwsQ0FBWjtBQUNBLFFBQU1DLFVBQVV2cEUsTUFBTTJtQixPQUFOLENBQWMwaUQsR0FBZCxJQUFxQkEsSUFBSTcyRSxLQUFKLEVBQXJCLGdCQUF1QzYyRSxHQUF2QyxDQUFoQjtBQUNBO0FBQ0FFLFlBQVF0dEUsR0FBUixJQUFlbXRFLGdCQUFnQkMsSUFBSXB0RSxHQUFKLENBQWhCLEVBQTBCazFCLElBQTFCLEVBQWdDbTRDLE1BQU0sQ0FBdEMsRUFBeUMzbkUsS0FBekMsQ0FBZjtBQUNBLFdBQU80bkUsT0FBUDtBQUNELEdBZEQ7O0FBZ0JBLE1BQU1DLGNBQWMsU0FBZEEsV0FBYyxDQUNsQkgsR0FEa0IsRUFFbEJsNEMsSUFGa0IsRUFHbEJ4dkIsS0FIa0IsRUFJTTtBQUN4QixXQUFPeW5FLGdCQUFnQkMsR0FBaEIsRUFBcUJsNEMsSUFBckIsRUFBMkIsQ0FBM0IsRUFBOEJ4dkIsS0FBOUIsQ0FBUDtBQUNELEdBTkQ7O0FBUUE7QUFDQXduRSxrQkFBZ0IsdUJBQUM5a0YsS0FBRCxFQUFlOHNDLElBQWYsRUFBNkN4dkIsS0FBN0MsRUFBNEQ7QUFDMUU7QUFDQXRkLFVBQU00bEIsWUFBTixHQUFxQnUvRCxZQUFZbmxGLE1BQU1nbUIsYUFBbEIsRUFBaUM4bUIsSUFBakMsRUFBdUN4dkIsS0FBdkMsQ0FBckI7QUFDQSxRQUFJdGQsTUFBTWlSLFNBQVYsRUFBcUI7QUFDbkJqUixZQUFNaVIsU0FBTixDQUFnQjJVLFlBQWhCLEdBQStCNWxCLE1BQU00bEIsWUFBckM7QUFDRDtBQUNELDJDQUFhNWxCLEtBQWIsRUFBb0JvQyw4QkFBcEI7QUFDRCxHQVBEO0FBUUQ7O0FBRU0sU0FBUzZoRixrQkFBVCxDQUE0Qm1CLGNBQTVCLEVBQXFFO0FBQUEsTUFDbkV2Uix1QkFEbUUsR0FDeEN1UixjQUR3QyxDQUNuRXZSLHVCQURtRTtBQUFBLE1BRW5FN3JELHNCQUZtRSxHQUV6QzlzQiw4QkFGeUMsQ0FFbkU4c0Isc0JBRm1FOzs7QUFJMUUsU0FBTywwREFDRm85RCxjQURFO0FBRUxOLGdDQUZLO0FBR0xPLDBCQUFzQnI5RCxzQkFIakI7QUFJTHM5RCwyQkFKSyxtQ0FJbUJ0bEYsS0FKbkIsRUFJaUU7QUFDcEUsVUFBTTJrRixZQUFZLHNDQUFxQjNrRixLQUFyQixDQUFsQjtBQUNBLFVBQUkya0YsY0FBYyxJQUFsQixFQUF3QjtBQUN0QixlQUFPLElBQVA7QUFDRDtBQUNELGFBQU9BLFVBQVVsMkUsU0FBakI7QUFDRCxLQVZJO0FBV0xvbEUsMkJBWEs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsZ0JBV21CeHNFLFFBWG5CLEVBV29FO0FBQ3ZFLFVBQUksQ0FBQ3dzRSx1QkFBTCxFQUE4QjtBQUM1QjtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBT0Esd0JBQXdCeHNFLFFBQXhCLENBQVA7QUFDRCxLQWpCSTtBQUFBLEtBQVA7QUFtQkQsQzs7Ozs7Ozs7Ozs7O1FDelNlaytFLGUsR0FBQUEsZTs7QUE1RmhCOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyR0E7Ozs7Ozs7OztBQTJHTyxTQUFTQSxlQUFULENBQ0wzOUQsYUFESyxFQUVMakIsWUFGSyxFQUdMb1UsT0FISyxFQUlNO0FBQ1g7QUFDQTtBQUNBLE1BQU15cUQscUJBQXFCLHFDQUFvQjcrRCxZQUFwQixDQUEzQjs7QUFFQSxNQUFJcUUsYUFBSjtBQUNBLE1BQUludkIseUNBQUosRUFBNEI7QUFDMUJtdkIsV0FBUTtBQUNOdHFCLGVBQVM4a0Ysa0JBREg7QUFFTjU5RCxxQkFBZUEsYUFGVDtBQUdOQyx1QkFBaUIsSUFIWDs7QUFLTnF1QiwyQkFBcUJoMEMsZ0NBTGY7QUFNTmkwQyx5QkFBbUJqMEMsZ0NBTmI7QUFPTm8wQyw2QkFBdUJwMEMsZ0NBUGpCO0FBUU5xMEMsMkJBQXFCcjBDLGdDQVJmO0FBU05zMEMsd0JBQWtCdDBDLGdDQVRaOztBQVdOaXZCLGlCQUFXLElBWEw7O0FBYU5oRyxnQkFBVSxLQWJKOztBQWVOVyxtQ0FBNkI1cEIsZ0NBZnZCO0FBZ0JOc1Esb0JBQWMsSUFoQlI7QUFpQk55Z0IscUJBQWVtQiwrQkFqQlQ7QUFrQk43aEIsZUFBUyxJQWxCSDtBQW1CTnFvQixzQkFBZ0IsSUFuQlY7QUFvQk5HLHNCQXBCTTtBQXFCTmxNLGtDQUE0QjNzQixnQ0FyQnRCO0FBc0JOTyxzQkFBZ0JQLGdDQXRCVjtBQXVCTm15QixrQkFBWSxJQXZCTjtBQXdCTmQseUJBQW1CLElBeEJiOztBQTBCTnJHLDJCQUFxQixvQ0ExQmY7QUEyQk5mLDRCQUFzQixJQUFJN0osR0FBSixFQTNCaEI7QUE0Qk5nTCw2QkFBdUIsSUFBSTlILEdBQUo7QUE1QmpCLEtBQVI7QUE4QkQsR0EvQkQsTUErQk87QUFDTHdGLFdBQVE7QUFDTnRxQixlQUFTOGtGLGtCQURIO0FBRU41OUQscUJBQWVBLGFBRlQ7QUFHTkMsdUJBQWlCLElBSFg7O0FBS05zSixpQkFBVyxJQUxMOztBQU9OK2tCLDJCQUFxQmgwQyxnQ0FQZjtBQVFOaTBDLHlCQUFtQmowQyxnQ0FSYjtBQVNObzBDLDZCQUF1QnAwQyxnQ0FUakI7QUFVTnEwQywyQkFBcUJyMEMsZ0NBVmY7QUFXTnMwQyx3QkFBa0J0MEMsZ0NBWFo7O0FBYU5pcEIsZ0JBQVUsS0FiSjs7QUFlTlcsbUNBQTZCNXBCLGdDQWZ2QjtBQWdCTnNRLG9CQUFjLElBaEJSO0FBaUJOeWdCLHFCQUFlbUIsK0JBakJUO0FBa0JON2hCLGVBQVMsSUFsQkg7QUFtQk5xb0Isc0JBQWdCLElBbkJWO0FBb0JORyxzQkFwQk07QUFxQk5sTSxrQ0FBNEIzc0IsZ0NBckJ0QjtBQXNCTk8sc0JBQWdCUCxnQ0F0QlY7QUF1Qk5teUIsa0JBQVksSUF2Qk47QUF3Qk5kLHlCQUFtQjtBQXhCYixLQUFSO0FBMEJEOztBQUVEaXlELHFCQUFtQi8yRSxTQUFuQixHQUErQnVjLElBQS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0EsSUFBVDtBQUNELEM7Ozs7Ozs7Ozs7Ozs7OzhRQ3hMRDs7Ozs7Ozs7O1FBaTBDZ0J5NkQsZ0IsR0FBQUEsZ0I7O0FBbnpDaEI7Ozs7QUFDQTs7QUFDQTs7QUFNQTs7QUFPQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFPQTs7QUFDQTs7QUFJQTs7OztBQUVBLElBQUlsakIseUJBQUo7QUFDQSxJQUFJbWpCLCtCQUFKO0FBQ0EsSUFBSUMsMENBQUo7QUFDQSxJQUFJblosOEJBQUo7QUFDQSxJQUFJb1osb0NBQUo7QUFDQSxJQUFJQyxvQkFBb0IsMkJBQUNseEUsS0FBRCxFQUFrQixDQUFFLENBQTVDOztBQUVBLElBQUl6YixJQUFKLEVBQWE7QUFDWHFwRSxxQkFBbUIsS0FBbkI7QUFDQW1qQiwyQkFBeUIsS0FBekI7QUFDQUMsc0NBQW9DLEVBQXBDOztBQUVBOzs7OztBQUtBblosMEJBQXdCLEVBQXhCO0FBQ0FvWixnQ0FBOEIsRUFBOUI7O0FBRUFDLHNCQUFvQiwyQkFBQ2x4RSxLQUFELEVBQWtCO0FBQ3BDLFFBQUlBLFVBQVUsSUFBVixJQUFrQixRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQXZDLEVBQWlEO0FBQy9DO0FBQ0Q7QUFDRCxRQUFJLENBQUNBLE1BQU1vc0IsTUFBUCxJQUFpQnBzQixNQUFNb3NCLE1BQU4sQ0FBYTZyQyxTQUE5QixJQUEyQ2o0RCxNQUFNaUQsR0FBTixJQUFhLElBQTVELEVBQWtFO0FBQ2hFO0FBQ0Q7QUFDRCw2QkFDRSxRQUFPakQsTUFBTW9zQixNQUFiLE1BQXdCLFFBRDFCLEVBRUUsZ0VBQ0Usc0VBSEo7QUFLQXBzQixVQUFNb3NCLE1BQU4sQ0FBYTZyQyxTQUFiLEdBQXlCLElBQXpCOztBQUVBLFFBQU1DLDRCQUNKLCtDQUNBLHVEQURBLEdBRUEsbUJBRkEsR0FHQSxtREFKRjtBQUtBLFFBQUlMLHNCQUFzQksseUJBQXRCLENBQUosRUFBc0Q7QUFDcEQ7QUFDRDtBQUNETCwwQkFBc0JLLHlCQUF0QixJQUFtRCxJQUFuRDs7QUFFQSwyQkFDRSxLQURGLEVBRUUsK0NBQ0UsdURBREYsR0FFRSxtQkFKSjtBQU1ELEdBOUJEO0FBK0JEOztBQUVELElBQU12cUMsVUFBVTNtQixNQUFNMm1CLE9BQXRCOztBQUVBLFNBQVN3akQsU0FBVCxDQUNFMTNELFdBREYsRUFFRTF0QixPQUZGLEVBR0UwbUIsT0FIRixFQUlFO0FBQ0EsTUFBSTIrRCxXQUFXMytELFFBQVFyQixHQUF2QjtBQUNBLE1BQ0VnZ0UsYUFBYSxJQUFiLElBQ0EsT0FBT0EsUUFBUCxLQUFvQixVQURwQixJQUVBLFFBQU9BLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFIdEIsRUFJRTtBQUNBLFFBQUk3c0YsSUFBSixFQUFhO0FBQ1gsVUFBSWsxQixZQUFZemMsSUFBWixHQUFtQjlKLDJCQUF2QixFQUFtQztBQUNqQyxZQUFNeVEsZ0JBQWdCLGdDQUFpQjhWLFlBQVl2d0IsSUFBN0IsS0FBc0MsV0FBNUQ7QUFDQSxZQUFJLENBQUM4bkYsa0NBQWtDcnRFLGFBQWxDLENBQUwsRUFBdUQ7QUFDckQsNkNBQ0UsS0FERixFQUVFLG1FQUNFLG9FQURGLEdBRUUseUNBRkYsR0FHRSxNQUhGLEdBSUUsOENBSkYsR0FLRSw4Q0FQSixFQVFFeXRFLFFBUkYsRUFTRSxvREFBNEIzM0QsV0FBNUIsQ0FURjtBQVdBdTNELDRDQUFrQ3J0RSxhQUFsQyxJQUFtRCxJQUFuRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJOE8sUUFBUUMsTUFBWixFQUFvQjtBQUNsQixVQUFNcG5CLFFBQWlCbW5CLFFBQVFDLE1BQS9CO0FBQ0EsVUFBSTdZLGFBQUo7QUFDQSxVQUFJdk8sS0FBSixFQUFXO0FBQ1QsWUFBTXUrRSxhQUFlditFLEtBQXJCO0FBQ0EsaUNBQ0V1K0UsV0FBVzFnRixHQUFYLEtBQW1CMUIsNkJBRHJCLEVBRUUsMkNBQ0UseUNBSEo7QUFLQW9TLGVBQU9nd0UsV0FBVy92RSxTQUFsQjtBQUNEO0FBQ0QsK0JBQ0VELElBREYsRUFFRSx1RUFDRSxxQ0FISixFQUlFdTNFLFFBSkY7QUFNQSxVQUFNQyxZQUFZLEtBQUtELFFBQXZCO0FBQ0E7QUFDQSxVQUNFcmxGLFlBQVksSUFBWixJQUNBQSxRQUFRcWxCLEdBQVIsS0FBZ0IsSUFEaEIsSUFFQSxPQUFPcmxCLFFBQVFxbEIsR0FBZixLQUF1QixVQUZ2QixJQUdBcmxCLFFBQVFxbEIsR0FBUixDQUFZa2dFLFVBQVosS0FBMkJELFNBSjdCLEVBS0U7QUFDQSxlQUFPdGxGLFFBQVFxbEIsR0FBZjtBQUNEO0FBQ0QsVUFBTUEsTUFBTSxTQUFOQSxHQUFNLENBQVN6SSxLQUFULEVBQWdCO0FBQzFCLFlBQUkyNUIsT0FBT3pvQyxLQUFLeW9DLElBQWhCO0FBQ0EsWUFBSUEsU0FBU0QseUNBQWIsRUFBOEI7QUFDNUI7QUFDQUMsaUJBQU96b0MsS0FBS3lvQyxJQUFMLEdBQVksRUFBbkI7QUFDRDtBQUNELFlBQUkzNUIsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCLGlCQUFPMjVCLEtBQUsrdUMsU0FBTCxDQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wvdUMsZUFBSyt1QyxTQUFMLElBQWtCMW9FLEtBQWxCO0FBQ0Q7QUFDRixPQVhEO0FBWUF5SSxVQUFJa2dFLFVBQUosR0FBaUJELFNBQWpCO0FBQ0EsYUFBT2pnRSxHQUFQO0FBQ0QsS0ExQ0QsTUEwQ087QUFDTCwrQkFDRSxPQUFPZ2dFLFFBQVAsS0FBb0IsUUFEdEIsRUFFRSw0RkFGRjtBQUlBLCtCQUNFMytELFFBQVFDLE1BRFYsRUFFRSxrR0FDRSwyQkFERixHQUVFLHNEQUZGLEdBR0UscUdBSEYsR0FJRSwrQ0FKRixHQUtFLG9FQVBKLEVBUUUwK0QsUUFSRjtBQVVEO0FBQ0Y7QUFDRCxTQUFPQSxRQUFQO0FBQ0Q7O0FBRUQsU0FBU0csd0JBQVQsQ0FBa0M5M0QsV0FBbEMsRUFBc0R5TCxRQUF0RCxFQUF3RTtBQUN0RSxNQUFJekwsWUFBWXZ3QixJQUFaLEtBQXFCLFVBQXpCLEVBQXFDO0FBQ25DLFFBQUl1b0QsV0FBVyxFQUFmO0FBQ0EsUUFBSWx0RCxJQUFKLEVBQWE7QUFDWGt0RCxpQkFDRSxvRUFDQSxVQURBLEdBRUEsbURBSEY7QUFJRDtBQUNELDZCQUNFLEtBREYsRUFFRSx1REFGRixFQUdFN2dELE9BQU81SyxTQUFQLENBQWlCdVQsUUFBakIsQ0FBMEJyVCxJQUExQixDQUErQmcvQixRQUEvQixNQUE2QyxpQkFBN0MsR0FDSSx1QkFBdUJ0MEIsT0FBTzRoQixJQUFQLENBQVkwUyxRQUFaLEVBQXNCdU8sSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBdkIsR0FBMEQsR0FEOUQsR0FFSXZPLFFBTE4sRUFNRXVzQixRQU5GO0FBUUQ7QUFDRjs7QUFFRCxTQUFTKy9CLGtCQUFULEdBQThCO0FBQzVCLE1BQU10Wiw0QkFDSixrRUFDQSwrREFEQSxHQUVBLGlFQUZBLEdBR0EsbURBSkY7O0FBTUEsTUFBSStZLDRCQUE0Qi9ZLHlCQUE1QixDQUFKLEVBQTREO0FBQzFEO0FBQ0Q7QUFDRCtZLDhCQUE0Qi9ZLHlCQUE1QixJQUF5RCxJQUF6RDs7QUFFQSx5QkFDRSxLQURGLEVBRUUsa0VBQ0UsK0RBREYsR0FFRSxpRUFKSjtBQU1EOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU3VaLGVBQVQsQ0FBeUJDLHNCQUF6QixFQUFpRDtBQUMvQyxXQUFTQyxXQUFULENBQXFCbDRELFdBQXJCLEVBQXlDazFCLGFBQXpDLEVBQXFFO0FBQ25FLFFBQUksQ0FBQytpQyxzQkFBTCxFQUE2QjtBQUMzQjtBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTW5wRCxPQUFPOU8sWUFBWTlkLFVBQXpCO0FBQ0EsUUFBSTRzQixTQUFTLElBQWIsRUFBbUI7QUFDakJBLFdBQUtwc0IsVUFBTCxHQUFrQnd5QyxhQUFsQjtBQUNBbDFCLGtCQUFZOWQsVUFBWixHQUF5Qmd6QyxhQUF6QjtBQUNELEtBSEQsTUFHTztBQUNMbDFCLGtCQUFZL2QsV0FBWixHQUEwQitkLFlBQVk5ZCxVQUFaLEdBQXlCZ3pDLGFBQW5EO0FBQ0Q7QUFDREEsa0JBQWN4eUMsVUFBZCxHQUEyQixJQUEzQjtBQUNBd3lDLGtCQUFjenhDLFNBQWQsR0FBMEIxUSw2QkFBMUI7QUFDRDs7QUFFRCxXQUFTb2xGLHVCQUFULENBQ0VuNEQsV0FERixFQUVFbzRELGlCQUZGLEVBR1E7QUFDTixRQUFJLENBQUNILHNCQUFMLEVBQTZCO0FBQzNCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFFBQUkvaUMsZ0JBQWdCa2pDLGlCQUFwQjtBQUNBLFdBQU9sakMsa0JBQWtCLElBQXpCLEVBQStCO0FBQzdCZ2pDLGtCQUFZbDRELFdBQVosRUFBeUJrMUIsYUFBekI7QUFDQUEsc0JBQWdCQSxjQUFjcHVDLE9BQTlCO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFTdXhFLG9CQUFULENBQ0VyNEQsV0FERixFQUVFbzRELGlCQUZGLEVBRytCO0FBQzdCO0FBQ0E7QUFFQSxRQUFNRSxtQkFBZ0QsSUFBSWxoRSxHQUFKLEVBQXREOztBQUVBLFFBQUltaEUsZ0JBQWdCSCxpQkFBcEI7QUFDQSxXQUFPRyxrQkFBa0IsSUFBekIsRUFBK0I7QUFDN0IsVUFBSUEsY0FBYy91RSxHQUFkLEtBQXNCLElBQTFCLEVBQWdDO0FBQzlCOHVFLHlCQUFpQmhnRixHQUFqQixDQUFxQmlnRixjQUFjL3VFLEdBQW5DLEVBQXdDK3VFLGFBQXhDO0FBQ0QsT0FGRCxNQUVPO0FBQ0xELHlCQUFpQmhnRixHQUFqQixDQUFxQmlnRixjQUFjN2dFLEtBQW5DLEVBQTBDNmdFLGFBQTFDO0FBQ0Q7QUFDREEsc0JBQWdCQSxjQUFjenhFLE9BQTlCO0FBQ0Q7QUFDRCxXQUFPd3hFLGdCQUFQO0FBQ0Q7O0FBRUQsV0FBU0UsUUFBVCxDQUNFNW1GLEtBREYsRUFFRTRsQixZQUZGLEVBR0VuakIsY0FIRixFQUlTO0FBQ1A7QUFDQTtBQUNBLFFBQU1va0YsUUFBUSxzQ0FBcUI3bUYsS0FBckIsRUFBNEI0bEIsWUFBNUIsRUFBMENuakIsY0FBMUMsQ0FBZDtBQUNBb2tGLFVBQU0vZ0UsS0FBTixHQUFjLENBQWQ7QUFDQStnRSxVQUFNM3hFLE9BQU4sR0FBZ0IsSUFBaEI7QUFDQSxXQUFPMnhFLEtBQVA7QUFDRDs7QUFFRCxXQUFTQyxVQUFULENBQ0VDLFFBREYsRUFFRUMsZUFGRixFQUdFQyxRQUhGLEVBSVU7QUFDUkYsYUFBU2poRSxLQUFULEdBQWlCbWhFLFFBQWpCO0FBQ0EsUUFBSSxDQUFDWixzQkFBTCxFQUE2QjtBQUMzQjtBQUNBLGFBQU9XLGVBQVA7QUFDRDtBQUNELFFBQU10bUYsVUFBVXFtRixTQUFTOTFFLFNBQXpCO0FBQ0EsUUFBSXZRLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsVUFBTXdtRixXQUFXeG1GLFFBQVFvbEIsS0FBekI7QUFDQSxVQUFJb2hFLFdBQVdGLGVBQWYsRUFBZ0M7QUFDOUI7QUFDQUQsaUJBQVNsMUUsU0FBVCxHQUFxQjdRLDhCQUFyQjtBQUNBLGVBQU9nbUYsZUFBUDtBQUNELE9BSkQsTUFJTztBQUNMO0FBQ0EsZUFBT0UsUUFBUDtBQUNEO0FBQ0YsS0FWRCxNQVVPO0FBQ0w7QUFDQUgsZUFBU2wxRSxTQUFULEdBQXFCN1EsOEJBQXJCO0FBQ0EsYUFBT2dtRixlQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTRyxnQkFBVCxDQUEwQkosUUFBMUIsRUFBa0Q7QUFDaEQ7QUFDQTtBQUNBLFFBQUlWLDBCQUEwQlUsU0FBUzkxRSxTQUFULEtBQXVCLElBQXJELEVBQTJEO0FBQ3pEODFFLGVBQVNsMUUsU0FBVCxHQUFxQjdRLDhCQUFyQjtBQUNEO0FBQ0QsV0FBTytsRixRQUFQO0FBQ0Q7O0FBRUQsV0FBU0ssY0FBVCxDQUNFaDVELFdBREYsRUFFRTF0QixPQUZGLEVBR0UyakQsV0FIRixFQUlFNWhELGNBSkYsRUFLRTtBQUNBLFFBQUkvQixZQUFZLElBQVosSUFBb0JBLFFBQVE1QyxHQUFSLEtBQWdCckIsdUJBQXhDLEVBQWtEO0FBQ2hEO0FBQ0EsVUFBTTRxRixVQUFVLHFDQUNkaGpDLFdBRGMsRUFFZGoyQixZQUFZemMsSUFGRSxFQUdkbFAsY0FIYyxDQUFoQjtBQUtBNGtGLGNBQVE1bUYsTUFBUixHQUFpQjJ0QixXQUFqQjtBQUNBLGFBQU9pNUQsT0FBUDtBQUNELEtBVEQsTUFTTztBQUNMO0FBQ0EsVUFBTUMsV0FBV1YsU0FBU2xtRixPQUFULEVBQWtCMmpELFdBQWxCLEVBQStCNWhELGNBQS9CLENBQWpCO0FBQ0E2a0YsZUFBUzdtRixNQUFULEdBQWtCMnRCLFdBQWxCO0FBQ0EsYUFBT2s1RCxRQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTQyxhQUFULENBQ0VuNUQsV0FERixFQUVFMXRCLE9BRkYsRUFHRTBtQixPQUhGLEVBSUUza0IsY0FKRixFQUtTO0FBQ1AsUUFBSS9CLFlBQVksSUFBWixJQUFvQkEsUUFBUW1sQixXQUFSLEtBQXdCdUIsUUFBUXZwQixJQUF4RCxFQUE4RDtBQUM1RDtBQUNBLFVBQU15cEYsV0FBV1YsU0FBU2xtRixPQUFULEVBQWtCMG1CLFFBQVExWSxLQUExQixFQUFpQ2pNLGNBQWpDLENBQWpCO0FBQ0E2a0YsZUFBU3ZoRSxHQUFULEdBQWUrL0QsVUFBVTEzRCxXQUFWLEVBQXVCMXRCLE9BQXZCLEVBQWdDMG1CLE9BQWhDLENBQWY7QUFDQWtnRSxlQUFTN21GLE1BQVQsR0FBa0IydEIsV0FBbEI7QUFDQSxVQUFJbDFCLElBQUosRUFBYTtBQUNYb3VGLGlCQUFTbG5GLFlBQVQsR0FBd0JnbkIsUUFBUUUsT0FBaEM7QUFDQWdnRSxpQkFBU3BuRixXQUFULEdBQXVCa25CLFFBQVFDLE1BQS9CO0FBQ0Q7QUFDRCxhQUFPaWdFLFFBQVA7QUFDRCxLQVZELE1BVU87QUFDTDtBQUNBLFVBQU1ELFVBQVUsd0NBQ2RqZ0UsT0FEYyxFQUVkZ0gsWUFBWXpjLElBRkUsRUFHZGxQLGNBSGMsQ0FBaEI7QUFLQTRrRixjQUFRdGhFLEdBQVIsR0FBYysvRCxVQUFVMTNELFdBQVYsRUFBdUIxdEIsT0FBdkIsRUFBZ0MwbUIsT0FBaEMsQ0FBZDtBQUNBaWdFLGNBQVE1bUYsTUFBUixHQUFpQjJ0QixXQUFqQjtBQUNBLGFBQU9pNUQsT0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU0csWUFBVCxDQUNFcDVELFdBREYsRUFFRTF0QixPQUZGLEVBR0VpbkIsTUFIRixFQUlFbGxCLGNBSkYsRUFLUztBQUNQLFFBQ0UvQixZQUFZLElBQVosSUFDQUEsUUFBUTVDLEdBQVIsS0FBZ0J2Qix5QkFEaEIsSUFFQW1FLFFBQVErTixTQUFSLENBQWtCbVosYUFBbEIsS0FBb0NELE9BQU9DLGFBRjNDLElBR0FsbkIsUUFBUStOLFNBQVIsQ0FBa0JxWixjQUFsQixLQUFxQ0gsT0FBT0csY0FKOUMsRUFLRTtBQUNBO0FBQ0EsVUFBTXUvRCxVQUFVLHVDQUNkMS9ELE1BRGMsRUFFZHlHLFlBQVl6YyxJQUZFLEVBR2RsUCxjQUhjLENBQWhCO0FBS0E0a0YsY0FBUTVtRixNQUFSLEdBQWlCMnRCLFdBQWpCO0FBQ0EsYUFBT2k1RCxPQUFQO0FBQ0QsS0FkRCxNQWNPO0FBQ0w7QUFDQSxVQUFNQyxXQUFXVixTQUFTbG1GLE9BQVQsRUFBa0JpbkIsT0FBT1gsUUFBUCxJQUFtQixFQUFyQyxFQUF5Q3ZrQixjQUF6QyxDQUFqQjtBQUNBNmtGLGVBQVM3bUYsTUFBVCxHQUFrQjJ0QixXQUFsQjtBQUNBLGFBQU9rNUQsUUFBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU3J0RCxjQUFULENBQ0U3TCxXQURGLEVBRUUxdEIsT0FGRixFQUdFeXNFLFFBSEYsRUFJRTFxRSxjQUpGLEVBS0VtVixHQUxGLEVBTVM7QUFDUCxRQUFJbFgsWUFBWSxJQUFaLElBQW9CQSxRQUFRNUMsR0FBUixLQUFnQnBCLHVCQUF4QyxFQUFrRDtBQUNoRDtBQUNBLFVBQU0ycUYsVUFBVSx5Q0FDZGxhLFFBRGMsRUFFZC8rQyxZQUFZemMsSUFGRSxFQUdkbFAsY0FIYyxFQUlkbVYsR0FKYyxDQUFoQjtBQU1BeXZFLGNBQVE1bUYsTUFBUixHQUFpQjJ0QixXQUFqQjtBQUNBLGFBQU9pNUQsT0FBUDtBQUNELEtBVkQsTUFVTztBQUNMO0FBQ0EsVUFBTUMsV0FBV1YsU0FBU2xtRixPQUFULEVBQWtCeXNFLFFBQWxCLEVBQTRCMXFFLGNBQTVCLENBQWpCO0FBQ0E2a0YsZUFBUzdtRixNQUFULEdBQWtCMnRCLFdBQWxCO0FBQ0EsYUFBT2s1RCxRQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTRyxXQUFULENBQ0VyNUQsV0FERixFQUVFeUwsUUFGRixFQUdFcDNCLGNBSEYsRUFJZ0I7QUFDZCxRQUFJLE9BQU9vM0IsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxPQUFPQSxRQUFQLEtBQW9CLFFBQXhELEVBQWtFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFVBQU13dEQsVUFBVSxxQ0FDZCxLQUFLeHRELFFBRFMsRUFFZHpMLFlBQVl6YyxJQUZFLEVBR2RsUCxjQUhjLENBQWhCO0FBS0E0a0YsY0FBUTVtRixNQUFSLEdBQWlCMnRCLFdBQWpCO0FBQ0EsYUFBT2k1RCxPQUFQO0FBQ0Q7O0FBRUQsUUFBSSxRQUFPeHRELFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBcEIsSUFBZ0NBLGFBQWEsSUFBakQsRUFBdUQ7QUFDckQsY0FBUUEsU0FBU3g3QixRQUFqQjtBQUNFLGFBQUthLGdDQUFMO0FBQXlCO0FBQ3ZCLGdCQUFNbW9GLFdBQVUsd0NBQ2R4dEQsUUFEYyxFQUVkekwsWUFBWXpjLElBRkUsRUFHZGxQLGNBSGMsQ0FBaEI7QUFLQTRrRixxQkFBUXRoRSxHQUFSLEdBQWMrL0QsVUFBVTEzRCxXQUFWLEVBQXVCLElBQXZCLEVBQTZCeUwsUUFBN0IsQ0FBZDtBQUNBd3RELHFCQUFRNW1GLE1BQVIsR0FBaUIydEIsV0FBakI7QUFDQSxtQkFBT2k1RCxRQUFQO0FBQ0Q7QUFDRCxhQUFLcHBGLCtCQUFMO0FBQXdCO0FBQ3RCLGdCQUFNb3BGLFlBQVUsdUNBQ2R4dEQsUUFEYyxFQUVkekwsWUFBWXpjLElBRkUsRUFHZGxQLGNBSGMsQ0FBaEI7QUFLQTRrRixzQkFBUTVtRixNQUFSLEdBQWlCMnRCLFdBQWpCO0FBQ0EsbUJBQU9pNUQsU0FBUDtBQUNEO0FBbkJIOztBQXNCQSxVQUFJL2tELFFBQVF6SSxRQUFSLEtBQXFCLGlDQUFjQSxRQUFkLENBQXpCLEVBQWtEO0FBQ2hELFlBQU13dEQsWUFBVSx5Q0FDZHh0RCxRQURjLEVBRWR6TCxZQUFZemMsSUFGRSxFQUdkbFAsY0FIYyxFQUlkLElBSmMsQ0FBaEI7QUFNQTRrRixrQkFBUTVtRixNQUFSLEdBQWlCMnRCLFdBQWpCO0FBQ0EsZUFBT2k1RCxTQUFQO0FBQ0Q7O0FBRURuQiwrQkFBeUI5M0QsV0FBekIsRUFBc0N5TCxRQUF0QztBQUNEOztBQUVELFFBQUkzZ0MsSUFBSixFQUFhO0FBQ1gsVUFBSSxPQUFPMmdDLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbENzc0Q7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQUVELFdBQVN1QixVQUFULENBQ0V0NUQsV0FERixFQUVFdTVELFFBRkYsRUFHRTl0RCxRQUhGLEVBSUVwM0IsY0FKRixFQUtnQjtBQUNkOztBQUVBLFFBQU1tVixNQUFNK3ZFLGFBQWEsSUFBYixHQUFvQkEsU0FBUy92RSxHQUE3QixHQUFtQyxJQUEvQzs7QUFFQSxRQUFJLE9BQU9paUIsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxPQUFPQSxRQUFQLEtBQW9CLFFBQXhELEVBQWtFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFVBQUlqaUIsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBT3d2RSxlQUNMaDVELFdBREssRUFFTHU1RCxRQUZLLEVBR0wsS0FBSzl0RCxRQUhBLEVBSUxwM0IsY0FKSyxDQUFQO0FBTUQ7O0FBRUQsUUFBSSxRQUFPbzNCLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBcEIsSUFBZ0NBLGFBQWEsSUFBakQsRUFBdUQ7QUFDckQsY0FBUUEsU0FBU3g3QixRQUFqQjtBQUNFLGFBQUthLGdDQUFMO0FBQXlCO0FBQ3ZCLGdCQUFJMjZCLFNBQVNqaUIsR0FBVCxLQUFpQkEsR0FBckIsRUFBMEI7QUFDeEIsa0JBQUlpaUIsU0FBU2g4QixJQUFULEtBQWtCRyxpQ0FBdEIsRUFBMkM7QUFDekMsdUJBQU9pOEIsZUFDTDdMLFdBREssRUFFTHU1RCxRQUZLLEVBR0w5dEQsU0FBU25yQixLQUFULENBQWVzWSxRQUhWLEVBSUx2a0IsY0FKSyxFQUtMbVYsR0FMSyxDQUFQO0FBT0Q7QUFDRCxxQkFBTzJ2RSxjQUNMbjVELFdBREssRUFFTHU1RCxRQUZLLEVBR0w5dEQsUUFISyxFQUlMcDNCLGNBSkssQ0FBUDtBQU1ELGFBaEJELE1BZ0JPO0FBQ0wscUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFLeEUsK0JBQUw7QUFBd0I7QUFDdEIsZ0JBQUk0N0IsU0FBU2ppQixHQUFULEtBQWlCQSxHQUFyQixFQUEwQjtBQUN4QixxQkFBTzR2RSxhQUNMcDVELFdBREssRUFFTHU1RCxRQUZLLEVBR0w5dEQsUUFISyxFQUlMcDNCLGNBSkssQ0FBUDtBQU1ELGFBUEQsTUFPTztBQUNMLHFCQUFPLElBQVA7QUFDRDtBQUNGO0FBakNIOztBQW9DQSxVQUFJNi9CLFFBQVF6SSxRQUFSLEtBQXFCLGlDQUFjQSxRQUFkLENBQXpCLEVBQWtEO0FBQ2hELFlBQUlqaUIsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxlQUFPcWlCLGVBQ0w3TCxXQURLLEVBRUx1NUQsUUFGSyxFQUdMOXRELFFBSEssRUFJTHAzQixjQUpLLEVBS0wsSUFMSyxDQUFQO0FBT0Q7O0FBRUR5akYsK0JBQXlCOTNELFdBQXpCLEVBQXNDeUwsUUFBdEM7QUFDRDs7QUFFRCxRQUFJM2dDLElBQUosRUFBYTtBQUNYLFVBQUksT0FBTzJnQyxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDc3NEO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFTeUIsYUFBVCxDQUNFbEIsZ0JBREYsRUFFRXQ0RCxXQUZGLEVBR0V5NUQsTUFIRixFQUlFaHVELFFBSkYsRUFLRXAzQixjQUxGLEVBTWdCO0FBQ2QsUUFBSSxPQUFPbzNCLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0MsT0FBT0EsUUFBUCxLQUFvQixRQUF4RCxFQUFrRTtBQUNoRTtBQUNBO0FBQ0EsVUFBTWl1RCxlQUFlcEIsaUJBQWlCLy9FLEdBQWpCLENBQXFCa2hGLE1BQXJCLEtBQWdDLElBQXJEO0FBQ0EsYUFBT1QsZUFDTGg1RCxXQURLLEVBRUwwNUQsWUFGSyxFQUdMLEtBQUtqdUQsUUFIQSxFQUlMcDNCLGNBSkssQ0FBUDtBQU1EOztBQUVELFFBQUksUUFBT28zQixRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXBCLElBQWdDQSxhQUFhLElBQWpELEVBQXVEO0FBQ3JELGNBQVFBLFNBQVN4N0IsUUFBakI7QUFDRSxhQUFLYSxnQ0FBTDtBQUF5QjtBQUN2QixnQkFBTTRvRixnQkFDSnBCLGlCQUFpQi8vRSxHQUFqQixDQUNFa3pCLFNBQVNqaUIsR0FBVCxLQUFpQixJQUFqQixHQUF3Qml3RSxNQUF4QixHQUFpQ2h1RCxTQUFTamlCLEdBRDVDLEtBRUssSUFIUDtBQUlBLGdCQUFJaWlCLFNBQVNoOEIsSUFBVCxLQUFrQkcsaUNBQXRCLEVBQTJDO0FBQ3pDLHFCQUFPaThCLGVBQ0w3TCxXQURLLEVBRUwwNUQsYUFGSyxFQUdManVELFNBQVNuckIsS0FBVCxDQUFlc1ksUUFIVixFQUlMdmtCLGNBSkssRUFLTG8zQixTQUFTamlCLEdBTEosQ0FBUDtBQU9EO0FBQ0QsbUJBQU8ydkUsY0FDTG41RCxXQURLLEVBRUwwNUQsYUFGSyxFQUdManVELFFBSEssRUFJTHAzQixjQUpLLENBQVA7QUFNRDtBQUNELGFBQUt4RSwrQkFBTDtBQUF3QjtBQUN0QixnQkFBTTZwRixpQkFDSnBCLGlCQUFpQi8vRSxHQUFqQixDQUNFa3pCLFNBQVNqaUIsR0FBVCxLQUFpQixJQUFqQixHQUF3Qml3RSxNQUF4QixHQUFpQ2h1RCxTQUFTamlCLEdBRDVDLEtBRUssSUFIUDtBQUlBLG1CQUFPNHZFLGFBQ0xwNUQsV0FESyxFQUVMMDVELGNBRkssRUFHTGp1RCxRQUhLLEVBSUxwM0IsY0FKSyxDQUFQO0FBTUQ7QUFqQ0g7O0FBb0NBLFVBQUk2L0IsUUFBUXpJLFFBQVIsS0FBcUIsaUNBQWNBLFFBQWQsQ0FBekIsRUFBa0Q7QUFDaEQsWUFBTWl1RCxpQkFBZXBCLGlCQUFpQi8vRSxHQUFqQixDQUFxQmtoRixNQUFyQixLQUFnQyxJQUFyRDtBQUNBLGVBQU81dEQsZUFDTDdMLFdBREssRUFFTDA1RCxjQUZLLEVBR0xqdUQsUUFISyxFQUlMcDNCLGNBSkssRUFLTCxJQUxLLENBQVA7QUFPRDs7QUFFRHlqRiwrQkFBeUI5M0QsV0FBekIsRUFBc0N5TCxRQUF0QztBQUNEOztBQUVELFFBQUkzZ0MsSUFBSixFQUFhO0FBQ1gsVUFBSSxPQUFPMmdDLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbENzc0Q7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQUVEOzs7QUFHQSxXQUFTNEIsZ0JBQVQsQ0FDRXB6RSxLQURGLEVBRUVxekUsU0FGRixFQUdzQjtBQUNwQixRQUFJOXVGLElBQUosRUFBYTtBQUNYLFVBQUksUUFBT3liLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBakIsSUFBNkJBLFVBQVUsSUFBM0MsRUFBaUQ7QUFDL0MsZUFBT3F6RSxTQUFQO0FBQ0Q7QUFDRCxjQUFRcnpFLE1BQU10VyxRQUFkO0FBQ0UsYUFBS2EsZ0NBQUw7QUFDQSxhQUFLakIsK0JBQUw7QUFDRTRuRiw0QkFBa0JseEUsS0FBbEI7QUFDQSxjQUFNaUQsTUFBTWpELE1BQU1pRCxHQUFsQjtBQUNBLGNBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCO0FBQ0Q7QUFDRCxjQUFJb3dFLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEJBLHdCQUFZLElBQUkxbEUsR0FBSixFQUFaO0FBQ0EwbEUsc0JBQVV2a0UsR0FBVixDQUFjN0wsR0FBZDtBQUNBO0FBQ0Q7QUFDRCxjQUFJLENBQUNvd0UsVUFBVXhrRSxHQUFWLENBQWM1TCxHQUFkLENBQUwsRUFBeUI7QUFDdkJvd0Usc0JBQVV2a0UsR0FBVixDQUFjN0wsR0FBZDtBQUNBO0FBQ0Q7QUFDRCxpQ0FDRSxLQURGLEVBRUUsdURBQ0UsbUVBREYsR0FFRSwyREFGRixHQUdFLDhEQUhGLEdBSUUsbUNBTkosRUFPRUEsR0FQRjtBQVNBO0FBQ0Y7QUFDRTtBQTVCSjtBQThCRDtBQUNELFdBQU9vd0UsU0FBUDtBQUNEOztBQUVELFdBQVNDLHNCQUFULENBQ0U3NUQsV0FERixFQUVFbzRELGlCQUZGLEVBR0Uvb0QsV0FIRixFQUlFaDdCLGNBSkYsRUFLZ0I7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBSXZKLElBQUosRUFBYTtBQUNYO0FBQ0EsVUFBSTh1RixZQUFZLElBQWhCO0FBQ0EsV0FBSyxJQUFJanVFLElBQUksQ0FBYixFQUFnQkEsSUFBSTBqQixZQUFZcmpDLE1BQWhDLEVBQXdDMmYsR0FBeEMsRUFBNkM7QUFDM0MsWUFBTXBGLFFBQVE4b0IsWUFBWTFqQixDQUFaLENBQWQ7QUFDQWl1RSxvQkFBWUQsaUJBQWlCcHpFLEtBQWpCLEVBQXdCcXpFLFNBQXhCLENBQVo7QUFDRDtBQUNGOztBQUVELFFBQUlFLHNCQUFvQyxJQUF4QztBQUNBLFFBQUlDLG1CQUFpQyxJQUFyQzs7QUFFQSxRQUFJUixXQUFXbkIsaUJBQWY7QUFDQSxRQUFJUSxrQkFBa0IsQ0FBdEI7QUFDQSxRQUFJYSxTQUFTLENBQWI7QUFDQSxRQUFJTyxlQUFlLElBQW5CO0FBQ0EsV0FBT1QsYUFBYSxJQUFiLElBQXFCRSxTQUFTcHFELFlBQVlyakMsTUFBakQsRUFBeUR5dEYsUUFBekQsRUFBbUU7QUFDakUsVUFBSUYsU0FBUzdoRSxLQUFULEdBQWlCK2hFLE1BQXJCLEVBQTZCO0FBQzNCTyx1QkFBZVQsUUFBZjtBQUNBQSxtQkFBVyxJQUFYO0FBQ0QsT0FIRCxNQUdPO0FBQ0xTLHVCQUFlVCxTQUFTenlFLE9BQXhCO0FBQ0Q7QUFDRCxVQUFNNnhFLFdBQVdXLFdBQ2Z0NUQsV0FEZSxFQUVmdTVELFFBRmUsRUFHZmxxRCxZQUFZb3FELE1BQVosQ0FIZSxFQUlmcGxGLGNBSmUsQ0FBakI7QUFNQSxVQUFJc2tGLGFBQWEsSUFBakIsRUFBdUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJWSxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCQSxxQkFBV1MsWUFBWDtBQUNEO0FBQ0Q7QUFDRDtBQUNELFVBQUkvQixzQkFBSixFQUE0QjtBQUMxQixZQUFJc0IsWUFBWVosU0FBUzkxRSxTQUFULEtBQXVCLElBQXZDLEVBQTZDO0FBQzNDO0FBQ0E7QUFDQXExRSxzQkFBWWw0RCxXQUFaLEVBQXlCdTVELFFBQXpCO0FBQ0Q7QUFDRjtBQUNEWCx3QkFBa0JGLFdBQVdDLFFBQVgsRUFBcUJDLGVBQXJCLEVBQXNDYSxNQUF0QyxDQUFsQjtBQUNBLFVBQUlNLHFCQUFxQixJQUF6QixFQUErQjtBQUM3QjtBQUNBRCw4QkFBc0JuQixRQUF0QjtBQUNELE9BSEQsTUFHTztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0FvQix5QkFBaUJqekUsT0FBakIsR0FBMkI2eEUsUUFBM0I7QUFDRDtBQUNEb0IseUJBQW1CcEIsUUFBbkI7QUFDQVksaUJBQVdTLFlBQVg7QUFDRDs7QUFFRCxRQUFJUCxXQUFXcHFELFlBQVlyakMsTUFBM0IsRUFBbUM7QUFDakM7QUFDQW1zRiw4QkFBd0JuNEQsV0FBeEIsRUFBcUN1NUQsUUFBckM7QUFDQSxhQUFPTyxtQkFBUDtBQUNEOztBQUVELFFBQUlQLGFBQWEsSUFBakIsRUFBdUI7QUFDckI7QUFDQTtBQUNBLGFBQU9FLFNBQVNwcUQsWUFBWXJqQyxNQUE1QixFQUFvQ3l0RixRQUFwQyxFQUE4QztBQUM1QyxZQUFNZCxZQUFXVSxZQUNmcjVELFdBRGUsRUFFZnFQLFlBQVlvcUQsTUFBWixDQUZlLEVBR2ZwbEYsY0FIZSxDQUFqQjtBQUtBLFlBQUksQ0FBQ3NrRixTQUFMLEVBQWU7QUFDYjtBQUNEO0FBQ0RDLDBCQUFrQkYsV0FBV0MsU0FBWCxFQUFxQkMsZUFBckIsRUFBc0NhLE1BQXRDLENBQWxCO0FBQ0EsWUFBSU0scUJBQXFCLElBQXpCLEVBQStCO0FBQzdCO0FBQ0FELGdDQUFzQm5CLFNBQXRCO0FBQ0QsU0FIRCxNQUdPO0FBQ0xvQiwyQkFBaUJqekUsT0FBakIsR0FBMkI2eEUsU0FBM0I7QUFDRDtBQUNEb0IsMkJBQW1CcEIsU0FBbkI7QUFDRDtBQUNELGFBQU9tQixtQkFBUDtBQUNEOztBQUVEO0FBQ0EsUUFBTXhCLG1CQUFtQkQscUJBQXFCcjRELFdBQXJCLEVBQWtDdTVELFFBQWxDLENBQXpCOztBQUVBO0FBQ0EsV0FBT0UsU0FBU3BxRCxZQUFZcmpDLE1BQTVCLEVBQW9DeXRGLFFBQXBDLEVBQThDO0FBQzVDLFVBQU1kLGFBQVdhLGNBQ2ZsQixnQkFEZSxFQUVmdDRELFdBRmUsRUFHZnk1RCxNQUhlLEVBSWZwcUQsWUFBWW9xRCxNQUFaLENBSmUsRUFLZnBsRixjQUxlLENBQWpCO0FBT0EsVUFBSXNrRixVQUFKLEVBQWM7QUFDWixZQUFJVixzQkFBSixFQUE0QjtBQUMxQixjQUFJVSxXQUFTOTFFLFNBQVQsS0FBdUIsSUFBM0IsRUFBaUM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQXkxRSw2QkFBaUJqNUQsTUFBakIsQ0FDRXM1RCxXQUFTbnZFLEdBQVQsS0FBaUIsSUFBakIsR0FBd0Jpd0UsTUFBeEIsR0FBaUNkLFdBQVNudkUsR0FENUM7QUFHRDtBQUNGO0FBQ0RvdkUsMEJBQWtCRixXQUFXQyxVQUFYLEVBQXFCQyxlQUFyQixFQUFzQ2EsTUFBdEMsQ0FBbEI7QUFDQSxZQUFJTSxxQkFBcUIsSUFBekIsRUFBK0I7QUFDN0JELGdDQUFzQm5CLFVBQXRCO0FBQ0QsU0FGRCxNQUVPO0FBQ0xvQiwyQkFBaUJqekUsT0FBakIsR0FBMkI2eEUsVUFBM0I7QUFDRDtBQUNEb0IsMkJBQW1CcEIsVUFBbkI7QUFDRDtBQUNGOztBQUVELFFBQUlWLHNCQUFKLEVBQTRCO0FBQzFCO0FBQ0E7QUFDQUssdUJBQWlCM29FLE9BQWpCLENBQXlCO0FBQUEsZUFBU3VvRSxZQUFZbDRELFdBQVosRUFBeUJ6WixLQUF6QixDQUFUO0FBQUEsT0FBekI7QUFDRDs7QUFFRCxXQUFPdXpFLG1CQUFQO0FBQ0Q7O0FBRUQsV0FBU0cseUJBQVQsQ0FDRWo2RCxXQURGLEVBRUVvNEQsaUJBRkYsRUFHRThCLG1CQUhGLEVBSUU3bEYsY0FKRixFQUtnQjtBQUNkO0FBQ0E7O0FBRUEsUUFBTWloRSxhQUFhLGlDQUFjNGtCLG1CQUFkLENBQW5CO0FBQ0EsNkJBQ0UsT0FBTzVrQixVQUFQLEtBQXNCLFVBRHhCLEVBRUUsMkVBQ0UsOEJBSEo7O0FBTUEsUUFBSXhxRSxJQUFKLEVBQWE7QUFDWDtBQUNBO0FBQ0EsVUFDRSxPQUFPOEYsTUFBUCxLQUFrQixVQUFsQjtBQUNBO0FBQ0FzcEYsMEJBQW9CdHBGLE9BQU91cEYsV0FBM0IsTUFBNEMsV0FIOUMsRUFJRTtBQUNBLCtCQUNFN0Msc0JBREYsRUFFRSx1RUFDRSxpRUFERixHQUVFLDREQUZGLEdBR0Usd0RBSEYsR0FJRSwrREFOSjtBQVFBQSxpQ0FBeUIsSUFBekI7QUFDRDs7QUFFRDtBQUNBLFVBQUs0QyxtQkFBRCxDQUEyQjNrQixPQUEzQixLQUF1Q0QsVUFBM0MsRUFBdUQ7QUFDckQsK0JBQ0VuQixnQkFERixFQUVFLGlFQUNFLGlFQURGLEdBRUUsd0JBSko7QUFNQUEsMkJBQW1CLElBQW5CO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQU05a0MsZUFBY2ltQyxXQUFXN29FLElBQVgsQ0FBZ0J5dEYsbUJBQWhCLENBQXBCO0FBQ0EsVUFBSTdxRCxZQUFKLEVBQWlCO0FBQ2YsWUFBSXVxRCxZQUFZLElBQWhCO0FBQ0EsWUFBSTEzQixRQUFPN3lCLGFBQVk1c0IsSUFBWixFQUFYO0FBQ0EsZUFBTyxDQUFDeS9DLE1BQUt1VCxJQUFiLEVBQW1CdlQsUUFBTzd5QixhQUFZNXNCLElBQVosRUFBMUIsRUFBOEM7QUFDNUMsY0FBTThELFFBQVEyN0MsTUFBS2h6QyxLQUFuQjtBQUNBMHFFLHNCQUFZRCxpQkFBaUJwekUsS0FBakIsRUFBd0JxekUsU0FBeEIsQ0FBWjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFNdnFELGNBQWNpbUMsV0FBVzdvRSxJQUFYLENBQWdCeXRGLG1CQUFoQixDQUFwQjtBQUNBLDZCQUFVN3FELGVBQWUsSUFBekIsRUFBK0IsMENBQS9COztBQUVBLFFBQUl5cUQsc0JBQW9DLElBQXhDO0FBQ0EsUUFBSUMsbUJBQWlDLElBQXJDOztBQUVBLFFBQUlSLFdBQVduQixpQkFBZjtBQUNBLFFBQUlRLGtCQUFrQixDQUF0QjtBQUNBLFFBQUlhLFNBQVMsQ0FBYjtBQUNBLFFBQUlPLGVBQWUsSUFBbkI7O0FBRUEsUUFBSTkzQixPQUFPN3lCLFlBQVk1c0IsSUFBWixFQUFYO0FBQ0EsV0FFRTgyRSxhQUFhLElBQWIsSUFBcUIsQ0FBQ3IzQixLQUFLdVQsSUFGN0IsRUFHRWdrQixVQUFVdjNCLE9BQU83eUIsWUFBWTVzQixJQUFaLEVBSG5CLEVBSUU7QUFDQSxVQUFJODJFLFNBQVM3aEUsS0FBVCxHQUFpQitoRSxNQUFyQixFQUE2QjtBQUMzQk8sdUJBQWVULFFBQWY7QUFDQUEsbUJBQVcsSUFBWDtBQUNELE9BSEQsTUFHTztBQUNMUyx1QkFBZVQsU0FBU3p5RSxPQUF4QjtBQUNEO0FBQ0QsVUFBTTZ4RSxXQUFXVyxXQUNmdDVELFdBRGUsRUFFZnU1RCxRQUZlLEVBR2ZyM0IsS0FBS2h6QyxLQUhVLEVBSWY3YSxjQUplLENBQWpCO0FBTUEsVUFBSXNrRixhQUFhLElBQWpCLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSSxDQUFDWSxRQUFMLEVBQWU7QUFDYkEscUJBQVdTLFlBQVg7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxVQUFJL0Isc0JBQUosRUFBNEI7QUFDMUIsWUFBSXNCLFlBQVlaLFNBQVM5MUUsU0FBVCxLQUF1QixJQUF2QyxFQUE2QztBQUMzQztBQUNBO0FBQ0FxMUUsc0JBQVlsNEQsV0FBWixFQUF5QnU1RCxRQUF6QjtBQUNEO0FBQ0Y7QUFDRFgsd0JBQWtCRixXQUFXQyxRQUFYLEVBQXFCQyxlQUFyQixFQUFzQ2EsTUFBdEMsQ0FBbEI7QUFDQSxVQUFJTSxxQkFBcUIsSUFBekIsRUFBK0I7QUFDN0I7QUFDQUQsOEJBQXNCbkIsUUFBdEI7QUFDRCxPQUhELE1BR087QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBb0IseUJBQWlCanpFLE9BQWpCLEdBQTJCNnhFLFFBQTNCO0FBQ0Q7QUFDRG9CLHlCQUFtQnBCLFFBQW5CO0FBQ0FZLGlCQUFXUyxZQUFYO0FBQ0Q7O0FBRUQsUUFBSTkzQixLQUFLdVQsSUFBVCxFQUFlO0FBQ2I7QUFDQTBpQiw4QkFBd0JuNEQsV0FBeEIsRUFBcUN1NUQsUUFBckM7QUFDQSxhQUFPTyxtQkFBUDtBQUNEOztBQUVELFFBQUlQLGFBQWEsSUFBakIsRUFBdUI7QUFDckI7QUFDQTtBQUNBLGFBQU8sQ0FBQ3IzQixLQUFLdVQsSUFBYixFQUFtQmdrQixVQUFVdjNCLE9BQU83eUIsWUFBWTVzQixJQUFaLEVBQXBDLEVBQXdEO0FBQ3RELFlBQU1rMkUsYUFBV1UsWUFBWXI1RCxXQUFaLEVBQXlCa2lDLEtBQUtoekMsS0FBOUIsRUFBcUM3YSxjQUFyQyxDQUFqQjtBQUNBLFlBQUlza0YsZUFBYSxJQUFqQixFQUF1QjtBQUNyQjtBQUNEO0FBQ0RDLDBCQUFrQkYsV0FBV0MsVUFBWCxFQUFxQkMsZUFBckIsRUFBc0NhLE1BQXRDLENBQWxCO0FBQ0EsWUFBSU0scUJBQXFCLElBQXpCLEVBQStCO0FBQzdCO0FBQ0FELGdDQUFzQm5CLFVBQXRCO0FBQ0QsU0FIRCxNQUdPO0FBQ0xvQiwyQkFBaUJqekUsT0FBakIsR0FBMkI2eEUsVUFBM0I7QUFDRDtBQUNEb0IsMkJBQW1CcEIsVUFBbkI7QUFDRDtBQUNELGFBQU9tQixtQkFBUDtBQUNEOztBQUVEO0FBQ0EsUUFBTXhCLG1CQUFtQkQscUJBQXFCcjRELFdBQXJCLEVBQWtDdTVELFFBQWxDLENBQXpCOztBQUVBO0FBQ0EsV0FBTyxDQUFDcjNCLEtBQUt1VCxJQUFiLEVBQW1CZ2tCLFVBQVV2M0IsT0FBTzd5QixZQUFZNXNCLElBQVosRUFBcEMsRUFBd0Q7QUFDdEQsVUFBTWsyRSxhQUFXYSxjQUNmbEIsZ0JBRGUsRUFFZnQ0RCxXQUZlLEVBR2Z5NUQsTUFIZSxFQUlmdjNCLEtBQUtoekMsS0FKVSxFQUtmN2EsY0FMZSxDQUFqQjtBQU9BLFVBQUlza0YsZUFBYSxJQUFqQixFQUF1QjtBQUNyQixZQUFJVixzQkFBSixFQUE0QjtBQUMxQixjQUFJVSxXQUFTOTFFLFNBQVQsS0FBdUIsSUFBM0IsRUFBaUM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQXkxRSw2QkFBaUJqNUQsTUFBakIsQ0FDRXM1RCxXQUFTbnZFLEdBQVQsS0FBaUIsSUFBakIsR0FBd0Jpd0UsTUFBeEIsR0FBaUNkLFdBQVNudkUsR0FENUM7QUFHRDtBQUNGO0FBQ0RvdkUsMEJBQWtCRixXQUFXQyxVQUFYLEVBQXFCQyxlQUFyQixFQUFzQ2EsTUFBdEMsQ0FBbEI7QUFDQSxZQUFJTSxxQkFBcUIsSUFBekIsRUFBK0I7QUFDN0JELGdDQUFzQm5CLFVBQXRCO0FBQ0QsU0FGRCxNQUVPO0FBQ0xvQiwyQkFBaUJqekUsT0FBakIsR0FBMkI2eEUsVUFBM0I7QUFDRDtBQUNEb0IsMkJBQW1CcEIsVUFBbkI7QUFDRDtBQUNGOztBQUVELFFBQUlWLHNCQUFKLEVBQTRCO0FBQzFCO0FBQ0E7QUFDQUssdUJBQWlCM29FLE9BQWpCLENBQXlCO0FBQUEsZUFBU3VvRSxZQUFZbDRELFdBQVosRUFBeUJ6WixLQUF6QixDQUFUO0FBQUEsT0FBekI7QUFDRDs7QUFFRCxXQUFPdXpFLG1CQUFQO0FBQ0Q7O0FBRUQsV0FBU00sdUJBQVQsQ0FDRXA2RCxXQURGLEVBRUVvNEQsaUJBRkYsRUFHRW5pQyxXQUhGLEVBSUU1aEQsY0FKRixFQUtTO0FBQ1A7QUFDQTtBQUNBLFFBQUkrakYsc0JBQXNCLElBQXRCLElBQThCQSxrQkFBa0Ixb0YsR0FBbEIsS0FBMEJyQix1QkFBNUQsRUFBc0U7QUFDcEU7QUFDQTtBQUNBOHBGLDhCQUF3Qm40RCxXQUF4QixFQUFxQ280RCxrQkFBa0J0eEUsT0FBdkQ7QUFDQSxVQUFNb3lFLFdBQVdWLFNBQVNKLGlCQUFULEVBQTRCbmlDLFdBQTVCLEVBQXlDNWhELGNBQXpDLENBQWpCO0FBQ0E2a0YsZUFBUzdtRixNQUFULEdBQWtCMnRCLFdBQWxCO0FBQ0EsYUFBT2s1RCxRQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0FmLDRCQUF3Qm40RCxXQUF4QixFQUFxQ280RCxpQkFBckM7QUFDQSxRQUFNYSxVQUFVLHFDQUNkaGpDLFdBRGMsRUFFZGoyQixZQUFZemMsSUFGRSxFQUdkbFAsY0FIYyxDQUFoQjtBQUtBNGtGLFlBQVE1bUYsTUFBUixHQUFpQjJ0QixXQUFqQjtBQUNBLFdBQU9pNUQsT0FBUDtBQUNEOztBQUVELFdBQVNvQixzQkFBVCxDQUNFcjZELFdBREYsRUFFRW80RCxpQkFGRixFQUdFcC9ELE9BSEYsRUFJRTNrQixjQUpGLEVBS1M7QUFDUCxRQUFNbVYsTUFBTXdQLFFBQVF4UCxHQUFwQjtBQUNBLFFBQUlqRCxRQUFRNnhFLGlCQUFaO0FBQ0EsV0FBTzd4RSxVQUFVLElBQWpCLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQSxVQUFJQSxNQUFNaUQsR0FBTixLQUFjQSxHQUFsQixFQUF1QjtBQUNyQixZQUNFakQsTUFBTTdXLEdBQU4sS0FBY3BCLHVCQUFkLEdBQ0kwcUIsUUFBUXZwQixJQUFSLEtBQWlCRyxpQ0FEckIsR0FFSTJXLE1BQU1rUixXQUFOLEtBQXNCdUIsUUFBUXZwQixJQUhwQyxFQUlFO0FBQ0Ewb0Ysa0NBQXdCbjRELFdBQXhCLEVBQXFDelosTUFBTU8sT0FBM0M7QUFDQSxjQUFNb3lFLFdBQVdWLFNBQ2ZqeUUsS0FEZSxFQUVmeVMsUUFBUXZwQixJQUFSLEtBQWlCRyxpQ0FBakIsR0FDSW9wQixRQUFRMVksS0FBUixDQUFjc1ksUUFEbEIsR0FFSUksUUFBUTFZLEtBSkcsRUFLZmpNLGNBTGUsQ0FBakI7QUFPQTZrRixtQkFBU3ZoRSxHQUFULEdBQWUrL0QsVUFBVTEzRCxXQUFWLEVBQXVCelosS0FBdkIsRUFBOEJ5UyxPQUE5QixDQUFmO0FBQ0FrZ0UsbUJBQVM3bUYsTUFBVCxHQUFrQjJ0QixXQUFsQjtBQUNBLGNBQUlsMUIsSUFBSixFQUFhO0FBQ1hvdUYscUJBQVNsbkYsWUFBVCxHQUF3QmduQixRQUFRRSxPQUFoQztBQUNBZ2dFLHFCQUFTcG5GLFdBQVQsR0FBdUJrbkIsUUFBUUMsTUFBL0I7QUFDRDtBQUNELGlCQUFPaWdFLFFBQVA7QUFDRCxTQXBCRCxNQW9CTztBQUNMZixrQ0FBd0JuNEQsV0FBeEIsRUFBcUN6WixLQUFyQztBQUNBO0FBQ0Q7QUFDRixPQXpCRCxNQXlCTztBQUNMMnhFLG9CQUFZbDRELFdBQVosRUFBeUJ6WixLQUF6QjtBQUNEO0FBQ0RBLGNBQVFBLE1BQU1PLE9BQWQ7QUFDRDs7QUFFRCxRQUFJa1MsUUFBUXZwQixJQUFSLEtBQWlCRyxpQ0FBckIsRUFBMEM7QUFDeEMsVUFBTXFwRixVQUFVLHlDQUNkamdFLFFBQVExWSxLQUFSLENBQWNzWSxRQURBLEVBRWRvSCxZQUFZemMsSUFGRSxFQUdkbFAsY0FIYyxFQUlkMmtCLFFBQVF4UCxHQUpNLENBQWhCO0FBTUF5dkUsY0FBUTVtRixNQUFSLEdBQWlCMnRCLFdBQWpCO0FBQ0EsYUFBT2k1RCxPQUFQO0FBQ0QsS0FURCxNQVNPO0FBQ0wsVUFBTUEsWUFBVSx3Q0FDZGpnRSxPQURjLEVBRWRnSCxZQUFZemMsSUFGRSxFQUdkbFAsY0FIYyxDQUFoQjtBQUtBNGtGLGdCQUFRdGhFLEdBQVIsR0FBYysvRCxVQUFVMTNELFdBQVYsRUFBdUJvNEQsaUJBQXZCLEVBQTBDcC9ELE9BQTFDLENBQWQ7QUFDQWlnRSxnQkFBUTVtRixNQUFSLEdBQWlCMnRCLFdBQWpCO0FBQ0EsYUFBT2k1RCxTQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTcUIscUJBQVQsQ0FDRXQ2RCxXQURGLEVBRUVvNEQsaUJBRkYsRUFHRTcrRCxNQUhGLEVBSUVsbEIsY0FKRixFQUtTO0FBQ1AsUUFBTW1WLE1BQU0rUCxPQUFPL1AsR0FBbkI7QUFDQSxRQUFJakQsUUFBUTZ4RSxpQkFBWjtBQUNBLFdBQU83eEUsVUFBVSxJQUFqQixFQUF1QjtBQUNyQjtBQUNBO0FBQ0EsVUFBSUEsTUFBTWlELEdBQU4sS0FBY0EsR0FBbEIsRUFBdUI7QUFDckIsWUFDRWpELE1BQU03VyxHQUFOLEtBQWN2Qix5QkFBZCxJQUNBb1ksTUFBTWxHLFNBQU4sQ0FBZ0JtWixhQUFoQixLQUFrQ0QsT0FBT0MsYUFEekMsSUFFQWpULE1BQU1sRyxTQUFOLENBQWdCcVosY0FBaEIsS0FBbUNILE9BQU9HLGNBSDVDLEVBSUU7QUFDQXkrRCxrQ0FBd0JuNEQsV0FBeEIsRUFBcUN6WixNQUFNTyxPQUEzQztBQUNBLGNBQU1veUUsV0FBV1YsU0FDZmp5RSxLQURlLEVBRWZnVCxPQUFPWCxRQUFQLElBQW1CLEVBRkosRUFHZnZrQixjQUhlLENBQWpCO0FBS0E2a0YsbUJBQVM3bUYsTUFBVCxHQUFrQjJ0QixXQUFsQjtBQUNBLGlCQUFPazVELFFBQVA7QUFDRCxTQWJELE1BYU87QUFDTGYsa0NBQXdCbjRELFdBQXhCLEVBQXFDelosS0FBckM7QUFDQTtBQUNEO0FBQ0YsT0FsQkQsTUFrQk87QUFDTDJ4RSxvQkFBWWw0RCxXQUFaLEVBQXlCelosS0FBekI7QUFDRDtBQUNEQSxjQUFRQSxNQUFNTyxPQUFkO0FBQ0Q7O0FBRUQsUUFBTW15RSxVQUFVLHVDQUNkMS9ELE1BRGMsRUFFZHlHLFlBQVl6YyxJQUZFLEVBR2RsUCxjQUhjLENBQWhCO0FBS0E0a0YsWUFBUTVtRixNQUFSLEdBQWlCMnRCLFdBQWpCO0FBQ0EsV0FBT2k1RCxPQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBU3NCLG9CQUFULENBQ0V2NkQsV0FERixFQUVFbzRELGlCQUZGLEVBR0Uzc0QsUUFIRixFQUlFcDNCLGNBSkYsRUFLZ0I7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFNbW1GLDRCQUNKLFFBQU8vdUQsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUFwQixJQUNBQSxhQUFhLElBRGIsSUFFQUEsU0FBU2g4QixJQUFULEtBQWtCRyxpQ0FGbEIsSUFHQTY3QixTQUFTamlCLEdBQVQsS0FBaUIsSUFKbkI7QUFLQSxRQUFJZ3hFLHlCQUFKLEVBQStCO0FBQzdCL3VELGlCQUFXQSxTQUFTbnJCLEtBQVQsQ0FBZXNZLFFBQTFCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFNNmhFLFdBQVcsUUFBT2h2RCxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXBCLElBQWdDQSxhQUFhLElBQTlEOztBQUVBLFFBQUlndkQsUUFBSixFQUFjO0FBQ1osY0FBUWh2RCxTQUFTeDdCLFFBQWpCO0FBQ0UsYUFBS2EsZ0NBQUw7QUFDRSxpQkFBT2lvRixpQkFDTHNCLHVCQUNFcjZELFdBREYsRUFFRW80RCxpQkFGRixFQUdFM3NELFFBSEYsRUFJRXAzQixjQUpGLENBREssQ0FBUDtBQVFGLGFBQUt4RSwrQkFBTDtBQUNFLGlCQUFPa3BGLGlCQUNMdUIsc0JBQ0V0NkQsV0FERixFQUVFbzRELGlCQUZGLEVBR0Uzc0QsUUFIRixFQUlFcDNCLGNBSkYsQ0FESyxDQUFQO0FBWEo7QUFvQkQ7O0FBRUQsUUFBSSxPQUFPbzNCLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0MsT0FBT0EsUUFBUCxLQUFvQixRQUF4RCxFQUFrRTtBQUNoRSxhQUFPc3RELGlCQUNMcUIsd0JBQ0VwNkQsV0FERixFQUVFbzRELGlCQUZGLEVBR0UsS0FBSzNzRCxRQUhQLEVBSUVwM0IsY0FKRixDQURLLENBQVA7QUFRRDs7QUFFRCxRQUFJNi9CLFFBQVF6SSxRQUFSLENBQUosRUFBdUI7QUFDckIsYUFBT291RCx1QkFDTDc1RCxXQURLLEVBRUxvNEQsaUJBRkssRUFHTDNzRCxRQUhLLEVBSUxwM0IsY0FKSyxDQUFQO0FBTUQ7O0FBRUQsUUFBSSxpQ0FBY28zQixRQUFkLENBQUosRUFBNkI7QUFDM0IsYUFBT3d1RCwwQkFDTGo2RCxXQURLLEVBRUxvNEQsaUJBRkssRUFHTDNzRCxRQUhLLEVBSUxwM0IsY0FKSyxDQUFQO0FBTUQ7O0FBRUQsUUFBSW9tRixRQUFKLEVBQWM7QUFDWjNDLCtCQUF5QjkzRCxXQUF6QixFQUFzQ3lMLFFBQXRDO0FBQ0Q7O0FBRUQsUUFBSTNnQyxJQUFKLEVBQWE7QUFDWCxVQUFJLE9BQU8yZ0MsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ3NzRDtBQUNEO0FBQ0Y7QUFDRCxRQUFJLE9BQU90c0QsUUFBUCxLQUFvQixXQUFwQixJQUFtQyxDQUFDK3VELHlCQUF4QyxFQUFtRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxjQUFReDZELFlBQVl0d0IsR0FBcEI7QUFDRSxhQUFLMUIsNkJBQUw7QUFBcUI7QUFDbkIsZ0JBQUlsRCxJQUFKLEVBQWE7QUFDWCxrQkFBTW1PLFdBQVcrbUIsWUFBWTNmLFNBQTdCO0FBQ0Esa0JBQUlwSCxTQUFTNUksTUFBVCxDQUFnQnFxRixlQUFwQixFQUFxQztBQUNuQztBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBSzNzRixnQ0FBTDtBQUF3QjtBQUN0QixnQkFBTSthLFlBQVlrWCxZQUFZdndCLElBQTlCO0FBQ0EscUNBQ0UsS0FERixFQUVFLHFFQUNFLHNEQURGLEdBRUUsY0FKSixFQUtFcVosVUFBVXZaLFdBQVYsSUFBeUJ1WixVQUFVamQsSUFBbkMsSUFBMkMsV0FMN0M7QUFPRDtBQXRCSDtBQXdCRDs7QUFFRDtBQUNBLFdBQU9zc0Ysd0JBQXdCbjRELFdBQXhCLEVBQXFDbzRELGlCQUFyQyxDQUFQO0FBQ0Q7O0FBRUQsU0FBT21DLG9CQUFQO0FBQ0Q7O0FBRU0sSUFBTUEsc0RBQXVCdkMsZ0JBQWdCLElBQWhCLENBQTdCO0FBQ0EsSUFBTTJDLDhDQUFtQjNDLGdCQUFnQixLQUFoQixDQUF6Qjs7QUFFQSxTQUFTWCxnQkFBVCxDQUNML2tGLE9BREssRUFFTEosY0FGSyxFQUdDO0FBQ04sMkJBQ0VJLFlBQVksSUFBWixJQUFvQkosZUFBZXFVLEtBQWYsS0FBeUJqVSxRQUFRaVUsS0FEdkQsRUFFRSxvQ0FGRjs7QUFLQSxNQUFJclUsZUFBZXFVLEtBQWYsS0FBeUIsSUFBN0IsRUFBbUM7QUFDakM7QUFDRDs7QUFFRCxNQUFJK2tCLGVBQWVwNUIsZUFBZXFVLEtBQWxDO0FBQ0EsTUFBSWtsQixXQUFXLHNDQUNiSCxZQURhLEVBRWJBLGFBQWE5VCxZQUZBLEVBR2I4VCxhQUFhajNCLGNBSEEsQ0FBZjtBQUtBbkMsaUJBQWVxVSxLQUFmLEdBQXVCa2xCLFFBQXZCOztBQUVBQSxXQUFTcDVCLE1BQVQsR0FBa0JILGNBQWxCO0FBQ0EsU0FBT281QixhQUFheGtCLE9BQWIsS0FBeUIsSUFBaEMsRUFBc0M7QUFDcEN3a0IsbUJBQWVBLGFBQWF4a0IsT0FBNUI7QUFDQTJrQixlQUFXQSxTQUFTM2tCLE9BQVQsR0FBbUIsc0NBQzVCd2tCLFlBRDRCLEVBRTVCQSxhQUFhOVQsWUFGZSxFQUc1QjhULGFBQWFqM0IsY0FIZSxDQUE5QjtBQUtBbzNCLGFBQVNwNUIsTUFBVCxHQUFrQkgsY0FBbEI7QUFDRDtBQUNEdTVCLFdBQVMza0IsT0FBVCxHQUFtQixJQUFuQjtBQUNELEM7Ozs7Ozs7Ozs7Ozs7O0FDNTBDRDs7QUFxQkE7O0FBUUE7Ozs7QUFFQTs7QUFnQkE7O0FBTUE7O0FBS0E7O0FBQ0E7O0FBTUE7Ozs7QUF0RkE7Ozs7Ozs7OztBQXdGQSxTQUFTOHpFLFVBQVQsQ0FBb0Ixb0YsY0FBcEIsRUFBMkM7QUFDekM7QUFDQTtBQUNBQSxpQkFBZXVSLFNBQWYsSUFBNEI1USwyQkFBNUI7QUFDRDs7QUFFRCxTQUFTbTVCLE9BQVQsQ0FBaUI5NUIsY0FBakIsRUFBd0M7QUFDdENBLGlCQUFldVIsU0FBZixJQUE0QnRRLHdCQUE1QjtBQUNEOztBQUVELElBQUkwbkYsMkJBQUo7QUFDQSxJQUFJQyw0QkFBSjtBQUNBLElBQUlsdUQsNEJBQUo7QUFDQSxJQUFJRSx1QkFBSjtBQUNBLElBQUlzckIsc0NBQUosRUFBc0I7QUFDcEI7O0FBRUF5aUMsdUJBQW9CLDJCQUNsQngwRSxNQURrQixFQUVsQm5VLGNBRmtCLEVBR2xCNm9GLHFCQUhrQixFQUlsQjVpQyxRQUprQixFQUtsQjtBQUNBO0FBQ0E7QUFDQSxRQUFJL2xELE9BQU9GLGVBQWVxVSxLQUExQjtBQUNBLFdBQU9uVSxTQUFTLElBQWhCLEVBQXNCO0FBQ3BCLFVBQUlBLEtBQUsxQyxHQUFMLEtBQWF0Qiw0QkFBYixJQUE4QmdFLEtBQUsxQyxHQUFMLEtBQWFyQix1QkFBL0MsRUFBeUQ7QUFDdkQsc0RBQW1CZ1ksTUFBbkIsRUFBMkJqVSxLQUFLaU8sU0FBaEM7QUFDRCxPQUZELE1BRU8sSUFBSWpPLEtBQUsxQyxHQUFMLEtBQWF2Qix5QkFBakIsRUFBNkI7QUFDbEM7QUFDQTtBQUNBO0FBQ0QsT0FKTSxNQUlBLElBQUlpRSxLQUFLbVUsS0FBTCxLQUFlLElBQW5CLEVBQXlCO0FBQzlCblUsYUFBS21VLEtBQUwsQ0FBV2xVLE1BQVgsR0FBb0JELElBQXBCO0FBQ0FBLGVBQU9BLEtBQUttVSxLQUFaO0FBQ0E7QUFDRDtBQUNELFVBQUluVSxTQUFTRixjQUFiLEVBQTZCO0FBQzNCO0FBQ0Q7QUFDRCxhQUFPRSxLQUFLMFUsT0FBTCxLQUFpQixJQUF4QixFQUE4QjtBQUM1QixZQUFJMVUsS0FBS0MsTUFBTCxLQUFnQixJQUFoQixJQUF3QkQsS0FBS0MsTUFBTCxLQUFnQkgsY0FBNUMsRUFBNEQ7QUFDMUQ7QUFDRDtBQUNERSxlQUFPQSxLQUFLQyxNQUFaO0FBQ0Q7QUFDREQsV0FBSzBVLE9BQUwsQ0FBYXpVLE1BQWIsR0FBc0JELEtBQUtDLE1BQTNCO0FBQ0FELGFBQU9BLEtBQUswVSxPQUFaO0FBQ0Q7QUFDRixHQWpDRDs7QUFtQ0FnMEUsd0JBQXNCLDZCQUFTNW9GLGNBQVQsRUFBZ0M7QUFDcEQ7QUFDRCxHQUZEO0FBR0EwNkIsd0JBQXNCLDZCQUNwQnQ2QixPQURvQixFQUVwQkosY0FGb0IsRUFHcEJ6QyxJQUhvQixFQUlwQnkvQixRQUpvQixFQUtwQjJtQixxQkFMb0IsRUFNcEI7QUFDQTtBQUNBO0FBQ0EsUUFBTTFtQixXQUFXNzhCLFFBQVFzbEIsYUFBekI7QUFDQSxRQUFJdVgsYUFBYUQsUUFBakIsRUFBMkI7QUFDekI7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNajJCLFdBQXFCL0csZUFBZW1PLFNBQTFDO0FBQ0EsUUFBTTI2RSxxQkFBcUIsNENBQTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTWpsQyxnQkFBZ0IseUNBQ3BCOThDLFFBRG9CLEVBRXBCeEosSUFGb0IsRUFHcEIwL0IsUUFIb0IsRUFJcEJELFFBSm9CLEVBS3BCMm1CLHFCQUxvQixFQU1wQm1sQyxrQkFOb0IsQ0FBdEI7QUFRQTtBQUNBOW9GLG1CQUFlOFEsV0FBZixHQUE4Qit5QyxhQUE5QjtBQUNBO0FBQ0E7QUFDQSxRQUFJQSxhQUFKLEVBQW1CO0FBQ2pCNmtDLGlCQUFXMW9GLGNBQVg7QUFDRDtBQUNGLEdBeENEO0FBeUNBNDZCLG1CQUFpQix3QkFDZng2QixPQURlLEVBRWZKLGNBRmUsRUFHZituRCxPQUhlLEVBSWZELE9BSmUsRUFLZjtBQUNBO0FBQ0EsUUFBSUMsWUFBWUQsT0FBaEIsRUFBeUI7QUFDdkI0Z0MsaUJBQVcxb0YsY0FBWDtBQUNEO0FBQ0YsR0FWRDtBQVdELENBN0ZELE1BNkZPLElBQUl5bUQseUNBQUosRUFBeUI7QUFDOUI7O0FBRUFraUMsdUJBQW9CLDJCQUNsQngwRSxNQURrQixFQUVsQm5VLGNBRmtCLEVBR2xCNm9GLHFCQUhrQixFQUlsQjVpQyxRQUprQixFQUtsQjtBQUNBO0FBQ0E7QUFDQSxRQUFJL2xELE9BQU9GLGVBQWVxVSxLQUExQjtBQUNBLFdBQU9uVSxTQUFTLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E2b0YsZ0JBQVUsSUFBSTdvRixLQUFLMUMsR0FBTCxLQUFhdEIsNEJBQWpCLEVBQWdDO0FBQ3hDLFlBQUk2SyxXQUFXN0csS0FBS2lPLFNBQXBCO0FBQ0EsWUFBSTA2RSxxQkFBSixFQUEyQjtBQUN6QixjQUFNejZFLFFBQVFsTyxLQUFLd2xCLGFBQW5CO0FBQ0EsY0FBTW5vQixPQUFPMkMsS0FBSzNDLElBQWxCO0FBQ0EsY0FBSTBvRCxRQUFKLEVBQWM7QUFDWjtBQUNBbC9DLHVCQUFXLCtDQUFvQkEsUUFBcEIsRUFBOEJ4SixJQUE5QixFQUFvQzZRLEtBQXBDLEVBQTJDbE8sSUFBM0MsQ0FBWDtBQUNELFdBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQTtBQUNBNkcsdUJBQVcsaURBQXNCQSxRQUF0QixFQUFnQ3hKLElBQWhDLEVBQXNDNlEsS0FBdEMsRUFBNkNsTyxJQUE3QyxDQUFYO0FBQ0Q7QUFDREEsZUFBS2lPLFNBQUwsR0FBaUJwSCxRQUFqQjtBQUNEO0FBQ0Qsc0RBQW1Cb04sTUFBbkIsRUFBMkJwTixRQUEzQjtBQUNELE9BakJTLE1BaUJILElBQUk3RyxLQUFLMUMsR0FBTCxLQUFhckIsdUJBQWpCLEVBQTJCO0FBQ2hDLFlBQUk0SyxZQUFXN0csS0FBS2lPLFNBQXBCO0FBQ0EsWUFBSTA2RSxxQkFBSixFQUEyQjtBQUN6QixjQUFNMXpELE9BQU9qMUIsS0FBS3dsQixhQUFsQjtBQUNBLGNBQU1pK0Isd0JBQXdCLGtEQUE5QjtBQUNBLGNBQU1tbEMscUJBQXFCLDRDQUEzQjtBQUNBLGNBQUk3aUMsUUFBSixFQUFjO0FBQ1psL0Msd0JBQVcsb0RBQ1RvdUIsSUFEUyxFQUVUd3VCLHFCQUZTLEVBR1RtbEMsa0JBSFMsRUFJVDlvRixjQUpTLENBQVg7QUFNRCxXQVBELE1BT087QUFDTCtHLHdCQUFXLDhDQUNUb3VCLElBRFMsRUFFVHd1QixxQkFGUyxFQUdUbWxDLGtCQUhTLEVBSVQ5b0YsY0FKUyxDQUFYO0FBTUQ7QUFDREUsZUFBS2lPLFNBQUwsR0FBaUJwSCxTQUFqQjtBQUNEO0FBQ0Qsc0RBQW1Cb04sTUFBbkIsRUFBMkJwTixTQUEzQjtBQUNELE9BeEJNLE1Bd0JBLElBQUk3RyxLQUFLMUMsR0FBTCxLQUFhdkIseUJBQWpCLEVBQTZCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNELE9BSk0sTUFJQSxJQUFJaUUsS0FBSzFDLEdBQUwsS0FBYWQsZ0NBQWpCLEVBQW9DO0FBQ3pDLFlBQU0wRCxVQUFVRixLQUFLeVEsU0FBckI7QUFDQSxZQUFJdlEsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixjQUFNeTNDLFdBQTBCejNDLFFBQVEyUSxhQUF4QztBQUNBLGNBQU0rbUMsV0FBMEI1M0MsS0FBSzZRLGFBQXJDO0FBQ0EsY0FBTWk0RSxjQUFjbnhDLGFBQWEsSUFBakM7QUFDQSxjQUFNb3hDLGNBQWNueEMsYUFBYSxJQUFqQztBQUNBLGNBQUlreEMsZ0JBQWdCQyxXQUFwQixFQUFpQztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBTWhoQyxxQkFBcUJnaEMsY0FBYy9vRixLQUFLbVUsS0FBbkIsR0FBMkJuVSxJQUF0RDtBQUNBLGdCQUFJK25ELHVCQUF1QixJQUEzQixFQUFpQztBQUMvQjBnQyxpQ0FBa0J4MEUsTUFBbEIsRUFBMEI4ekMsa0JBQTFCLEVBQThDLElBQTlDLEVBQW9EZ2hDLFdBQXBEO0FBQ0Q7QUFDRDtBQUNBLGtCQUFNRixRQUFOO0FBQ0Q7QUFDRjtBQUNELFlBQUk3b0YsS0FBS21VLEtBQUwsS0FBZSxJQUFuQixFQUF5QjtBQUN2QjtBQUNBblUsZUFBS21VLEtBQUwsQ0FBV2xVLE1BQVgsR0FBb0JELElBQXBCO0FBQ0FBLGlCQUFPQSxLQUFLbVUsS0FBWjtBQUNBO0FBQ0Q7QUFDRixPQXpCTSxNQXlCQSxJQUFJblUsS0FBS21VLEtBQUwsS0FBZSxJQUFuQixFQUF5QjtBQUM5Qm5VLGFBQUttVSxLQUFMLENBQVdsVSxNQUFYLEdBQW9CRCxJQUFwQjtBQUNBQSxlQUFPQSxLQUFLbVUsS0FBWjtBQUNBO0FBQ0Q7QUFDRDtBQUNBblUsYUFBUUEsSUFBUjtBQUNBLFVBQUlBLFNBQVNGLGNBQWIsRUFBNkI7QUFDM0I7QUFDRDtBQUNELGFBQU9FLEtBQUswVSxPQUFMLEtBQWlCLElBQXhCLEVBQThCO0FBQzVCLFlBQUkxVSxLQUFLQyxNQUFMLEtBQWdCLElBQWhCLElBQXdCRCxLQUFLQyxNQUFMLEtBQWdCSCxjQUE1QyxFQUE0RDtBQUMxRDtBQUNEO0FBQ0RFLGVBQU9BLEtBQUtDLE1BQVo7QUFDRDtBQUNERCxXQUFLMFUsT0FBTCxDQUFhelUsTUFBYixHQUFzQkQsS0FBS0MsTUFBM0I7QUFDQUQsYUFBT0EsS0FBSzBVLE9BQVo7QUFDRDtBQUNGLEdBcEdEOztBQXNHQTtBQUNBLE1BQU1zMEUsK0JBQStCLFNBQS9CQSw0QkFBK0IsQ0FDbkNDLGlCQURtQyxFQUVuQ25wRixjQUZtQyxFQUduQzZvRixxQkFIbUMsRUFJbkM1aUMsUUFKbUMsRUFLbkM7QUFDQTtBQUNBO0FBQ0EsUUFBSS9sRCxPQUFPRixlQUFlcVUsS0FBMUI7QUFDQSxXQUFPblUsU0FBUyxJQUFoQixFQUFzQjtBQUNwQjtBQUNBNm9GLGdCQUFVLElBQUk3b0YsS0FBSzFDLEdBQUwsS0FBYXRCLDRCQUFqQixFQUFnQztBQUN4QyxZQUFJNkssV0FBVzdHLEtBQUtpTyxTQUFwQjtBQUNBLFlBQUkwNkUscUJBQUosRUFBMkI7QUFDekIsY0FBTXo2RSxRQUFRbE8sS0FBS3dsQixhQUFuQjtBQUNBLGNBQU1ub0IsT0FBTzJDLEtBQUszQyxJQUFsQjtBQUNBLGNBQUkwb0QsUUFBSixFQUFjO0FBQ1o7QUFDQWwvQyx1QkFBVywrQ0FBb0JBLFFBQXBCLEVBQThCeEosSUFBOUIsRUFBb0M2USxLQUFwQyxFQUEyQ2xPLElBQTNDLENBQVg7QUFDRCxXQUhELE1BR087QUFDTDtBQUNBO0FBQ0E7QUFDQTZHLHVCQUFXLGlEQUFzQkEsUUFBdEIsRUFBZ0N4SixJQUFoQyxFQUFzQzZRLEtBQXRDLEVBQTZDbE8sSUFBN0MsQ0FBWDtBQUNEO0FBQ0RBLGVBQUtpTyxTQUFMLEdBQWlCcEgsUUFBakI7QUFDRDtBQUNELGtFQUErQm9pRixpQkFBL0IsRUFBa0RwaUYsUUFBbEQ7QUFDRCxPQWpCUyxNQWlCSCxJQUFJN0csS0FBSzFDLEdBQUwsS0FBYXJCLHVCQUFqQixFQUEyQjtBQUNoQyxZQUFJNEssYUFBVzdHLEtBQUtpTyxTQUFwQjtBQUNBLFlBQUkwNkUscUJBQUosRUFBMkI7QUFDekIsY0FBTTF6RCxPQUFPajFCLEtBQUt3bEIsYUFBbEI7QUFDQSxjQUFNaStCLHdCQUF3QixrREFBOUI7QUFDQSxjQUFNbWxDLHFCQUFxQiw0Q0FBM0I7QUFDQSxjQUFJN2lDLFFBQUosRUFBYztBQUNabC9DLHlCQUFXLG9EQUNUb3VCLElBRFMsRUFFVHd1QixxQkFGUyxFQUdUbWxDLGtCQUhTLEVBSVQ5b0YsY0FKUyxDQUFYO0FBTUQsV0FQRCxNQU9PO0FBQ0wrRyx5QkFBVyw4Q0FDVG91QixJQURTLEVBRVR3dUIscUJBRlMsRUFHVG1sQyxrQkFIUyxFQUlUOW9GLGNBSlMsQ0FBWDtBQU1EO0FBQ0RFLGVBQUtpTyxTQUFMLEdBQWlCcEgsVUFBakI7QUFDRDtBQUNELGtFQUErQm9pRixpQkFBL0IsRUFBa0RwaUYsVUFBbEQ7QUFDRCxPQXhCTSxNQXdCQSxJQUFJN0csS0FBSzFDLEdBQUwsS0FBYXZCLHlCQUFqQixFQUE2QjtBQUNsQztBQUNBO0FBQ0E7QUFDRCxPQUpNLE1BSUEsSUFBSWlFLEtBQUsxQyxHQUFMLEtBQWFkLGdDQUFqQixFQUFvQztBQUN6QyxZQUFNMEQsVUFBVUYsS0FBS3lRLFNBQXJCO0FBQ0EsWUFBSXZRLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsY0FBTXkzQyxXQUEwQnozQyxRQUFRMlEsYUFBeEM7QUFDQSxjQUFNK21DLFdBQTBCNTNDLEtBQUs2USxhQUFyQztBQUNBLGNBQU1pNEUsY0FBY254QyxhQUFhLElBQWpDO0FBQ0EsY0FBTW94QyxjQUFjbnhDLGFBQWEsSUFBakM7QUFDQSxjQUFJa3hDLGdCQUFnQkMsV0FBcEIsRUFBaUM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQU1oaEMscUJBQXFCZ2hDLGNBQWMvb0YsS0FBS21VLEtBQW5CLEdBQTJCblUsSUFBdEQ7QUFDQSxnQkFBSStuRCx1QkFBdUIsSUFBM0IsRUFBaUM7QUFDL0JpaEMsMkNBQ0VDLGlCQURGLEVBRUVsaEMsa0JBRkYsRUFHRSxJQUhGLEVBSUVnaEMsV0FKRjtBQU1EO0FBQ0Q7QUFDQSxrQkFBTUYsUUFBTjtBQUNEO0FBQ0Y7QUFDRCxZQUFJN29GLEtBQUttVSxLQUFMLEtBQWUsSUFBbkIsRUFBeUI7QUFDdkI7QUFDQW5VLGVBQUttVSxLQUFMLENBQVdsVSxNQUFYLEdBQW9CRCxJQUFwQjtBQUNBQSxpQkFBT0EsS0FBS21VLEtBQVo7QUFDQTtBQUNEO0FBQ0YsT0E5Qk0sTUE4QkEsSUFBSW5VLEtBQUttVSxLQUFMLEtBQWUsSUFBbkIsRUFBeUI7QUFDOUJuVSxhQUFLbVUsS0FBTCxDQUFXbFUsTUFBWCxHQUFvQkQsSUFBcEI7QUFDQUEsZUFBT0EsS0FBS21VLEtBQVo7QUFDQTtBQUNEO0FBQ0Q7QUFDQW5VLGFBQVFBLElBQVI7QUFDQSxVQUFJQSxTQUFTRixjQUFiLEVBQTZCO0FBQzNCO0FBQ0Q7QUFDRCxhQUFPRSxLQUFLMFUsT0FBTCxLQUFpQixJQUF4QixFQUE4QjtBQUM1QixZQUFJMVUsS0FBS0MsTUFBTCxLQUFnQixJQUFoQixJQUF3QkQsS0FBS0MsTUFBTCxLQUFnQkgsY0FBNUMsRUFBNEQ7QUFDMUQ7QUFDRDtBQUNERSxlQUFPQSxLQUFLQyxNQUFaO0FBQ0Q7QUFDREQsV0FBSzBVLE9BQUwsQ0FBYXpVLE1BQWIsR0FBc0JELEtBQUtDLE1BQTNCO0FBQ0FELGFBQU9BLEtBQUswVSxPQUFaO0FBQ0Q7QUFDRixHQXpHRDtBQTBHQWcwRSx3QkFBc0IsNkJBQVM1b0YsY0FBVCxFQUFnQztBQUNwRCxRQUFNK21ELGVBSUovbUQsZUFBZW1PLFNBSmpCO0FBS0EsUUFBTWk3RSxvQkFBb0JwcEYsZUFBZStQLFdBQWYsS0FBK0IsSUFBekQ7QUFDQSxRQUFJcTVFLGlCQUFKLEVBQXVCO0FBQ3JCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBTS9aLFlBQVl0b0IsYUFBYXovQixhQUEvQjtBQUNBLFVBQUkraEUsY0FBYyxtREFBd0JoYSxTQUF4QixDQUFsQjtBQUNBO0FBQ0E2WixtQ0FBNkJHLFdBQTdCLEVBQTBDcnBGLGNBQTFDLEVBQTBELEtBQTFELEVBQWlFLEtBQWpFO0FBQ0ErbUQsbUJBQWF4L0IsZUFBYixHQUErQjhoRSxXQUEvQjtBQUNBO0FBQ0FYLGlCQUFXMW9GLGNBQVg7QUFDQSwyREFBMEJxdkUsU0FBMUIsRUFBcUNnYSxXQUFyQztBQUNEO0FBQ0YsR0FuQkQ7QUFvQkEzdUQsd0JBQXNCLDZCQUNwQnQ2QixPQURvQixFQUVwQkosY0FGb0IsRUFHcEJ6QyxJQUhvQixFQUlwQnkvQixRQUpvQixFQUtwQjJtQixxQkFMb0IsRUFNcEI7QUFDQSxRQUFNMmxDLGtCQUFrQmxwRixRQUFRK04sU0FBaEM7QUFDQSxRQUFNOHVCLFdBQVc3OEIsUUFBUXNsQixhQUF6QjtBQUNBO0FBQ0E7QUFDQSxRQUFNMGpFLG9CQUFvQnBwRixlQUFlK1AsV0FBZixLQUErQixJQUF6RDtBQUNBLFFBQUlxNUUscUJBQXFCbnNELGFBQWFELFFBQXRDLEVBQWdEO0FBQzlDO0FBQ0E7QUFDQWg5QixxQkFBZW1PLFNBQWYsR0FBMkJtN0UsZUFBM0I7QUFDQTtBQUNEO0FBQ0QsUUFBTUMscUJBQStCdnBGLGVBQWVtTyxTQUFwRDtBQUNBLFFBQU0yNkUscUJBQXFCLDRDQUEzQjtBQUNBLFFBQUlqbEMsZ0JBQWdCLElBQXBCO0FBQ0EsUUFBSTVtQixhQUFhRCxRQUFqQixFQUEyQjtBQUN6QjZtQixzQkFBZ0IseUNBQ2QwbEMsa0JBRGMsRUFFZGhzRixJQUZjLEVBR2QwL0IsUUFIYyxFQUlkRCxRQUpjLEVBS2QybUIscUJBTGMsRUFNZG1sQyxrQkFOYyxDQUFoQjtBQVFEO0FBQ0QsUUFBSU0scUJBQXFCdmxDLGtCQUFrQixJQUEzQyxFQUFpRDtBQUMvQztBQUNBO0FBQ0E3akQscUJBQWVtTyxTQUFmLEdBQTJCbTdFLGVBQTNCO0FBQ0E7QUFDRDtBQUNELFFBQUlFLGNBQWMseUNBQ2hCRixlQURnQixFQUVoQnpsQyxhQUZnQixFQUdoQnRtRCxJQUhnQixFQUloQjAvQixRQUpnQixFQUtoQkQsUUFMZ0IsRUFNaEJoOUIsY0FOZ0IsRUFPaEJvcEYsaUJBUGdCLEVBUWhCRyxrQkFSZ0IsQ0FBbEI7QUFVQSxRQUNFLG1EQUNFQyxXQURGLEVBRUVqc0YsSUFGRixFQUdFeS9CLFFBSEYsRUFJRTJtQixxQkFKRixFQUtFbWxDLGtCQUxGLENBREYsRUFRRTtBQUNBSixpQkFBVzFvRixjQUFYO0FBQ0Q7QUFDREEsbUJBQWVtTyxTQUFmLEdBQTJCcTdFLFdBQTNCO0FBQ0EsUUFBSUosaUJBQUosRUFBdUI7QUFDckI7QUFDQTtBQUNBO0FBQ0FWLGlCQUFXMW9GLGNBQVg7QUFDRCxLQUxELE1BS087QUFDTDtBQUNBMm9GLHlCQUFrQmEsV0FBbEIsRUFBK0J4cEYsY0FBL0IsRUFBK0MsS0FBL0MsRUFBc0QsS0FBdEQ7QUFDRDtBQUNGLEdBcEVEO0FBcUVBNDZCLG1CQUFpQix3QkFDZng2QixPQURlLEVBRWZKLGNBRmUsRUFHZituRCxPQUhlLEVBSWZELE9BSmUsRUFLZjtBQUNBLFFBQUlDLFlBQVlELE9BQWhCLEVBQXlCO0FBQ3ZCO0FBQ0EsVUFBTW5FLHdCQUF3QixrREFBOUI7QUFDQSxVQUFNbWxDLHFCQUFxQiw0Q0FBM0I7QUFDQTlvRixxQkFBZW1PLFNBQWYsR0FBMkIsOENBQ3pCMjVDLE9BRHlCLEVBRXpCbkUscUJBRnlCLEVBR3pCbWxDLGtCQUh5QixFQUl6QjlvRixjQUp5QixDQUEzQjtBQU1BO0FBQ0E7QUFDQTBvRixpQkFBVzFvRixjQUFYO0FBQ0Q7QUFDRixHQXBCRDtBQXFCRCxDQWxVTSxNQWtVQTtBQUNMO0FBQ0E0b0Ysd0JBQXNCLDZCQUFTNW9GLGNBQVQsRUFBZ0M7QUFDcEQ7QUFDRCxHQUZEO0FBR0EwNkIsd0JBQXNCLDZCQUNwQnQ2QixPQURvQixFQUVwQkosY0FGb0IsRUFHcEJ6QyxJQUhvQixFQUlwQnkvQixRQUpvQixFQUtwQjJtQixxQkFMb0IsRUFNcEI7QUFDQTtBQUNELEdBUkQ7QUFTQS9vQixtQkFBaUIsd0JBQ2Z4NkIsT0FEZSxFQUVmSixjQUZlLEVBR2YrbkQsT0FIZSxFQUlmRCxPQUplLEVBS2Y7QUFDQTtBQUNELEdBUEQ7QUFRRDs7QUFFRCxTQUFTMmhDLFlBQVQsQ0FDRXJwRixPQURGLEVBRUVKLGNBRkYsRUFHRXlSLG9CQUhGLEVBSWdCO0FBQ2QsTUFBTXVyQixXQUFXaDlCLGVBQWVzbEIsWUFBaEM7O0FBRUEsVUFBUXRsQixlQUFleEMsR0FBdkI7QUFDRSxTQUFLekIscUNBQUw7QUFDRTtBQUNGLFNBQUtjLDRCQUFMO0FBQ0U7QUFDRixTQUFLRCxrQ0FBTDtBQUNBLFNBQUtmLGdDQUFMO0FBQ0U7QUFDRixTQUFLQyw2QkFBTDtBQUFxQjtBQUNuQixZQUFNOGEsWUFBWTVXLGVBQWV6QyxJQUFqQztBQUNBLFlBQUksMENBQXdCcVosU0FBeEIsQ0FBSixFQUF3QztBQUN0Qyw2Q0FBaUI1VyxjQUFqQjtBQUNEO0FBQ0Q7QUFDRDtBQUNELFNBQUtoRSx1QkFBTDtBQUFlO0FBQ2IscURBQWlCZ0UsY0FBakI7QUFDQSx5REFBK0JBLGNBQS9CO0FBQ0EsWUFBTTBwRixZQUFhMXBGLGVBQWVtTyxTQUFsQztBQUNBLFlBQUl1N0UsVUFBVXB2RCxjQUFkLEVBQThCO0FBQzVCb3ZELG9CQUFVejNFLE9BQVYsR0FBb0J5M0UsVUFBVXB2RCxjQUE5QjtBQUNBb3ZELG9CQUFVcHZELGNBQVYsR0FBMkIsSUFBM0I7QUFDRDtBQUNELFlBQUlsNkIsWUFBWSxJQUFaLElBQW9CQSxRQUFRaVUsS0FBUixLQUFrQixJQUExQyxFQUFnRDtBQUM5QztBQUNBO0FBQ0EsNkRBQWtCclUsY0FBbEI7QUFDQTtBQUNBO0FBQ0FBLHlCQUFldVIsU0FBZixJQUE0QixDQUFDN1EsOEJBQTdCO0FBQ0Q7QUFDRGtvRiw0QkFBb0I1b0YsY0FBcEI7QUFDQTtBQUNEO0FBQ0QsU0FBSzlELDRCQUFMO0FBQW9CO0FBQ2xCLG1EQUFlOEQsY0FBZjtBQUNBLFlBQU0yakQsd0JBQXdCLGtEQUE5QjtBQUNBLFlBQU1wbUQsT0FBT3lDLGVBQWV6QyxJQUE1QjtBQUNBLFlBQUk2QyxZQUFZLElBQVosSUFBb0JKLGVBQWVtTyxTQUFmLElBQTRCLElBQXBELEVBQTBEO0FBQ3hEdXNCLDhCQUNFdDZCLE9BREYsRUFFRUosY0FGRixFQUdFekMsSUFIRixFQUlFeS9CLFFBSkYsRUFLRTJtQixxQkFMRjs7QUFRQSxjQUFJdmpELFFBQVFxbEIsR0FBUixLQUFnQnpsQixlQUFleWxCLEdBQW5DLEVBQXdDO0FBQ3RDcVUsb0JBQVE5NUIsY0FBUjtBQUNEO0FBQ0YsU0FaRCxNQVlPO0FBQ0wsY0FBSSxDQUFDZzlCLFFBQUwsRUFBZTtBQUNiLHFDQUNFaDlCLGVBQWVtTyxTQUFmLEtBQTZCLElBRC9CLEVBRUUsaUVBQ0UsaURBSEo7QUFLQTtBQUNBO0FBQ0Q7O0FBRUQsY0FBTTI2RSxxQkFBcUIsNENBQTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFJYSxjQUFjLG1EQUFrQjNwRixjQUFsQixDQUFsQjtBQUNBLGNBQUkycEYsV0FBSixFQUFpQjtBQUNmO0FBQ0E7QUFDQSxnQkFDRSw4REFDRTNwRixjQURGLEVBRUUyakQscUJBRkYsRUFHRW1sQyxrQkFIRixDQURGLEVBTUU7QUFDQTtBQUNBO0FBQ0FKLHlCQUFXMW9GLGNBQVg7QUFDRDtBQUNGLFdBZEQsTUFjTztBQUNMLGdCQUFJK0csV0FBVywwQ0FDYnhKLElBRGEsRUFFYnkvQixRQUZhLEVBR2IybUIscUJBSGEsRUFJYm1sQyxrQkFKYSxFQUtiOW9GLGNBTGEsQ0FBZjs7QUFRQTJvRiwrQkFBa0I1aEYsUUFBbEIsRUFBNEIvRyxjQUE1QixFQUE0QyxLQUE1QyxFQUFtRCxLQUFuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFDRSxtREFDRStHLFFBREYsRUFFRXhKLElBRkYsRUFHRXkvQixRQUhGLEVBSUUybUIscUJBSkYsRUFLRW1sQyxrQkFMRixDQURGLEVBUUU7QUFDQUoseUJBQVcxb0YsY0FBWDtBQUNEO0FBQ0RBLDJCQUFlbU8sU0FBZixHQUEyQnBILFFBQTNCO0FBQ0Q7O0FBRUQsY0FBSS9HLGVBQWV5bEIsR0FBZixLQUF1QixJQUEzQixFQUFpQztBQUMvQjtBQUNBcVUsb0JBQVE5NUIsY0FBUjtBQUNEO0FBQ0Y7QUFDRDtBQUNEO0FBQ0QsU0FBSzdELHVCQUFMO0FBQWU7QUFDYixZQUFJMnJELFVBQVU5cUIsUUFBZDtBQUNBLFlBQUk1OEIsV0FBV0osZUFBZW1PLFNBQWYsSUFBNEIsSUFBM0MsRUFBaUQ7QUFDL0MsY0FBTTQ1QyxVQUFVM25ELFFBQVFzbEIsYUFBeEI7QUFDQTtBQUNBO0FBQ0FrVix5QkFBZXg2QixPQUFmLEVBQXdCSixjQUF4QixFQUF3QytuRCxPQUF4QyxFQUFpREQsT0FBakQ7QUFDRCxTQUxELE1BS087QUFDTCxjQUFJLE9BQU9BLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0IscUNBQ0U5bkQsZUFBZW1PLFNBQWYsS0FBNkIsSUFEL0IsRUFFRSxpRUFDRSxpREFISjtBQUtBO0FBQ0Q7QUFDRCxjQUFNdzFDLHlCQUF3QixrREFBOUI7QUFDQSxjQUFNbWxDLHNCQUFxQiw0Q0FBM0I7QUFDQSxjQUFJYSxlQUFjLG1EQUFrQjNwRixjQUFsQixDQUFsQjtBQUNBLGNBQUkycEYsWUFBSixFQUFpQjtBQUNmLGdCQUFJLGtFQUFpQzNwRixjQUFqQyxDQUFKLEVBQXNEO0FBQ3BEMG9GLHlCQUFXMW9GLGNBQVg7QUFDRDtBQUNGLFdBSkQsTUFJTztBQUNMQSwyQkFBZW1PLFNBQWYsR0FBMkIsOENBQ3pCMjVDLE9BRHlCLEVBRXpCbkUsc0JBRnlCLEVBR3pCbWxDLG1CQUh5QixFQUl6QjlvRixjQUp5QixDQUEzQjtBQU1EO0FBQ0Y7QUFDRDtBQUNEO0FBQ0QsU0FBS3hELHlCQUFMO0FBQ0U7QUFDRixTQUFLRSxnQ0FBTDtBQUF3QjtBQUN0QixZQUFNNFUsWUFBWXRSLGVBQWUrUSxhQUFqQztBQUNBLFlBQUksQ0FBQy9RLGVBQWV1UixTQUFmLEdBQTJCdlEsK0JBQTVCLE1BQTRDUiw2QkFBaEQsRUFBMEQ7QUFDeEQ7QUFDQVIseUJBQWVtQyxjQUFmLEdBQWdDc1Asb0JBQWhDO0FBQ0E7QUFDQSxpQkFBT3pSLGNBQVA7QUFDRDs7QUFFRCxZQUFNNDdCLGlCQUFpQnRxQixjQUFjLElBQXJDO0FBQ0EsWUFBTWdyQixpQkFBaUJsOEIsWUFBWSxJQUFaLElBQW9CQSxRQUFRMlEsYUFBUixLQUEwQixJQUFyRTs7QUFFQSxZQUFJM1EsWUFBWSxJQUFaLElBQW9CLENBQUN3N0IsY0FBckIsSUFBdUNVLGNBQTNDLEVBQTJEO0FBQ3pEO0FBQ0E7QUFDQTtBQUVBLGNBQU1zdEQsdUJBQXNDeHBGLFFBQVFpVSxLQUFULENBQXFCTyxPQUFoRTtBQUNBLGNBQUlnMUUseUJBQXlCLElBQTdCLEVBQW1DO0FBQ2pDO0FBQ0EsZ0JBQU1sMUUsUUFBUTFVLGVBQWUrUCxXQUE3QjtBQUNBLGdCQUFJMkUsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCMVUsNkJBQWUrUCxXQUFmLEdBQTZCNjVFLG9CQUE3QjtBQUNBQSxtQ0FBcUJwNUUsVUFBckIsR0FBa0NrRSxLQUFsQztBQUNELGFBSEQsTUFHTztBQUNMMVUsNkJBQWUrUCxXQUFmLEdBQTZCL1AsZUFBZWdRLFVBQWYsR0FBNEI0NUUsb0JBQXpEO0FBQ0FBLG1DQUFxQnA1RSxVQUFyQixHQUFrQyxJQUFsQztBQUNEO0FBQ0RvNUUsaUNBQXFCcjRFLFNBQXJCLEdBQWlDMVEsNkJBQWpDO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJKzZCLGtCQUFrQlUsY0FBdEIsRUFBc0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0F0OEIseUJBQWV1UixTQUFmLElBQTRCNVEsMkJBQTVCO0FBQ0Q7QUFDRDtBQUNEO0FBQ0QsU0FBS3ZFLHVCQUFMO0FBQ0U7QUFDRixTQUFLQyxtQkFBTDtBQUNFO0FBQ0YsU0FBS0ksdUJBQUw7QUFDRTtBQUNGLFNBQUtSLHlCQUFMO0FBQ0UsbURBQWlCK0QsY0FBakI7QUFDQTRvRiwwQkFBb0I1b0YsY0FBcEI7QUFDQTtBQUNGLFNBQUt6RCw4QkFBTDtBQUNFO0FBQ0EsNkNBQVl5RCxjQUFaO0FBQ0E7QUFDRixTQUFLMUQsOEJBQUw7QUFDRTtBQUNGLFNBQUtLLDRCQUFMO0FBQ0U7QUFDRixTQUFLRyx1Q0FBTDtBQUErQjtBQUM3QjtBQUNBO0FBQ0EsWUFBTThaLGFBQVk1VyxlQUFlekMsSUFBakM7QUFDQSxZQUFJLDBDQUF3QnFaLFVBQXhCLENBQUosRUFBd0M7QUFDdEMsNkNBQWlCNVcsY0FBakI7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxTQUFLakQsMENBQUw7QUFBa0M7QUFDaEMsWUFBSXZCLCtDQUFKLEVBQWtDO0FBQ2hDLGNBQUk0RSxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLGdCQUFJdXBGLGdCQUFjLG1EQUFrQjNwRixjQUFsQixDQUFsQjtBQUNBLHFDQUNFMnBGLGFBREYsRUFFRSw0RUFDRSxrQ0FISjtBQUtBLGdGQUFtQzNwRixjQUFuQztBQUNELFdBUkQsTUFRTyxJQUFJLENBQUNBLGVBQWV1UixTQUFmLEdBQTJCdlEsK0JBQTVCLE1BQTRDUiw2QkFBaEQsRUFBMEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0FKLG9CQUFRdVEsU0FBUixHQUFvQixJQUFwQjtBQUNBM1EsMkJBQWUyUSxTQUFmLEdBQTJCLElBQTNCO0FBQ0EzUSwyQkFBZXhDLEdBQWYsR0FBcUJkLGdDQUFyQjtBQUNBc0QsMkJBQWUrUSxhQUFmLEdBQStCLElBQS9CO0FBQ0EvUSwyQkFBZW1PLFNBQWYsR0FBMkIsSUFBM0I7QUFDRDtBQUNGO0FBQ0Q7QUFDRDtBQUNEO0FBQ0UsK0JBQ0UsS0FERixFQUVFLHVFQUNFLDhCQUhKO0FBblBKOztBQTBQQSxTQUFPLElBQVA7QUFDRDs7UUFFT3M3RSxZLEdBQUFBLFk7Ozs7Ozs7Ozs7Ozs7OzhRQ2p5QlI7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBVUE7O0FBT0E7O0FBSUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBT0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBS0E7O0FBQ0E7O0FBVUE7Ozs7QUFDQTs7OztBQUNBOztBQUtBOzs7O0FBRUEsSUFBTW5sQyxrQkFBa0IsT0FBT0MsT0FBUCxLQUFtQixVQUFuQixHQUFnQ0EsT0FBaEMsR0FBMEN2aUMsR0FBbEU7QUFDQSxJQUFNNm5FLGtCQUFrQixPQUFPQyxPQUFQLEtBQW1CLFVBQW5CLEdBQWdDQSxPQUFoQyxHQUEwQzVrRSxHQUFsRTs7QUFFQSxTQUFTNmtFLHFCQUFULENBQ0VycUYsS0FERixFQUVFa3dCLFNBRkYsRUFHRXp0QixjQUhGLEVBSWlCO0FBQ2YsTUFBTXVPLFNBQVMsb0NBQWF2TyxjQUFiLENBQWY7QUFDQTtBQUNBdU8sU0FBT2xULEdBQVAsR0FBYTRSLCtCQUFiO0FBQ0E7QUFDQTtBQUNBc0IsU0FBT0wsT0FBUCxHQUFpQixFQUFDeVcsU0FBUyxJQUFWLEVBQWpCO0FBQ0EsTUFBTXZ0QixRQUFRcTJCLFVBQVU1UyxLQUF4QjtBQUNBdE0sU0FBT0osUUFBUCxHQUFrQixZQUFNO0FBQ3RCLDhDQUFnQi9XLEtBQWhCO0FBQ0Esd0NBQVNtRyxLQUFULEVBQWdCa3dCLFNBQWhCO0FBQ0QsR0FIRDtBQUlBLFNBQU9sZixNQUFQO0FBQ0Q7O0FBRUQsU0FBU3M1RSxzQkFBVCxDQUNFdHFGLEtBREYsRUFFRWt3QixTQUZGLEVBR0V6dEIsY0FIRixFQUlpQjtBQUNmLE1BQU11TyxTQUFTLG9DQUFhdk8sY0FBYixDQUFmO0FBQ0F1TyxTQUFPbFQsR0FBUCxHQUFhNFIsK0JBQWI7QUFDQSxNQUFNc2dCLDJCQUEyQmh3QixNQUFNbkMsSUFBTixDQUFXbXlCLHdCQUE1QztBQUNBLE1BQUksT0FBT0Esd0JBQVAsS0FBb0MsVUFBeEMsRUFBb0Q7QUFDbEQsUUFBTW4yQixRQUFRcTJCLFVBQVU1UyxLQUF4QjtBQUNBdE0sV0FBT0wsT0FBUCxHQUFpQixZQUFNO0FBQ3JCLGFBQU9xZix5QkFBeUJuMkIsS0FBekIsQ0FBUDtBQUNELEtBRkQ7QUFHRDs7QUFFRCxNQUFNMlUsT0FBT3hPLE1BQU15TyxTQUFuQjtBQUNBLE1BQUlELFNBQVMsSUFBVCxJQUFpQixPQUFPQSxLQUFLeWhCLGlCQUFaLEtBQWtDLFVBQXZELEVBQW1FO0FBQ2pFamYsV0FBT0osUUFBUCxHQUFrQixTQUFTQSxRQUFULEdBQW9CO0FBQ3BDLFVBQUksT0FBT29mLHdCQUFQLEtBQW9DLFVBQXhDLEVBQW9EO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBZ0MsSUFBaEM7QUFDRDtBQUNELFVBQU1uMkIsUUFBUXEyQixVQUFVNVMsS0FBeEI7QUFDQSxVQUFNbmlCLFFBQVErMEIsVUFBVS8wQixLQUF4QjtBQUNBLDBDQUFTNkUsS0FBVCxFQUFnQmt3QixTQUFoQjtBQUNBLFdBQUtELGlCQUFMLENBQXVCcDJCLEtBQXZCLEVBQThCO0FBQzVCbXJELHdCQUFnQjdwRCxVQUFVLElBQVYsR0FBaUJBLEtBQWpCLEdBQXlCO0FBRGIsT0FBOUI7QUFHQSxVQUFJakMsSUFBSixFQUFhO0FBQ1gsWUFBSSxPQUFPODJCLHdCQUFQLEtBQW9DLFVBQXhDLEVBQW9EO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDZDQUNFaHdCLE1BQU15QyxjQUFOLEtBQXlCTCw4QkFEM0IsRUFFRSx1RUFDRSxtRkFISixFQUlFLGdDQUFpQnBDLE1BQU1uQyxJQUF2QixLQUFnQyxTQUpsQztBQU1EO0FBQ0Y7QUFDRixLQTVCRDtBQTZCRDtBQUNELFNBQU9tVCxNQUFQO0FBQ0Q7O0FBRUQsU0FBU3U1RSxrQkFBVCxDQUNFdi9ELElBREYsRUFFRWpaLG9CQUZGLEVBR0VuVCxRQUhGLEVBSUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJdXlCLFlBQVluRyxLQUFLbUcsU0FBckI7QUFDQSxNQUFJcTVELGtCQUFKO0FBQ0EsTUFBSXI1RCxjQUFjLElBQWxCLEVBQXdCO0FBQ3RCQSxnQkFBWW5HLEtBQUttRyxTQUFMLEdBQWlCLElBQUlnNUQsZUFBSixFQUE3QjtBQUNBSyxnQkFBWSxJQUFJbG9FLEdBQUosRUFBWjtBQUNBNk8sY0FBVXpxQixHQUFWLENBQWM5SCxRQUFkLEVBQXdCNHJGLFNBQXhCO0FBQ0QsR0FKRCxNQUlPO0FBQ0xBLGdCQUFZcjVELFVBQVV4cUIsR0FBVixDQUFjL0gsUUFBZCxDQUFaO0FBQ0EsUUFBSTRyRixjQUFjcHhGLFNBQWxCLEVBQTZCO0FBQzNCb3hGLGtCQUFZLElBQUlsb0UsR0FBSixFQUFaO0FBQ0E2TyxnQkFBVXpxQixHQUFWLENBQWM5SCxRQUFkLEVBQXdCNHJGLFNBQXhCO0FBQ0Q7QUFDRjtBQUNELE1BQUksQ0FBQ0EsVUFBVWhuRSxHQUFWLENBQWN6UixvQkFBZCxDQUFMLEVBQTBDO0FBQ3hDO0FBQ0F5NEUsY0FBVS9tRSxHQUFWLENBQWMxUixvQkFBZDtBQUNBLFFBQUkwNEUsT0FBT3g1RCx1Q0FBa0I3RSxJQUFsQixDQUNULElBRFMsRUFFVHBCLElBRlMsRUFHVHBzQixRQUhTLEVBSVRtVCxvQkFKUyxDQUFYO0FBTUEsUUFBSWxXLHlDQUFKLEVBQTRCO0FBQzFCNHVGLGFBQU8sNEJBQXNCQSxJQUF0QixDQUFQO0FBQ0Q7QUFDRDdyRixhQUFTaXJCLElBQVQsQ0FBYzRnRSxJQUFkLEVBQW9CQSxJQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsY0FBVCxDQUNFMS9ELElBREYsRUFFRW9ELFdBRkYsRUFHRWUsV0FIRixFQUlFN1IsS0FKRixFQUtFdkwsb0JBTEYsRUFNRTtBQUNBO0FBQ0FvZCxjQUFZdGQsU0FBWixJQUF5QmpRLCtCQUF6QjtBQUNBO0FBQ0F1dEIsY0FBWTllLFdBQVosR0FBMEI4ZSxZQUFZN2UsVUFBWixHQUF5QixJQUFuRDs7QUFFQSxNQUNFZ04sVUFBVSxJQUFWLElBQ0EsUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQURqQixJQUVBLE9BQU9BLE1BQU11TSxJQUFiLEtBQXNCLFVBSHhCLEVBSUU7QUFDQTtBQUNBLFFBQU1qckIsV0FBc0IwZSxLQUE1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSWhkLGtCQUFpQjh0QixXQUFyQjtBQUNBLFFBQUl1OEQsb0JBQW9CLENBQUMsQ0FBekI7QUFDQSxRQUFJQyxjQUFjLENBQUMsQ0FBbkI7QUFDQSxPQUFHO0FBQ0QsVUFBSXRxRixnQkFBZXhDLEdBQWYsS0FBdUJkLGdDQUEzQixFQUE4QztBQUM1QyxZQUFNMEQsVUFBVUosZ0JBQWUyUSxTQUEvQjtBQUNBLFlBQUl2USxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLGNBQU1raEQsZUFBcUNsaEQsUUFBUTJRLGFBQW5EO0FBQ0EsY0FBSXV3QyxpQkFBaUIsSUFBckIsRUFBMkI7QUFDekI7QUFDQTtBQUNBLGdCQUFNemxCLGFBQWF5bEIsYUFBYXpsQixVQUFoQztBQUNBeXVELDBCQUFjLGtEQUFtQnp1RCxVQUFuQixDQUFkO0FBQ0E7QUFDQTtBQUNEO0FBQ0Y7QUFDRCxZQUFJMHVELGdCQUFnQnZxRixnQkFBZXNsQixZQUFmLENBQTRCa2xFLFdBQWhEO0FBQ0EsWUFBSSxPQUFPRCxhQUFQLEtBQXlCLFFBQTdCLEVBQXVDO0FBQ3JDLGNBQUlBLGlCQUFpQixDQUFyQixFQUF3QjtBQUN0QkYsZ0NBQW9CLENBQXBCO0FBQ0QsV0FGRCxNQUVPLElBQ0xBLHNCQUFzQixDQUFDLENBQXZCLElBQ0FFLGdCQUFnQkYsaUJBRlgsRUFHTDtBQUNBQSxnQ0FBb0JFLGFBQXBCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0F2cUYsd0JBQWlCQSxnQkFBZUcsTUFBaEM7QUFDRCxLQTlCRCxRQThCU0gsb0JBQW1CLElBOUI1Qjs7QUFnQ0E7QUFDQUEsc0JBQWlCOHRCLFdBQWpCO0FBQ0EsT0FBRztBQUNELFVBQ0U5dEIsZ0JBQWV4QyxHQUFmLEtBQXVCZCxnQ0FBdkIsSUFDQSx3REFBc0JzRCxlQUF0QixDQUZGLEVBR0U7QUFDQTs7QUFFQTtBQUVBLFlBQU1rb0QsWUFBNEJsb0QsZ0JBQWU4USxXQUFqRDtBQUNBLFlBQUlvM0MsY0FBYyxJQUFsQixFQUF3QjtBQUN0QixjQUFNcDNDLGNBQWUsSUFBSWtSLEdBQUosRUFBckI7QUFDQWxSLHNCQUFZcVMsR0FBWixDQUFnQjdrQixRQUFoQjtBQUNBMEIsMEJBQWU4USxXQUFmLEdBQTZCQSxXQUE3QjtBQUNELFNBSkQsTUFJTztBQUNMbzNDLG9CQUFVL2tDLEdBQVYsQ0FBYzdrQixRQUFkO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksQ0FBQzBCLGdCQUFlcVIsSUFBZixHQUFzQi9KLCtCQUF2QixNQUEyQzlHLDZCQUEvQyxFQUF5RDtBQUN2RFIsMEJBQWV1UixTQUFmLElBQTRCdlEsK0JBQTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBNnRCLHNCQUFZdGQsU0FBWixJQUF5QixFQUFFblEsMkNBQXNCRSwrQkFBeEIsQ0FBekI7O0FBRUEsY0FBSXV0QixZQUFZcnhCLEdBQVosS0FBb0IxQiw2QkFBeEIsRUFBd0M7QUFDdEMsZ0JBQU0ydUYscUJBQXFCNTdELFlBQVlsZSxTQUF2QztBQUNBLGdCQUFJODVFLHVCQUF1QixJQUEzQixFQUFpQztBQUMvQjtBQUNBO0FBQ0E7QUFDQTU3RCwwQkFBWXJ4QixHQUFaLEdBQWtCVix1Q0FBbEI7QUFDRCxhQUxELE1BS087QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBTTRULFNBQVMsb0NBQWE1Tyw4QkFBYixDQUFmO0FBQ0E0TyxxQkFBT2xULEdBQVAsR0FBYTJSLDZCQUFiO0FBQ0EsbURBQWMwZixXQUFkLEVBQTJCbmUsTUFBM0I7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQW1lLHNCQUFZMXNCLGNBQVosR0FBNkJMLDhCQUE3Qjs7QUFFQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTs7QUFFQW1vRiwyQkFBbUJ2L0QsSUFBbkIsRUFBeUJqWixvQkFBekIsRUFBK0NuVCxRQUEvQzs7QUFFQSxZQUFJa3lCLDBCQUFKO0FBQ0EsWUFBSTY1RCxzQkFBc0IsQ0FBQyxDQUEzQixFQUE4QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTc1RCw4QkFBb0JnMUMsMkJBQXBCO0FBQ0QsU0FMRCxNQUtPO0FBQ0wsY0FBSThrQixnQkFBZ0IsQ0FBQyxDQUFyQixFQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBTW43RCx5QkFBeUIscUVBQzdCekUsSUFENkIsRUFFN0JqWixvQkFGNkIsQ0FBL0I7QUFJQSxnQkFBTTJkLDJCQUEyQixrREFDL0JELHNCQUQrQixDQUFqQztBQUdBbTdELDBCQUFjbDdELDJCQUEyQnpzQixpREFBekM7QUFDRDtBQUNENnRCLDhCQUFvQjg1RCxjQUFjRCxpQkFBbEM7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFpQjMvRCxJQUFqQixFQUF1QjhGLGlCQUF2QixFQUEwQy9lLG9CQUExQzs7QUFFQXpSLHdCQUFldVIsU0FBZixJQUE0QmhRLGtDQUE1QjtBQUNBdkIsd0JBQWVtQyxjQUFmLEdBQWdDc1Asb0JBQWhDO0FBQ0E7QUFDRCxPQXJHRCxNQXFHTyxJQUNMalcsbURBQ0F3RSxnQkFBZXhDLEdBQWYsS0FBdUJULDBDQUZsQixFQUdMO0FBQ0FrdEYsMkJBQW1Cdi9ELElBQW5CLEVBQXlCalosb0JBQXpCLEVBQStDblQsUUFBL0M7O0FBRUE7QUFDQSxZQUFJMHlCLGFBQWFoeEIsZ0JBQWUrUSxhQUFoQztBQUNBLFlBQUlpZ0IsZUFBZSxJQUFuQixFQUF5QjtBQUN2QkEsdUJBQWFoeEIsZ0JBQWUrUSxhQUFmLEdBQStCLElBQUl1ekMsZUFBSixFQUE1QztBQUNBLGNBQU1sa0QsV0FBVUosZ0JBQWUyUSxTQUEvQjtBQUNBLG1DQUNFdlEsUUFERixFQUVFLHlFQUNFLGtDQUhKO0FBS0FBLG1CQUFRMlEsYUFBUixHQUF3QmlnQixVQUF4QjtBQUNEO0FBQ0Q7QUFDQSxZQUFJLENBQUNBLFdBQVc5TixHQUFYLENBQWU1a0IsUUFBZixDQUFMLEVBQStCO0FBQzdCMHlCLHFCQUFXN04sR0FBWCxDQUFlN2tCLFFBQWY7QUFDQSxjQUFJNnBELFFBQVFyM0IsMkNBQXNCaEYsSUFBdEIsQ0FDVixJQURVLEVBRVY5ckIsZUFGVSxFQUdWMUIsUUFIVSxDQUFaO0FBS0EsY0FBSS9DLHlDQUFKLEVBQTRCO0FBQzFCNHNELG9CQUFRLDRCQUFzQkEsS0FBdEIsQ0FBUjtBQUNEO0FBQ0Q3cEQsbUJBQVNpckIsSUFBVCxDQUFjNCtCLEtBQWQsRUFBcUJBLEtBQXJCO0FBQ0Q7QUFDRG5vRCx3QkFBZXVSLFNBQWYsSUFBNEJoUSxrQ0FBNUI7QUFDQXZCLHdCQUFlbUMsY0FBZixHQUFnQ3NQLG9CQUFoQztBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBQ0F6Uix3QkFBaUJBLGdCQUFlRyxNQUFoQztBQUNELEtBNUlELFFBNElTSCxvQkFBbUIsSUE1STVCO0FBNklBO0FBQ0E7QUFDQWdkLFlBQVEsSUFBSWprQixLQUFKLENBQ04sQ0FBQyxnQ0FBaUI4MUIsWUFBWXR4QixJQUE3QixLQUFzQyxtQkFBdkMsSUFDRSxpRUFERixHQUVFLElBRkYsR0FHRSxnRUFIRixHQUlFLHdEQUpGLEdBS0Usb0RBQTRCc3hCLFdBQTVCLENBTkksQ0FBUjtBQVFEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E3UixVQUFRLDZDQUFvQkEsS0FBcEIsRUFBMkI2UixXQUEzQixDQUFSO0FBQ0EsTUFBSTd1QixpQkFBaUI4dEIsV0FBckI7QUFDQSxLQUFHO0FBQ0QsWUFBUTl0QixlQUFleEMsR0FBdkI7QUFDRSxXQUFLeEIsdUJBQUw7QUFBZTtBQUNiLGNBQU00ekIsYUFBWTVTLEtBQWxCO0FBQ0FoZCx5QkFBZXVSLFNBQWYsSUFBNEJoUSxrQ0FBNUI7QUFDQXZCLHlCQUFlbUMsY0FBZixHQUFnQ3NQLG9CQUFoQztBQUNBLGNBQU1mLFVBQVNxNUUsc0JBQ2IvcEYsY0FEYSxFQUViNHZCLFVBRmEsRUFHYm5lLG9CQUhhLENBQWY7QUFLQSx1REFBc0J6UixjQUF0QixFQUFzQzBRLE9BQXRDO0FBQ0E7QUFDRDtBQUNELFdBQUs1VSw2QkFBTDtBQUNFO0FBQ0EsWUFBTTh6QixZQUFZNVMsS0FBbEI7QUFDQSxZQUFNeVMsT0FBT3p2QixlQUFlekMsSUFBNUI7QUFDQSxZQUFNd0osV0FBVy9HLGVBQWVtTyxTQUFoQztBQUNBLFlBQ0UsQ0FBQ25PLGVBQWV1UixTQUFmLEdBQTJCdlEsK0JBQTVCLE1BQTRDUiw2QkFBNUMsS0FDQyxPQUFPaXZCLEtBQUtDLHdCQUFaLEtBQXlDLFVBQXpDLElBQ0Uzb0IsYUFBYSxJQUFiLElBQ0MsT0FBT0EsU0FBUzRvQixpQkFBaEIsS0FBc0MsVUFEdkMsSUFFQyxDQUFDLDZEQUFtQzVvQixRQUFuQyxDQUpMLENBREYsRUFNRTtBQUNBL0cseUJBQWV1UixTQUFmLElBQTRCaFEsa0NBQTVCO0FBQ0F2Qix5QkFBZW1DLGNBQWYsR0FBZ0NzUCxvQkFBaEM7QUFDQTtBQUNBLGNBQU1mLFdBQVNzNUUsdUJBQ2JocUYsY0FEYSxFQUViNHZCLFNBRmEsRUFHYm5lLG9CQUhhLENBQWY7QUFLQSx1REFBc0J6UixjQUF0QixFQUFzQzBRLFFBQXRDO0FBQ0E7QUFDRDtBQUNEO0FBQ0Y7QUFDRTtBQXRDSjtBQXdDQTFRLHFCQUFpQkEsZUFBZUcsTUFBaEM7QUFDRCxHQTFDRCxRQTBDU0gsbUJBQW1CLElBMUM1QjtBQTJDRDs7QUFFRCxTQUFTMHFGLFVBQVQsQ0FDRTFxRixjQURGLEVBRUV5UixvQkFGRixFQUdFO0FBQ0EsVUFBUXpSLGVBQWV4QyxHQUF2QjtBQUNFLFNBQUsxQiw2QkFBTDtBQUFxQjtBQUNuQixZQUFNOGEsWUFBWTVXLGVBQWV6QyxJQUFqQztBQUNBLFlBQUksMENBQXdCcVosU0FBeEIsQ0FBSixFQUF3QztBQUN0Qyw2Q0FBaUI1VyxjQUFqQjtBQUNEO0FBQ0QsWUFBTXVSLFlBQVl2UixlQUFldVIsU0FBakM7QUFDQSxZQUFJQSxZQUFZaFEsa0NBQWhCLEVBQStCO0FBQzdCdkIseUJBQWV1UixTQUFmLEdBQTRCQSxZQUFZLENBQUNoUSxrQ0FBZCxHQUErQlAsK0JBQTFEO0FBQ0EsaUJBQU9oQixjQUFQO0FBQ0Q7QUFDRCxlQUFPLElBQVA7QUFDRDtBQUNELFNBQUtoRSx1QkFBTDtBQUFlO0FBQ2IscURBQWlCZ0UsY0FBakI7QUFDQSx5REFBK0JBLGNBQS9CO0FBQ0EsWUFBTXVSLGFBQVl2UixlQUFldVIsU0FBakM7QUFDQSxpQ0FDRSxDQUFDQSxhQUFZdlEsK0JBQWIsTUFBNkJSLDZCQUQvQixFQUVFLHdFQUNFLDhCQUhKO0FBS0FSLHVCQUFldVIsU0FBZixHQUE0QkEsYUFBWSxDQUFDaFEsa0NBQWQsR0FBK0JQLCtCQUExRDtBQUNBLGVBQU9oQixjQUFQO0FBQ0Q7QUFDRCxTQUFLOUQsNEJBQUw7QUFBb0I7QUFDbEI7QUFDQSxtREFBZThELGNBQWY7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNELFNBQUt0RCxnQ0FBTDtBQUF3QjtBQUN0QixZQUFNNlUsY0FBWXZSLGVBQWV1UixTQUFqQztBQUNBLFlBQUlBLGNBQVloUSxrQ0FBaEIsRUFBK0I7QUFDN0J2Qix5QkFBZXVSLFNBQWYsR0FBNEJBLGNBQVksQ0FBQ2hRLGtDQUFkLEdBQStCUCwrQkFBMUQ7QUFDQTtBQUNBLGlCQUFPaEIsY0FBUDtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFLakQsMENBQUw7QUFBa0M7QUFDaEMsWUFBSXZCLCtDQUFKLEVBQWtDO0FBQ2hDO0FBQ0EsY0FBTStWLGNBQVl2UixlQUFldVIsU0FBakM7QUFDQSxjQUFJQSxjQUFZaFEsa0NBQWhCLEVBQStCO0FBQzdCdkIsMkJBQWV1UixTQUFmLEdBQTRCQSxjQUFZLENBQUNoUSxrQ0FBZCxHQUErQlAsK0JBQTFEO0FBQ0E7QUFDQSxtQkFBT2hCLGNBQVA7QUFDRDtBQUNGO0FBQ0QsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFLL0QseUJBQUw7QUFDRSxtREFBaUIrRCxjQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNGLFNBQUt6RCw4QkFBTDtBQUNFLDZDQUFZeUQsY0FBWjtBQUNBLGFBQU8sSUFBUDtBQUNGO0FBQ0UsYUFBTyxJQUFQO0FBMURKO0FBNEREOztBQUVELFNBQVMycUYscUJBQVQsQ0FBK0I5Z0UsZUFBL0IsRUFBdUQ7QUFDckQsVUFBUUEsZ0JBQWdCcnNCLEdBQXhCO0FBQ0UsU0FBSzFCLDZCQUFMO0FBQXFCO0FBQ25CLFlBQU0wYixvQkFBb0JxUyxnQkFBZ0J0c0IsSUFBaEIsQ0FBcUJpYSxpQkFBL0M7QUFDQSxZQUFJQSxzQkFBc0IsSUFBdEIsSUFBOEJBLHNCQUFzQjFlLFNBQXhELEVBQW1FO0FBQ2pFLDZDQUFpQit3QixlQUFqQjtBQUNEO0FBQ0Q7QUFDRDtBQUNELFNBQUs3dEIsdUJBQUw7QUFBZTtBQUNiLHFEQUFpQjZ0QixlQUFqQjtBQUNBLHlEQUErQkEsZUFBL0I7QUFDQTtBQUNEO0FBQ0QsU0FBSzN0Qiw0QkFBTDtBQUFvQjtBQUNsQixtREFBZTJ0QixlQUFmO0FBQ0E7QUFDRDtBQUNELFNBQUs1dEIseUJBQUw7QUFDRSxtREFBaUI0dEIsZUFBakI7QUFDQTtBQUNGLFNBQUt0dEIsOEJBQUw7QUFDRSw2Q0FBWXN0QixlQUFaO0FBQ0E7QUFDRjtBQUNFO0FBeEJKO0FBMEJEOztRQUdDdWdFLGMsR0FBQUEsYztRQUNBTSxVLEdBQUFBLFU7UUFDQUMscUIsR0FBQUEscUI7UUFDQVoscUIsR0FBQUEscUI7UUFDQUMsc0IsR0FBQUEsc0I7Ozs7Ozs7Ozs7OztRQzNoQmNZLHFCLEdBQUFBLHFCO0FBQVQsU0FBU0EscUJBQVQsQ0FBK0I1cUYsY0FBL0IsRUFBK0Q7QUFDcEU7QUFDQSxNQUFJQSxlQUFlMGxCLGFBQWYsQ0FBNkJvVyxRQUE3QixLQUEwQ2hqQyxTQUE5QyxFQUF5RDtBQUN2RCxXQUFPLEtBQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQSxNQUFNd1ksWUFBa0N0UixlQUFlK1EsYUFBdkQ7QUFDQSxTQUFPTyxjQUFjLElBQXJCO0FBQ0QsQyxDQXpCRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQ2FnQnU1RSxnQixHQUFBQSxnQjs7QUFGaEI7O0FBWEE7Ozs7Ozs7OztBQWFPLFNBQVNBLGdCQUFULENBQTBCcG1DLGFBQTFCLEVBQThEO0FBQ25FLE1BQU1MLFdBQVcsNENBQWdCSyxhQUFoQixDQUFqQjs7QUFFQTtBQUNBO0FBQ0EsTUFBSUwsYUFBYSxLQUFqQixFQUF3QjtBQUN0QjtBQUNEOztBQUVELE1BQU03cUQsUUFBU2tyRCxjQUFjbHJELEtBQTdCO0FBQ0EsTUFBSVgsSUFBSixFQUFhO0FBQUEsUUFFVG9mLGFBRlMsR0FPUHlzQyxhQVBPLENBRVR6c0MsYUFGUztBQUFBLFFBR1Qwc0MsY0FIUyxHQU9QRCxhQVBPLENBR1RDLGNBSFM7QUFBQSxRQUlURSxpQkFKUyxHQU9QSCxhQVBPLENBSVRHLGlCQUpTO0FBQUEsUUFLVEMsa0JBTFMsR0FPUEosYUFQTyxDQUtUSSxrQkFMUztBQUFBLFFBTVRDLFNBTlMsR0FPUEwsYUFQTyxDQU1USyxTQU5TOztBQVNYO0FBQ0E7QUFDQTs7QUFDQSxRQUFJdnJELFNBQVMsSUFBVCxJQUFpQkEsTUFBTW13QixnQkFBM0IsRUFBNkM7QUFDM0MsVUFBSW03QixzQkFBc0JDLFNBQTFCLEVBQXFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBL3FELGNBQVFSLEtBQVIsQ0FBY0EsS0FBZDtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxRQUFNdXhGLHVCQUF1Qjl5RSxzREFDV0EsYUFEWCxvQkFFekIsMkRBRko7O0FBSUEsUUFBSSt5RSw2QkFBSjtBQUNBO0FBQ0EsUUFBSWxtQyxzQkFBc0JELGlCQUExQixFQUE2QztBQUMzQyxVQUFJRSxTQUFKLEVBQWU7QUFDYmltQywrQkFDRSw4R0FDMENubUMsaUJBRDFDLE9BREY7QUFHRCxPQUpELE1BSU87QUFDTG1tQywrQkFDRSw0REFBMERubUMsaUJBQTFELG9GQURGO0FBR0Q7QUFDRixLQVZELE1BVU87QUFDTG1tQyw2QkFDRSwyRkFDQSxrRkFGRjtBQUdEO0FBQ0QsUUFBTUMsa0JBQ0osS0FBR0Ysb0JBQUgsR0FBMEJwbUMsY0FBMUIsa0JBQ0dxbUMsb0JBREgsQ0FERjs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBaHhGLFlBQVFSLEtBQVIsQ0FBY3l4RixlQUFkO0FBQ0QsR0ExREQsTUEwRE87QUFDTDtBQUNBO0FBQ0E7QUFDQWp4RixZQUFRUixLQUFSLENBQWNBLEtBQWQ7QUFDRDtBQUNGLEM7Ozs7Ozs7Ozs7OztRQ3pFZTB4RixlLEdBQUFBLGU7OztBQUhoQjtBQUNBO0FBQ0E7QUFDTyxTQUFTQSxlQUFULENBQXlCeG1DLGFBQXpCLEVBQWdFO0FBQ3JFLFNBQU8sSUFBUDtBQUNELEMsQ0FoQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNhZ0J5dEIsWSxHQUFBQSxZOztBQUpoQjs7QUFJTyxTQUFTQSxZQUFULENBQ0x4ckQsUUFESyxFQUVMWSxhQUZLO0FBR0w7QUFDQUUsY0FKSyxFQU1RO0FBQUEsTUFEYmxRLEdBQ2EsdUVBREUsSUFDRjs7QUFDYixTQUFPO0FBQ0w7QUFDQXZaLGNBQVVKLCtCQUZMO0FBR0wyWixTQUFLQSxPQUFPLElBQVAsR0FBYyxJQUFkLEdBQXFCLEtBQUtBLEdBSDFCO0FBSUxvUCxzQkFKSztBQUtMWSxnQ0FMSztBQU1MRTtBQU5LLEdBQVA7QUFRRCxDLENBNUJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4UUNBQTs7Ozs7Ozs7O0FBU0E7OztRQTBRZ0IwakUsZ0MsR0FBQUEsZ0M7UUFrR0ExOEUsYSxHQUFBQSxhO1FBcUZBMjhFLGMsR0FBQUEsYztRQVNBQyxvQixHQUFBQSxvQjtRQW1JQUMsYyxHQUFBQSxjO1FBd01BQyxnQixHQUFBQSxnQjtRQTJEQUMsc0IsR0FBQUEsc0I7UUFrU0FDLGdCLEdBQUFBLGdCO1FBS0FDLG9CLEdBQUFBLG9CO1FBTUFDLCtCLEdBQUFBLCtCO1FBa0JBQyw0QixHQUFBQSw0QjtRQWtCQUMsOEIsR0FBQUEsOEI7UUFtQkFDLDJCLEdBQUFBLDJCO1FBeUJBOThDLHNCLEdBQUFBLHNCOztBQTVzQ2hCOztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7QUFLQTs7QUFRQTs7QUFLQTs7QUFPQTs7QUFPQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBUUE7O0FBRUE7O0FBS0E7O0FBQ0E7O0FBS0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxJQUFJKzhDLDBCQUEwQixLQUE5QjtBQUNBLElBQUlDLGtCQUFrQixLQUF0Qjs7QUFFQSxJQUFNQyw2QkFBNkIseUJBQW5DO0FBQ0EsSUFBTUMsb0NBQW9DLGdDQUExQztBQUNBLElBQU1DLDZCQUE2QiwwQkFBbkM7QUFDQSxJQUFNQyxZQUFZLFdBQWxCO0FBQ0EsSUFBTUMsV0FBVyxVQUFqQjtBQUNBLElBQU1DLFFBQVEsT0FBZDtBQUNBLElBQU1DLE9BQU8sUUFBYjs7SUFFYS9qQyxjLEdBQWtCRyx5QixDQUF4QkMsSTs7O0FBRVAsSUFBSTRqQywwQkFBSjtBQUNBLElBQUlDLGlDQUFKOztBQUVBLElBQUlDLHdDQUFKO0FBQ0EsSUFBSUMsOEJBQUo7QUFDQSxJQUFJQyw4QkFBSjtBQUNBLElBQUlDLCtCQUFKO0FBQ0EsSUFBSUMsb0NBQUo7QUFDQSxJQUFJQyx3Q0FBSjs7QUFFQSxJQUFJQywwQ0FBSjtBQUNBLElBQUlDLHNCQUFKOztBQUVBLElBQUlwMEYsSUFBSixFQUFhO0FBQ1gyekYsc0JBQW9CO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0F4K0MsVUFBTSxJQUxZO0FBTWxCO0FBQ0FrL0MsWUFBUSxJQVBVO0FBUWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsYUFBUztBQWJTLEdBQXBCOztBQWdCQVQsb0NBQWtDLHlDQUFTbHZGLElBQVQsRUFBZTZRLEtBQWYsRUFBc0I7QUFDdEQscURBQXVCN1EsSUFBdkIsRUFBNkI2USxLQUE3QjtBQUNBLDREQUF3QjdRLElBQXhCLEVBQThCNlEsS0FBOUI7QUFDQSx5REFBMEI3USxJQUExQixFQUFnQzZRLEtBQWhDLEVBQXVDLHVCQUF3QixJQUEvRDtBQUNELEdBSkQ7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBMCtFLG9DQUFrQ3orRSxtQ0FBYSxDQUFDRSxTQUFTK21FLFlBQXpEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNNlgsMkJBQTJCLFFBQWpDO0FBQ0EsTUFBTUMsdUNBQXVDLGdCQUE3Qzs7QUFFQUwsc0NBQW9DLDJDQUFTTSxNQUFULEVBQWdDO0FBQ2xFLFFBQU1DLGVBQ0osT0FBT0QsTUFBUCxLQUFrQixRQUFsQixHQUE2QkEsTUFBN0IsR0FBc0MsS0FBTUEsTUFEOUM7QUFFQSxXQUFPQyxhQUNKNXpGLE9BREksQ0FDSXl6Rix3QkFESixFQUM4QixJQUQ5QixFQUVKenpGLE9BRkksQ0FFSTB6RixvQ0FGSixFQUUwQyxFQUYxQyxDQUFQO0FBR0QsR0FORDs7QUFRQVYsMEJBQXdCLCtCQUN0QmEsVUFEc0IsRUFFdEJDLFVBRnNCLEVBR3RCO0FBQ0EsUUFBSTFCLHVCQUFKLEVBQTZCO0FBQzNCO0FBQ0Q7QUFDRCxRQUFNMkIsdUJBQXVCVixrQ0FBa0NTLFVBQWxDLENBQTdCO0FBQ0EsUUFBTUUsdUJBQXVCWCxrQ0FBa0NRLFVBQWxDLENBQTdCO0FBQ0EsUUFBSUcseUJBQXlCRCxvQkFBN0IsRUFBbUQ7QUFDakQ7QUFDRDtBQUNEM0IsOEJBQTBCLElBQTFCO0FBQ0EsdUNBQ0UsS0FERixFQUVFLHVEQUZGLEVBR0U0QixvQkFIRixFQUlFRCxvQkFKRjtBQU1ELEdBbkJEOztBQXFCQWQsMEJBQXdCLCtCQUN0QjluRixRQURzQixFQUV0QjhvRixXQUZzQixFQUd0QkMsV0FIc0IsRUFJdEI7QUFDQSxRQUFJOUIsdUJBQUosRUFBNkI7QUFDM0I7QUFDRDtBQUNELFFBQU0rQix3QkFBd0JkLGtDQUM1QmEsV0FENEIsQ0FBOUI7QUFHQSxRQUFNRSx3QkFBd0JmLGtDQUM1QlksV0FENEIsQ0FBOUI7QUFHQSxRQUFJRywwQkFBMEJELHFCQUE5QixFQUFxRDtBQUNuRDtBQUNEO0FBQ0QvQiw4QkFBMEIsSUFBMUI7QUFDQSx1Q0FDRSxLQURGLEVBRUUsZ0RBRkYsRUFHRWpuRixRQUhGLEVBSUV3ckMsS0FBS0MsU0FBTCxDQUFldzlDLHFCQUFmLENBSkYsRUFLRXo5QyxLQUFLQyxTQUFMLENBQWV1OUMscUJBQWYsQ0FMRjtBQU9ELEdBekJEOztBQTJCQWpCLDJCQUF5QixnQ0FBU21CLGNBQVQsRUFBc0M7QUFDN0QsUUFBSWpDLHVCQUFKLEVBQTZCO0FBQzNCO0FBQ0Q7QUFDREEsOEJBQTBCLElBQTFCO0FBQ0EsUUFBTWtDLFFBQVEsRUFBZDtBQUNBRCxtQkFBZXR3RSxPQUFmLENBQXVCLFVBQVM5akIsSUFBVCxFQUFlO0FBQ3BDcTBGLFlBQU05bUYsSUFBTixDQUFXdk4sSUFBWDtBQUNELEtBRkQ7QUFHQSx1Q0FBb0IsS0FBcEIsRUFBMkIsc0NBQTNCLEVBQW1FcTBGLEtBQW5FO0FBQ0QsR0FWRDs7QUFZQW5CLGdDQUE4QixxQ0FBU3YzRSxnQkFBVCxFQUEyQkcsUUFBM0IsRUFBcUM7QUFDakUsUUFBSUEsYUFBYSxLQUFqQixFQUF3QjtBQUN0Qiw2QkFDRSxLQURGLEVBRUUsc0VBQ0UscUVBREYsR0FFRSxrREFKSixFQUtFSCxnQkFMRixFQU1FQSxnQkFORixFQU9FQSxnQkFQRjtBQVNELEtBVkQsTUFVTztBQUNMLDZCQUNFLEtBREYsRUFFRSw0RUFGRixFQUdFQSxnQkFIRixTQUlTRyxRQUpULHlDQUlTQSxRQUpUO0FBTUQ7QUFDRixHQW5CRDs7QUFxQkE7QUFDQTtBQUNBdTNFLGtCQUFnQix1QkFBUzc0RSxNQUFULEVBQTBCdzBDLElBQTFCLEVBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTXNsQyxjQUNKOTVFLE9BQU8rNUUsWUFBUCxLQUF3QjNsQyxjQUF4QixHQUNJcDBDLE9BQU91OEIsYUFBUCxDQUFxQmxpQyxhQUFyQixDQUFtQzJGLE9BQU91eEIsT0FBMUMsQ0FESixHQUVJdnhCLE9BQU91OEIsYUFBUCxDQUFxQnk5QyxlQUFyQixDQUNHaDZFLE9BQU8rNUUsWUFEVixFQUVFLzVFLE9BQU91eEIsT0FGVCxDQUhOO0FBT0F1b0QsZ0JBQVlHLFNBQVosR0FBd0J6bEMsSUFBeEI7QUFDQSxXQUFPc2xDLFlBQVlHLFNBQW5CO0FBQ0QsR0FkRDtBQWVEOztBQUVELFNBQVNDLGlCQUFULENBQTJCQyxvQkFBM0IsRUFBaURoNUUsZ0JBQWpELEVBQW1FO0FBQ2pFLE1BQU1pNUUsdUJBQ0pELHFCQUFxQmpnRCxRQUFyQixLQUFrQ3BoQywyQkFBbEMsSUFDQXFoRixxQkFBcUJqZ0QsUUFBckIsS0FBa0NuaEMsb0NBRnBDO0FBR0EsTUFBTWdvQyxNQUFNcTVDLHVCQUNSRCxvQkFEUSxHQUVSQSxxQkFBcUI1OUMsYUFGekI7QUFHQSwwQ0FBU3A3QixnQkFBVCxFQUEyQjQvQixHQUEzQjtBQUNEOztBQUVELFNBQVNzNUMsaUNBQVQsQ0FDRUYsb0JBREYsRUFFWTtBQUNWLFNBQU9BLHFCQUFxQmpnRCxRQUFyQixLQUFrQ3BoQywyQkFBbEMsR0FDRnFoRixvQkFERSxHQUVIQSxxQkFBcUI1OUMsYUFGekI7QUFHRDs7QUFFRCxTQUFTMDlCLElBQVQsR0FBZ0IsQ0FBRTs7QUFFWCxTQUFTOGMsZ0NBQVQsQ0FBMENockYsSUFBMUMsRUFBNkQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLE9BQUt1dUYsT0FBTCxHQUFlcmdCLElBQWY7QUFDRDs7QUFFRCxTQUFTc2dCLHVCQUFULENBQ0VseEYsR0FERixFQUVFbXhGLFVBRkYsRUFHRUwsb0JBSEYsRUFJRWw5RSxTQUpGLEVBS0UyTCxvQkFMRixFQU1RO0FBQ04sT0FBSyxJQUFNNnhFLE9BQVgsSUFBc0J4OUUsU0FBdEIsRUFBaUM7QUFDL0IsUUFBSSxDQUFDQSxVQUFVdE0sY0FBVixDQUF5QjhwRixPQUF6QixDQUFMLEVBQXdDO0FBQ3RDO0FBQ0Q7QUFDRCxRQUFNQyxXQUFXejlFLFVBQVV3OUUsT0FBVixDQUFqQjtBQUNBLFFBQUlBLFlBQVl2QyxLQUFoQixFQUF1QjtBQUNyQixVQUFJenpGLElBQUosRUFBYTtBQUNYLFlBQUlpMkYsUUFBSixFQUFjO0FBQ1o7QUFDQTtBQUNBNXBGLGlCQUFPc1IsTUFBUCxDQUFjczRFLFFBQWQ7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxvREFBa0JGLFVBQWxCLEVBQThCRSxRQUE5QjtBQUNELEtBVkQsTUFVTyxJQUFJRCxZQUFZNUMsMEJBQWhCLEVBQTRDO0FBQ2pELFVBQU04QyxXQUFXRCxXQUFXQSxTQUFTdkMsSUFBVCxDQUFYLEdBQTRCeHpGLFNBQTdDO0FBQ0EsVUFBSWcyRixZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLG9DQUFhSCxVQUFiLEVBQXlCRyxRQUF6QjtBQUNEO0FBQ0YsS0FMTSxNQUtBLElBQUlGLFlBQVl4QyxRQUFoQixFQUEwQjtBQUMvQixVQUFJLE9BQU95QyxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBTUUsb0JBQW9CdnhGLFFBQVEsVUFBUixJQUFzQnF4RixhQUFhLEVBQTdEO0FBQ0EsWUFBSUUsaUJBQUosRUFBdUI7QUFDckIsd0NBQWVKLFVBQWYsRUFBMkJFLFFBQTNCO0FBQ0Q7QUFDRixPQVRELE1BU08sSUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ3ZDLHNDQUFlRixVQUFmLEVBQTJCLEtBQUtFLFFBQWhDO0FBQ0Q7QUFDRixLQWJNLE1BYUEsSUFDTEQsWUFBWTNDLGlDQUFaLElBQ0EyQyxZQUFZMUMsMEJBRlAsRUFHTDtBQUNBO0FBQ0QsS0FMTSxNQUtBLElBQUkwQyxZQUFZekMsU0FBaEIsRUFBMkI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDRCxLQUxNLE1BS0EsSUFBSXR4RSw2Q0FBd0IvVixjQUF4QixDQUF1QzhwRixPQUF2QyxDQUFKLEVBQXFEO0FBQzFELFVBQUlDLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsWUFBSWoyRixJQUFPQSxJQUFJLE9BQU9pMkYsUUFBUCxLQUFvQixVQUFuQyxFQUErQztBQUM3Q2hDLHNDQUE0QitCLE9BQTVCLEVBQXFDQyxRQUFyQztBQUNEO0FBQ0RSLDBCQUFrQkMsb0JBQWxCLEVBQXdDTSxPQUF4QztBQUNEO0FBQ0YsS0FQTSxNQU9BLElBQUlDLFlBQVksSUFBaEIsRUFBc0I7QUFDM0Isc0RBQW9CRixVQUFwQixFQUFnQ0MsT0FBaEMsRUFBeUNDLFFBQXpDLEVBQW1EOXhFLG9CQUFuRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTaXlFLG1CQUFULENBQ0VMLFVBREYsRUFFRTlxQyxhQUZGLEVBR0VvckMscUJBSEYsRUFJRWx5RSxvQkFKRixFQUtRO0FBQ047QUFDQSxPQUFLLElBQUl0RCxJQUFJLENBQWIsRUFBZ0JBLElBQUlvcUMsY0FBYy9wRCxNQUFsQyxFQUEwQzJmLEtBQUssQ0FBL0MsRUFBa0Q7QUFDaEQsUUFBTW0xRSxVQUFVL3FDLGNBQWNwcUMsQ0FBZCxDQUFoQjtBQUNBLFFBQU15MUUsWUFBWXJyQyxjQUFjcHFDLElBQUksQ0FBbEIsQ0FBbEI7QUFDQSxRQUFJbTFFLFlBQVl2QyxLQUFoQixFQUF1QjtBQUNyQixvREFBa0JzQyxVQUFsQixFQUE4Qk8sU0FBOUI7QUFDRCxLQUZELE1BRU8sSUFBSU4sWUFBWTVDLDBCQUFoQixFQUE0QztBQUNqRCxrQ0FBYTJDLFVBQWIsRUFBeUJPLFNBQXpCO0FBQ0QsS0FGTSxNQUVBLElBQUlOLFlBQVl4QyxRQUFoQixFQUEwQjtBQUMvQixvQ0FBZXVDLFVBQWYsRUFBMkJPLFNBQTNCO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsc0RBQW9CUCxVQUFwQixFQUFnQ0MsT0FBaEMsRUFBeUNNLFNBQXpDLEVBQW9EbnlFLG9CQUFwRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFTSxTQUFTdk8sYUFBVCxDQUNMalIsSUFESyxFQUVMNlEsS0FGSyxFQUdMa2dGLG9CQUhLLEVBSUx4bEMsZUFKSyxFQUtJO0FBQ1QsTUFBSS9yQyw2QkFBSjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTJ6QixnQkFBMEI4OUMsa0NBQzlCRixvQkFEOEIsQ0FBaEM7QUFHQSxNQUFJSyxtQkFBSjtBQUNBLE1BQUlULGVBQWVwbEMsZUFBbkI7QUFDQSxNQUFJb2xDLGlCQUFpQjNsQyxjQUFyQixFQUFxQztBQUNuQzJsQyxtQkFBZSwwQ0FBc0Izd0YsSUFBdEIsQ0FBZjtBQUNEO0FBQ0QsTUFBSTJ3RixpQkFBaUIzbEMsY0FBckIsRUFBcUM7QUFDbkMsUUFBSTN2RCxJQUFKLEVBQWE7QUFDWG1rQiw2QkFBdUIsaUNBQWtCeGYsSUFBbEIsRUFBd0I2USxLQUF4QixDQUF2QjtBQUNBO0FBQ0E7QUFDQSw2QkFDRTJPLHdCQUF3QnhmLFNBQVNBLEtBQUswZCxXQUFMLEVBRG5DLEVBRUUsdUNBQ0UsdUNBREYsR0FFRSxpQ0FKSixFQUtFMWQsSUFMRjtBQU9EOztBQUVELFFBQUlBLFNBQVMsUUFBYixFQUF1QjtBQUNyQjtBQUNBO0FBQ0EsVUFBTTR4RixNQUFNeitDLGNBQWNsaUMsYUFBZCxDQUE0QixLQUE1QixDQUFaO0FBQ0EyZ0YsVUFBSWYsU0FBSixHQUFnQixjQUFjLFVBQTlCLENBSnFCLENBSXFCO0FBQzFDO0FBQ0EsVUFBTS9jLGFBQWU4ZCxJQUFJOWQsVUFBekI7QUFDQXNkLG1CQUFhUSxJQUFJcGQsV0FBSixDQUFnQlYsVUFBaEIsQ0FBYjtBQUNELEtBUkQsTUFRTyxJQUFJLE9BQU9qakUsTUFBTW80QixFQUFiLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ3ZDO0FBQ0Ftb0QsbUJBQWFqK0MsY0FBY2xpQyxhQUFkLENBQTRCalIsSUFBNUIsRUFBa0MsRUFBQ2lwQyxJQUFJcDRCLE1BQU1vNEIsRUFBWCxFQUFsQyxDQUFiO0FBQ0QsS0FITSxNQUdBO0FBQ0w7QUFDQTtBQUNBO0FBQ0Ftb0QsbUJBQWFqK0MsY0FBY2xpQyxhQUFkLENBQTRCalIsSUFBNUIsQ0FBYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJQSxTQUFTLFFBQVQsSUFBcUI2USxNQUFNdy9DLFFBQS9CLEVBQXlDO0FBQ3ZDLFlBQU0xdEQsT0FBU3l1RixVQUFmO0FBQ0F6dUYsYUFBSzB0RCxRQUFMLEdBQWdCLElBQWhCO0FBQ0Q7QUFDRjtBQUNGLEdBeENELE1Bd0NPO0FBQ0wrZ0MsaUJBQWFqK0MsY0FBY3k5QyxlQUFkLENBQThCRCxZQUE5QixFQUE0QzN3RixJQUE1QyxDQUFiO0FBQ0Q7O0FBRUQsTUFBSTNFLElBQUosRUFBYTtBQUNYLFFBQUlzMUYsaUJBQWlCM2xDLGNBQXJCLEVBQXFDO0FBQ25DLFVBQ0UsQ0FBQ3hyQyxvQkFBRCxJQUNBOVgsT0FBTzVLLFNBQVAsQ0FBaUJ1VCxRQUFqQixDQUEwQnJULElBQTFCLENBQStCbzBGLFVBQS9CLE1BQ0UsNkJBRkYsSUFHQSxDQUFDMXBGLE9BQU81SyxTQUFQLENBQWlCeUssY0FBakIsQ0FBZ0N2SyxJQUFoQyxDQUFxQ2d5RixpQkFBckMsRUFBd0RodkYsSUFBeEQsQ0FKSCxFQUtFO0FBQ0FndkYsMEJBQWtCaHZGLElBQWxCLElBQTBCLElBQTFCO0FBQ0EsK0JBQ0UsS0FERixFQUVFLG1EQUNFLGdFQURGLEdBRUUsc0JBSkosRUFLRUEsSUFMRjtBQU9EO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPb3hGLFVBQVA7QUFDRDs7QUFFTSxTQUFTeEQsY0FBVCxDQUNMaDJELElBREssRUFFTG01RCxvQkFGSyxFQUdDO0FBQ04sU0FBT0Usa0NBQWtDRixvQkFBbEMsRUFBd0RuRCxjQUF4RCxDQUNMaDJELElBREssQ0FBUDtBQUdEOztBQUVNLFNBQVNpMkQsb0JBQVQsQ0FDTHVELFVBREssRUFFTG54RixHQUZLLEVBR0w0eEYsUUFISyxFQUlMZCxvQkFKSyxFQUtDO0FBQ04sTUFBTXZ4RSx1QkFBdUIsaUNBQWtCdmYsR0FBbEIsRUFBdUI0eEYsUUFBdkIsQ0FBN0I7QUFDQSxNQUFJeDJGLElBQUosRUFBYTtBQUNYNnpGLG9DQUFnQ2p2RixHQUFoQyxFQUFxQzR4RixRQUFyQztBQUNBLFFBQ0VyeUUsd0JBQ0EsQ0FBQ2d2RSxlQURELElBRUM0QyxVQUFELENBQWtCVSxTQUhwQixFQUlFO0FBQ0EsNkJBQ0UsS0FERixFQUVFLDJEQUNFLCtCQUhKLEVBSUUsaUVBQXlDLGFBSjNDO0FBTUF0RCx3QkFBa0IsSUFBbEI7QUFDRDtBQUNGOztBQUVEO0FBQ0EsTUFBSTM5RSxjQUFKO0FBQ0EsVUFBUTVRLEdBQVI7QUFDRSxTQUFLLFFBQUw7QUFDQSxTQUFLLFFBQUw7QUFDRSxzREFBaUJ5TSwrQkFBakIsRUFBMkIwa0YsVUFBM0I7QUFDQXZnRixjQUFRZ2hGLFFBQVI7QUFDQTtBQUNGLFNBQUssT0FBTDtBQUNBLFNBQUssT0FBTDtBQUNFO0FBQ0EsV0FBSyxJQUFJMzFFLElBQUksQ0FBYixFQUFnQkEsSUFBSTdNLHVDQUFnQjlTLE1BQXBDLEVBQTRDMmYsR0FBNUMsRUFBaUQ7QUFDL0Msd0RBQWlCN00sdUNBQWdCNk0sQ0FBaEIsQ0FBakIsRUFBcUNrMUUsVUFBckM7QUFDRDtBQUNEdmdGLGNBQVFnaEYsUUFBUjtBQUNBO0FBQ0YsU0FBSyxRQUFMO0FBQ0Usc0RBQWlCM2xGLGdDQUFqQixFQUE0QmtsRixVQUE1QjtBQUNBdmdGLGNBQVFnaEYsUUFBUjtBQUNBO0FBQ0YsU0FBSyxLQUFMO0FBQ0EsU0FBSyxPQUFMO0FBQ0EsU0FBSyxNQUFMO0FBQ0Usc0RBQWlCM2xGLGdDQUFqQixFQUE0QmtsRixVQUE1QjtBQUNBLHNEQUFpQjFrRiwrQkFBakIsRUFBMkIwa0YsVUFBM0I7QUFDQXZnRixjQUFRZ2hGLFFBQVI7QUFDQTtBQUNGLFNBQUssTUFBTDtBQUNFLHNEQUFpQjNqRixnQ0FBakIsRUFBNEJrakYsVUFBNUI7QUFDQSxzREFBaUI1aUYsaUNBQWpCLEVBQTZCNGlGLFVBQTdCO0FBQ0F2Z0YsY0FBUWdoRixRQUFSO0FBQ0E7QUFDRixTQUFLLFNBQUw7QUFDRSxzREFBaUJqakYsaUNBQWpCLEVBQTZCd2lGLFVBQTdCO0FBQ0F2Z0YsY0FBUWdoRixRQUFSO0FBQ0E7QUFDRixTQUFLLE9BQUw7QUFDRSwyQ0FBOEJULFVBQTlCLEVBQTBDUyxRQUExQztBQUNBaGhGLGNBQVEsaUNBQTBCdWdGLFVBQTFCLEVBQXNDUyxRQUF0QyxDQUFSO0FBQ0Esc0RBQWlCdmxGLGtDQUFqQixFQUE4QjhrRixVQUE5QjtBQUNBO0FBQ0E7QUFDQU4sd0JBQWtCQyxvQkFBbEIsRUFBd0MsVUFBeEM7QUFDQTtBQUNGLFNBQUssUUFBTDtBQUNFLHlDQUE0QkssVUFBNUIsRUFBd0NTLFFBQXhDO0FBQ0FoaEYsY0FBUSxrQ0FBMkJ1Z0YsVUFBM0IsRUFBdUNTLFFBQXZDLENBQVI7QUFDQTtBQUNGLFNBQUssUUFBTDtBQUNFLDRDQUErQlQsVUFBL0IsRUFBMkNTLFFBQTNDO0FBQ0FoaEYsY0FBUSxrQ0FBMkJ1Z0YsVUFBM0IsRUFBdUNTLFFBQXZDLENBQVI7QUFDQSxzREFBaUJ2bEYsa0NBQWpCLEVBQThCOGtGLFVBQTlCO0FBQ0E7QUFDQTtBQUNBTix3QkFBa0JDLG9CQUFsQixFQUF3QyxVQUF4QztBQUNBO0FBQ0YsU0FBSyxVQUFMO0FBQ0UsOENBQWlDSyxVQUFqQyxFQUE2Q1MsUUFBN0M7QUFDQWhoRixjQUFRLG9DQUE2QnVnRixVQUE3QixFQUF5Q1MsUUFBekMsQ0FBUjtBQUNBLHNEQUFpQnZsRixrQ0FBakIsRUFBOEI4a0YsVUFBOUI7QUFDQTtBQUNBO0FBQ0FOLHdCQUFrQkMsb0JBQWxCLEVBQXdDLFVBQXhDO0FBQ0E7QUFDRjtBQUNFbGdGLGNBQVFnaEYsUUFBUjtBQS9ESjs7QUFrRUEsa0NBQWlCNXhGLEdBQWpCLEVBQXNCNFEsS0FBdEI7O0FBRUFzZ0YsMEJBQ0VseEYsR0FERixFQUVFbXhGLFVBRkYsRUFHRUwsb0JBSEYsRUFJRWxnRixLQUpGLEVBS0UyTyxvQkFMRjs7QUFRQSxVQUFRdmYsR0FBUjtBQUNFLFNBQUssT0FBTDtBQUNFO0FBQ0E7QUFDQSxxQ0FBT214RixVQUFQO0FBQ0EsMkNBQThCQSxVQUE5QixFQUEwQ1MsUUFBMUMsRUFBb0QsS0FBcEQ7QUFDQTtBQUNGLFNBQUssVUFBTDtBQUNFO0FBQ0E7QUFDQSxxQ0FBT1QsVUFBUDtBQUNBLDhDQUFpQ0EsVUFBakMsRUFBNkNTLFFBQTdDO0FBQ0E7QUFDRixTQUFLLFFBQUw7QUFDRSw0Q0FBK0JULFVBQS9CLEVBQTJDUyxRQUEzQztBQUNBO0FBQ0YsU0FBSyxRQUFMO0FBQ0UsNENBQStCVCxVQUEvQixFQUEyQ1MsUUFBM0M7QUFDQTtBQUNGO0FBQ0UsVUFBSSxPQUFPaGhGLE1BQU1raEYsT0FBYixLQUF5QixVQUE3QixFQUF5QztBQUN2QztBQUNBcEUseUNBQW1DeUQsVUFBbkM7QUFDRDtBQUNEO0FBeEJKO0FBMEJEOztBQUVEO0FBQ08sU0FBU3RELGNBQVQsQ0FDTHNELFVBREssRUFFTG54RixHQUZLLEVBR0wreEYsWUFISyxFQUlMQyxZQUpLLEVBS0xsQixvQkFMSyxFQU1nQjtBQUNyQixNQUFJMTFGLElBQUosRUFBYTtBQUNYNnpGLG9DQUFnQ2p2RixHQUFoQyxFQUFxQ2d5RixZQUFyQztBQUNEOztBQUVELE1BQUkzckMsZ0JBQW1DLElBQXZDOztBQUVBLE1BQUk0ckMsa0JBQUo7QUFDQSxNQUFJcitFLGtCQUFKO0FBQ0EsVUFBUTVULEdBQVI7QUFDRSxTQUFLLE9BQUw7QUFDRWl5RixrQkFBWSxpQ0FBMEJkLFVBQTFCLEVBQXNDWSxZQUF0QyxDQUFaO0FBQ0FuK0Usa0JBQVksaUNBQTBCdTlFLFVBQTFCLEVBQXNDYSxZQUF0QyxDQUFaO0FBQ0EzckMsc0JBQWdCLEVBQWhCO0FBQ0E7QUFDRixTQUFLLFFBQUw7QUFDRTRyQyxrQkFBWSxrQ0FBMkJkLFVBQTNCLEVBQXVDWSxZQUF2QyxDQUFaO0FBQ0FuK0Usa0JBQVksa0NBQTJCdTlFLFVBQTNCLEVBQXVDYSxZQUF2QyxDQUFaO0FBQ0EzckMsc0JBQWdCLEVBQWhCO0FBQ0E7QUFDRixTQUFLLFFBQUw7QUFDRTRyQyxrQkFBWSxrQ0FBMkJkLFVBQTNCLEVBQXVDWSxZQUF2QyxDQUFaO0FBQ0FuK0Usa0JBQVksa0NBQTJCdTlFLFVBQTNCLEVBQXVDYSxZQUF2QyxDQUFaO0FBQ0EzckMsc0JBQWdCLEVBQWhCO0FBQ0E7QUFDRixTQUFLLFVBQUw7QUFDRTRyQyxrQkFBWSxvQ0FBNkJkLFVBQTdCLEVBQXlDWSxZQUF6QyxDQUFaO0FBQ0FuK0Usa0JBQVksb0NBQTZCdTlFLFVBQTdCLEVBQXlDYSxZQUF6QyxDQUFaO0FBQ0EzckMsc0JBQWdCLEVBQWhCO0FBQ0E7QUFDRjtBQUNFNHJDLGtCQUFZRixZQUFaO0FBQ0FuK0Usa0JBQVlvK0UsWUFBWjtBQUNBLFVBQ0UsT0FBT0MsVUFBVUgsT0FBakIsS0FBNkIsVUFBN0IsSUFDQSxPQUFPbCtFLFVBQVVrK0UsT0FBakIsS0FBNkIsVUFGL0IsRUFHRTtBQUNBO0FBQ0FwRSx5Q0FBbUN5RCxVQUFuQztBQUNEO0FBQ0Q7QUEvQko7O0FBa0NBLGtDQUFpQm54RixHQUFqQixFQUFzQjRULFNBQXRCOztBQUVBLE1BQUl3OUUsZ0JBQUo7QUFDQSxNQUFJYyxrQkFBSjtBQUNBLE1BQUlDLGVBQWUsSUFBbkI7QUFDQSxPQUFLZixPQUFMLElBQWdCYSxTQUFoQixFQUEyQjtBQUN6QixRQUNFcitFLFVBQVV0TSxjQUFWLENBQXlCOHBGLE9BQXpCLEtBQ0EsQ0FBQ2EsVUFBVTNxRixjQUFWLENBQXlCOHBGLE9BQXpCLENBREQsSUFFQWEsVUFBVWIsT0FBVixLQUFzQixJQUh4QixFQUlFO0FBQ0E7QUFDRDtBQUNELFFBQUlBLFlBQVl2QyxLQUFoQixFQUF1QjtBQUNyQixVQUFNdUQsWUFBWUgsVUFBVWIsT0FBVixDQUFsQjtBQUNBLFdBQUtjLFNBQUwsSUFBa0JFLFNBQWxCLEVBQTZCO0FBQzNCLFlBQUlBLFVBQVU5cUYsY0FBVixDQUF5QjRxRixTQUF6QixDQUFKLEVBQXlDO0FBQ3ZDLGNBQUksQ0FBQ0MsWUFBTCxFQUFtQjtBQUNqQkEsMkJBQWUsRUFBZjtBQUNEO0FBQ0RBLHVCQUFhRCxTQUFiLElBQTBCLEVBQTFCO0FBQ0Q7QUFDRjtBQUNGLEtBVkQsTUFVTyxJQUFJZCxZQUFZNUMsMEJBQVosSUFBMEM0QyxZQUFZeEMsUUFBMUQsRUFBb0U7QUFDekU7QUFDRCxLQUZNLE1BRUEsSUFDTHdDLFlBQVkzQyxpQ0FBWixJQUNBMkMsWUFBWTFDLDBCQUZQLEVBR0w7QUFDQTtBQUNELEtBTE0sTUFLQSxJQUFJMEMsWUFBWXpDLFNBQWhCLEVBQTJCO0FBQ2hDO0FBQ0QsS0FGTSxNQUVBLElBQUl0eEUsNkNBQXdCL1YsY0FBeEIsQ0FBdUM4cEYsT0FBdkMsQ0FBSixFQUFxRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxVQUFJLENBQUMvcUMsYUFBTCxFQUFvQjtBQUNsQkEsd0JBQWdCLEVBQWhCO0FBQ0Q7QUFDRixLQVBNLE1BT0E7QUFDTDtBQUNBO0FBQ0EsT0FBQ0EsZ0JBQWdCQSxpQkFBaUIsRUFBbEMsRUFBc0MzOEMsSUFBdEMsQ0FBMkMwbkYsT0FBM0MsRUFBb0QsSUFBcEQ7QUFDRDtBQUNGO0FBQ0QsT0FBS0EsT0FBTCxJQUFnQng5RSxTQUFoQixFQUEyQjtBQUN6QixRQUFNeTlFLFdBQVd6OUUsVUFBVXc5RSxPQUFWLENBQWpCO0FBQ0EsUUFBTWlCLFdBQVdKLGFBQWEsSUFBYixHQUFvQkEsVUFBVWIsT0FBVixDQUFwQixHQUF5QzkxRixTQUExRDtBQUNBLFFBQ0UsQ0FBQ3NZLFVBQVV0TSxjQUFWLENBQXlCOHBGLE9BQXpCLENBQUQsSUFDQUMsYUFBYWdCLFFBRGIsSUFFQ2hCLFlBQVksSUFBWixJQUFvQmdCLFlBQVksSUFIbkMsRUFJRTtBQUNBO0FBQ0Q7QUFDRCxRQUFJakIsWUFBWXZDLEtBQWhCLEVBQXVCO0FBQ3JCLFVBQUl6ekYsSUFBSixFQUFhO0FBQ1gsWUFBSWkyRixRQUFKLEVBQWM7QUFDWjtBQUNBO0FBQ0E1cEYsaUJBQU9zUixNQUFQLENBQWNzNEUsUUFBZDtBQUNEO0FBQ0Y7QUFDRCxVQUFJZ0IsUUFBSixFQUFjO0FBQ1o7QUFDQSxhQUFLSCxTQUFMLElBQWtCRyxRQUFsQixFQUE0QjtBQUMxQixjQUNFQSxTQUFTL3FGLGNBQVQsQ0FBd0I0cUYsU0FBeEIsTUFDQyxDQUFDYixRQUFELElBQWEsQ0FBQ0EsU0FBUy9wRixjQUFULENBQXdCNHFGLFNBQXhCLENBRGYsQ0FERixFQUdFO0FBQ0EsZ0JBQUksQ0FBQ0MsWUFBTCxFQUFtQjtBQUNqQkEsNkJBQWUsRUFBZjtBQUNEO0FBQ0RBLHlCQUFhRCxTQUFiLElBQTBCLEVBQTFCO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsYUFBS0EsU0FBTCxJQUFrQmIsUUFBbEIsRUFBNEI7QUFDMUIsY0FDRUEsU0FBUy9wRixjQUFULENBQXdCNHFGLFNBQXhCLEtBQ0FHLFNBQVNILFNBQVQsTUFBd0JiLFNBQVNhLFNBQVQsQ0FGMUIsRUFHRTtBQUNBLGdCQUFJLENBQUNDLFlBQUwsRUFBbUI7QUFDakJBLDZCQUFlLEVBQWY7QUFDRDtBQUNEQSx5QkFBYUQsU0FBYixJQUEwQmIsU0FBU2EsU0FBVCxDQUExQjtBQUNEO0FBQ0Y7QUFDRixPQXpCRCxNQXlCTztBQUNMO0FBQ0EsWUFBSSxDQUFDQyxZQUFMLEVBQW1CO0FBQ2pCLGNBQUksQ0FBQzlyQyxhQUFMLEVBQW9CO0FBQ2xCQSw0QkFBZ0IsRUFBaEI7QUFDRDtBQUNEQSx3QkFBYzM4QyxJQUFkLENBQW1CMG5GLE9BQW5CLEVBQTRCZSxZQUE1QjtBQUNEO0FBQ0RBLHVCQUFlZCxRQUFmO0FBQ0Q7QUFDRixLQTNDRCxNQTJDTyxJQUFJRCxZQUFZNUMsMEJBQWhCLEVBQTRDO0FBQ2pELFVBQU04QyxXQUFXRCxXQUFXQSxTQUFTdkMsSUFBVCxDQUFYLEdBQTRCeHpGLFNBQTdDO0FBQ0EsVUFBTWczRixXQUFXRCxXQUFXQSxTQUFTdkQsSUFBVCxDQUFYLEdBQTRCeHpGLFNBQTdDO0FBQ0EsVUFBSWcyRixZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFlBQUlnQixhQUFhaEIsUUFBakIsRUFBMkI7QUFDekIsV0FBQ2pyQyxnQkFBZ0JBLGlCQUFpQixFQUFsQyxFQUFzQzM4QyxJQUF0QyxDQUEyQzBuRixPQUEzQyxFQUFvRCxLQUFLRSxRQUF6RDtBQUNEO0FBQ0YsT0FKRCxNQUlPO0FBQ0w7QUFDQTtBQUNEO0FBQ0YsS0FYTSxNQVdBLElBQUlGLFlBQVl4QyxRQUFoQixFQUEwQjtBQUMvQixVQUNFeUQsYUFBYWhCLFFBQWIsS0FDQyxPQUFPQSxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLE9BQU9BLFFBQVAsS0FBb0IsUUFEckQsQ0FERixFQUdFO0FBQ0EsU0FBQ2hyQyxnQkFBZ0JBLGlCQUFpQixFQUFsQyxFQUFzQzM4QyxJQUF0QyxDQUEyQzBuRixPQUEzQyxFQUFvRCxLQUFLQyxRQUF6RDtBQUNEO0FBQ0YsS0FQTSxNQU9BLElBQ0xELFlBQVkzQyxpQ0FBWixJQUNBMkMsWUFBWTFDLDBCQUZQLEVBR0w7QUFDQTtBQUNELEtBTE0sTUFLQSxJQUFJcnhFLDZDQUF3Qi9WLGNBQXhCLENBQXVDOHBGLE9BQXZDLENBQUosRUFBcUQ7QUFDMUQsVUFBSUMsWUFBWSxJQUFoQixFQUFzQjtBQUNwQjtBQUNBLFlBQUlqMkYsSUFBT0EsSUFBSSxPQUFPaTJGLFFBQVAsS0FBb0IsVUFBbkMsRUFBK0M7QUFDN0NoQyxzQ0FBNEIrQixPQUE1QixFQUFxQ0MsUUFBckM7QUFDRDtBQUNEUiwwQkFBa0JDLG9CQUFsQixFQUF3Q00sT0FBeEM7QUFDRDtBQUNELFVBQUksQ0FBQy9xQyxhQUFELElBQWtCZ3NDLGFBQWFoQixRQUFuQyxFQUE2QztBQUMzQztBQUNBO0FBQ0E7QUFDQWhyQyx3QkFBZ0IsRUFBaEI7QUFDRDtBQUNGLEtBZE0sTUFjQTtBQUNMO0FBQ0E7QUFDQSxPQUFDQSxnQkFBZ0JBLGlCQUFpQixFQUFsQyxFQUFzQzM4QyxJQUF0QyxDQUEyQzBuRixPQUEzQyxFQUFvREMsUUFBcEQ7QUFDRDtBQUNGO0FBQ0QsTUFBSWMsWUFBSixFQUFrQjtBQUNoQixRQUFJLzJGLElBQUosRUFBYTtBQUNYLDBFQUF3QysyRixZQUF4QyxFQUFzRHYrRSxVQUFVaTdFLEtBQVYsQ0FBdEQ7QUFDRDtBQUNELEtBQUN4b0MsZ0JBQWdCQSxpQkFBaUIsRUFBbEMsRUFBc0MzOEMsSUFBdEMsQ0FBMkNtbEYsS0FBM0MsRUFBa0RzRCxZQUFsRDtBQUNEO0FBQ0QsU0FBTzlyQyxhQUFQO0FBQ0Q7O0FBRUQ7QUFDTyxTQUFTeW5DLGdCQUFULENBQ0xxRCxVQURLLEVBRUw5cUMsYUFGSyxFQUdMcm1ELEdBSEssRUFJTCt4RixZQUpLLEVBS0xDLFlBTEssRUFNQztBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQ0VoeUYsUUFBUSxPQUFSLElBQ0FneUYsYUFBYWp5RixJQUFiLEtBQXNCLE9BRHRCLElBRUFpeUYsYUFBYTcxRixJQUFiLElBQXFCLElBSHZCLEVBSUU7QUFDQSxzQ0FBMkJnMUYsVUFBM0IsRUFBdUNhLFlBQXZDO0FBQ0Q7O0FBRUQsTUFBTVAsd0JBQXdCLGlDQUFrQnp4RixHQUFsQixFQUF1Qit4RixZQUF2QixDQUE5QjtBQUNBLE1BQU14eUUsdUJBQXVCLGlDQUFrQnZmLEdBQWxCLEVBQXVCZ3lGLFlBQXZCLENBQTdCO0FBQ0E7QUFDQVIsc0JBQ0VMLFVBREYsRUFFRTlxQyxhQUZGLEVBR0VvckMscUJBSEYsRUFJRWx5RSxvQkFKRjs7QUFPQTtBQUNBO0FBQ0EsVUFBUXZmLEdBQVI7QUFDRSxTQUFLLE9BQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQSx3Q0FBMkJteEYsVUFBM0IsRUFBdUNhLFlBQXZDO0FBQ0E7QUFDRixTQUFLLFVBQUw7QUFDRSwyQ0FBOEJiLFVBQTlCLEVBQTBDYSxZQUExQztBQUNBO0FBQ0YsU0FBSyxRQUFMO0FBQ0U7QUFDQTtBQUNBLDZDQUFnQ2IsVUFBaEMsRUFBNENhLFlBQTVDO0FBQ0E7QUFkSjtBQWdCRDs7QUFFRCxTQUFTTyx1QkFBVCxDQUFpQ2xyRixRQUFqQyxFQUFrRTtBQUNoRSxNQUFJak0sSUFBSixFQUFhO0FBQ1gsUUFBTW9pQixpQkFBaUJuVyxTQUFTb1csV0FBVCxFQUF2QjtBQUNBLFFBQUksQ0FBQzh0QyxnQ0FBc0Jqa0QsY0FBdEIsQ0FBcUNrVyxjQUFyQyxDQUFMLEVBQTJEO0FBQ3pELGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBTyt0QyxnQ0FBc0IvdEMsY0FBdEIsS0FBeUMsSUFBaEQ7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVNLFNBQVN1d0Usc0JBQVQsQ0FDTG9ELFVBREssRUFFTG54RixHQUZLLEVBR0w0eEYsUUFISyxFQUlMdG1DLGVBSkssRUFLTHdsQyxvQkFMSyxFQU1nQjtBQUNyQixNQUFJdnhFLDZCQUFKO0FBQ0EsTUFBSWl6RSw0QkFBSjs7QUFFQSxNQUFJcDNGLElBQUosRUFBYTtBQUNYNHpGLCtCQUEyQjRDLFNBQVNsRCwwQkFBVCxNQUF5QyxJQUFwRTtBQUNBbnZFLDJCQUF1QixpQ0FBa0J2ZixHQUFsQixFQUF1QjR4RixRQUF2QixDQUF2QjtBQUNBM0Msb0NBQWdDanZGLEdBQWhDLEVBQXFDNHhGLFFBQXJDO0FBQ0EsUUFDRXJ5RSx3QkFDQSxDQUFDZ3ZFLGVBREQsSUFFQzRDLFVBQUQsQ0FBa0JVLFNBSHBCLEVBSUU7QUFDQSw2QkFDRSxLQURGLEVBRUUsMkRBQ0UsK0JBSEosRUFJRSxpRUFBeUMsYUFKM0M7QUFNQXRELHdCQUFrQixJQUFsQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxVQUFRdnVGLEdBQVI7QUFDRSxTQUFLLFFBQUw7QUFDQSxTQUFLLFFBQUw7QUFDRSxzREFBaUJ5TSwrQkFBakIsRUFBMkIwa0YsVUFBM0I7QUFDQTtBQUNGLFNBQUssT0FBTDtBQUNBLFNBQUssT0FBTDtBQUNFO0FBQ0EsV0FBSyxJQUFJbDFFLElBQUksQ0FBYixFQUFnQkEsSUFBSTdNLHVDQUFnQjlTLE1BQXBDLEVBQTRDMmYsR0FBNUMsRUFBaUQ7QUFDL0Msd0RBQWlCN00sdUNBQWdCNk0sQ0FBaEIsQ0FBakIsRUFBcUNrMUUsVUFBckM7QUFDRDtBQUNEO0FBQ0YsU0FBSyxRQUFMO0FBQ0Usc0RBQWlCbGxGLGdDQUFqQixFQUE0QmtsRixVQUE1QjtBQUNBO0FBQ0YsU0FBSyxLQUFMO0FBQ0EsU0FBSyxPQUFMO0FBQ0EsU0FBSyxNQUFMO0FBQ0Usc0RBQWlCbGxGLGdDQUFqQixFQUE0QmtsRixVQUE1QjtBQUNBLHNEQUFpQjFrRiwrQkFBakIsRUFBMkIwa0YsVUFBM0I7QUFDQTtBQUNGLFNBQUssTUFBTDtBQUNFLHNEQUFpQmxqRixnQ0FBakIsRUFBNEJrakYsVUFBNUI7QUFDQSxzREFBaUI1aUYsaUNBQWpCLEVBQTZCNGlGLFVBQTdCO0FBQ0E7QUFDRixTQUFLLFNBQUw7QUFDRSxzREFBaUJ4aUYsaUNBQWpCLEVBQTZCd2lGLFVBQTdCO0FBQ0E7QUFDRixTQUFLLE9BQUw7QUFDRSwyQ0FBOEJBLFVBQTlCLEVBQTBDUyxRQUExQztBQUNBLHNEQUFpQnZsRixrQ0FBakIsRUFBOEI4a0YsVUFBOUI7QUFDQTtBQUNBO0FBQ0FOLHdCQUFrQkMsb0JBQWxCLEVBQXdDLFVBQXhDO0FBQ0E7QUFDRixTQUFLLFFBQUw7QUFDRSx5Q0FBNEJLLFVBQTVCLEVBQXdDUyxRQUF4QztBQUNBO0FBQ0YsU0FBSyxRQUFMO0FBQ0UsNENBQStCVCxVQUEvQixFQUEyQ1MsUUFBM0M7QUFDQSxzREFBaUJ2bEYsa0NBQWpCLEVBQThCOGtGLFVBQTlCO0FBQ0E7QUFDQTtBQUNBTix3QkFBa0JDLG9CQUFsQixFQUF3QyxVQUF4QztBQUNBO0FBQ0YsU0FBSyxVQUFMO0FBQ0UsOENBQWlDSyxVQUFqQyxFQUE2Q1MsUUFBN0M7QUFDQSxzREFBaUJ2bEYsa0NBQWpCLEVBQThCOGtGLFVBQTlCO0FBQ0E7QUFDQTtBQUNBTix3QkFBa0JDLG9CQUFsQixFQUF3QyxVQUF4QztBQUNBO0FBbkRKOztBQXNEQSxrQ0FBaUI5d0YsR0FBakIsRUFBc0I0eEYsUUFBdEI7O0FBRUEsTUFBSXgyRixJQUFKLEVBQWE7QUFDWG8zRiwwQkFBc0IsSUFBSWh1RSxHQUFKLEVBQXRCO0FBQ0EsUUFBTWl1RSxhQUFhdEIsV0FBV3NCLFVBQTlCO0FBQ0EsU0FBSyxJQUFJeDJFLEtBQUksQ0FBYixFQUFnQkEsS0FBSXcyRSxXQUFXbjJGLE1BQS9CLEVBQXVDMmYsSUFBdkMsRUFBNEM7QUFDMUMsVUFBTTlmLE9BQU9zMkYsV0FBV3gyRSxFQUFYLEVBQWM5ZixJQUFkLENBQW1Cc2hCLFdBQW5CLEVBQWI7QUFDQSxjQUFRdGhCLElBQVI7QUFDRTtBQUNBLGFBQUssZ0JBQUw7QUFDRTtBQUNGO0FBQ0E7QUFDQSxhQUFLLE9BQUw7QUFDRTtBQUNGLGFBQUssU0FBTDtBQUNFO0FBQ0YsYUFBSyxVQUFMO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDQXEyRiw4QkFBb0I3c0UsR0FBcEIsQ0FBd0I4c0UsV0FBV3gyRSxFQUFYLEVBQWM5ZixJQUF0QztBQWZKO0FBaUJEO0FBQ0Y7O0FBRUQsTUFBSWtxRCxnQkFBZ0IsSUFBcEI7QUFDQSxPQUFLLElBQU0rcUMsT0FBWCxJQUFzQlEsUUFBdEIsRUFBZ0M7QUFDOUIsUUFBSSxDQUFDQSxTQUFTdHFGLGNBQVQsQ0FBd0I4cEYsT0FBeEIsQ0FBTCxFQUF1QztBQUNyQztBQUNEO0FBQ0QsUUFBTUMsV0FBV08sU0FBU1IsT0FBVCxDQUFqQjtBQUNBLFFBQUlBLFlBQVl4QyxRQUFoQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJLE9BQU95QyxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLFlBQUlGLFdBQVc1cUMsV0FBWCxLQUEyQjhxQyxRQUEvQixFQUF5QztBQUN2QyxjQUFJajJGLElBQU9BLElBQUksQ0FBQzR6Rix3QkFBaEIsRUFBMEM7QUFDeENFLGtDQUFzQmlDLFdBQVc1cUMsV0FBakMsRUFBOEM4cUMsUUFBOUM7QUFDRDtBQUNEaHJDLDBCQUFnQixDQUFDdW9DLFFBQUQsRUFBV3lDLFFBQVgsQ0FBaEI7QUFDRDtBQUNGLE9BUEQsTUFPTyxJQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDdkMsWUFBSUYsV0FBVzVxQyxXQUFYLEtBQTJCLEtBQUs4cUMsUUFBcEMsRUFBOEM7QUFDNUMsY0FBSWoyRixJQUFPQSxJQUFJLENBQUM0ekYsd0JBQWhCLEVBQTBDO0FBQ3hDRSxrQ0FBc0JpQyxXQUFXNXFDLFdBQWpDLEVBQThDOHFDLFFBQTlDO0FBQ0Q7QUFDRGhyQywwQkFBZ0IsQ0FBQ3VvQyxRQUFELEVBQVcsS0FBS3lDLFFBQWhCLENBQWhCO0FBQ0Q7QUFDRjtBQUNGLEtBekJELE1BeUJPLElBQUloMEUsNkNBQXdCL1YsY0FBeEIsQ0FBdUM4cEYsT0FBdkMsQ0FBSixFQUFxRDtBQUMxRCxVQUFJQyxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFlBQUlqMkYsSUFBT0EsSUFBSSxPQUFPaTJGLFFBQVAsS0FBb0IsVUFBbkMsRUFBK0M7QUFDN0NoQyxzQ0FBNEIrQixPQUE1QixFQUFxQ0MsUUFBckM7QUFDRDtBQUNEUiwwQkFBa0JDLG9CQUFsQixFQUF3Q00sT0FBeEM7QUFDRDtBQUNGLEtBUE0sTUFPQSxJQUNMaDJGLElBQU9BO0FBQ1A7QUFDQSxXQUFPbWtCLG9CQUFQLEtBQWdDLFNBSDNCLEVBSUw7QUFDQTtBQUNBLFVBQUk0d0Usb0JBQUo7QUFDQSxVQUFNN3dFLGVBQWUsa0NBQWdCOHhFLE9BQWhCLENBQXJCO0FBQ0EsVUFBSXBDLHdCQUFKLEVBQThCO0FBQzVCO0FBQ0QsT0FGRCxNQUVPLElBQ0xvQyxZQUFZM0MsaUNBQVosSUFDQTJDLFlBQVkxQywwQkFEWjtBQUVBO0FBQ0E7QUFDQTBDLGtCQUFZLE9BSlosSUFLQUEsWUFBWSxTQUxaLElBTUFBLFlBQVksVUFQUCxFQVFMO0FBQ0E7QUFDRCxPQVZNLE1BVUEsSUFBSUEsWUFBWTVDLDBCQUFoQixFQUE0QztBQUNqRCxZQUFNa0UsYUFBYXZCLFdBQVdQLFNBQTlCO0FBQ0EsWUFBTVUsV0FBV0QsV0FBV0EsU0FBU3ZDLElBQVQsQ0FBWCxHQUE0Qnh6RixTQUE3QztBQUNBLFlBQU1xM0YsZUFBZW5ELGNBQ25CMkIsVUFEbUIsRUFFbkJHLFlBQVksSUFBWixHQUFtQkEsUUFBbkIsR0FBOEIsRUFGWCxDQUFyQjtBQUlBLFlBQUlxQixpQkFBaUJELFVBQXJCLEVBQWlDO0FBQy9CdkQsZ0NBQXNCaUMsT0FBdEIsRUFBK0JzQixVQUEvQixFQUEyQ0MsWUFBM0M7QUFDRDtBQUNGLE9BVk0sTUFVQSxJQUFJdkIsWUFBWXZDLEtBQWhCLEVBQXVCO0FBQzVCO0FBQ0EyRCw0QkFBb0I3aUUsTUFBcEIsQ0FBMkJ5aEUsT0FBM0I7O0FBRUEsWUFBSTlCLCtCQUFKLEVBQXFDO0FBQ25DLGNBQU1zRCxnQkFBZ0IsMkRBQStCdkIsUUFBL0IsQ0FBdEI7QUFDQWxCLHdCQUFjZ0IsV0FBV3o5QyxZQUFYLENBQXdCLE9BQXhCLENBQWQ7QUFDQSxjQUFJay9DLGtCQUFrQnpDLFdBQXRCLEVBQW1DO0FBQ2pDaEIsa0NBQXNCaUMsT0FBdEIsRUFBK0JqQixXQUEvQixFQUE0Q3lDLGFBQTVDO0FBQ0Q7QUFDRjtBQUNGLE9BWE0sTUFXQSxJQUFJcnpFLG9CQUFKLEVBQTBCO0FBQy9CO0FBQ0FpekUsNEJBQW9CN2lFLE1BQXBCLENBQTJCeWhFLFFBQVEzekUsV0FBUixFQUEzQjtBQUNBMHlFLHNCQUFjLGlEQUFxQmdCLFVBQXJCLEVBQWlDQyxPQUFqQyxFQUEwQ0MsUUFBMUMsQ0FBZDs7QUFFQSxZQUFJQSxhQUFhbEIsV0FBakIsRUFBOEI7QUFDNUJoQixnQ0FBc0JpQyxPQUF0QixFQUErQmpCLFdBQS9CLEVBQTRDa0IsUUFBNUM7QUFDRDtBQUNGLE9BUk0sTUFRQSxJQUNMLENBQUMsd0NBQXNCRCxPQUF0QixFQUErQjl4RSxZQUEvQixFQUE2Q0Msb0JBQTdDLENBQUQsSUFDQSxDQUFDLHdDQUNDNnhFLE9BREQsRUFFQ0MsUUFGRCxFQUdDL3hFLFlBSEQsRUFJQ0Msb0JBSkQsQ0FGSSxFQVFMO0FBQ0EsWUFBSXN6RSwyQkFBMkIsS0FBL0I7QUFDQSxZQUFJdnpFLGlCQUFpQixJQUFyQixFQUEyQjtBQUN6QjtBQUNBa3pFLDhCQUFvQjdpRSxNQUFwQixDQUEyQnJRLGFBQWFGLGFBQXhDO0FBQ0Erd0Usd0JBQWMsZ0RBQ1pnQixVQURZLEVBRVpDLE9BRlksRUFHWkMsUUFIWSxFQUlaL3hFLFlBSlksQ0FBZDtBQU1ELFNBVEQsTUFTTztBQUNMLGNBQUl3ekUsZUFBZXhuQyxlQUFuQjtBQUNBLGNBQUl3bkMsaUJBQWlCL25DLGNBQXJCLEVBQXFDO0FBQ25DK25DLDJCQUFlLDBDQUFzQjl5RixHQUF0QixDQUFmO0FBQ0Q7QUFDRCxjQUFJOHlGLGlCQUFpQi9uQyxjQUFyQixFQUFxQztBQUNuQztBQUNBeW5DLGdDQUFvQjdpRSxNQUFwQixDQUEyQnloRSxRQUFRM3pFLFdBQVIsRUFBM0I7QUFDRCxXQUhELE1BR087QUFDTCxnQkFBTXMxRSxlQUFlUix3QkFBd0JuQixPQUF4QixDQUFyQjtBQUNBLGdCQUFJMkIsaUJBQWlCLElBQWpCLElBQXlCQSxpQkFBaUIzQixPQUE5QyxFQUF1RDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0F5Qix5Q0FBMkIsSUFBM0I7QUFDQTtBQUNBTCxrQ0FBb0I3aUUsTUFBcEIsQ0FBMkJvakUsWUFBM0I7QUFDRDtBQUNEO0FBQ0FQLGdDQUFvQjdpRSxNQUFwQixDQUEyQnloRSxPQUEzQjtBQUNEO0FBQ0RqQix3QkFBYyxpREFBcUJnQixVQUFyQixFQUFpQ0MsT0FBakMsRUFBMENDLFFBQTFDLENBQWQ7QUFDRDs7QUFFRCxZQUFJQSxhQUFhbEIsV0FBYixJQUE0QixDQUFDMEMsd0JBQWpDLEVBQTJEO0FBQ3pEMUQsZ0NBQXNCaUMsT0FBdEIsRUFBK0JqQixXQUEvQixFQUE0Q2tCLFFBQTVDO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsTUFBSWoyRixJQUFKLEVBQWE7QUFDWDtBQUNBLFFBQUlvM0Ysb0JBQW9CdmpFLElBQXBCLEdBQTJCLENBQTNCLElBQWdDLENBQUMrL0Qsd0JBQXJDLEVBQStEO0FBQzdEO0FBQ0FJLDZCQUF1Qm9ELG1CQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsVUFBUXh5RixHQUFSO0FBQ0UsU0FBSyxPQUFMO0FBQ0U7QUFDQTtBQUNBLHFDQUFPbXhGLFVBQVA7QUFDQSwyQ0FBOEJBLFVBQTlCLEVBQTBDUyxRQUExQyxFQUFvRCxJQUFwRDtBQUNBO0FBQ0YsU0FBSyxVQUFMO0FBQ0U7QUFDQTtBQUNBLHFDQUFPVCxVQUFQO0FBQ0EsOENBQWlDQSxVQUFqQyxFQUE2Q1MsUUFBN0M7QUFDQTtBQUNGLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0UsVUFBSSxPQUFPQSxTQUFTRSxPQUFoQixLQUE0QixVQUFoQyxFQUE0QztBQUMxQztBQUNBcEUseUNBQW1DeUQsVUFBbkM7QUFDRDtBQUNEO0FBMUJKOztBQTZCQSxTQUFPOXFDLGFBQVA7QUFDRDs7QUFFTSxTQUFTMm5DLGdCQUFULENBQTBCZ0YsUUFBMUIsRUFBMENyN0QsSUFBMUMsRUFBaUU7QUFDdEUsTUFBTXM3RCxjQUFjRCxTQUFTcmYsU0FBVCxLQUF1Qmg4QyxJQUEzQztBQUNBLFNBQU9zN0QsV0FBUDtBQUNEOztBQUVNLFNBQVNoRixvQkFBVCxDQUE4QitFLFFBQTlCLEVBQThDcjdELElBQTlDLEVBQTREO0FBQ2pFLE1BQUl2OEIsSUFBSixFQUFhO0FBQ1g4ekYsMEJBQXNCOEQsU0FBU3JmLFNBQS9CLEVBQTBDaDhDLElBQTFDO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTdTJELCtCQUFULENBQ0x6OUUsVUFESyxFQUVMb0csS0FGSyxFQUdMO0FBQ0EsTUFBSXpiLElBQUosRUFBYTtBQUNYLFFBQUlrekYsdUJBQUosRUFBNkI7QUFDM0I7QUFDRDtBQUNEQSw4QkFBMEIsSUFBMUI7QUFDQSx1Q0FDRSxLQURGLEVBRUUsdURBRkYsRUFHRXozRSxNQUFNOHZCLFFBQU4sQ0FBZWxwQixXQUFmLEVBSEYsRUFJRWhOLFdBQVdrMkIsUUFBWCxDQUFvQmxwQixXQUFwQixFQUpGO0FBTUQ7QUFDRjs7QUFFTSxTQUFTMHdFLDRCQUFULENBQ0wxOUUsVUFESyxFQUVMb0csS0FGSyxFQUdMO0FBQ0EsTUFBSXpiLElBQUosRUFBYTtBQUNYLFFBQUlrekYsdUJBQUosRUFBNkI7QUFDM0I7QUFDRDtBQUNEQSw4QkFBMEIsSUFBMUI7QUFDQSx1Q0FDRSxLQURGLEVBRUUsbUVBRkYsRUFHRXozRSxNQUFNODhELFNBSFIsRUFJRWxqRSxXQUFXazJCLFFBQVgsQ0FBb0JscEIsV0FBcEIsRUFKRjtBQU1EO0FBQ0Y7O0FBRU0sU0FBUzJ3RSw4QkFBVCxDQUNMMzlFLFVBREssRUFFTHpRLEdBRkssRUFHTDRRLEtBSEssRUFJTDtBQUNBLE1BQUl4VixJQUFKLEVBQWE7QUFDWCxRQUFJa3pGLHVCQUFKLEVBQTZCO0FBQzNCO0FBQ0Q7QUFDREEsOEJBQTBCLElBQTFCO0FBQ0EsdUNBQ0UsS0FERixFQUVFLDBEQUZGLEVBR0V0dUYsR0FIRixFQUlFeVEsV0FBV2syQixRQUFYLENBQW9CbHBCLFdBQXBCLEVBSkY7QUFNRDtBQUNGOztBQUVNLFNBQVM0d0UsMkJBQVQsQ0FDTDU5RSxVQURLLEVBRUxrbkIsSUFGSyxFQUdMO0FBQ0EsTUFBSXY4QixJQUFKLEVBQWE7QUFDWCxRQUFJdThCLFNBQVMsRUFBYixFQUFpQjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNELFFBQUkyMkQsdUJBQUosRUFBNkI7QUFDM0I7QUFDRDtBQUNEQSw4QkFBMEIsSUFBMUI7QUFDQSx1Q0FDRSxLQURGLEVBRUUsd0VBRkYsRUFHRTMyRCxJQUhGLEVBSUVsbkIsV0FBV2syQixRQUFYLENBQW9CbHBCLFdBQXBCLEVBSkY7QUFNRDtBQUNGOztBQUVNLFNBQVM4ekIsc0JBQVQsQ0FDTDQvQyxVQURLLEVBRUxueEYsR0FGSyxFQUdMNFEsS0FISyxFQUlDO0FBQ04sVUFBUTVRLEdBQVI7QUFDRSxTQUFLLE9BQUw7QUFDRSxpREFBb0NteEYsVUFBcEMsRUFBZ0R2Z0YsS0FBaEQ7QUFDQTtBQUNGLFNBQUssVUFBTDtBQUNFLG9EQUF1Q3VnRixVQUF2QyxFQUFtRHZnRixLQUFuRDtBQUNBO0FBQ0YsU0FBSyxRQUFMO0FBQ0Usa0RBQXFDdWdGLFVBQXJDLEVBQWlEdmdGLEtBQWpEO0FBQ0E7QUFUSjtBQVdELEM7Ozs7Ozs7Ozs7Ozs7Ozs4UUN0dUNEOzs7Ozs7Ozs7UUF5Q2dCc2lGLGEsR0FBQUEsYTtRQXVDQTVoRCxnQixHQUFBQSxnQjtRQU9BSixZLEdBQUFBLFk7O0FBOUVoQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQSxJQUFJaWlELDZCQUE2QixLQUFqQztBQUNBLElBQUlDLHNCQUFzQixLQUExQjs7QUFFQSxTQUFTQyxlQUFULENBQXlCbnFFLFFBQXpCLEVBQW1DO0FBQ2pDLE1BQUlVLFVBQVUsRUFBZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Fya0Isa0JBQU04OEQsUUFBTixDQUFlcGlELE9BQWYsQ0FBdUJpSixRQUF2QixFQUFpQyxVQUFTclMsS0FBVCxFQUFnQjtBQUMvQyxRQUFJQSxTQUFTLElBQWIsRUFBbUI7QUFDakI7QUFDRDtBQUNEK1MsZUFBVy9TLEtBQVg7QUFDQTtBQUNBO0FBQ0E7QUFDRCxHQVJEOztBQVVBLFNBQU8rUyxPQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJTyxTQUFTc3BFLGFBQVQsQ0FBdUI1cEUsT0FBdkIsRUFBeUMxWSxLQUF6QyxFQUF3RDtBQUM3RCxNQUFJeFYsSUFBSixFQUFhO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLFFBQU93VixNQUFNc1ksUUFBYixNQUEwQixRQUExQixJQUFzQ3RZLE1BQU1zWSxRQUFOLEtBQW1CLElBQTdELEVBQW1FO0FBQ2pFM2pCLHNCQUFNODhELFFBQU4sQ0FBZXBpRCxPQUFmLENBQXVCclAsTUFBTXNZLFFBQTdCLEVBQXVDLFVBQVNyUyxLQUFULEVBQWdCO0FBQ3JELFlBQUlBLFNBQVMsSUFBYixFQUFtQjtBQUNqQjtBQUNEO0FBQ0QsWUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCLE9BQU9BLEtBQVAsS0FBaUIsUUFBbEQsRUFBNEQ7QUFDMUQ7QUFDRDtBQUNELFlBQUksT0FBT0EsTUFBTTlXLElBQWIsS0FBc0IsUUFBMUIsRUFBb0M7QUFDbEM7QUFDRDtBQUNELFlBQUksQ0FBQ3F6RixtQkFBTCxFQUEwQjtBQUN4QkEsZ0NBQXNCLElBQXRCO0FBQ0EsaUNBQ0UsS0FERixFQUVFLDhEQUZGO0FBSUQ7QUFDRixPQWpCRDtBQWtCRDs7QUFFRDtBQUNBLFFBQUl4aUYsTUFBTWtoRCxRQUFOLElBQWtCLElBQWxCLElBQTBCLENBQUNxaEMsMEJBQS9CLEVBQTJEO0FBQ3pELDZCQUNFLEtBREYsRUFFRSxvRUFDRSxpQ0FISjtBQUtBQSxtQ0FBNkIsSUFBN0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBUzdoRCxnQkFBVCxDQUEwQmhvQixPQUExQixFQUE0QzFZLEtBQTVDLEVBQTJEO0FBQ2hFO0FBQ0EsTUFBSUEsTUFBTTRPLEtBQU4sSUFBZSxJQUFuQixFQUF5QjtBQUN2QjhKLFlBQVEybkIsWUFBUixDQUFxQixPQUFyQixFQUE4Qiw2QkFBUyxxQ0FBaUJyZ0MsTUFBTTRPLEtBQXZCLENBQVQsQ0FBOUI7QUFDRDtBQUNGOztBQUVNLFNBQVMweEIsWUFBVCxDQUFzQjVuQixPQUF0QixFQUF3QzFZLEtBQXhDLEVBQXVEO0FBQzVELE1BQU1taEMsdUJBQWE3b0IsVUFBVTV0QixTQUF2QixJQUFxQ3NWLEtBQXJDLENBQU47QUFDQSxNQUFNZ1osVUFBVXlwRSxnQkFBZ0J6aUYsTUFBTXNZLFFBQXRCLENBQWhCOztBQUVBLE1BQUlVLE9BQUosRUFBYTtBQUNYbW9CLGNBQVU3b0IsUUFBVixHQUFxQlUsT0FBckI7QUFDRDs7QUFFRCxTQUFPbW9CLFNBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7UUN3Q2ViLFksR0FBQUEsWTtRQU1BQyxnQixHQUFBQSxnQjtRQTZCQUcsZ0IsR0FBQUEsZ0I7UUFXQWdpRCxpQixHQUFBQSxpQjtRQW1CQS9oRCxzQixHQUFBQSxzQjs7QUEvTGhCOztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQWRBOzs7Ozs7Ozs7QUFTQTtBQU9BLElBQUlFLGlDQUFKOztBQUVBLElBQUlyMkMsSUFBSixFQUFhO0FBQ1hxMkMsNkJBQTJCLEtBQTNCO0FBQ0Q7O0FBUUQsU0FBUzg4QiwyQkFBVCxHQUF1QztBQUNyQyxNQUFNaHNFLFlBQVksNkRBQWxCO0FBQ0EsTUFBSUEsU0FBSixFQUFlO0FBQ2IsV0FBTyxxQ0FBcUNBLFNBQXJDLEdBQWlELElBQXhEO0FBQ0Q7QUFDRCxTQUFPLEVBQVA7QUFDRDs7QUFFRCxJQUFNZ3hGLGlCQUFpQixDQUFDLE9BQUQsRUFBVSxjQUFWLENBQXZCOztBQUVBOzs7QUFHQSxTQUFTQyxvQkFBVCxDQUE4QjVpRixLQUE5QixFQUFxQztBQUNuQzQyQiwwQ0FBOEI1UCxjQUE5QixDQUE2QyxRQUE3QyxFQUF1RGhuQixLQUF2RDs7QUFFQSxPQUFLLElBQUlxTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlzM0UsZUFBZWozRixNQUFuQyxFQUEyQzJmLEdBQTNDLEVBQWdEO0FBQzlDLFFBQU01VSxXQUFXa3NGLGVBQWV0M0UsQ0FBZixDQUFqQjtBQUNBLFFBQUlyTCxNQUFNdkosUUFBTixLQUFtQixJQUF2QixFQUE2QjtBQUMzQjtBQUNEO0FBQ0QsUUFBTW05QixVQUFVM21CLE1BQU0ybUIsT0FBTixDQUFjNXpCLE1BQU12SixRQUFOLENBQWQsQ0FBaEI7QUFDQSxRQUFJdUosTUFBTXcvQyxRQUFOLElBQWtCLENBQUM1ckIsT0FBdkIsRUFBZ0M7QUFDOUIsNkJBQ0UsS0FERixFQUVFLDREQUNFLHVCQUhKLEVBSUVuOUIsUUFKRixFQUtFa25FLDZCQUxGO0FBT0QsS0FSRCxNQVFPLElBQUksQ0FBQzM5RCxNQUFNdy9DLFFBQVAsSUFBbUI1ckIsT0FBdkIsRUFBZ0M7QUFDckMsNkJBQ0UsS0FERixFQUVFLHlEQUNFLGlDQUhKLEVBSUVuOUIsUUFKRixFQUtFa25FLDZCQUxGO0FBT0Q7QUFDRjtBQUNGOztBQUVELFNBQVNrbEIsYUFBVCxDQUNFL3dGLElBREYsRUFFRTB0RCxRQUZGLEVBR0VzaEMsU0FIRixFQUlFZ0Msa0JBSkYsRUFLRTtBQUlBLE1BQU03ZCxVQUEwQ256RSxLQUFLbXpFLE9BQXJEOztBQUVBLE1BQUl6bEIsUUFBSixFQUFjO0FBQ1osUUFBSXVqQyxpQkFBa0JqQyxTQUF0QjtBQUNBLFFBQUlrQyxnQkFBZ0IsRUFBcEI7QUFDQSxTQUFLLElBQUkzM0UsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMDNFLGVBQWVyM0YsTUFBbkMsRUFBMkMyZixHQUEzQyxFQUFnRDtBQUM5QztBQUNBMjNFLG9CQUFjLE1BQU1ELGVBQWUxM0UsQ0FBZixDQUFwQixJQUF5QyxJQUF6QztBQUNEO0FBQ0QsU0FBSyxJQUFJQSxLQUFJLENBQWIsRUFBZ0JBLEtBQUk0NUQsUUFBUXY1RSxNQUE1QixFQUFvQzJmLElBQXBDLEVBQXlDO0FBQ3ZDLFVBQU02MUMsV0FBVzhoQyxjQUFjdHNGLGNBQWQsQ0FBNkIsTUFBTXV1RSxRQUFRNTVELEVBQVIsRUFBV3VELEtBQTlDLENBQWpCO0FBQ0EsVUFBSXEyRCxRQUFRNTVELEVBQVIsRUFBVzYxQyxRQUFYLEtBQXdCQSxRQUE1QixFQUFzQztBQUNwQytqQixnQkFBUTU1RCxFQUFSLEVBQVc2MUMsUUFBWCxHQUFzQkEsUUFBdEI7QUFDRDtBQUNELFVBQUlBLFlBQVk0aEMsa0JBQWhCLEVBQW9DO0FBQ2xDN2QsZ0JBQVE1NUQsRUFBUixFQUFXNDNFLGVBQVgsR0FBNkIsSUFBN0I7QUFDRDtBQUNGO0FBQ0YsR0FoQkQsTUFnQk87QUFDTDtBQUNBO0FBQ0EsUUFBSUQsaUJBQWdCLDZCQUFTLHFDQUFrQmxDLFNBQWxCLENBQVQsQ0FBcEI7QUFDQSxRQUFJbUMsa0JBQWtCLElBQXRCO0FBQ0EsU0FBSyxJQUFJNTNFLE1BQUksQ0FBYixFQUFnQkEsTUFBSTQ1RCxRQUFRdjVFLE1BQTVCLEVBQW9DMmYsS0FBcEMsRUFBeUM7QUFDdkMsVUFBSTQ1RCxRQUFRNTVELEdBQVIsRUFBV3VELEtBQVgsS0FBcUJvMEUsY0FBekIsRUFBd0M7QUFDdEMvZCxnQkFBUTU1RCxHQUFSLEVBQVc2MUMsUUFBWCxHQUFzQixJQUF0QjtBQUNBLFlBQUk0aEMsa0JBQUosRUFBd0I7QUFDdEI3ZCxrQkFBUTU1RCxHQUFSLEVBQVc0M0UsZUFBWCxHQUE2QixJQUE3QjtBQUNEO0FBQ0Q7QUFDRDtBQUNELFVBQUlBLG9CQUFvQixJQUFwQixJQUE0QixDQUFDaGUsUUFBUTU1RCxHQUFSLEVBQVdMLFFBQTVDLEVBQXNEO0FBQ3BEaTRFLDBCQUFrQmhlLFFBQVE1NUQsR0FBUixDQUFsQjtBQUNEO0FBQ0Y7QUFDRCxRQUFJNDNFLG9CQUFvQixJQUF4QixFQUE4QjtBQUM1QkEsc0JBQWdCL2hDLFFBQWhCLEdBQTJCLElBQTNCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JPLFNBQVM1Z0IsWUFBVCxDQUFzQjVuQixPQUF0QixFQUF3QzFZLEtBQXhDLEVBQXVEO0FBQzVELFNBQU9uSixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQmtKLEtBQWxCLEVBQXlCO0FBQzlCNE8sV0FBT2xrQjtBQUR1QixHQUF6QixDQUFQO0FBR0Q7O0FBRU0sU0FBUzYxQyxnQkFBVCxDQUEwQjduQixPQUExQixFQUE0QzFZLEtBQTVDLEVBQTJEO0FBQ2hFLE1BQU1sTyxPQUFTNG1CLE9BQWY7QUFDQSxNQUFJbHVCLElBQUosRUFBYTtBQUNYbzRGLHlCQUFxQjVpRixLQUFyQjtBQUNEOztBQUVEbE8sT0FBS3V2QyxhQUFMLEdBQXFCO0FBQ25CNmhELGlCQUFhLENBQUMsQ0FBQ2xqRixNQUFNdy9DO0FBREYsR0FBckI7O0FBSUEsTUFBSWgxRCxJQUFKLEVBQWE7QUFDWCxRQUNFd1YsTUFBTTRPLEtBQU4sS0FBZ0Jsa0IsU0FBaEIsSUFDQXNWLE1BQU0wb0IsWUFBTixLQUF1QmgrQixTQUR2QixJQUVBLENBQUNtMkMsd0JBSEgsRUFJRTtBQUNBLDZCQUNFLEtBREYsRUFFRSwrREFDRSxvRUFERixHQUVFLGtFQUZGLEdBR0Usb0RBSEYsR0FJRSwyQ0FOSjtBQVFBQSxpQ0FBMkIsSUFBM0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBU0gsZ0JBQVQsQ0FBMEJob0IsT0FBMUIsRUFBNEMxWSxLQUE1QyxFQUEyRDtBQUNoRSxNQUFNbE8sT0FBUzRtQixPQUFmO0FBQ0E1bUIsT0FBSzB0RCxRQUFMLEdBQWdCLENBQUMsQ0FBQ3gvQyxNQUFNdy9DLFFBQXhCO0FBQ0EsTUFBTTV3QyxRQUFRNU8sTUFBTTRPLEtBQXBCO0FBQ0EsTUFBSUEsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCaTBFLGtCQUFjL3dGLElBQWQsRUFBb0IsQ0FBQyxDQUFDa08sTUFBTXcvQyxRQUE1QixFQUFzQzV3QyxLQUF0QyxFQUE2QyxLQUE3QztBQUNELEdBRkQsTUFFTyxJQUFJNU8sTUFBTTBvQixZQUFOLElBQXNCLElBQTFCLEVBQWdDO0FBQ3JDbTZELGtCQUFjL3dGLElBQWQsRUFBb0IsQ0FBQyxDQUFDa08sTUFBTXcvQyxRQUE1QixFQUFzQ3gvQyxNQUFNMG9CLFlBQTVDLEVBQTBELElBQTFEO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTZzZELGlCQUFULENBQTJCaHFFLE9BQTNCLEVBQTZDMVksS0FBN0MsRUFBNEQ7QUFDakUsTUFBTWxPLE9BQVM0bUIsT0FBZjtBQUNBLE1BQU13cUUsY0FBY3B4RixLQUFLdXZDLGFBQUwsQ0FBbUI2aEQsV0FBdkM7QUFDQXB4RixPQUFLdXZDLGFBQUwsQ0FBbUI2aEQsV0FBbkIsR0FBaUMsQ0FBQyxDQUFDbGpGLE1BQU13L0MsUUFBekM7O0FBRUEsTUFBTTV3QyxRQUFRNU8sTUFBTTRPLEtBQXBCO0FBQ0EsTUFBSUEsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCaTBFLGtCQUFjL3dGLElBQWQsRUFBb0IsQ0FBQyxDQUFDa08sTUFBTXcvQyxRQUE1QixFQUFzQzV3QyxLQUF0QyxFQUE2QyxLQUE3QztBQUNELEdBRkQsTUFFTyxJQUFJczBFLGdCQUFnQixDQUFDLENBQUNsakYsTUFBTXcvQyxRQUE1QixFQUFzQztBQUMzQztBQUNBLFFBQUl4L0MsTUFBTTBvQixZQUFOLElBQXNCLElBQTFCLEVBQWdDO0FBQzlCbTZELG9CQUFjL3dGLElBQWQsRUFBb0IsQ0FBQyxDQUFDa08sTUFBTXcvQyxRQUE1QixFQUFzQ3gvQyxNQUFNMG9CLFlBQTVDLEVBQTBELElBQTFEO0FBQ0QsS0FGRCxNQUVPO0FBQ0w7QUFDQW02RCxvQkFBYy93RixJQUFkLEVBQW9CLENBQUMsQ0FBQ2tPLE1BQU13L0MsUUFBNUIsRUFBc0N4L0MsTUFBTXcvQyxRQUFOLEdBQWlCLEVBQWpCLEdBQXNCLEVBQTVELEVBQWdFLEtBQWhFO0FBQ0Q7QUFDRjtBQUNGOztBQUVNLFNBQVM3ZSxzQkFBVCxDQUFnQ2pvQixPQUFoQyxFQUFrRDFZLEtBQWxELEVBQWlFO0FBQ3RFLE1BQU1sTyxPQUFTNG1CLE9BQWY7QUFDQSxNQUFNOUosUUFBUTVPLE1BQU00TyxLQUFwQjs7QUFFQSxNQUFJQSxTQUFTLElBQWIsRUFBbUI7QUFDakJpMEUsa0JBQWMvd0YsSUFBZCxFQUFvQixDQUFDLENBQUNrTyxNQUFNdy9DLFFBQTVCLEVBQXNDNXdDLEtBQXRDLEVBQTZDLEtBQTdDO0FBQ0Q7QUFDRixDOzs7Ozs7Ozs7Ozs7O2tRQ2hORDs7Ozs7Ozs7O1FBeUNnQjB4QixZLEdBQUFBLFk7UUF1QkFDLGdCLEdBQUFBLGdCO1FBK0RBRSxhLEdBQUFBLGE7UUFxQkFDLGdCLEdBQUFBLGdCO1FBZUFDLHNCLEdBQUFBLHNCOztBQTFKaEI7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFHQSxJQUFJd2lELHVCQUF1QixLQUEzQjs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCTyxTQUFTN2lELFlBQVQsQ0FBc0I1bkIsT0FBdEIsRUFBd0MxWSxLQUF4QyxFQUF1RDtBQUM1RCxNQUFNbE8sT0FBUzRtQixPQUFmO0FBQ0EsMkJBQ0UxWSxNQUFNb2pGLHVCQUFOLElBQWlDLElBRG5DLEVBRUUsOERBRkY7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTWppRCx5QkFDRG5oQyxLQURDO0FBRUo0TyxXQUFPbGtCLFNBRkg7QUFHSmcrQixrQkFBY2grQixTQUhWO0FBSUo0dEIsY0FBVSw2QkFBU3htQixLQUFLdXZDLGFBQUwsQ0FBbUJFLFlBQTVCO0FBSk4sSUFBTjs7QUFPQSxTQUFPSixTQUFQO0FBQ0Q7O0FBRU0sU0FBU1osZ0JBQVQsQ0FBMEI3bkIsT0FBMUIsRUFBNEMxWSxLQUE1QyxFQUEyRDtBQUNoRSxNQUFNbE8sT0FBUzRtQixPQUFmO0FBQ0EsTUFBSWx1QixJQUFKLEVBQWE7QUFDWG9zQyw0Q0FBOEI1UCxjQUE5QixDQUE2QyxVQUE3QyxFQUF5RGhuQixLQUF6RDtBQUNBLFFBQ0VBLE1BQU00TyxLQUFOLEtBQWdCbGtCLFNBQWhCLElBQ0FzVixNQUFNMG9CLFlBQU4sS0FBdUJoK0IsU0FEdkIsSUFFQSxDQUFDeTRGLG9CQUhILEVBSUU7QUFDQSw2QkFDRSxLQURGLEVBRUUsb0VBQ0UsOERBREYsR0FFRSxvRUFGRixHQUdFLG9FQUhGLEdBSUUsNENBSkYsR0FLRSwyQ0FQSixFQVFFLGlFQUF5QyxhQVIzQztBQVVBQSw2QkFBdUIsSUFBdkI7QUFDRDtBQUNGOztBQUVELE1BQUk1aEQsZUFBZXZoQyxNQUFNNE8sS0FBekI7O0FBRUE7QUFDQSxNQUFJMnlCLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixRQUFJN1ksZUFBZTFvQixNQUFNMG9CLFlBQXpCO0FBQ0E7QUFDQSxRQUFJcFEsV0FBV3RZLE1BQU1zWSxRQUFyQjtBQUNBLFFBQUlBLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsVUFBSTl0QixJQUFKLEVBQWE7QUFDWCwrQkFDRSxLQURGLEVBRUUsZ0VBQ0UseUJBSEo7QUFLRDtBQUNELCtCQUNFaytCLGdCQUFnQixJQURsQixFQUVFLHFFQUZGO0FBSUEsVUFBSXpiLE1BQU0ybUIsT0FBTixDQUFjdGIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLGlDQUNFQSxTQUFTNXNCLE1BQVQsSUFBbUIsQ0FEckIsRUFFRSw2Q0FGRjtBQUlBNHNCLG1CQUFXQSxTQUFTLENBQVQsQ0FBWDtBQUNEOztBQUVEb1EscUJBQWVwUSxRQUFmO0FBQ0Q7QUFDRCxRQUFJb1EsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCQSxxQkFBZSxFQUFmO0FBQ0Q7QUFDRDZZLG1CQUFlN1ksWUFBZjtBQUNEOztBQUVENTJCLE9BQUt1dkMsYUFBTCxHQUFxQjtBQUNuQkUsa0JBQWMscUNBQWlCQSxZQUFqQjtBQURLLEdBQXJCO0FBR0Q7O0FBRU0sU0FBU2QsYUFBVCxDQUF1Qi9uQixPQUF2QixFQUF5QzFZLEtBQXpDLEVBQXdEO0FBQzdELE1BQU1sTyxPQUFTNG1CLE9BQWY7QUFDQSxNQUFNOUosUUFBUSxxQ0FBaUI1TyxNQUFNNE8sS0FBdkIsQ0FBZDtBQUNBLE1BQU04WixlQUFlLHFDQUFpQjFvQixNQUFNMG9CLFlBQXZCLENBQXJCO0FBQ0EsTUFBSTlaLFNBQVMsSUFBYixFQUFtQjtBQUNqQjtBQUNBO0FBQ0EsUUFBTWxKLFdBQVcsNkJBQVNrSixLQUFULENBQWpCO0FBQ0E7QUFDQSxRQUFJbEosYUFBYTVULEtBQUs4YyxLQUF0QixFQUE2QjtBQUMzQjljLFdBQUs4YyxLQUFMLEdBQWFsSixRQUFiO0FBQ0Q7QUFDRCxRQUFJMUYsTUFBTTBvQixZQUFOLElBQXNCLElBQXRCLElBQThCNTJCLEtBQUs0MkIsWUFBTCxLQUFzQmhqQixRQUF4RCxFQUFrRTtBQUNoRTVULFdBQUs0MkIsWUFBTCxHQUFvQmhqQixRQUFwQjtBQUNEO0FBQ0Y7QUFDRCxNQUFJZ2pCLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QjUyQixTQUFLNDJCLFlBQUwsR0FBb0IsNkJBQVNBLFlBQVQsQ0FBcEI7QUFDRDtBQUNGOztBQUVNLFNBQVNnWSxnQkFBVCxDQUEwQmhvQixPQUExQixFQUE0QzFZLEtBQTVDLEVBQTJEO0FBQ2hFLE1BQU1sTyxPQUFTNG1CLE9BQWY7QUFDQTtBQUNBO0FBQ0EsTUFBTWk5QixjQUFjN2pELEtBQUs2akQsV0FBekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxnQkFBZ0I3akQsS0FBS3V2QyxhQUFMLENBQW1CRSxZQUF2QyxFQUFxRDtBQUNuRHp2QyxTQUFLOGMsS0FBTCxHQUFhK21DLFdBQWI7QUFDRDtBQUNGOztBQUVNLFNBQVNoVixzQkFBVCxDQUFnQ2pvQixPQUFoQyxFQUFrRDFZLEtBQWxELEVBQWlFO0FBQ3RFO0FBQ0F5Z0MsZ0JBQWMvbkIsT0FBZCxFQUF1QjFZLEtBQXZCO0FBQ0QsQzs7Ozs7Ozs7Ozs7OztBQzdKRDs7QUFDQTs7Ozs7O0FBRUE7QUFaQTs7Ozs7Ozs7O0FBYUEsSUFBSXFqRiw2QkFBSjs7QUFFQTs7Ozs7OztBQU9BLElBQU1DLGVBQWUsa0RBQW1DLFVBQ3REeHhGLElBRHNELEVBRXREeW9ELElBRnNELEVBR2hEO0FBQ047QUFDQTtBQUNBOztBQUVBLE1BQUl6b0QsS0FBS2d1RixZQUFMLEtBQXNCeGxDLDBCQUFXRyxHQUFqQyxJQUF3QyxFQUFFLGVBQWUzb0QsSUFBakIsQ0FBNUMsRUFBb0U7QUFDbEV1eEYsMkJBQ0VBLHdCQUF3QmxqRixTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBRDFCO0FBRUFpakYseUJBQXFCckQsU0FBckIsR0FBaUMsVUFBVXpsQyxJQUFWLEdBQWlCLFFBQWxEO0FBQ0EsUUFBTWdwQyxVQUFVRixxQkFBcUJwZ0IsVUFBckM7QUFDQSxXQUFPbnhFLEtBQUtteEUsVUFBWixFQUF3QjtBQUN0Qm54RSxXQUFLNnhFLFdBQUwsQ0FBaUI3eEUsS0FBS214RSxVQUF0QjtBQUNEO0FBQ0QsV0FBT3NnQixRQUFRdGdCLFVBQWYsRUFBMkI7QUFDekJueEUsV0FBSzB4RixXQUFMLENBQWlCRCxRQUFRdGdCLFVBQXpCO0FBQ0Q7QUFDRixHQVhELE1BV087QUFDTG54RSxTQUFLa3VGLFNBQUwsR0FBaUJ6bEMsSUFBakI7QUFDRDtBQUNGLENBdEJvQixDQUFyQjs7a0JBd0JlK29DLFk7Ozs7Ozs7Ozs7OztBQzlDZjs7Ozs7OztBQU9BOztBQUVBOzs7QUFHQSxJQUFNRyxxQ0FBcUMsU0FBckNBLGtDQUFxQyxDQUFTdjdELElBQVQsRUFBZTtBQUN4RCxNQUFJLE9BQU93N0QsS0FBUCxLQUFpQixXQUFqQixJQUFnQ0EsTUFBTUMsdUJBQTFDLEVBQW1FO0FBQ2pFLFdBQU8sVUFBU0MsSUFBVCxFQUFlQyxJQUFmLEVBQXFCQyxJQUFyQixFQUEyQkMsSUFBM0IsRUFBaUM7QUFDdENMLFlBQU1DLHVCQUFOLENBQThCLFlBQVc7QUFDdkMsZUFBT3o3RCxLQUFLMDdELElBQUwsRUFBV0MsSUFBWCxFQUFpQkMsSUFBakIsRUFBdUJDLElBQXZCLENBQVA7QUFDRCxPQUZEO0FBR0QsS0FKRDtBQUtELEdBTkQsTUFNTztBQUNMLFdBQU83N0QsSUFBUDtBQUNEO0FBQ0YsQ0FWRDs7a0JBWWV1N0Qsa0M7Ozs7Ozs7Ozs7Ozs7QUNmZjs7QUFFQTs7Ozs7Ozs7O0FBU0EsSUFBSU8saUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTbHlGLElBQVQsRUFBd0JpMUIsSUFBeEIsRUFBNEM7QUFDL0QsTUFBSUEsSUFBSixFQUFVO0FBQ1IsUUFBSWs4QyxhQUFhbnhFLEtBQUtteEUsVUFBdEI7O0FBRUEsUUFDRUEsY0FDQUEsZUFBZW54RSxLQUFLNHhFLFNBRHBCLElBRUFULFdBQVdoakMsUUFBWCxLQUF3QnRoQyx1QkFIMUIsRUFJRTtBQUNBc2tFLGlCQUFXRixTQUFYLEdBQXVCaDhDLElBQXZCO0FBQ0E7QUFDRDtBQUNGO0FBQ0RqMUIsT0FBSzZqRCxXQUFMLEdBQW1CNXVCLElBQW5CO0FBQ0QsQ0FkRCxDLENBcEJBOzs7Ozs7Ozs7a0JBb0NlaTlELGM7Ozs7Ozs7Ozs7OztRQ1ZDQyw4QixHQUFBQSw4QjtRQWdDQUMsaUIsR0FBQUEsaUI7UUFpRUFDLHVDLEdBQUFBLHVDOztBQXBIaEI7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUVBOzs7O0FBSUE7Ozs7OztBQXBCQTs7Ozs7OztBQTBCTyxTQUFTRiw4QkFBVCxDQUF3Q0csTUFBeEMsRUFBZ0Q7QUFDckQsTUFBSTU1RixJQUFKLEVBQWE7QUFDWCxRQUFJNjVGLGFBQWEsRUFBakI7QUFDQSxRQUFJQyxZQUFZLEVBQWhCO0FBQ0EsU0FBSyxJQUFNaEQsU0FBWCxJQUF3QjhDLE1BQXhCLEVBQWdDO0FBQzlCLFVBQUksQ0FBQ0EsT0FBTzF0RixjQUFQLENBQXNCNHFGLFNBQXRCLENBQUwsRUFBdUM7QUFDckM7QUFDRDtBQUNELFVBQU1pRCxhQUFhSCxPQUFPOUMsU0FBUCxDQUFuQjtBQUNBLFVBQUlpRCxjQUFjLElBQWxCLEVBQXdCO0FBQ3RCLFlBQU1DLG1CQUFtQmxELFVBQVV0MUUsT0FBVixDQUFrQixJQUFsQixNQUE0QixDQUFyRDtBQUNBcTRFLHNCQUFjQyxZQUFZLGtDQUFtQmhELFNBQW5CLENBQVosR0FBNEMsR0FBMUQ7QUFDQStDLHNCQUFjLG1DQUNaL0MsU0FEWSxFQUVaaUQsVUFGWSxFQUdaQyxnQkFIWSxDQUFkOztBQU1BRixvQkFBWSxHQUFaO0FBQ0Q7QUFDRjtBQUNELFdBQU9ELGNBQWMsSUFBckI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O0FBT08sU0FBU0gsaUJBQVQsQ0FBMkJweUYsSUFBM0IsRUFBaUNzeUYsTUFBakMsRUFBeUM7QUFDOUMsTUFBTXZpQyxRQUFRL3ZELEtBQUsrdkQsS0FBbkI7QUFDQSxPQUFLLElBQUl5L0IsU0FBVCxJQUFzQjhDLE1BQXRCLEVBQThCO0FBQzVCLFFBQUksQ0FBQ0EsT0FBTzF0RixjQUFQLENBQXNCNHFGLFNBQXRCLENBQUwsRUFBdUM7QUFDckM7QUFDRDtBQUNELFFBQU1rRCxtQkFBbUJsRCxVQUFVdDFFLE9BQVYsQ0FBa0IsSUFBbEIsTUFBNEIsQ0FBckQ7QUFDQSxRQUFJeGhCLElBQUosRUFBYTtBQUNYLFVBQUksQ0FBQ2c2RixnQkFBTCxFQUF1QjtBQUNyQixzQ0FBZWxELFNBQWYsRUFBMEI4QyxPQUFPOUMsU0FBUCxDQUExQjtBQUNEO0FBQ0Y7QUFDRCxRQUFNaUQsYUFBYSxtQ0FDakJqRCxTQURpQixFQUVqQjhDLE9BQU85QyxTQUFQLENBRmlCLEVBR2pCa0QsZ0JBSGlCLENBQW5CO0FBS0EsUUFBSWxELGNBQWMsT0FBbEIsRUFBMkI7QUFDekJBLGtCQUFZLFVBQVo7QUFDRDtBQUNELFFBQUlrRCxnQkFBSixFQUFzQjtBQUNwQjNpQyxZQUFNNGlDLFdBQU4sQ0FBa0JuRCxTQUFsQixFQUE2QmlELFVBQTdCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wxaUMsWUFBTXkvQixTQUFOLElBQW1CaUQsVUFBbkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU0csWUFBVCxDQUFzQjkxRSxLQUF0QixFQUE2QjtBQUMzQixTQUFPQSxTQUFTLElBQVQsSUFBaUIsT0FBT0EsS0FBUCxLQUFpQixTQUFsQyxJQUErQ0EsVUFBVSxFQUFoRTtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVMrMUUsa0JBQVQsQ0FBNEJQLE1BQTVCLEVBQW9DO0FBQ2xDLE1BQU1RLFdBQVcsRUFBakI7QUFDQSxPQUFLLElBQU0xN0UsR0FBWCxJQUFrQms3RSxNQUFsQixFQUEwQjtBQUN4QixRQUFNUyxZQUFZQywwQ0FBb0I1N0UsR0FBcEIsS0FBNEIsQ0FBQ0EsR0FBRCxDQUE5QztBQUNBLFNBQUssSUFBSW1DLElBQUksQ0FBYixFQUFnQkEsSUFBSXc1RSxVQUFVbjVGLE1BQTlCLEVBQXNDMmYsR0FBdEMsRUFBMkM7QUFDekN1NUUsZUFBU0MsVUFBVXg1RSxDQUFWLENBQVQsSUFBeUJuQyxHQUF6QjtBQUNEO0FBQ0Y7QUFDRCxTQUFPMDdFLFFBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUFjTyxTQUFTVCx1Q0FBVCxDQUNMNUMsWUFESyxFQUVMd0QsVUFGSyxFQUdMO0FBQ0EsTUFBSSxDQUFDdjNGLHNEQUFMLEVBQTBDO0FBQ3hDO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDdTNGLFVBQUwsRUFBaUI7QUFDZjtBQUNEOztBQUVELE1BQU1DLGtCQUFrQkwsbUJBQW1CcEQsWUFBbkIsQ0FBeEI7QUFDQSxNQUFNMEQsaUJBQWlCTixtQkFBbUJJLFVBQW5CLENBQXZCO0FBQ0EsTUFBTUcsY0FBYyxFQUFwQjtBQUNBLE9BQUssSUFBTWg4RSxHQUFYLElBQWtCODdFLGVBQWxCLEVBQW1DO0FBQ2pDLFFBQU1HLGNBQWNILGdCQUFnQjk3RSxHQUFoQixDQUFwQjtBQUNBLFFBQU1rOEUscUJBQXFCSCxlQUFlLzdFLEdBQWYsQ0FBM0I7QUFDQSxRQUFJazhFLHNCQUFzQkQsZ0JBQWdCQyxrQkFBMUMsRUFBOEQ7QUFDNUQsVUFBTWw0RCxhQUFhaTRELGNBQWMsR0FBZCxHQUFvQkMsa0JBQXZDO0FBQ0EsVUFBSUYsWUFBWWg0RCxVQUFaLENBQUosRUFBNkI7QUFDM0I7QUFDRDtBQUNEZzRELGtCQUFZaDRELFVBQVosSUFBMEIsSUFBMUI7QUFDQSw2QkFDRSxLQURGLEVBRUUscURBQ0UsZ0VBREYsR0FFRSwrREFGRixHQUdFLDBEQUhGLEdBSUUsa0JBTkosRUFPRXczRCxhQUFhbkQsYUFBYTRELFdBQWIsQ0FBYixJQUEwQyxVQUExQyxHQUF1RCxVQVB6RCxFQVFFQSxXQVJGLEVBU0VDLGtCQVRGO0FBV0Q7QUFDRjtBQUNGLEM7Ozs7Ozs7Ozs7OztBQ2hLRDs7Ozs7OztBQU9BO0FBQ0E7QUFDTyxJQUFNTixvREFBc0I7QUFDakNoYSxhQUFXLENBQ1QsZ0JBRFMsRUFFVCxvQkFGUyxFQUdULG1CQUhTLEVBSVQsbUJBSlMsRUFLVCx5QkFMUyxFQU1ULGVBTlMsRUFPVCxvQkFQUyxFQVFULHlCQVJTLENBRHNCO0FBV2pDdWEsY0FBWSxDQUNWLHNCQURVLEVBRVYsZ0JBRlUsRUFHVixpQkFIVSxFQUlWLGlCQUpVLEVBS1Ysa0JBTFUsRUFNVixxQkFOVSxFQU9WLHFCQVBVLEVBUVYsa0JBUlUsRUFTVixnQkFUVSxDQVhxQjtBQXNCakNDLHNCQUFvQixDQUFDLHFCQUFELEVBQXdCLHFCQUF4QixDQXRCYTtBQXVCakNDLFVBQVEsQ0FDTixtQkFETSxFQUVOLG1CQUZNLEVBR04sbUJBSE0sRUFJTixtQkFKTSxFQUtOLG1CQUxNLEVBTU4sa0JBTk0sRUFPTixtQkFQTSxFQVFOLGtCQVJNLEVBU04saUJBVE0sRUFVTixpQkFWTSxFQVdOLGlCQVhNLEVBWU4sa0JBWk0sRUFhTixrQkFiTSxFQWNOLGtCQWRNLEVBZU4sZ0JBZk0sRUFnQk4sZ0JBaEJNLEVBaUJOLGdCQWpCTSxDQXZCeUI7QUEwQ2pDQyxrQkFBZ0IsQ0FDZCxxQkFEYyxFQUVkLHFCQUZjLEVBR2QscUJBSGMsQ0ExQ2lCO0FBK0NqQ0Msb0JBQWtCLENBQ2hCLHVCQURnQixFQUVoQix1QkFGZ0IsRUFHaEIsdUJBSGdCLENBL0NlO0FBb0RqQ0MsZ0JBQWMsQ0FBQyxtQkFBRCxFQUFzQixtQkFBdEIsRUFBMkMsbUJBQTNDLENBcERtQjtBQXFEakNDLGVBQWEsQ0FDWCxtQkFEVyxFQUVYLGlCQUZXLEVBR1gsa0JBSFcsRUFJWCxnQkFKVyxDQXJEb0I7QUEyRGpDQyxlQUFhLENBQ1gsbUJBRFcsRUFFWCxtQkFGVyxFQUdYLGtCQUhXLEVBSVgsbUJBSlcsRUFLWCxrQkFMVyxDQTNEb0I7QUFrRWpDQyxtQkFBaUIsQ0FDZixzQkFEZSxFQUVmLHNCQUZlLEVBR2Ysc0JBSGUsQ0FsRWdCO0FBdUVqQ0MscUJBQW1CLENBQ2pCLHdCQURpQixFQUVqQix3QkFGaUIsRUFHakIsd0JBSGlCLENBdkVjO0FBNEVqQ0MsY0FBWSxDQUFDLGlCQUFELEVBQW9CLGlCQUFwQixFQUF1QyxpQkFBdkMsQ0E1RXFCO0FBNkVqQ0MsZ0JBQWMsQ0FDWix3QkFEWSxFQUVaLHlCQUZZLEVBR1oscUJBSFksRUFJWixzQkFKWSxDQTdFbUI7QUFtRmpDQyxlQUFhLENBQUMsa0JBQUQsRUFBcUIsa0JBQXJCLEVBQXlDLGtCQUF6QyxDQW5Gb0I7QUFvRmpDQyxlQUFhLENBQ1gsbUJBRFcsRUFFWCxpQkFGVyxFQUdYLGtCQUhXLEVBSVgsZ0JBSlcsQ0FwRm9CO0FBMEZqQ0MsYUFBVyxDQUFDLGdCQUFELEVBQW1CLGdCQUFuQixFQUFxQyxnQkFBckMsQ0ExRnNCO0FBMkZqQ0MsZUFBYSxDQUNYLG1CQURXLEVBRVgsaUJBRlcsRUFHWCxrQkFIVyxFQUlYLGdCQUpXLENBM0ZvQjtBQWlHakNDLGNBQVksQ0FBQyxpQkFBRCxFQUFvQixpQkFBcEIsRUFBdUMsaUJBQXZDLENBakdxQjtBQWtHakNDLFdBQVMsQ0FBQyxhQUFELEVBQWdCLGFBQWhCLENBbEd3QjtBQW1HakNDLFFBQU0sQ0FBQyxXQUFELEVBQWMsVUFBZCxFQUEwQixZQUExQixDQW5HMkI7QUFvR2pDQyxZQUFVLENBQUMsZUFBRCxFQUFrQixVQUFsQixDQXBHdUI7QUFxR2pDQyxRQUFNLENBQ0osWUFESSxFQUVKLHFCQUZJLEVBR0osYUFISSxFQUlKLHNCQUpJLEVBS0osVUFMSSxFQU1KLGdCQU5JLEVBT0osYUFQSSxFQVFKLFdBUkksRUFTSixhQVRJLEVBVUosdUJBVkksRUFXSixpQkFYSSxFQVlKLHNCQVpJLEVBYUosc0JBYkksRUFjSixvQkFkSSxFQWVKLHFCQWZJLEVBZ0JKLFlBaEJJLEVBaUJKLFlBakJJLENBckcyQjtBQXdIakNDLGVBQWEsQ0FDWCx1QkFEVyxFQUVYLGlCQUZXLEVBR1gsc0JBSFcsRUFJWCxzQkFKVyxFQUtYLG9CQUxXLEVBTVgscUJBTlcsQ0F4SG9CO0FBZ0lqQ0MsT0FBSyxDQUFDLFdBQUQsRUFBYyxRQUFkLENBaEk0QjtBQWlJakNDLFFBQU0sQ0FDSixpQkFESSxFQUVKLGNBRkksRUFHSixjQUhJLEVBSUosbUJBSkksRUFLSixxQkFMSSxFQU1KLGtCQU5JLENBakkyQjtBQXlJakNDLFlBQVUsQ0FBQyxlQUFELEVBQWtCLGlCQUFsQixFQUFxQyxZQUFyQyxFQUFtRCxjQUFuRCxDQXpJdUI7QUEwSWpDQyxjQUFZLENBQUMsZUFBRCxFQUFrQixpQkFBbEIsQ0ExSXFCO0FBMklqQ0MsaUJBQWUsQ0FBQyxXQUFELENBM0lrQjtBQTRJakNDLFdBQVMsQ0FBQyxXQUFELEVBQWMsUUFBZCxDQTVJd0I7QUE2SWpDQyxXQUFTLENBQUMsWUFBRCxFQUFlLGNBQWYsQ0E3SXdCO0FBOElqQ0MsY0FBWSxDQUFDLFFBQUQsQ0E5SXFCO0FBK0lqQ0MsZ0JBQWMsQ0FDWixtQkFEWSxFQUVaLHFCQUZZLEVBR1osa0JBSFksQ0EvSW1CO0FBb0pqQ0MsYUFBVyxDQUFDLGdCQUFELEVBQW1CLG1CQUFuQixFQUF3QyxlQUF4QyxDQXBKc0I7QUFxSmpDQyxVQUFRLENBQUMsY0FBRCxFQUFpQixZQUFqQixFQUErQixhQUEvQixFQUE4QyxXQUE5QyxDQXJKeUI7QUFzSmpDam9CLFVBQVEsQ0FBQyxXQUFELEVBQWMsV0FBZCxFQUEyQixhQUEzQixDQXRKeUI7QUF1SmpDblcsUUFBTSxDQUNKLFVBREksRUFFSixlQUZJLEVBR0osV0FISSxFQUlKLFVBSkksRUFLSixZQUxJLEVBTUosZUFOSSxFQU9KLGVBUEksRUFRSixZQVJJLEVBU0osVUFUSSxDQXZKMkI7QUFrS2pDcStCLGdCQUFjLENBQUMsZUFBRCxFQUFrQixlQUFsQixDQWxLbUI7QUFtS2pDQyxXQUFTLENBQUMsY0FBRCxFQUFpQixjQUFqQixFQUFpQyxjQUFqQyxDQW5Ld0I7QUFvS2pDMTlCLFlBQVUsQ0FBQyxXQUFELEVBQWMsV0FBZCxDQXBLdUI7QUFxS2pDMjlCLFdBQVMsQ0FBQyxlQUFELEVBQWtCLGFBQWxCLEVBQWlDLGNBQWpDLEVBQWlELFlBQWpELENBckt3QjtBQXNLakNDLGdCQUFjLENBQUMsY0FBRCxFQUFpQixnQkFBakIsQ0F0S21CO0FBdUtqQ0MsY0FBWSxDQUFDLFlBQUQsRUFBZSxjQUFmLENBdktxQjtBQXdLakNDLGFBQVcsQ0FBQyxXQUFELEVBQWMsYUFBZCxDQXhLc0I7QUF5S2pDQyxrQkFBZ0IsQ0FDZCxxQkFEYyxFQUVkLG9CQUZjLEVBR2QscUJBSGMsQ0F6S2lCO0FBOEtqQ0MsZ0JBQWMsQ0FBQyxtQkFBRCxFQUFzQixtQkFBdEIsQ0E5S21CO0FBK0tqQzljLGNBQVksQ0FDVixpQkFEVSxFQUVWLG9CQUZVLEVBR1Ysb0JBSFUsRUFJViwwQkFKVSxDQS9LcUI7QUFxTGpDK2MsWUFBVSxDQUFDLGNBQUQ7QUFyTHVCLENBQTVCLEM7Ozs7Ozs7Ozs7Ozs7QUNGUDs7QUFFQTs7Ozs7Ozs7O0FBU0EsU0FBU0MsbUJBQVQsQ0FBNkJ4OEYsSUFBN0IsRUFBbUNxakIsS0FBbkMsRUFBMEM0MUUsZ0JBQTFDLEVBQTREO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNNzdELFVBQVUvWixTQUFTLElBQVQsSUFBaUIsT0FBT0EsS0FBUCxLQUFpQixTQUFsQyxJQUErQ0EsVUFBVSxFQUF6RTtBQUNBLE1BQUkrWixPQUFKLEVBQWE7QUFDWCxXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUNFLENBQUM2N0QsZ0JBQUQsSUFDQSxPQUFPNTFFLEtBQVAsS0FBaUIsUUFEakIsSUFFQUEsVUFBVSxDQUZWLElBR0EsRUFBRW81RSw4QkFBaUJ0eEYsY0FBakIsQ0FBZ0NuTCxJQUFoQyxLQUF5Q3k4Riw4QkFBaUJ6OEYsSUFBakIsQ0FBM0MsQ0FKRixFQUtFO0FBQ0EsV0FBT3FqQixRQUFRLElBQWYsQ0FEQSxDQUNxQjtBQUN0Qjs7QUFFRCxTQUFPLENBQUMsS0FBS0EsS0FBTixFQUFhcTVFLElBQWIsRUFBUDtBQUNELEMsQ0E1Q0Q7Ozs7Ozs7a0JBOENlRixtQjs7Ozs7Ozs7Ozs7O0FDOUNmOzs7Ozs7O0FBT0E7OztBQUdPLElBQU1DLDhDQUFtQjtBQUM5QkUsMkJBQXlCLElBREs7QUFFOUJDLHFCQUFtQixJQUZXO0FBRzlCQyxvQkFBa0IsSUFIWTtBQUk5QkMsb0JBQWtCLElBSlk7QUFLOUJDLFdBQVMsSUFMcUI7QUFNOUJDLGdCQUFjLElBTmdCO0FBTzlCQyxtQkFBaUIsSUFQYTtBQVE5QkMsZUFBYSxJQVJpQjtBQVM5Qm5DLFdBQVMsSUFUcUI7QUFVOUJDLFFBQU0sSUFWd0I7QUFXOUJtQyxZQUFVLElBWG9CO0FBWTlCQyxnQkFBYyxJQVpnQjtBQWE5QkMsY0FBWSxJQWJrQjtBQWM5QkMsZ0JBQWMsSUFkZ0I7QUFlOUJDLGFBQVcsSUFmbUI7QUFnQjlCakMsWUFBVSxJQWhCb0I7QUFpQjlCSSxXQUFTLElBakJxQjtBQWtCOUI4QixjQUFZLElBbEJrQjtBQW1COUJDLGVBQWEsSUFuQmlCO0FBb0I5QkMsZ0JBQWMsSUFwQmdCO0FBcUI5Qm5DLGNBQVksSUFyQmtCO0FBc0I5Qm9DLGlCQUFlLElBdEJlO0FBdUI5QkMsa0JBQWdCLElBdkJjO0FBd0I5QkMsbUJBQWlCLElBeEJhO0FBeUI5QkMsY0FBWSxJQXpCa0I7QUEwQjlCQyxhQUFXLElBMUJtQjtBQTJCOUJDLGNBQVksSUEzQmtCO0FBNEI5QmhnQyxXQUFTLElBNUJxQjtBQTZCOUJFLFNBQU8sSUE3QnVCO0FBOEI5QisvQixXQUFTLElBOUJxQjtBQStCOUJDLFdBQVMsSUEvQnFCO0FBZ0M5QkMsVUFBUSxJQWhDc0I7QUFpQzlCQyxVQUFRLElBakNzQjtBQWtDOUJDLFFBQU0sSUFsQ3dCOztBQW9DOUI7QUFDQUMsZUFBYSxJQXJDaUI7QUFzQzlCQyxnQkFBYyxJQXRDZ0I7QUF1QzlCQyxlQUFhLElBdkNpQjtBQXdDOUJDLG1CQUFpQixJQXhDYTtBQXlDOUJDLG9CQUFrQixJQXpDWTtBQTBDOUJDLG9CQUFrQixJQTFDWTtBQTJDOUJDLGlCQUFlLElBM0NlO0FBNEM5QkMsZUFBYTtBQTVDaUIsQ0FBekI7O0FBK0NQOzs7Ozs7QUFNQSxTQUFTQyxTQUFULENBQW1CdjdFLE1BQW5CLEVBQTJCNUYsR0FBM0IsRUFBZ0M7QUFDOUIsU0FBTzRGLFNBQVM1RixJQUFJb2hGLE1BQUosQ0FBVyxDQUFYLEVBQWM3NkUsV0FBZCxFQUFULEdBQXVDdkcsSUFBSXFoRixTQUFKLENBQWMsQ0FBZCxDQUE5QztBQUNEOztBQUVEOzs7O0FBSUEsSUFBTWhnQixXQUFXLENBQUMsUUFBRCxFQUFXLElBQVgsRUFBaUIsS0FBakIsRUFBd0IsR0FBeEIsQ0FBakI7O0FBRUE7QUFDQTtBQUNBMXpFLE9BQU80aEIsSUFBUCxDQUFZdXZFLGdCQUFaLEVBQThCMzRFLE9BQTlCLENBQXNDLFVBQVNtN0UsSUFBVCxFQUFlO0FBQ25EamdCLFdBQVNsN0QsT0FBVCxDQUFpQixVQUFTUCxNQUFULEVBQWlCO0FBQ2hDazVFLHFCQUFpQnFDLFVBQVV2N0UsTUFBVixFQUFrQjA3RSxJQUFsQixDQUFqQixJQUE0Q3hDLGlCQUFpQndDLElBQWpCLENBQTVDO0FBQ0QsR0FGRDtBQUdELENBSkQsRTs7Ozs7Ozs7Ozs7O2tCQ2xEd0JDLGtCO0FBekJ4Qjs7Ozs7Ozs7O0FBU0EsSUFBTUMsbUJBQW1CLFVBQXpCO0FBQ0EsSUFBTUMsWUFBWSxNQUFsQjs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFlLFNBQVNGLGtCQUFULENBQTRCbC9GLElBQTVCLEVBQWtEO0FBQy9ELFNBQU9BLEtBQ0pELE9BREksQ0FDSW8vRixnQkFESixFQUNzQixLQUR0QixFQUVKNzlFLFdBRkksR0FHSnZoQixPQUhJLENBR0lxL0YsU0FISixFQUdlLE1BSGYsQ0FBUDtBQUlELEM7Ozs7Ozs7Ozs7Ozs7QUN2QkQ7Ozs7OztBQUVBLElBQUlDLGlCQUFpQiwwQkFBTSxDQUFFLENBQTdCLEMsQ0FUQTs7Ozs7OztBQVdBLElBQUlwZ0csSUFBSixFQUFhO0FBQ1g7QUFDQSxNQUFNcWdHLDhCQUE4Qix3QkFBcEM7QUFDQSxNQUFNRixZQUFZLE9BQWxCO0FBQ0EsTUFBTUcsZ0JBQWdCLE9BQXRCOztBQUVBO0FBQ0EsTUFBTUMsb0NBQW9DLE9BQTFDOztBQUVBLE1BQU1DLG1CQUFtQixFQUF6QjtBQUNBLE1BQU1DLG9CQUFvQixFQUExQjtBQUNBLE1BQUlDLG9CQUFvQixLQUF4QjtBQUNBLE1BQUlDLHlCQUF5QixLQUE3Qjs7QUFFQSxNQUFNQyxXQUFXLFNBQVhBLFFBQVcsQ0FBU24rQixNQUFULEVBQWlCO0FBQ2hDLFdBQU9BLE9BQU8zaEUsT0FBUCxDQUFldy9GLGFBQWYsRUFBOEIsVUFBU08sQ0FBVCxFQUFZQyxTQUFaLEVBQXVCO0FBQzFELGFBQU9BLFVBQVU3N0UsV0FBVixFQUFQO0FBQ0QsS0FGTSxDQUFQO0FBR0QsR0FKRDs7QUFNQSxNQUFNODdFLDBCQUEwQixTQUExQkEsdUJBQTBCLENBQVNoZ0csSUFBVCxFQUFlO0FBQzdDLFFBQUl5L0YsaUJBQWlCdDBGLGNBQWpCLENBQWdDbkwsSUFBaEMsS0FBeUN5L0YsaUJBQWlCei9GLElBQWpCLENBQTdDLEVBQXFFO0FBQ25FO0FBQ0Q7O0FBRUR5L0YscUJBQWlCei9GLElBQWpCLElBQXlCLElBQXpCO0FBQ0EsMkJBQ0UsS0FERixFQUVFLGlEQUZGLEVBR0VBLElBSEY7QUFJRTtBQUNBO0FBQ0E7QUFDQTYvRixhQUFTNy9GLEtBQUtELE9BQUwsQ0FBYXEvRixTQUFiLEVBQXdCLEtBQXhCLENBQVQsQ0FQRjtBQVNELEdBZkQ7O0FBaUJBLE1BQU1hLDJCQUEyQixTQUEzQkEsd0JBQTJCLENBQVNqZ0csSUFBVCxFQUFlO0FBQzlDLFFBQUl5L0YsaUJBQWlCdDBGLGNBQWpCLENBQWdDbkwsSUFBaEMsS0FBeUN5L0YsaUJBQWlCei9GLElBQWpCLENBQTdDLEVBQXFFO0FBQ25FO0FBQ0Q7O0FBRUR5L0YscUJBQWlCei9GLElBQWpCLElBQXlCLElBQXpCO0FBQ0EsMkJBQ0UsS0FERixFQUVFLGlFQUZGLEVBR0VBLElBSEYsRUFJRUEsS0FBSysrRixNQUFMLENBQVksQ0FBWixFQUFlNzZFLFdBQWYsS0FBK0Jsa0IsS0FBS2tVLEtBQUwsQ0FBVyxDQUFYLENBSmpDO0FBTUQsR0FaRDs7QUFjQSxNQUFNZ3NGLDhCQUE4QixTQUE5QkEsMkJBQThCLENBQVNsZ0csSUFBVCxFQUFlcWpCLEtBQWYsRUFBc0I7QUFDeEQsUUFBSXE4RSxrQkFBa0J2MEYsY0FBbEIsQ0FBaUNrWSxLQUFqQyxLQUEyQ3E4RSxrQkFBa0JyOEUsS0FBbEIsQ0FBL0MsRUFBeUU7QUFDdkU7QUFDRDs7QUFFRHE4RSxzQkFBa0JyOEUsS0FBbEIsSUFBMkIsSUFBM0I7QUFDQSwyQkFDRSxLQURGLEVBRUUsMERBQ0UsdUJBSEosRUFJRXJqQixJQUpGLEVBS0VxakIsTUFBTXRqQixPQUFOLENBQWN5L0YsaUNBQWQsRUFBaUQsRUFBakQsQ0FMRjtBQU9ELEdBYkQ7O0FBZUEsTUFBTVcsc0JBQXNCLFNBQXRCQSxtQkFBc0IsQ0FBU25nRyxJQUFULEVBQWVxakIsS0FBZixFQUFzQjtBQUNoRCxRQUFJczhFLGlCQUFKLEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBRURBLHdCQUFvQixJQUFwQjtBQUNBLDJCQUNFLEtBREYsRUFFRSw0REFGRixFQUdFMy9GLElBSEY7QUFLRCxHQVhEOztBQWFBLE1BQU1vZ0csMkJBQTJCLFNBQTNCQSx3QkFBMkIsQ0FBU3BnRyxJQUFULEVBQWVxakIsS0FBZixFQUFzQjtBQUNyRCxRQUFJdThFLHNCQUFKLEVBQTRCO0FBQzFCO0FBQ0Q7O0FBRURBLDZCQUF5QixJQUF6QjtBQUNBLDJCQUNFLEtBREYsRUFFRSxpRUFGRixFQUdFNS9GLElBSEY7QUFLRCxHQVhEOztBQWFBcS9GLG1CQUFpQix3QkFBU3IvRixJQUFULEVBQWVxakIsS0FBZixFQUFzQjtBQUNyQyxRQUFJcmpCLEtBQUt5Z0IsT0FBTCxDQUFhLEdBQWIsSUFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUMxQnUvRSw4QkFBd0JoZ0csSUFBeEI7QUFDRCxLQUZELE1BRU8sSUFBSXMvRiw0QkFBNEJwOEUsSUFBNUIsQ0FBaUNsakIsSUFBakMsQ0FBSixFQUE0QztBQUNqRGlnRywrQkFBeUJqZ0csSUFBekI7QUFDRCxLQUZNLE1BRUEsSUFBSXcvRixrQ0FBa0N0OEUsSUFBbEMsQ0FBdUNHLEtBQXZDLENBQUosRUFBbUQ7QUFDeEQ2OEUsa0NBQTRCbGdHLElBQTVCLEVBQWtDcWpCLEtBQWxDO0FBQ0Q7O0FBRUQsUUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFVBQUlHLE1BQU1ILEtBQU4sQ0FBSixFQUFrQjtBQUNoQjg4RSw0QkFBb0JuZ0csSUFBcEIsRUFBMEJxakIsS0FBMUI7QUFDRCxPQUZELE1BRU8sSUFBSSxDQUFDZzlFLFNBQVNoOUUsS0FBVCxDQUFMLEVBQXNCO0FBQzNCKzhFLGlDQUF5QnBnRyxJQUF6QixFQUErQnFqQixLQUEvQjtBQUNEO0FBQ0Y7QUFDRixHQWhCRDtBQWlCRDs7a0JBRWNnOEUsYzs7Ozs7Ozs7Ozs7Ozs4UUMxSGY7Ozs7Ozs7QUFTQTtBQUNBOzs7QUFIQTs7OztBQUNBOzs7O0FBR0E7Ozs7QUFFQTs7Ozs7O0FBRUEsSUFBTTFNLE9BQU8sUUFBYjs7QUFFQSxJQUFJM3hGLHlCQUF5QixJQUE3QjtBQUNBLElBQUkvQixJQUFKLEVBQWE7QUFDWCtCLDJCQUF5QkMsK0JBQXFCRCxzQkFBOUM7QUFDRDs7QUFFRCxTQUFTcy9GLGdCQUFULENBQTBCejhGLEdBQTFCLEVBQXVDNFEsS0FBdkMsRUFBdUQ7QUFDckQsTUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDVjtBQUNEO0FBQ0Q7QUFDQSxNQUFJOHJGLDBCQUFnQjE4RixHQUFoQixDQUFKLEVBQTBCO0FBQ3hCLDZCQUNFNFEsTUFBTXNZLFFBQU4sSUFBa0IsSUFBbEIsSUFBMEJ0WSxNQUFNb2pGLHVCQUFOLElBQWlDLElBRDdELEVBRUUsbUVBQ0Usa0NBSEosRUFJRWgwRixHQUpGLEVBS0U1RSxLQUFPQSxHQUFHK0IsdUJBQXVCRyxnQkFBdkIsRUFBVixHQUFzRCxFQUx4RDtBQU9EO0FBQ0QsTUFBSXNULE1BQU1vakYsdUJBQU4sSUFBaUMsSUFBckMsRUFBMkM7QUFDekMsNkJBQ0VwakYsTUFBTXNZLFFBQU4sSUFBa0IsSUFEcEIsRUFFRSxvRUFGRjtBQUlBLDZCQUNFLFFBQU90WSxNQUFNb2pGLHVCQUFiLE1BQXlDLFFBQXpDLElBQ0VsRixRQUFRbCtFLE1BQU1vakYsdUJBRmxCLEVBR0UsMEVBQ0Usd0VBREYsR0FFRSx1QkFMSjtBQU9EO0FBQ0QsTUFBSTU0RixJQUFKLEVBQWE7QUFDWCwyQkFDRXdWLE1BQU0rckYsOEJBQU4sSUFDRSxDQUFDL3JGLE1BQU1xdkUsZUFEVCxJQUVFcnZFLE1BQU1zWSxRQUFOLElBQWtCLElBSHRCLEVBSUUseUVBQ0UsaUVBREYsR0FFRSwrREFGRixHQUdFLDJCQVBKO0FBU0Q7QUFDRCwyQkFDRXRZLE1BQU02aEQsS0FBTixJQUFlLElBQWYsSUFBdUIsUUFBTzdoRCxNQUFNNmhELEtBQWIsTUFBdUIsUUFEaEQsRUFFRSx5RUFDRSx3RUFERixHQUVFLGNBSkosRUFLRXIzRCxLQUFPQSxHQUFHK0IsdUJBQXVCRyxnQkFBdkIsRUFBVixHQUFzRCxFQUx4RDtBQU9EOztrQkFFY20vRixnQjs7Ozs7Ozs7Ozs7OztrUUNyRWY7Ozs7Ozs7QUFPQTs7Ozs7O0FBRUE7QUFDQTs7QUFFQSxJQUFNQztBQUNKRSxZQUFVO0FBRE4sR0FFREMsMEJBRkMsQ0FBTjs7a0JBS2VILGU7Ozs7Ozs7Ozs7OztBQ2pCZjs7Ozs7OztBQU9BO0FBQ0E7O0FBRUEsSUFBTUcsbUJBQW1CO0FBQ3ZCQyxRQUFNLElBRGlCO0FBRXZCQyxRQUFNLElBRmlCO0FBR3ZCQyxNQUFJLElBSG1CO0FBSXZCQyxPQUFLLElBSmtCO0FBS3ZCQyxTQUFPLElBTGdCO0FBTXZCQyxNQUFJLElBTm1CO0FBT3ZCQyxPQUFLLElBUGtCO0FBUXZCN1ksU0FBTyxJQVJnQjtBQVN2QjhZLFVBQVEsSUFUZTtBQVV2QkMsUUFBTSxJQVZpQjtBQVd2QkMsUUFBTSxJQVhpQjtBQVl2QkMsU0FBTyxJQVpnQjtBQWF2Qm43RixVQUFRLElBYmU7QUFjdkJpa0MsU0FBTyxJQWRnQjtBQWV2Qm0zRCxPQUFLO0FBQ0w7QUFoQnVCLENBQXpCOztrQkFtQmVaLGdCOzs7Ozs7Ozs7Ozs7UUNzRkNhLGtCLEdBQUFBLGtCOztBQTVHaEI7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUFYQTs7Ozs7OztBQWFBLElBQU1DLG1CQUFtQixFQUF6QjtBQUNBLElBQU1DLFFBQVEsSUFBSTMrRSxNQUFKLENBQVcsY0FBY0osZ0NBQWQsR0FBb0MsS0FBL0MsQ0FBZDtBQUNBLElBQU1nL0UsYUFBYSxJQUFJNStFLE1BQUosQ0FBVyxrQkFBa0JKLGdDQUFsQixHQUF3QyxLQUFuRCxDQUFuQjs7QUFFQSxJQUFNdlgsaUJBQWlCRyxPQUFPNUssU0FBUCxDQUFpQnlLLGNBQXhDOztBQUVBLFNBQVN3MkYsZ0JBQVQsQ0FBMEI1MUQsT0FBMUIsRUFBbUMvckMsSUFBbkMsRUFBeUM7QUFDdkMsTUFBSW1MLGVBQWV2SyxJQUFmLENBQW9CNGdHLGdCQUFwQixFQUFzQ3hoRyxJQUF0QyxLQUErQ3doRyxpQkFBaUJ4aEcsSUFBakIsQ0FBbkQsRUFBMkU7QUFDekUsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSTBoRyxXQUFXeCtFLElBQVgsQ0FBZ0JsakIsSUFBaEIsQ0FBSixFQUEyQjtBQUN6QixRQUFNNGhHLFdBQVcsVUFBVTVoRyxLQUFLa1UsS0FBTCxDQUFXLENBQVgsRUFBY29OLFdBQWQsRUFBM0I7QUFDQSxRQUFNdWdGLGNBQWNDLDhCQUFvQjMyRixjQUFwQixDQUFtQ3kyRixRQUFuQyxJQUNoQkEsUUFEZ0IsR0FFaEIsSUFGSjs7QUFJQTtBQUNBO0FBQ0EsUUFBSUMsZUFBZSxJQUFuQixFQUF5QjtBQUN2Qiw2QkFDRSxLQURGLEVBRUUsK0ZBRkYsRUFHRTdoRyxJQUhGO0FBS0F3aEcsdUJBQWlCeGhHLElBQWpCLElBQXlCLElBQXpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7QUFDRDtBQUNBLFFBQUlBLFNBQVM2aEcsV0FBYixFQUEwQjtBQUN4Qiw2QkFDRSxLQURGLEVBRUUsaURBRkYsRUFHRTdoRyxJQUhGLEVBSUU2aEcsV0FKRjtBQU1BTCx1QkFBaUJ4aEcsSUFBakIsSUFBeUIsSUFBekI7QUFDQSxhQUFPLElBQVA7QUFDRDtBQUNGOztBQUVELE1BQUl5aEcsTUFBTXYrRSxJQUFOLENBQVdsakIsSUFBWCxDQUFKLEVBQXNCO0FBQ3BCLFFBQU1xaEIsaUJBQWlCcmhCLEtBQUtzaEIsV0FBTCxFQUF2QjtBQUNBLFFBQU1zMUUsZUFBZWtMLDhCQUFvQjMyRixjQUFwQixDQUFtQ2tXLGNBQW5DLElBQ2pCQSxjQURpQixHQUVqQixJQUZKOztBQUlBO0FBQ0E7QUFDQSxRQUFJdTFFLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QjRLLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sS0FBUDtBQUNEO0FBQ0Q7QUFDQSxRQUFJQSxTQUFTNDJGLFlBQWIsRUFBMkI7QUFDekIsNkJBQ0UsS0FERixFQUVFLGlEQUZGLEVBR0U1MkYsSUFIRixFQUlFNDJGLFlBSkY7QUFNQTRLLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBUytoRyxvQkFBVCxDQUE4Qm4rRixJQUE5QixFQUFvQzZRLEtBQXBDLEVBQTJDO0FBQ3pDLE1BQU11dEYsZUFBZSxFQUFyQjs7QUFFQSxPQUFLLElBQU1ya0YsR0FBWCxJQUFrQmxKLEtBQWxCLEVBQXlCO0FBQ3ZCLFFBQU13dEYsVUFBVU4saUJBQWlCLzlGLElBQWpCLEVBQXVCK1osR0FBdkIsQ0FBaEI7QUFDQSxRQUFJLENBQUNza0YsT0FBTCxFQUFjO0FBQ1pELG1CQUFhejBGLElBQWIsQ0FBa0JvUSxHQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBTXVrRixvQkFBb0JGLGFBQ3ZCMWhHLEdBRHVCLENBQ25CO0FBQUEsV0FBUSxNQUFNMitGLElBQU4sR0FBYSxHQUFyQjtBQUFBLEdBRG1CLEVBRXZCOXdELElBRnVCLENBRWxCLElBRmtCLENBQTFCOztBQUlBLE1BQUk2ekQsYUFBYTdoRyxNQUFiLEtBQXdCLENBQTVCLEVBQStCO0FBQzdCLDJCQUNFLEtBREYsRUFFRSx1Q0FDRSxrREFISixFQUlFK2hHLGlCQUpGLEVBS0V0K0YsSUFMRjtBQU9ELEdBUkQsTUFRTyxJQUFJbytGLGFBQWE3aEcsTUFBYixHQUFzQixDQUExQixFQUE2QjtBQUNsQywyQkFDRSxLQURGLEVBRUUsd0NBQ0Usa0RBSEosRUFJRStoRyxpQkFKRixFQUtFdCtGLElBTEY7QUFPRDtBQUNGOztBQUVNLFNBQVMyOUYsa0JBQVQsQ0FBNEIzOUYsSUFBNUIsRUFBa0M2USxLQUFsQyxFQUF5QztBQUM5QyxNQUFJLGlDQUFrQjdRLElBQWxCLEVBQXdCNlEsS0FBeEIsQ0FBSixFQUFvQztBQUNsQztBQUNEO0FBQ0RzdEYsdUJBQXFCbitGLElBQXJCLEVBQTJCNlEsS0FBM0I7QUFDRCxDOzs7Ozs7Ozs7Ozs7QUN4SEQ7Ozs7Ozs7QUFPQSxJQUFNMHRGLGlCQUFpQjtBQUNyQixrQkFBZ0IsQ0FESyxFQUNGO0FBQ25CLGtCQUFnQixDQUZLO0FBR3JCLG1CQUFpQixDQUhJLEVBR0Q7QUFDcEIsaUJBQWUsQ0FKTSxFQUlIO0FBQ2xCLGtCQUFnQixDQUxLLEVBS0Y7QUFDbkIsdUJBQXFCLENBTkE7QUFPckIsZ0JBQWMsQ0FQTztBQVFyQiwwQkFBd0IsQ0FSSDtBQVNyQjtBQUNBLHVCQUFxQixDQVZBO0FBV3JCLGtCQUFnQixDQVhLO0FBWXJCLG1CQUFpQixDQVpJO0FBYXJCLG1CQUFpQixDQWJJO0FBY3JCLGdCQUFjLENBZE87QUFlckIsZ0JBQWMsQ0FmTztBQWdCckIsb0JBQWtCLENBaEJHO0FBaUJyQiwwQkFBd0IsQ0FqQkg7QUFrQnJCLHNCQUFvQixDQWxCQztBQW1CckIsc0JBQW9CLENBbkJDO0FBb0JyQixrQkFBZ0IsQ0FwQks7QUFxQnJCLG1CQUFpQixDQXJCSTtBQXNCckIsbUJBQWlCLENBdEJJO0FBdUJyQixtQkFBaUIsQ0F2Qkk7QUF3QnJCLGVBQWEsQ0F4QlE7QUF5QnJCLG1CQUFpQixDQXpCSTtBQTBCckIsbUJBQWlCLENBMUJJO0FBMkJyQixtQkFBaUIsQ0EzQkk7QUE0QnJCLG9CQUFrQixDQTVCRztBQTZCckI7QUFDQSxpQkFBZSxDQTlCTTtBQStCckIsZUFBYSxDQS9CUTtBQWdDckIsZUFBYSxDQWhDUTtBQWlDckIsbUJBQWlCLENBakNJO0FBa0NyQjtBQUNBLHFCQUFtQixDQW5DRTtBQW9DckIsa0JBQWdCLENBcENLO0FBcUNyQjtBQUNBLDJCQUF5QixDQXRDSjtBQXVDckIsbUJBQWlCLENBdkNJO0FBd0NyQixtQkFBaUIsQ0F4Q0k7QUF5Q3JCLGtCQUFnQixDQXpDSztBQTBDckIsbUJBQWlCLENBMUNJO0FBMkNyQixzQkFBb0IsQ0EzQ0M7QUE0Q3JCLHVCQUFxQixDQTVDQTtBQTZDckIsaUJBQWUsQ0E3Q007QUE4Q3JCLHFCQUFtQixDQTlDRTtBQStDckIsZUFBYSxDQS9DUTtBQWdEckIsbUJBQWlCLENBaERJO0FBaURyQixtQkFBaUIsQ0FqREk7QUFrRHJCLG1CQUFpQixDQWxESTtBQW1EckIsa0JBQWdCLENBbkRLO0FBb0RyQixrQkFBZ0I7QUFwREssQ0FBdkI7O2tCQXVEZUEsYzs7Ozs7Ozs7Ozs7O1FDbkRDWixrQixHQUFBQSxrQjs7QUFKaEI7Ozs7OztBQUVBLElBQUlhLG1CQUFtQixLQUF2QixDLENBVEE7Ozs7Ozs7QUFXTyxTQUFTYixrQkFBVCxDQUE0QjM5RixJQUE1QixFQUFrQzZRLEtBQWxDLEVBQXlDO0FBQzlDLE1BQUk3USxTQUFTLE9BQVQsSUFBb0JBLFNBQVMsVUFBN0IsSUFBMkNBLFNBQVMsUUFBeEQsRUFBa0U7QUFDaEU7QUFDRDs7QUFFRCxNQUFJNlEsU0FBUyxJQUFULElBQWlCQSxNQUFNNE8sS0FBTixLQUFnQixJQUFqQyxJQUF5QyxDQUFDKytFLGdCQUE5QyxFQUFnRTtBQUM5REEsdUJBQW1CLElBQW5CO0FBQ0EsUUFBSXgrRixTQUFTLFFBQVQsSUFBcUI2USxNQUFNdy9DLFFBQS9CLEVBQXlDO0FBQ3ZDLDZCQUNFLEtBREYsRUFFRSw4Q0FDRSxpRUFERixHQUVFLG9FQUpKLEVBS0Vyd0QsSUFMRjtBQU9ELEtBUkQsTUFRTztBQUNMLDZCQUNFLEtBREYsRUFFRSw4Q0FDRSx1RUFERixHQUVFLDhCQUpKLEVBS0VBLElBTEY7QUFPRDtBQUNGO0FBQ0YsQzs7Ozs7Ozs7Ozs7Ozs4UUNwQ0Q7Ozs7Ozs7UUFpU2dCMjlGLGtCLEdBQUFBLGtCOztBQTFSaEI7O0FBSUE7Ozs7QUFFQTs7QUFPQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJSSxtQkFBbUIsNEJBQU0sQ0FBRSxDQUEvQjs7QUFFQSxJQUFJMWlHLElBQUosRUFBYTtBQUNYLE1BQU11aUcsbUJBQW1CLEVBQXpCO0FBQ0EsTUFBTXIyRixrQkFBaUJHLE9BQU81SyxTQUFQLENBQWlCeUssY0FBeEM7QUFDQSxNQUFNazNGLG1CQUFtQixNQUF6QjtBQUNBLE1BQU1DLDJCQUEyQixXQUFqQztBQUNBLE1BQU1iLFFBQVEsSUFBSTMrRSxNQUFKLENBQVcsY0FBY0osZ0NBQWQsR0FBb0MsS0FBL0MsQ0FBZDtBQUNBLE1BQU1nL0UsYUFBYSxJQUFJNStFLE1BQUosQ0FBVyxrQkFBa0JKLGdDQUFsQixHQUF3QyxLQUFuRCxDQUFuQjs7QUFFQWkvRSxxQkFBbUIsMEJBQVM1MUQsT0FBVCxFQUFrQi9yQyxJQUFsQixFQUF3QnFqQixLQUF4QixFQUErQmsvRSxpQkFBL0IsRUFBa0Q7QUFDbkUsUUFBSXAzRixnQkFBZXZLLElBQWYsQ0FBb0I0Z0csZ0JBQXBCLEVBQXNDeGhHLElBQXRDLEtBQStDd2hHLGlCQUFpQnhoRyxJQUFqQixDQUFuRCxFQUEyRTtBQUN6RSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFNcWhCLGlCQUFpQnJoQixLQUFLc2hCLFdBQUwsRUFBdkI7QUFDQSxRQUFJRCxtQkFBbUIsV0FBbkIsSUFBa0NBLG1CQUFtQixZQUF6RCxFQUF1RTtBQUNyRSw2QkFDRSxLQURGLEVBRUUsd0VBQ0UseUVBREYsR0FFRSxvQ0FKSjtBQU1BbWdGLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0EsUUFBSXVpRyxpQkFBSixFQUF1QjtBQUNyQixVQUFJcmhGLDZDQUF3Qi9WLGNBQXhCLENBQXVDbkwsSUFBdkMsQ0FBSixFQUFrRDtBQUNoRCxlQUFPLElBQVA7QUFDRDtBQUNELFVBQU0yYixtQkFBbUI0RiwrQ0FBMEJwVyxjQUExQixDQUN2QmtXLGNBRHVCLElBR3JCRSwrQ0FBMEJGLGNBQTFCLENBSHFCLEdBSXJCLElBSko7QUFLQSxVQUFJMUYsb0JBQW9CLElBQXhCLEVBQThCO0FBQzVCLCtCQUNFLEtBREYsRUFFRSx5REFGRixFQUdFM2IsSUFIRixFQUlFMmIsZ0JBSkY7QUFNQTZsRix5QkFBaUJ4aEcsSUFBakIsSUFBeUIsSUFBekI7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNELFVBQUlxaUcsaUJBQWlCbi9FLElBQWpCLENBQXNCbGpCLElBQXRCLENBQUosRUFBaUM7QUFDL0IsK0JBQ0UsS0FERixFQUVFLDBEQUZGLEVBR0VBLElBSEY7QUFLQXdoRyx5QkFBaUJ4aEcsSUFBakIsSUFBeUIsSUFBekI7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNGLEtBNUJELE1BNEJPLElBQUlxaUcsaUJBQWlCbi9FLElBQWpCLENBQXNCbGpCLElBQXRCLENBQUosRUFBaUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBSXNpRyx5QkFBeUJwL0UsSUFBekIsQ0FBOEJsakIsSUFBOUIsQ0FBSixFQUF5QztBQUN2QywrQkFDRSxLQURGLEVBRUUsMENBQ0UsMEVBSEosRUFJRUEsSUFKRjtBQU1EO0FBQ0R3aEcsdUJBQWlCeGhHLElBQWpCLElBQXlCLElBQXpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJeWhHLE1BQU12K0UsSUFBTixDQUFXbGpCLElBQVgsS0FBb0IwaEcsV0FBV3grRSxJQUFYLENBQWdCbGpCLElBQWhCLENBQXhCLEVBQStDO0FBQzdDLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUlxaEIsbUJBQW1CLFdBQXZCLEVBQW9DO0FBQ2xDLDZCQUNFLEtBREYsRUFFRSw2REFDRSwwRUFISjtBQUtBbWdGLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUlxaEIsbUJBQW1CLE1BQXZCLEVBQStCO0FBQzdCLDZCQUNFLEtBREYsRUFFRSwrREFDRSw2Q0FISjtBQUtBbWdGLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQ0VxaEIsbUJBQW1CLElBQW5CLElBQ0FnQyxVQUFVLElBRFYsSUFFQUEsVUFBVWxrQixTQUZWLElBR0EsT0FBT2trQixLQUFQLEtBQWlCLFFBSm5CLEVBS0U7QUFDQSw2QkFDRSxLQURGLEVBRUUsNEVBQ0Usd0JBSEosU0FJU0EsS0FKVCx5Q0FJU0EsS0FKVDtBQU1BbStFLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUksT0FBT3FqQixLQUFQLEtBQWlCLFFBQWpCLElBQTZCRyxNQUFNSCxLQUFOLENBQWpDLEVBQStDO0FBQzdDLDZCQUNFLEtBREYsRUFFRSxvRUFDRSx3QkFISixFQUlFcmpCLElBSkY7QUFNQXdoRyx1QkFBaUJ4aEcsSUFBakIsSUFBeUIsSUFBekI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFNbWpCLGVBQWUsa0NBQWdCbmpCLElBQWhCLENBQXJCO0FBQ0EsUUFBTXdpRyxhQUFhci9FLGlCQUFpQixJQUFqQixJQUF5QkEsYUFBYXZmLElBQWIsS0FBc0JzZSxxQkFBbEU7O0FBRUE7QUFDQSxRQUFJa3RDLGdDQUFzQmprRCxjQUF0QixDQUFxQ2tXLGNBQXJDLENBQUosRUFBMEQ7QUFDeEQsVUFBTXUxRSxlQUFleG5DLGdDQUFzQi90QyxjQUF0QixDQUFyQjtBQUNBLFVBQUl1MUUsaUJBQWlCNTJGLElBQXJCLEVBQTJCO0FBQ3pCLCtCQUNFLEtBREYsRUFFRSwrQ0FGRixFQUdFQSxJQUhGLEVBSUU0MkYsWUFKRjtBQU1BNEsseUJBQWlCeGhHLElBQWpCLElBQXlCLElBQXpCO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRixLQVpELE1BWU8sSUFBSSxDQUFDd2lHLFVBQUQsSUFBZXhpRyxTQUFTcWhCLGNBQTVCLEVBQTRDO0FBQ2pEO0FBQ0E7QUFDQSw2QkFDRSxLQURGLEVBRUUscUVBQ0UseURBREYsR0FFRSxpREFGRixHQUdFLGdFQUhGLEdBSUUsMEJBTkosRUFPRXJoQixJQVBGLEVBUUVxaEIsY0FSRjtBQVVBbWdGLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQ0UsT0FBT3FqQixLQUFQLEtBQWlCLFNBQWpCLElBQ0EsbURBQWlDcmpCLElBQWpDLEVBQXVDcWpCLEtBQXZDLEVBQThDRixZQUE5QyxFQUE0RCxLQUE1RCxDQUZGLEVBR0U7QUFDQSxVQUFJRSxLQUFKLEVBQVc7QUFDVCwrQkFDRSxLQURGLEVBRUUsd0RBQ0UsNkRBREYsR0FFRSxtQ0FKSixFQUtFQSxLQUxGLEVBTUVyakIsSUFORixFQU9FQSxJQVBGLEVBUUVxakIsS0FSRixFQVNFcmpCLElBVEY7QUFXRCxPQVpELE1BWU87QUFDTCwrQkFDRSxLQURGLEVBRUUsd0RBQ0UsNkRBREYsR0FFRSx1Q0FGRixHQUdFLHFFQUhGLEdBSUUsa0RBTkosRUFPRXFqQixLQVBGLEVBUUVyakIsSUFSRixFQVNFQSxJQVRGLEVBVUVxakIsS0FWRixFQVdFcmpCLElBWEYsRUFZRUEsSUFaRixFQWFFQSxJQWJGO0FBZUQ7QUFDRHdoRyx1QkFBaUJ4aEcsSUFBakIsSUFBeUIsSUFBekI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsUUFBSXdpRyxVQUFKLEVBQWdCO0FBQ2QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLG1EQUFpQ3hpRyxJQUFqQyxFQUF1Q3FqQixLQUF2QyxFQUE4Q0YsWUFBOUMsRUFBNEQsS0FBNUQsQ0FBSixFQUF3RTtBQUN0RXErRSx1QkFBaUJ4aEcsSUFBakIsSUFBeUIsSUFBekI7QUFDQSxhQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNBLFFBQ0UsQ0FBQ3FqQixVQUFVLE9BQVYsSUFBcUJBLFVBQVUsTUFBaEMsS0FDQUYsaUJBQWlCLElBRGpCLElBRUFBLGFBQWF2ZixJQUFiLEtBQXNCeWUsb0JBSHhCLEVBSUU7QUFDQSw2QkFDRSxLQURGLEVBRUUsOERBQ0UsS0FERixHQUVFLHVCQUpKLEVBS0VnQixLQUxGLEVBTUVyakIsSUFORixFQU9FcWpCLFVBQVUsT0FBVixHQUNJLGtEQURKLEdBRUksbUZBVE4sRUFVRXJqQixJQVZGLEVBV0VxakIsS0FYRjtBQWFBbStFLHVCQUFpQnhoRyxJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFdBQU8sSUFBUDtBQUNELEdBNU5EO0FBNk5EOztBQUVELElBQU15aUcsd0JBQXdCLFNBQXhCQSxxQkFBd0IsQ0FBUzcrRixJQUFULEVBQWU2USxLQUFmLEVBQXNCOHRGLGlCQUF0QixFQUF5QztBQUNyRSxNQUFNRyxlQUFlLEVBQXJCO0FBQ0EsT0FBSyxJQUFNL2tGLEdBQVgsSUFBa0JsSixLQUFsQixFQUF5QjtBQUN2QixRQUFNd3RGLFVBQVVOLGlCQUFpQi85RixJQUFqQixFQUF1QitaLEdBQXZCLEVBQTRCbEosTUFBTWtKLEdBQU4sQ0FBNUIsRUFBd0M0a0YsaUJBQXhDLENBQWhCO0FBQ0EsUUFBSSxDQUFDTixPQUFMLEVBQWM7QUFDWlMsbUJBQWFuMUYsSUFBYixDQUFrQm9RLEdBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNdWtGLG9CQUFvQlEsYUFDdkJwaUcsR0FEdUIsQ0FDbkI7QUFBQSxXQUFRLE1BQU0yK0YsSUFBTixHQUFhLEdBQXJCO0FBQUEsR0FEbUIsRUFFdkI5d0QsSUFGdUIsQ0FFbEIsSUFGa0IsQ0FBMUI7QUFHQSxNQUFJdTBELGFBQWF2aUcsTUFBYixLQUF3QixDQUE1QixFQUErQjtBQUM3QiwyQkFDRSxLQURGLEVBRUUsK0VBQ0UsMERBREYsR0FFRSx5REFKSixFQUtFK2hHLGlCQUxGLEVBTUV0K0YsSUFORjtBQVFELEdBVEQsTUFTTyxJQUFJOCtGLGFBQWF2aUcsTUFBYixHQUFzQixDQUExQixFQUE2QjtBQUNsQywyQkFDRSxLQURGLEVBRUUsbUZBQ0UsNERBREYsR0FFRSx5REFKSixFQUtFK2hHLGlCQUxGLEVBTUV0K0YsSUFORjtBQVFEO0FBQ0YsQ0EvQkQ7O0FBaUNPLFNBQVMyOUYsa0JBQVQsQ0FBNEIzOUYsSUFBNUIsRUFBa0M2USxLQUFsQyxFQUF5Qzh0RixpQkFBekMsRUFBNEQ7QUFDakUsTUFBSSxpQ0FBa0IzK0YsSUFBbEIsRUFBd0I2USxLQUF4QixDQUFKLEVBQW9DO0FBQ2xDO0FBQ0Q7QUFDRGd1Rix3QkFBc0I3K0YsSUFBdEIsRUFBNEI2USxLQUE1QixFQUFtQzh0RixpQkFBbkM7QUFDRCxDOzs7Ozs7Ozs7Ozs7Ozs7QUM3UkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7Ozs7Ozs7Ozs7Ozs7OzhRQ1RBOzs7Ozs7Ozs7QUFvRTZCOzs7QUFJN0I7Ozs7O3NCQU1FenhELFk7Ozs7OztzQkFDQUMseUI7Ozs7OztzQkFDQUYsb0I7Ozs7OztzQkFDQUQsdUI7Ozs7OztBQTJCRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7UUFFZ0IreEQsa0IsR0FBQUEsa0I7UUFpQ0FDLG1CLEdBQUFBLG1CO1FBa0JBQyxpQixHQUFBQSxpQjtRQUlBQyxnQixHQUFBQSxnQjtRQU1BQyxnQixHQUFBQSxnQjtRQU9BQyxjLEdBQUFBLGM7UUFzQ0FDLGtCLEdBQUFBLGtCO1FBT0FDLHVCLEdBQUFBLHVCO1FBV0FDLGEsR0FBQUEsYTtRQWdDQUMsb0IsR0FBQUEsb0I7UUFhQUMseUIsR0FBQUEseUI7UUFJQUMsa0IsR0FBQUEsa0I7UUFpQ0FDLFcsR0FBQUEsVztRQXFCQUMsWSxHQUFBQSxZO1FBZUFDLGdCLEdBQUFBLGdCO1FBSUFDLGdCLEdBQUFBLGdCO1FBUUF6TCxXLEdBQUFBLFc7UUFPQTBMLHNCLEdBQUFBLHNCO1FBOEJBcnNCLFksR0FBQUEsWTtRQVFBc3NCLHVCLEdBQUFBLHVCO1FBWUF4ckIsVyxHQUFBQSxXO1FBT0F5ckIsd0IsR0FBQUEsd0I7UUFXQUMscUIsR0FBQUEscUI7UUE4QkFDLGtDLEdBQUFBLGtDO1FBYUFDLFksR0FBQUEsWTtRQU9BQyxnQixHQUFBQSxnQjtRQUlBQyxjLEdBQUFBLGM7UUFZQUMsa0IsR0FBQUEsa0I7UUFhQUMsa0IsR0FBQUEsa0I7UUFlQUMsc0IsR0FBQUEsc0I7UUFZQUMsMEIsR0FBQUEsMEI7UUFXQUMsd0IsR0FBQUEsd0I7UUFrQkFDLHVCLEdBQUFBLHVCO1FBa0JBQyxlLEdBQUFBLGU7UUE0QkFDLG1CLEdBQUFBLG1CO1FBU0FDLDhDLEdBQUFBLDhDO1FBMkJBQyx3QyxHQUFBQSx3QztRQVVBQywrQixHQUFBQSwrQjtRQVlBQyw4QixHQUFBQSw4QjtRQWVBQyxxQixHQUFBQSxxQjtRQWlCQUMscUMsR0FBQUEscUM7UUFVQUMseUMsR0FBQUEseUM7UUFTQUMsNkMsR0FBQUEsNkM7UUFRQUMsNEIsR0FBQUEsNEI7UUFZQUMsZ0MsR0FBQUEsZ0M7UUFXQUMsb0MsR0FBQUEsb0M7O0FBL3VCaEI7O0FBQ0E7O0FBZUE7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFPQTs7OztBQW9DQTs7OztBQVFBLElBQUk5UyxtQ0FBSjtBQUNBLElBQUl0ekYsSUFBSixFQUFhO0FBQ1hzekYsK0JBQTZCLDBCQUE3QjtBQUNEOztBQUVELElBQU0rUyxzQkFBc0IsR0FBNUI7QUFDQSxJQUFNQyxvQkFBb0IsSUFBMUI7O0FBRUEsSUFBTTdTLFFBQVEsT0FBZDs7QUFFQSxJQUFJOFMsZ0JBQTBCLElBQTlCO0FBQ0EsSUFBSUMsdUJBQStCLElBQW5DOztBQUVBLFNBQVNDLDRCQUFULENBQXNDOWhHLElBQXRDLEVBQW9ENlEsS0FBcEQsRUFBMkU7QUFDekUsVUFBUTdRLElBQVI7QUFDRSxTQUFLLFFBQUw7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLFFBQUw7QUFDQSxTQUFLLFVBQUw7QUFDRSxhQUFPLENBQUMsQ0FBQzZRLE1BQU1reEYsU0FBZjtBQUxKO0FBT0EsU0FBTyxLQUFQO0FBQ0Q7O0FBSU0sU0FBU2hELGtCQUFULENBQ0wzNEMscUJBREssRUFFUTtBQUNiLE1BQUlwbUQsYUFBSjtBQUNBLE1BQUlnaUcsa0JBQUo7QUFDQSxNQUFNbHhELFdBQVdzVixzQkFBc0J0VixRQUF2QztBQUNBLFVBQVFBLFFBQVI7QUFDRSxTQUFLcGhDLDJCQUFMO0FBQ0EsU0FBS0Msb0NBQUw7QUFBNkI7QUFDM0IzUCxlQUFPOHdDLGFBQWFwaEMsMkJBQWIsR0FBNkIsV0FBN0IsR0FBMkMsV0FBbEQ7QUFDQSxZQUFJeWQsT0FBUWk1QixxQkFBRCxDQUE2Qnl0QixlQUF4QztBQUNBbXVCLG9CQUFZNzBFLE9BQU9BLEtBQUt3akUsWUFBWixHQUEyQixzQ0FBa0IsSUFBbEIsRUFBd0IsRUFBeEIsQ0FBdkM7QUFDQTtBQUNEO0FBQ0Q7QUFBUztBQUNQLFlBQU03ZSxZQUNKaGhDLGFBQWFyaEMsMEJBQWIsR0FDSTIyQyxzQkFBc0IxMUMsVUFEMUIsR0FFSTAxQyxxQkFITjtBQUlBLFlBQU0yc0MsZUFBZWpoQixVQUFVNmUsWUFBVixJQUEwQixJQUEvQztBQUNBM3dGLGVBQU84eEUsVUFBVTNwQyxPQUFqQjtBQUNBNjVELG9CQUFZLHNDQUFrQmpQLFlBQWxCLEVBQWdDL3lGLElBQWhDLENBQVo7QUFDQTtBQUNEO0FBakJIO0FBbUJBLE1BQUkzRSxJQUFKLEVBQWE7QUFDWCxRQUFNNG1HLGVBQWVqaUcsS0FBSzBkLFdBQUwsRUFBckI7QUFDQSxRQUFNd2tGLGdCQUFlLDZDQUFvQixJQUFwQixFQUEwQkQsWUFBMUIsQ0FBckI7QUFDQSxXQUFPLEVBQUNELG9CQUFELEVBQVlFLDJCQUFaLEVBQVA7QUFDRDtBQUNELFNBQU9GLFNBQVA7QUFDRDs7QUFFTSxTQUFTaEQsbUJBQVQsQ0FDTG1ELGlCQURLLEVBRUxuaUcsSUFGSyxFQUdMb21ELHFCQUhLLEVBSVE7QUFDYixNQUFJL3FELElBQUosRUFBYTtBQUNYLFFBQU0rbUcsdUJBQXlCRCxpQkFBL0I7QUFDQSxRQUFNSCxhQUFZLHNDQUFrQkkscUJBQXFCSixTQUF2QyxFQUFrRGhpRyxJQUFsRCxDQUFsQjtBQUNBLFFBQU1raUcsaUJBQWUsNkNBQ25CRSxxQkFBcUJGLFlBREYsRUFFbkJsaUcsSUFGbUIsQ0FBckI7QUFJQSxXQUFPLEVBQUNnaUcscUJBQUQsRUFBWUUsNEJBQVosRUFBUDtBQUNEO0FBQ0QsTUFBTTMyQyxrQkFBb0I0MkMsaUJBQTFCO0FBQ0EsU0FBTyxzQ0FBa0I1MkMsZUFBbEIsRUFBbUN2ckQsSUFBbkMsQ0FBUDtBQUNEOztBQUVNLFNBQVNpL0YsaUJBQVQsQ0FBMkJ6MUYsUUFBM0IsRUFBa0Q7QUFDdkQsU0FBT0EsUUFBUDtBQUNEOztBQUVNLFNBQVMwMUYsZ0JBQVQsQ0FBMEJuMUUsYUFBMUIsRUFBMEQ7QUFDL0Q2M0Usa0JBQWdCLDBDQUFoQjtBQUNBQyx5QkFBdUIsbURBQXZCO0FBQ0EsNENBQW1DLEtBQW5DO0FBQ0Q7O0FBRU0sU0FBUzFDLGdCQUFULENBQTBCcDFFLGFBQTFCLEVBQTBEO0FBQy9ELDZDQUFpQjgzRSxvQkFBakI7QUFDQUEseUJBQXVCLElBQXZCO0FBQ0EsNENBQW1DRCxhQUFuQztBQUNBQSxrQkFBZ0IsSUFBaEI7QUFDRDs7QUFFTSxTQUFTeEMsY0FBVCxDQUNMcC9GLElBREssRUFFTDZRLEtBRkssRUFHTHUxQyxxQkFISyxFQUlMQyxXQUpLLEVBS0xnOEMsc0JBTEssRUFNSztBQUNWLE1BQUk5MkMsd0JBQUo7QUFDQSxNQUFJbHdELElBQUosRUFBYTtBQUNYO0FBQ0EsUUFBTWluRyxpQkFBbUJqOEMsV0FBekI7QUFDQSxnREFBbUJybUQsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0JzaUcsZUFBZUosWUFBOUM7QUFDQSxRQUNFLE9BQU9yeEYsTUFBTXNZLFFBQWIsS0FBMEIsUUFBMUIsSUFDQSxPQUFPdFksTUFBTXNZLFFBQWIsS0FBMEIsUUFGNUIsRUFHRTtBQUNBLFVBQU0yMEMsU0FBUyxLQUFLanRELE1BQU1zWSxRQUExQjtBQUNBLFVBQU1vNUUsa0JBQWtCLDZDQUN0QkQsZUFBZUosWUFETyxFQUV0QmxpRyxJQUZzQixDQUF4QjtBQUlBLGtEQUFtQixJQUFuQixFQUF5Qjg5RCxNQUF6QixFQUFpQ3lrQyxlQUFqQztBQUNEO0FBQ0RoM0Msc0JBQWtCKzJDLGVBQWVOLFNBQWpDO0FBQ0QsR0FoQkQsTUFnQk87QUFDTHoyQyxzQkFBb0JsRixXQUFwQjtBQUNEO0FBQ0QsTUFBTStxQyxhQUF1QixzQ0FDM0JweEYsSUFEMkIsRUFFM0I2USxLQUYyQixFQUczQnUxQyxxQkFIMkIsRUFJM0JtRixlQUoyQixDQUE3QjtBQU1BLGdEQUFrQjgyQyxzQkFBbEIsRUFBMENqUixVQUExQztBQUNBLCtDQUFpQkEsVUFBakIsRUFBNkJ2Z0YsS0FBN0I7QUFDQSxTQUFPdWdGLFVBQVA7QUFDRDs7QUFFTSxTQUFTaU8sa0JBQVQsQ0FDTGo2QyxjQURLLEVBRUx0dUMsS0FGSyxFQUdDO0FBQ05zdUMsaUJBQWVpdkMsV0FBZixDQUEyQnY5RSxLQUEzQjtBQUNEOztBQUVNLFNBQVN3b0YsdUJBQVQsQ0FDTGxPLFVBREssRUFFTHB4RixJQUZLLEVBR0w2USxLQUhLLEVBSUx1MUMscUJBSkssRUFLTEMsV0FMSyxFQU1JO0FBQ1QsK0NBQXFCK3FDLFVBQXJCLEVBQWlDcHhGLElBQWpDLEVBQXVDNlEsS0FBdkMsRUFBOEN1MUMscUJBQTlDO0FBQ0EsU0FBTzA3Qyw2QkFBNkI5aEcsSUFBN0IsRUFBbUM2USxLQUFuQyxDQUFQO0FBQ0Q7O0FBRU0sU0FBUzB1RixhQUFULENBQ0xuTyxVQURLLEVBRUxweEYsSUFGSyxFQUdMMC9CLFFBSEssRUFJTEQsUUFKSyxFQUtMMm1CLHFCQUxLLEVBTUxDLFdBTkssRUFPZ0I7QUFDckIsTUFBSWhyRCxJQUFKLEVBQWE7QUFDWCxRQUFNaW5HLGlCQUFtQmo4QyxXQUF6QjtBQUNBLFFBQ0UsUUFBTzVtQixTQUFTdFcsUUFBaEIsY0FBb0N1VyxTQUFTdlcsUUFBN0MsTUFDQyxPQUFPc1csU0FBU3RXLFFBQWhCLEtBQTZCLFFBQTdCLElBQ0MsT0FBT3NXLFNBQVN0VyxRQUFoQixLQUE2QixRQUYvQixDQURGLEVBSUU7QUFDQSxVQUFNMjBDLFNBQVMsS0FBS3IrQixTQUFTdFcsUUFBN0I7QUFDQSxVQUFNbzVFLGtCQUFrQiw2Q0FDdEJELGVBQWVKLFlBRE8sRUFFdEJsaUcsSUFGc0IsQ0FBeEI7QUFJQSxrREFBbUIsSUFBbkIsRUFBeUI4OUQsTUFBekIsRUFBaUN5a0MsZUFBakM7QUFDRDtBQUNGO0FBQ0QsU0FBTyx1Q0FDTG5SLFVBREssRUFFTHB4RixJQUZLLEVBR0wwL0IsUUFISyxFQUlMRCxRQUpLLEVBS0wybUIscUJBTEssQ0FBUDtBQU9EOztBQUVNLFNBQVNvNUMsb0JBQVQsQ0FBOEJ4L0YsSUFBOUIsRUFBNEM2USxLQUE1QyxFQUFtRTtBQUN4RSxTQUNFN1EsU0FBUyxVQUFULElBQ0FBLFNBQVMsUUFEVCxJQUVBQSxTQUFTLFVBRlQsSUFHQSxPQUFPNlEsTUFBTXNZLFFBQWIsS0FBMEIsUUFIMUIsSUFJQSxPQUFPdFksTUFBTXNZLFFBQWIsS0FBMEIsUUFKMUIsSUFLQyxRQUFPdFksTUFBTW9qRix1QkFBYixNQUF5QyxRQUF6QyxJQUNDcGpGLE1BQU1vakYsdUJBQU4sS0FBa0MsSUFEbkMsSUFFQ3BqRixNQUFNb2pGLHVCQUFOLENBQThCdU8sTUFBOUIsSUFBd0MsSUFSNUM7QUFVRDs7QUFFTSxTQUFTL0MseUJBQVQsQ0FBbUN6L0YsSUFBbkMsRUFBaUQ2USxLQUFqRCxFQUF3RTtBQUM3RSxTQUFPLENBQUMsQ0FBQ0EsTUFBTWczQixNQUFmO0FBQ0Q7O0FBRU0sU0FBUzYzRCxrQkFBVCxDQUNMOW5FLElBREssRUFFTHd1QixxQkFGSyxFQUdMQyxXQUhLLEVBSUxnOEMsc0JBSkssRUFLUztBQUNkLE1BQUlobkcsSUFBSixFQUFhO0FBQ1gsUUFBTWluRyxpQkFBbUJqOEMsV0FBekI7QUFDQSxnREFBbUIsSUFBbkIsRUFBeUJ6dUIsSUFBekIsRUFBK0IwcUUsZUFBZUosWUFBOUM7QUFDRDtBQUNELE1BQU1qUCxXQUF5Qix1Q0FBZXI3RCxJQUFmLEVBQXFCd3VCLHFCQUFyQixDQUEvQjtBQUNBLGdEQUFrQmk4QyxzQkFBbEIsRUFBMENwUCxRQUExQztBQUNBLFNBQU9BLFFBQVA7QUFDRDs7QUFFTSxJQUFNaDlFLGdEQUFvQixJQUExQjtBQUNQO0FBQ0E7QUFDQTtBQUNPLElBQU13c0YsNENBQ1gsT0FBT2o3QyxVQUFQLEtBQXNCLFVBQXRCLEdBQW1DQSxVQUFuQyxHQUFpRGpzRCxTQUQ1QztBQUVBLElBQU1tbkcsd0NBQ1gsT0FBTy8zQixZQUFQLEtBQXdCLFVBQXhCLEdBQXFDQSxZQUFyQyxHQUFxRHB2RSxTQURoRDtBQUVBLElBQU1nN0IsZ0NBQVksQ0FBQyxDQUFuQjtBQUNBLElBQU1vc0UsMERBQXlCQyxvQ0FBL0I7QUFDQSxJQUFNQyxzREFBdUJDLGtDQUE3Qjs7QUFFUDtBQUNBO0FBQ0E7O0FBRU8sSUFBTW42Qyw4Q0FBbUIsSUFBekI7O0FBRUEsU0FBU2czQyxXQUFULENBQ0x2TyxVQURLLEVBRUxweEYsSUFGSyxFQUdMeS9CLFFBSEssRUFJTDRpRSxzQkFKSyxFQUtDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSVAsNkJBQTZCOWhHLElBQTdCLEVBQW1DeS9CLFFBQW5DLENBQUosRUFBa0Q7QUFDOUMyeEQsY0FBRixDQUl5QjdNLEtBSnpCO0FBS0Q7QUFDRjs7QUFFTSxTQUFTcWIsWUFBVCxDQUNMeE8sVUFESyxFQUVMOXFDLGFBRkssRUFHTHRtRCxJQUhLLEVBSUwwL0IsUUFKSyxFQUtMRCxRQUxLLEVBTUw0aUUsc0JBTkssRUFPQztBQUNOO0FBQ0E7QUFDQSwrQ0FBaUJqUixVQUFqQixFQUE2QjN4RCxRQUE3QjtBQUNBO0FBQ0EsMkNBQWlCMnhELFVBQWpCLEVBQTZCOXFDLGFBQTdCLEVBQTRDdG1ELElBQTVDLEVBQWtEMC9CLFFBQWxELEVBQTRERCxRQUE1RDtBQUNEOztBQUVNLFNBQVNvZ0UsZ0JBQVQsQ0FBMEJ6TyxVQUExQixFQUFzRDtBQUMzRCxnQ0FBZUEsVUFBZixFQUEyQixFQUEzQjtBQUNEOztBQUVNLFNBQVMwTyxnQkFBVCxDQUNMOTVDLFlBREssRUFFTHdFLE9BRkssRUFHTEQsT0FISyxFQUlDO0FBQ052RSxlQUFhNHRCLFNBQWIsR0FBeUJycEIsT0FBekI7QUFDRDs7QUFFTSxTQUFTOHBDLFdBQVQsQ0FDTGp2QyxjQURLLEVBRUx0dUMsS0FGSyxFQUdDO0FBQ05zdUMsaUJBQWVpdkMsV0FBZixDQUEyQnY5RSxLQUEzQjtBQUNEOztBQUVNLFNBQVNpcEYsc0JBQVQsQ0FDTGp1QixTQURLLEVBRUxoN0QsS0FGSyxFQUdDO0FBQ04sTUFBSXBHLG1CQUFKO0FBQ0EsTUFBSW9oRSxVQUFVaGhDLFFBQVYsS0FBdUJyaEMsMEJBQTNCLEVBQXlDO0FBQ3ZDaUIsaUJBQWNvaEUsVUFBVXBoRSxVQUF4QjtBQUNBQSxlQUFXZ2pFLFlBQVgsQ0FBd0I1OEQsS0FBeEIsRUFBK0JnN0QsU0FBL0I7QUFDRCxHQUhELE1BR087QUFDTHBoRSxpQkFBYW9oRSxTQUFiO0FBQ0FwaEUsZUFBVzJqRixXQUFYLENBQXVCdjlFLEtBQXZCO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTWlzRixxQkFBcUJqeEIsVUFBVUMsbUJBQXJDO0FBQ0EsTUFDRSxDQUFDZ3hCLHVCQUF1QixJQUF2QixJQUErQkEsdUJBQXVCeG5HLFNBQXZELEtBQ0FtVixXQUFXd2dGLE9BQVgsS0FBdUIsSUFGekIsRUFHRTtBQUNBO0FBQ0EsNkRBQW1DeGdGLFVBQW5DO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTZ2pFLFlBQVQsQ0FDTHR1QixjQURLLEVBRUx0dUMsS0FGSyxFQUdMa3NGLFdBSEssRUFJQztBQUNONTlDLGlCQUFlc3VCLFlBQWYsQ0FBNEI1OEQsS0FBNUIsRUFBbUNrc0YsV0FBbkM7QUFDRDs7QUFFTSxTQUFTaEQsdUJBQVQsQ0FDTGx1QixTQURLLEVBRUxoN0QsS0FGSyxFQUdMa3NGLFdBSEssRUFJQztBQUNOLE1BQUlseEIsVUFBVWhoQyxRQUFWLEtBQXVCcmhDLDBCQUEzQixFQUF5QztBQUN0Q3FpRSxjQUFVcGhFLFVBQVgsQ0FBNEJnakUsWUFBNUIsQ0FBeUM1OEQsS0FBekMsRUFBZ0Rrc0YsV0FBaEQ7QUFDRCxHQUZELE1BRU87QUFDTGx4QixjQUFVNEIsWUFBVixDQUF1QjU4RCxLQUF2QixFQUE4QmtzRixXQUE5QjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU3h1QixXQUFULENBQ0xwdkIsY0FESyxFQUVMdHVDLEtBRkssRUFHQztBQUNOc3VDLGlCQUFlb3ZCLFdBQWYsQ0FBMkIxOUQsS0FBM0I7QUFDRDs7QUFFTSxTQUFTbXBGLHdCQUFULENBQ0xudUIsU0FESyxFQUVMaDdELEtBRkssRUFHQztBQUNOLE1BQUlnN0QsVUFBVWhoQyxRQUFWLEtBQXVCcmhDLDBCQUEzQixFQUF5QztBQUN0Q3FpRSxjQUFVcGhFLFVBQVgsQ0FBNEI4akUsV0FBNUIsQ0FBd0MxOUQsS0FBeEM7QUFDRCxHQUZELE1BRU87QUFDTGc3RCxjQUFVMEMsV0FBVixDQUFzQjE5RCxLQUF0QjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU29wRixxQkFBVCxDQUNMOTZDLGNBREssRUFFTEUsZ0JBRkssRUFHQztBQUNOLE1BQUkzaUQsT0FBTzJpRCxnQkFBWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlvMUIsUUFBUSxDQUFaO0FBQ0EsS0FBRztBQUNELFFBQUl1b0IsV0FBV3RnRyxLQUFLc2lGLFdBQXBCO0FBQ0E3L0IsbUJBQWVvdkIsV0FBZixDQUEyQjd4RSxJQUEzQjtBQUNBLFFBQUlzZ0csWUFBWUEsU0FBU255RCxRQUFULEtBQXNCcmhDLDBCQUF0QyxFQUFvRDtBQUNsRCxVQUFJKzlDLE9BQVN5MUMsUUFBRCxDQUFnQnoxQyxJQUE1QjtBQUNBLFVBQUlBLFNBQVNtMEMsaUJBQWIsRUFBZ0M7QUFDOUIsWUFBSWpuQixVQUFVLENBQWQsRUFBaUI7QUFDZnQxQix5QkFBZW92QixXQUFmLENBQTJCeXVCLFFBQTNCO0FBQ0E7QUFDRCxTQUhELE1BR087QUFDTHZvQjtBQUNEO0FBQ0YsT0FQRCxNQU9PLElBQUlsdEIsU0FBU2swQyxtQkFBYixFQUFrQztBQUN2Q2huQjtBQUNEO0FBQ0Y7QUFDRC8zRSxXQUFPc2dHLFFBQVA7QUFDRCxHQWpCRCxRQWlCU3RnRyxJQWpCVDtBQWtCQTtBQUNEOztBQUVNLFNBQVN3OUYsa0NBQVQsQ0FDTHJ1QixTQURLLEVBRUx4c0IsZ0JBRkssRUFHQztBQUNOLE1BQUl3c0IsVUFBVWhoQyxRQUFWLEtBQXVCcmhDLDBCQUEzQixFQUF5QztBQUN2Q3l3RiwwQkFBdUJwdUIsVUFBVXBoRSxVQUFqQyxFQUFtRDQwQyxnQkFBbkQ7QUFDRCxHQUZELE1BRU8sSUFBSXdzQixVQUFVaGhDLFFBQVYsS0FBdUJ2aEMsMEJBQTNCLEVBQXlDO0FBQzlDMndGLDBCQUF1QnB1QixTQUF2QixFQUF3Q3hzQixnQkFBeEM7QUFDRCxHQUZNLE1BRUE7QUFDTDtBQUNEO0FBQ0Y7O0FBRU0sU0FBUzg2QyxZQUFULENBQXNCNTJGLFFBQXRCLEVBQWdEO0FBQ3JEO0FBQ0E7QUFDQUEsYUFBYUEsUUFBYjtBQUNBQSxXQUFTa3BELEtBQVQsQ0FBZStDLE9BQWYsR0FBeUIsTUFBekI7QUFDRDs7QUFFTSxTQUFTNHFDLGdCQUFULENBQTBCcjZDLFlBQTFCLEVBQTREO0FBQ2pFQSxlQUFhNHRCLFNBQWIsR0FBeUIsRUFBekI7QUFDRDs7QUFFTSxTQUFTMHNCLGNBQVQsQ0FBd0I5MkYsUUFBeEIsRUFBNENxSCxLQUE1QyxFQUFnRTtBQUNyRXJILGFBQWFBLFFBQWI7QUFDQSxNQUFNMnhFLFlBQVl0cUUsTUFBTWkrRSxLQUFOLENBQWxCO0FBQ0EsTUFBTXI1QixVQUNKMGxCLGNBQWM1L0UsU0FBZCxJQUNBNC9FLGNBQWMsSUFEZCxJQUVBQSxVQUFVNXpFLGNBQVYsQ0FBeUIsU0FBekIsQ0FGQSxHQUdJNHpFLFVBQVUxbEIsT0FIZCxHQUlJLElBTE47QUFNQWpzRCxXQUFTa3BELEtBQVQsQ0FBZStDLE9BQWYsR0FBeUIsbUNBQW9CLFNBQXBCLEVBQStCQSxPQUEvQixDQUF6QjtBQUNEOztBQUVNLFNBQVM4cUMsa0JBQVQsQ0FDTHY2QyxZQURLLEVBRUxwdUIsSUFGSyxFQUdDO0FBQ05vdUIsZUFBYTR0QixTQUFiLEdBQXlCaDhDLElBQXpCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOztBQUVPLElBQU11dEIsZ0RBQW9CLElBQTFCOztBQUVBLFNBQVNxN0Msa0JBQVQsQ0FDTGgzRixRQURLLEVBRUx4SixJQUZLLEVBR0w2USxLQUhLLEVBSVk7QUFDakIsTUFDRXJILFNBQVNzbkMsUUFBVCxLQUFzQnZoQywwQkFBdEIsSUFDQXZQLEtBQUswZCxXQUFMLE9BQXVCbFUsU0FBU285QixRQUFULENBQWtCbHBCLFdBQWxCLEVBRnpCLEVBR0U7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNEO0FBQ0EsU0FBU2xVLFFBQVQ7QUFDRDs7QUFFTSxTQUFTaTNGLHNCQUFULENBQ0xqM0YsUUFESyxFQUVMb3VCLElBRkssRUFHZ0I7QUFDckIsTUFBSUEsU0FBUyxFQUFULElBQWVwdUIsU0FBU3NuQyxRQUFULEtBQXNCdGhDLHVCQUF6QyxFQUFvRDtBQUNsRDtBQUNBLFdBQU8sSUFBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFTaEcsUUFBVDtBQUNEOztBQUVNLFNBQVNrM0YsMEJBQVQsQ0FDTGwzRixRQURLLEVBRW9CO0FBQ3pCLE1BQUlBLFNBQVNzbkMsUUFBVCxLQUFzQnJoQywwQkFBMUIsRUFBd0M7QUFDdEM7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNEO0FBQ0EsU0FBU2pHLFFBQVQ7QUFDRDs7QUFFTSxTQUFTbTNGLHdCQUFULENBQ0xuM0YsUUFESyxFQUVzQjtBQUMzQixNQUFJN0csT0FBTzZHLFNBQVN5N0UsV0FBcEI7QUFDQTtBQUNBLFNBQ0V0aUYsUUFDQUEsS0FBS211QyxRQUFMLEtBQWtCdmhDLDBCQURsQixJQUVBNU0sS0FBS211QyxRQUFMLEtBQWtCdGhDLHVCQUZsQixLQUdDLENBQUN2UiwrQ0FBRCxJQUNDMEUsS0FBS211QyxRQUFMLEtBQWtCcmhDLDBCQURuQixJQUVFOU0sSUFBRCxDQUFZNnFELElBQVosS0FBcUJrMEMsbUJBTHZCLENBREYsRUFPRTtBQUNBLytGLFdBQU9BLEtBQUtzaUYsV0FBWjtBQUNEO0FBQ0QsU0FBUXRpRixJQUFSO0FBQ0Q7O0FBRU0sU0FBU2krRix1QkFBVCxDQUNMeDdDLGNBREssRUFFc0I7QUFDM0IsTUFBSXB5QyxPQUFPb3lDLGVBQWUwdUIsVUFBMUI7QUFDQTtBQUNBLFNBQ0U5Z0UsUUFDQUEsS0FBSzg5QixRQUFMLEtBQWtCdmhDLDBCQURsQixJQUVBeUQsS0FBSzg5QixRQUFMLEtBQWtCdGhDLHVCQUZsQixLQUdDLENBQUN2UiwrQ0FBRCxJQUNDK1UsS0FBSzg5QixRQUFMLEtBQWtCcmhDLDBCQURuQixJQUVFdUQsSUFBRCxDQUFZdzZDLElBQVosS0FBcUJrMEMsbUJBTHZCLENBREYsRUFPRTtBQUNBMXVGLFdBQU9BLEtBQUtpeUUsV0FBWjtBQUNEO0FBQ0QsU0FBUWp5RSxJQUFSO0FBQ0Q7O0FBRU0sU0FBUzZ0RixlQUFULENBQ0xyM0YsUUFESyxFQUVMeEosSUFGSyxFQUdMNlEsS0FISyxFQUlMdTFDLHFCQUpLLEVBS0xDLFdBTEssRUFNTGc4QyxzQkFOSyxFQU9nQjtBQUNyQixnREFBa0JBLHNCQUFsQixFQUEwQzc0RixRQUExQztBQUNBO0FBQ0E7QUFDQSwrQ0FBaUJBLFFBQWpCLEVBQTJCcUgsS0FBM0I7QUFDQSxNQUFJMDZDLHdCQUFKO0FBQ0EsTUFBSWx3RCxJQUFKLEVBQWE7QUFDWCxRQUFNaW5HLGlCQUFtQmo4QyxXQUF6QjtBQUNBa0Ysc0JBQWtCKzJDLGVBQWVOLFNBQWpDO0FBQ0QsR0FIRCxNQUdPO0FBQ0x6MkMsc0JBQW9CbEYsV0FBcEI7QUFDRDtBQUNELFNBQU8sK0NBQ0w3OEMsUUFESyxFQUVMeEosSUFGSyxFQUdMNlEsS0FISyxFQUlMMDZDLGVBSkssRUFLTG5GLHFCQUxLLENBQVA7QUFPRDs7QUFFTSxTQUFTMDZDLG1CQUFULENBQ0w5NkMsWUFESyxFQUVMcHVCLElBRkssRUFHTHlxRSxzQkFISyxFQUlJO0FBQ1QsZ0RBQWtCQSxzQkFBbEIsRUFBMENyOEMsWUFBMUM7QUFDQSxTQUFPLHlDQUFpQkEsWUFBakIsRUFBK0JwdUIsSUFBL0IsQ0FBUDtBQUNEOztBQUVNLFNBQVNtcEUsOENBQVQsQ0FDTHo3QyxnQkFESyxFQUVzQjtBQUMzQixNQUFJM2lELE9BQU8yaUQsaUJBQWlCMi9CLFdBQTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSXZLLFFBQVEsQ0FBWjtBQUNBLFNBQU8vM0UsSUFBUCxFQUFhO0FBQ1gsUUFBSUEsS0FBS211QyxRQUFMLEtBQWtCcmhDLDBCQUF0QixFQUFvQztBQUNsQyxVQUFJKzlDLE9BQVM3cUQsSUFBRCxDQUFZNnFELElBQXhCO0FBQ0EsVUFBSUEsU0FBU20wQyxpQkFBYixFQUFnQztBQUM5QixZQUFJam5CLFVBQVUsQ0FBZCxFQUFpQjtBQUNmLGlCQUFPaW1CLHlCQUEwQmgrRixJQUExQixDQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wrM0U7QUFDRDtBQUNGLE9BTkQsTUFNTyxJQUFJbHRCLFNBQVNrMEMsbUJBQWIsRUFBa0M7QUFDdkNobkI7QUFDRDtBQUNGO0FBQ0QvM0UsV0FBT0EsS0FBS3NpRixXQUFaO0FBQ0Q7QUFDRDtBQUNBLFNBQU8sSUFBUDtBQUNEOztBQUVNLFNBQVMrYix3Q0FBVCxDQUNMcjdDLGVBREssRUFFTEssWUFGSyxFQUdMcHVCLElBSEssRUFJTDtBQUNBLE1BQUl2OEIsSUFBSixFQUFhO0FBQ1gsaURBQXFCMnFELFlBQXJCLEVBQW1DcHVCLElBQW5DO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTcXBFLCtCQUFULENBQ0xyN0MsVUFESyxFQUVMQyxXQUZLLEVBR0xULGNBSEssRUFJTFksWUFKSyxFQUtMcHVCLElBTEssRUFNTDtBQUNBLE1BQUl2OEIsSUFBT0EsSUFBSXdxRCxZQUFZOG9DLDBCQUFaLE1BQTRDLElBQTNELEVBQWlFO0FBQy9ELGlEQUFxQjNvQyxZQUFyQixFQUFtQ3B1QixJQUFuQztBQUNEO0FBQ0Y7O0FBRU0sU0FBU3NwRSw4QkFBVCxDQUNMdjdDLGVBREssRUFFTG44QyxRQUZLLEVBR0w7QUFDQSxNQUFJbk8sSUFBSixFQUFhO0FBQ1gsUUFBSW1PLFNBQVNzbkMsUUFBVCxLQUFzQnZoQywwQkFBMUIsRUFBd0M7QUFDdEMsOERBQWdDbzJDLGVBQWhDLEVBQWtEbjhDLFFBQWxEO0FBQ0QsS0FGRCxNQUVPLElBQUlBLFNBQVNzbkMsUUFBVCxLQUFzQnJoQywwQkFBMUIsRUFBd0M7QUFDN0M7QUFDRCxLQUZNLE1BRUE7QUFDTCwyREFBNkJrMkMsZUFBN0IsRUFBK0NuOEMsUUFBL0M7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBUzIzRixxQkFBVCxDQUNMdjdDLFVBREssRUFFTEMsV0FGSyxFQUdMVCxjQUhLLEVBSUw1N0MsUUFKSyxFQUtMO0FBQ0EsTUFBSW5PLElBQU9BLElBQUl3cUQsWUFBWThvQywwQkFBWixNQUE0QyxJQUEzRCxFQUFpRTtBQUMvRCxRQUFJbmxGLFNBQVNzbkMsUUFBVCxLQUFzQnZoQywwQkFBMUIsRUFBd0M7QUFDdEMsOERBQWdDNjFDLGNBQWhDLEVBQWlENTdDLFFBQWpEO0FBQ0QsS0FGRCxNQUVPLElBQUlBLFNBQVNzbkMsUUFBVCxLQUFzQnJoQywwQkFBMUIsRUFBd0M7QUFDN0M7QUFDRCxLQUZNLE1BRUE7QUFDTCwyREFBNkIyMUMsY0FBN0IsRUFBOEM1N0MsUUFBOUM7QUFDRDtBQUNGO0FBQ0Y7O0FBRU0sU0FBUzQzRixxQ0FBVCxDQUNMejdDLGVBREssRUFFTDNsRCxJQUZLLEVBR0w2USxLQUhLLEVBSUw7QUFDQSxNQUFJeFYsSUFBSixFQUFhO0FBQ1gsMkRBQStCc3FELGVBQS9CLEVBQWdEM2xELElBQWhELEVBQXNENlEsS0FBdEQ7QUFDRDtBQUNGOztBQUVNLFNBQVN3d0YseUNBQVQsQ0FDTDE3QyxlQURLLEVBRUwvdEIsSUFGSyxFQUdMO0FBQ0EsTUFBSXY4QixJQUFKLEVBQWE7QUFDWCx3REFBNEJzcUQsZUFBNUIsRUFBNkMvdEIsSUFBN0M7QUFDRDtBQUNGOztBQUVNLFNBQVMwcEUsNkNBQVQsQ0FDTDM3QyxlQURLLEVBRUw7QUFDQSxNQUFJdHFELElBQUosRUFBYTtBQUNYO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTa21HLDRCQUFULENBQ0wzN0MsVUFESyxFQUVMQyxXQUZLLEVBR0xULGNBSEssRUFJTHBsRCxJQUpLLEVBS0w2USxLQUxLLEVBTUw7QUFDQSxNQUFJeFYsSUFBT0EsSUFBSXdxRCxZQUFZOG9DLDBCQUFaLE1BQTRDLElBQTNELEVBQWlFO0FBQy9ELDJEQUErQnZwQyxjQUEvQixFQUErQ3BsRCxJQUEvQyxFQUFxRDZRLEtBQXJEO0FBQ0Q7QUFDRjs7QUFFTSxTQUFTMndGLGdDQUFULENBQ0w1N0MsVUFESyxFQUVMQyxXQUZLLEVBR0xULGNBSEssRUFJTHh0QixJQUpLLEVBS0w7QUFDQSxNQUFJdjhCLElBQU9BLElBQUl3cUQsWUFBWThvQywwQkFBWixNQUE0QyxJQUEzRCxFQUFpRTtBQUMvRCx3REFBNEJ2cEMsY0FBNUIsRUFBNEN4dEIsSUFBNUM7QUFDRDtBQUNGOztBQUVNLFNBQVM2cEUsb0NBQVQsQ0FDTDc3QyxVQURLLEVBRUxDLFdBRkssRUFHTFQsY0FISyxFQUlMO0FBQ0EsTUFBSS9wRCxJQUFPQSxJQUFJd3FELFlBQVk4b0MsMEJBQVosTUFBNEMsSUFBM0QsRUFBaUU7QUFDL0Q7QUFDRDtBQUNGLEM7Ozs7Ozs7Ozs7Ozs7O0FDdnZCRDs7Ozs7O0FBRUE7QUFDQTs7QUFFQSxTQUFTdVUsSUFBVCxHQUE0QjtBQUMxQiwyQkFDRSxLQURGLEVBRUUsd0RBQ0UsaURBREYsR0FFRSx1QkFKSjtBQU1EOztBQUVEO0FBdkJBOzs7Ozs7Ozs7QUF3Qk8sSUFBTWg2QyxvREFBc0IsS0FBNUI7QUFDQSxJQUFNaTZDLHdDQUFnQkQsSUFBdEI7QUFDQSxJQUFNRSw0REFBMEJGLElBQWhDO0FBQ0EsSUFBTUcsMEVBQWlDSCxJQUF2QztBQUNBLElBQU1JLGdFQUE0QkosSUFBbEM7QUFDQSxJQUFNSyw4REFBMkJMLElBQWpDO0FBQ0EsSUFBTU0sb0RBQXNCTixJQUE1QjtBQUNBLElBQU1PLHdEQUF3QlAsSUFBOUI7QUFDQSxJQUFNUSw4REFBMkJSLElBQWpDLEM7Ozs7Ozs7Ozs7Ozs7O2tRQ2hDUDs7Ozs7OztBQVFBOzs7QUFEQTs7OztBQUVBOzs7O0FBRUEsSUFBSVMscUJBQXFCLDhCQUFNLENBQUUsQ0FBakM7QUFDQSxJQUFJQyxzQkFBc0IsK0JBQU0sQ0FBRSxDQUFsQzs7QUFFQSxJQUFJdm9HLElBQUosRUFBYTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTXdvRyxjQUFjLENBQ2xCLFNBRGtCLEVBRWxCLFFBRmtCLEVBR2xCLE1BSGtCLEVBSWxCLFNBSmtCLEVBS2xCLE9BTGtCLEVBTWxCLE1BTmtCLEVBT2xCLFVBUGtCLEVBUWxCLFNBUmtCLEVBU2xCLFlBVGtCLEVBVWxCLE1BVmtCLEVBV2xCLElBWGtCLEVBWWxCLFFBWmtCLEVBYWxCLFNBYmtCLEVBY2xCLFFBZGtCLEVBZWxCLEtBZmtCLEVBZ0JsQixVQWhCa0IsRUFpQmxCLElBakJrQixFQWtCbEIsU0FsQmtCLEVBbUJsQixLQW5Ca0IsRUFvQmxCLEtBcEJrQixFQXFCbEIsSUFyQmtCLEVBc0JsQixJQXRCa0IsRUF1QmxCLE9BdkJrQixFQXdCbEIsVUF4QmtCLEVBeUJsQixZQXpCa0IsRUEwQmxCLFFBMUJrQixFQTJCbEIsUUEzQmtCLEVBNEJsQixNQTVCa0IsRUE2QmxCLE9BN0JrQixFQThCbEIsVUE5QmtCLEVBK0JsQixJQS9Ca0IsRUFnQ2xCLElBaENrQixFQWlDbEIsSUFqQ2tCLEVBa0NsQixJQWxDa0IsRUFtQ2xCLElBbkNrQixFQW9DbEIsSUFwQ2tCLEVBcUNsQixNQXJDa0IsRUFzQ2xCLFFBdENrQixFQXVDbEIsUUF2Q2tCLEVBd0NsQixJQXhDa0IsRUF5Q2xCLE1BekNrQixFQTBDbEIsUUExQ2tCLEVBMkNsQixLQTNDa0IsRUE0Q2xCLE9BNUNrQixFQTZDbEIsU0E3Q2tCLEVBOENsQixJQTlDa0IsRUErQ2xCLE1BL0NrQixFQWdEbEIsU0FoRGtCLEVBaURsQixNQWpEa0IsRUFrRGxCLFNBbERrQixFQW1EbEIsTUFuRGtCLEVBb0RsQixVQXBEa0IsRUFxRGxCLE1BckRrQixFQXNEbEIsS0F0RGtCLEVBdURsQixTQXZEa0IsRUF3RGxCLFVBeERrQixFQXlEbEIsVUF6RGtCLEVBMERsQixRQTFEa0IsRUEyRGxCLElBM0RrQixFQTREbEIsR0E1RGtCLEVBNkRsQixPQTdEa0IsRUE4RGxCLFdBOURrQixFQStEbEIsS0EvRGtCLEVBZ0VsQixRQWhFa0IsRUFpRWxCLFNBakVrQixFQWtFbEIsUUFsRWtCLEVBbUVsQixRQW5Fa0IsRUFvRWxCLE9BcEVrQixFQXFFbEIsU0FyRWtCLEVBc0VsQixPQXRFa0IsRUF1RWxCLE9BdkVrQixFQXdFbEIsSUF4RWtCLEVBeUVsQixVQXpFa0IsRUEwRWxCLFVBMUVrQixFQTJFbEIsT0EzRWtCLEVBNEVsQixJQTVFa0IsRUE2RWxCLE9BN0VrQixFQThFbEIsT0E5RWtCLEVBK0VsQixJQS9Fa0IsRUFnRmxCLE9BaEZrQixFQWlGbEIsSUFqRmtCLEVBa0ZsQixLQWxGa0IsRUFtRmxCLEtBbkZrQixDQUFwQjs7QUFzRkE7QUFDQSxNQUFNQyxjQUFjLENBQ2xCLFFBRGtCLEVBRWxCLFNBRmtCLEVBR2xCLE1BSGtCLEVBSWxCLE9BSmtCLEVBS2xCLElBTGtCLEVBTWxCLElBTmtCLEVBT2xCLFNBUGtCLEVBUWxCLFFBUmtCLEVBU2xCLFVBVGtCOztBQVdsQjtBQUNBO0FBQ0E7QUFDQSxpQkFka0IsRUFlbEIsTUFma0IsRUFnQmxCLE9BaEJrQixDQUFwQjs7QUFtQkE7QUFDQSxNQUFNQyxrQkFBa0JELFlBQVl0MEQsTUFBWixDQUFtQixDQUFDLFFBQUQsQ0FBbkIsQ0FBeEI7O0FBRUE7QUFDQSxNQUFNdzBELGlCQUFpQixDQUNyQixJQURxQixFQUVyQixJQUZxQixFQUdyQixJQUhxQixFQUlyQixRQUpxQixFQUtyQixVQUxxQixFQU1yQixHQU5xQixFQU9yQixJQVBxQixFQVFyQixJQVJxQixDQUF2Qjs7QUFXQSxNQUFNQyxvQkFBb0I7QUFDeEJwaEcsYUFBUyxJQURlOztBQUd4QnFoRyxhQUFTLElBSGU7QUFJeEJDLGlCQUFhLElBSlc7QUFLeEJDLHNCQUFrQixJQUxNO0FBTXhCQyxvQkFBZ0IsSUFOUTtBQU94QkMsdUJBQW1CLElBUEs7O0FBU3hCQyw0QkFBd0IsSUFUQTtBQVV4QkMsMEJBQXNCO0FBVkUsR0FBMUI7O0FBYUEsVUFpVU1aLG1CQWpVTix5QkFBc0IsNkJBQVNhLE9BQVQsRUFBa0J4a0csR0FBbEIsRUFBdUI7QUFDM0MsUUFBSWlpRyw0QkFBb0J1QyxXQUFXUixpQkFBL0IsQ0FBSjtBQUNBLFFBQUl2aEcsT0FBTyxFQUFDekMsUUFBRCxFQUFYOztBQUVBLFFBQUk2akcsWUFBWWpuRixPQUFaLENBQW9CNWMsR0FBcEIsTUFBNkIsQ0FBQyxDQUFsQyxFQUFxQztBQUNuQ2lpRyxtQkFBYWlDLFdBQWIsR0FBMkIsSUFBM0I7QUFDQWpDLG1CQUFha0MsZ0JBQWIsR0FBZ0MsSUFBaEM7QUFDQWxDLG1CQUFhbUMsY0FBYixHQUE4QixJQUE5QjtBQUNEO0FBQ0QsUUFBSU4sZ0JBQWdCbG5GLE9BQWhCLENBQXdCNWMsR0FBeEIsTUFBaUMsQ0FBQyxDQUF0QyxFQUF5QztBQUN2Q2lpRyxtQkFBYW9DLGlCQUFiLEdBQWlDLElBQWpDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFFBQ0VULFlBQVlobkYsT0FBWixDQUFvQjVjLEdBQXBCLE1BQTZCLENBQUMsQ0FBOUIsSUFDQUEsUUFBUSxTQURSLElBRUFBLFFBQVEsS0FGUixJQUdBQSxRQUFRLEdBSlYsRUFLRTtBQUNBaWlHLG1CQUFhcUMsc0JBQWIsR0FBc0MsSUFBdEM7QUFDQXJDLG1CQUFhc0Msb0JBQWIsR0FBb0MsSUFBcEM7QUFDRDs7QUFFRHRDLGlCQUFhci9GLE9BQWIsR0FBdUJILElBQXZCOztBQUVBLFFBQUl6QyxRQUFRLE1BQVosRUFBb0I7QUFDbEJpaUcsbUJBQWFnQyxPQUFiLEdBQXVCeGhHLElBQXZCO0FBQ0Q7QUFDRCxRQUFJekMsUUFBUSxHQUFaLEVBQWlCO0FBQ2ZpaUcsbUJBQWFpQyxXQUFiLEdBQTJCemhHLElBQTNCO0FBQ0Q7QUFDRCxRQUFJekMsUUFBUSxRQUFaLEVBQXNCO0FBQ3BCaWlHLG1CQUFha0MsZ0JBQWIsR0FBZ0MxaEcsSUFBaEM7QUFDRDtBQUNELFFBQUl6QyxRQUFRLE1BQVosRUFBb0I7QUFDbEJpaUcsbUJBQWFtQyxjQUFiLEdBQThCM2hHLElBQTlCO0FBQ0Q7QUFDRCxRQUFJekMsUUFBUSxHQUFaLEVBQWlCO0FBQ2ZpaUcsbUJBQWFvQyxpQkFBYixHQUFpQzVoRyxJQUFqQztBQUNEO0FBQ0QsUUFBSXpDLFFBQVEsSUFBWixFQUFrQjtBQUNoQmlpRyxtQkFBYXFDLHNCQUFiLEdBQXNDN2hHLElBQXRDO0FBQ0Q7QUFDRCxRQUFJekMsUUFBUSxJQUFSLElBQWdCQSxRQUFRLElBQTVCLEVBQWtDO0FBQ2hDaWlHLG1CQUFhc0Msb0JBQWIsR0FBb0M5aEcsSUFBcEM7QUFDRDs7QUFFRCxXQUFPdy9GLFlBQVA7QUFDRCxHQWxERDs7QUFvREE7OztBQUdBLE1BQU13Qyx1QkFBdUIsU0FBdkJBLG9CQUF1QixDQUFTemtHLEdBQVQsRUFBYzBrRyxTQUFkLEVBQXlCO0FBQ3BEO0FBQ0EsWUFBUUEsU0FBUjtBQUNFO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBTzFrRyxRQUFRLFFBQVIsSUFBb0JBLFFBQVEsVUFBNUIsSUFBMENBLFFBQVEsT0FBekQ7QUFDRixXQUFLLFVBQUw7QUFDRSxlQUFPQSxRQUFRLFFBQVIsSUFBb0JBLFFBQVEsT0FBbkM7QUFDRjtBQUNBO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBT0EsUUFBUSxPQUFmO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFLLElBQUw7QUFDRSxlQUNFQSxRQUFRLElBQVIsSUFDQUEsUUFBUSxJQURSLElBRUFBLFFBQVEsT0FGUixJQUdBQSxRQUFRLFFBSFIsSUFJQUEsUUFBUSxVQUxWO0FBT0Y7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLE9BQUw7QUFDRSxlQUNFQSxRQUFRLElBQVIsSUFDQUEsUUFBUSxPQURSLElBRUFBLFFBQVEsUUFGUixJQUdBQSxRQUFRLFVBSlY7QUFNRjtBQUNBLFdBQUssVUFBTDtBQUNFLGVBQU9BLFFBQVEsS0FBUixJQUFpQkEsUUFBUSxVQUFoQztBQUNGO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFDRUEsUUFBUSxTQUFSLElBQ0FBLFFBQVEsVUFEUixJQUVBQSxRQUFRLE9BRlIsSUFHQUEsUUFBUSxPQUhSLElBSUFBLFFBQVEsT0FKUixJQUtBQSxRQUFRLE9BTFIsSUFNQUEsUUFBUSxRQU5SLElBT0FBLFFBQVEsVUFSVjtBQVVGO0FBQ0EsV0FBSyxNQUFMO0FBQ0UsZUFDRUEsUUFBUSxNQUFSLElBQ0FBLFFBQVEsVUFEUixJQUVBQSxRQUFRLFNBRlIsSUFHQUEsUUFBUSxNQUhSLElBSUFBLFFBQVEsTUFKUixJQUtBQSxRQUFRLE9BTFIsSUFNQUEsUUFBUSxVQU5SLElBT0FBLFFBQVEsVUFQUixJQVFBQSxRQUFRLE9BUlIsSUFTQUEsUUFBUSxRQVRSLElBVUFBLFFBQVEsVUFYVjtBQWFGO0FBQ0EsV0FBSyxNQUFMO0FBQ0UsZUFBT0EsUUFBUSxNQUFSLElBQWtCQSxRQUFRLE1BQWpDO0FBQ0YsV0FBSyxXQUFMO0FBQ0UsZUFBT0EsUUFBUSxNQUFmO0FBcEVKOztBQXVFQTtBQUNBO0FBQ0E7QUFDQSxZQUFRQSxHQUFSO0FBQ0UsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0UsZUFDRTBrRyxjQUFjLElBQWQsSUFDQUEsY0FBYyxJQURkLElBRUFBLGNBQWMsSUFGZCxJQUdBQSxjQUFjLElBSGQsSUFJQUEsY0FBYyxJQUpkLElBS0FBLGNBQWMsSUFOaEI7O0FBU0YsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0UsZUFBT1gsZUFBZW5uRixPQUFmLENBQXVCOG5GLFNBQXZCLE1BQXNDLENBQUMsQ0FBOUM7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxLQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxNQUFMO0FBQ0EsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFPQSxhQUFhLElBQXBCO0FBckNKOztBQXdDQSxXQUFPLElBQVA7QUFDRCxHQXJIRDs7QUF1SEE7OztBQUdBLE1BQU1DLDRCQUE0QixTQUE1QkEseUJBQTRCLENBQVMza0csR0FBVCxFQUFjaWlHLFlBQWQsRUFBNEI7QUFDNUQsWUFBUWppRyxHQUFSO0FBQ0UsV0FBSyxTQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxZQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxLQUFMO0FBQ0EsV0FBSyxLQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0EsV0FBSyxZQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxNQUFMO0FBQ0EsV0FBSyxNQUFMO0FBQ0EsV0FBSyxLQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxHQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxLQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxLQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0UsZUFBT2lpRyxhQUFhb0MsaUJBQXBCOztBQUVGLFdBQUssTUFBTDtBQUNFLGVBQU9wQyxhQUFhZ0MsT0FBYixJQUF3QmhDLGFBQWFvQyxpQkFBNUM7O0FBRUYsV0FBSyxJQUFMO0FBQ0UsZUFBT3BDLGFBQWFxQyxzQkFBcEI7O0FBRUYsV0FBSyxJQUFMO0FBQ0EsV0FBSyxJQUFMO0FBQ0UsZUFBT3JDLGFBQWFzQyxvQkFBcEI7O0FBRUYsV0FBSyxRQUFMO0FBQ0UsZUFBT3RDLGFBQWFrQyxnQkFBcEI7O0FBRUYsV0FBSyxHQUFMO0FBQ0U7QUFDQTtBQUNBLGVBQU9sQyxhQUFhaUMsV0FBcEI7O0FBRUYsV0FBSyxNQUFMO0FBQ0UsZUFBT2pDLGFBQWFtQyxjQUFwQjtBQXpESjs7QUE0REEsV0FBTyxJQUFQO0FBQ0QsR0E5REQ7O0FBZ0VBLE1BQU1RLFVBQVUsRUFBaEI7O0FBRUEsVUE4RTJCbEIsa0JBOUUzQix3QkFBcUIsNEJBQVNtQixRQUFULEVBQW1CQyxTQUFuQixFQUE4QjdDLFlBQTlCLEVBQTRDO0FBQy9EQSxtQkFBZUEsZ0JBQWdCK0IsaUJBQS9CO0FBQ0EsUUFBTWUsYUFBYTlDLGFBQWFyL0YsT0FBaEM7QUFDQSxRQUFNOGhHLFlBQVlLLGNBQWNBLFdBQVcva0csR0FBM0M7O0FBRUEsUUFBSThrRyxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCLHlDQUNFRCxZQUFZLElBRGQsRUFFRSx1RUFGRjtBQUlBQSxpQkFBVyxPQUFYO0FBQ0Q7O0FBRUQsUUFBTUcsZ0JBQWdCUCxxQkFBcUJJLFFBQXJCLEVBQStCSCxTQUEvQixJQUNsQixJQURrQixHQUVsQkssVUFGSjtBQUdBLFFBQU1FLGtCQUFrQkQsZ0JBQ3BCLElBRG9CLEdBRXBCTCwwQkFBMEJFLFFBQTFCLEVBQW9DNUMsWUFBcEMsQ0FGSjtBQUdBLFFBQU1pRCwwQkFBMEJGLGlCQUFpQkMsZUFBakQ7QUFDQSxRQUFJLENBQUNDLHVCQUFMLEVBQThCO0FBQzVCO0FBQ0Q7O0FBRUQsUUFBTUMsY0FBY0Qsd0JBQXdCbGxHLEdBQTVDO0FBQ0EsUUFBTXNvRCxXQUFXLG1EQUFqQjs7QUFFQSxRQUFNODhDLFVBQ0osQ0FBQyxDQUFDSixhQUFGLEdBQWtCLEdBQWxCLEdBQXdCSCxRQUF4QixHQUFtQyxHQUFuQyxHQUF5Q00sV0FBekMsR0FBdUQsR0FBdkQsR0FBNkQ3OEMsUUFEL0Q7QUFFQSxRQUFJczhDLFFBQVFRLE9BQVIsQ0FBSixFQUFzQjtBQUNwQjtBQUNEO0FBQ0RSLFlBQVFRLE9BQVIsSUFBbUIsSUFBbkI7O0FBRUEsUUFBSUMsaUJBQWlCUixRQUFyQjtBQUNBLFFBQUlTLGlCQUFpQixFQUFyQjtBQUNBLFFBQUlULGFBQWEsT0FBakIsRUFBMEI7QUFDeEIsVUFBSSxLQUFLeGxGLElBQUwsQ0FBVXlsRixTQUFWLENBQUosRUFBMEI7QUFDeEJPLHlCQUFpQixZQUFqQjtBQUNELE9BRkQsTUFFTztBQUNMQSx5QkFBaUIsdUJBQWpCO0FBQ0FDLHlCQUNFLG9FQUNBLGdDQUZGO0FBR0Q7QUFDRixLQVRELE1BU087QUFDTEQsdUJBQWlCLE1BQU1SLFFBQU4sR0FBaUIsR0FBbEM7QUFDRDs7QUFFRCxRQUFJRyxhQUFKLEVBQW1CO0FBQ2pCLFVBQUl2aUcsT0FBTyxFQUFYO0FBQ0EsVUFBSTBpRyxnQkFBZ0IsT0FBaEIsSUFBMkJOLGFBQWEsSUFBNUMsRUFBa0Q7QUFDaERwaUcsZ0JBQ0Usb0VBQ0EsY0FGRjtBQUdEO0FBQ0QseUNBQ0UsS0FERixFQUVFLHFFQUZGLEVBR0U0aUcsY0FIRixFQUlFRixXQUpGLEVBS0VHLGNBTEYsRUFNRTdpRyxJQU5GLEVBT0U2bEQsUUFQRjtBQVNELEtBaEJELE1BZ0JPO0FBQ0wseUNBQ0UsS0FERixFQUVFLGtFQUNFLFNBSEosRUFJRSs4QyxjQUpGLEVBS0VGLFdBTEYsRUFNRTc4QyxRQU5GO0FBUUQ7QUFDRixHQTNFRDtBQTRFRDs7UUFFT3E3QyxtQixHQUFBQSxtQjtRQUFxQkQsa0IsR0FBQUEsa0IiLCJmaWxlIjoiaW5kZXhfYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0ZnVuY3Rpb24gaG90RGlzcG9zZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdH1cbiBcdHZhciBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayA9IHdpbmRvd1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdID0gXHJcbiBcdGZ1bmN0aW9uIHdlYnBhY2tIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHRcdGlmKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XHJcbiBcdH0gO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuIFx0XHRzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSBcInV0Zi04XCI7XHJcbiBcdFx0c2NyaXB0LnNyYyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNcIjtcclxuIFx0XHQ7XHJcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZE1hbmlmZXN0KHJlcXVlc3RUaW1lb3V0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xyXG4gXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdGlmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc29uXCI7XHJcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XHJcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnNlbmQobnVsbCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRyZXR1cm4gcmVqZWN0KGVycik7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRpZihyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5zdGF0dXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG4gXHRcdFx0XHRcdC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcclxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XHJcbiBcdFx0XHRcdH0gZWxzZSBpZihyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwICYmIHJlcXVlc3Quc3RhdHVzICE9PSAzMDQpIHtcclxuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZSkge1xyXG4gXHRcdFx0XHRcdFx0cmVqZWN0KGUpO1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRyZXNvbHZlKHVwZGF0ZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuXG4gXHRcclxuIFx0XHJcbiBcdHZhciBob3RBcHBseU9uVXBkYXRlID0gdHJ1ZTtcclxuIFx0dmFyIGhvdEN1cnJlbnRIYXNoID0gXCIxZWQyMGVlOGU4YmJjZjBjMzA0YlwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xyXG4gXHR2YXIgaG90Q3VycmVudE1vZHVsZURhdGEgPSB7fTtcclxuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHNUZW1wID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdGlmKCFtZSkgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX187XHJcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xyXG4gXHRcdFx0aWYobWUuaG90LmFjdGl2ZSkge1xyXG4gXHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XHJcbiBcdFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpIDwgMClcclxuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpIDwgMClcclxuIFx0XHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xyXG4gXHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVxdWVzdCArIFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArIG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xyXG4gXHRcdH07XHJcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcclxuIFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fTtcclxuIFx0XHR9O1xyXG4gXHRcdGZvcih2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX193ZWJwYWNrX3JlcXVpcmVfXywgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcclxuIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBuYW1lLCBPYmplY3RGYWN0b3J5KG5hbWUpKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0Zm4uZSA9IGZ1bmN0aW9uKGNodW5rSWQpIHtcclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKVxyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XHJcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG4gXHRcdFx0XHR0aHJvdyBlcnI7XHJcbiBcdFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0XHRmdW5jdGlvbiBmaW5pc2hDaHVua0xvYWRpbmcoKSB7XHJcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcclxuIFx0XHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIikge1xyXG4gXHRcdFx0XHRcdGlmKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH07XHJcbiBcdFx0cmV0dXJuIGZuO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBob3QgPSB7XHJcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXHJcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxyXG4gXHRcdFx0X2RlY2xpbmVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXHJcbiBcdFx0XHRfZGlzcG9zZUhhbmRsZXJzOiBbXSxcclxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxyXG4gXHRcclxuIFx0XHRcdC8vIE1vZHVsZSBBUElcclxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcclxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0ZGVjbGluZTogZnVuY3Rpb24oZGVwKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXHJcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXHJcbiBcdFx0XHRhcHBseTogaG90QXBwbHksXHJcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aWYoIWwpIHJldHVybiBob3RTdGF0dXM7XHJcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0YWRkU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSBob3RTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdH0sXHJcbiBcdFxyXG4gXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXHJcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cclxuIFx0XHR9O1xyXG4gXHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcclxuIFx0XHRyZXR1cm4gaG90O1xyXG4gXHR9XHJcbiBcdFxyXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xyXG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xyXG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90RGVmZXJyZWQ7XHJcbiBcdFxyXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cclxuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcclxuIFx0XHR2YXIgaXNOdW1iZXIgPSAoK2lkKSArIFwiXCIgPT09IGlkO1xyXG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xyXG4gXHRcdGlmKGhvdFN0YXR1cyAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xyXG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcclxuIFx0XHRyZXR1cm4gaG90RG93bmxvYWRNYW5pZmVzdChob3RSZXF1ZXN0VGltZW91dCkudGhlbihmdW5jdGlvbih1cGRhdGUpIHtcclxuIFx0XHRcdGlmKCF1cGRhdGUpIHtcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RBdmFpbGFibGVGaWxlc01hcCA9IHVwZGF0ZS5jO1xyXG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xyXG4gXHRcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XHJcbiBcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcclxuIFx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxyXG4gXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xyXG4gXHRcdFx0dmFyIGNodW5rSWQgPSAwO1xyXG4gXHRcdFx0eyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmUtYmxvY2tzXHJcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXHJcbiBcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gcHJvbWlzZTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSB8fCAhaG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0pXHJcbiBcdFx0XHRyZXR1cm47XHJcbiBcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSBmYWxzZTtcclxuIFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHRpZigtLWhvdFdhaXRpbmdGaWxlcyA9PT0gMCAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwKSB7XHJcbiBcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XHJcbiBcdFx0aWYoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcclxuIFx0XHRcdGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RVcGRhdGVEb3dubG9hZGVkKCkge1xyXG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xyXG4gXHRcdHZhciBkZWZlcnJlZCA9IGhvdERlZmVycmVkO1xyXG4gXHRcdGhvdERlZmVycmVkID0gbnVsbDtcclxuIFx0XHRpZighZGVmZXJyZWQpIHJldHVybjtcclxuIFx0XHRpZihob3RBcHBseU9uVXBkYXRlKSB7XHJcbiBcdFx0XHQvLyBXcmFwIGRlZmVycmVkIG9iamVjdCBpbiBQcm9taXNlIHRvIG1hcmsgaXQgYXMgYSB3ZWxsLWhhbmRsZWQgUHJvbWlzZSB0b1xyXG4gXHRcdFx0Ly8gYXZvaWQgdHJpZ2dlcmluZyB1bmNhdWdodCBleGNlcHRpb24gd2FybmluZyBpbiBDaHJvbWUuXHJcbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XHJcbiBcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XHJcbiBcdFx0XHR9KS50aGVuKFxyXG4gXHRcdFx0XHRmdW5jdGlvbihyZXN1bHQpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdChlcnIpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHQpO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFwcGx5KG9wdGlvbnMpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xyXG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgY2I7XHJcbiBcdFx0dmFyIGk7XHJcbiBcdFx0dmFyIGo7XHJcbiBcdFx0dmFyIG1vZHVsZTtcclxuIFx0XHR2YXIgbW9kdWxlSWQ7XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGdldEFmZmVjdGVkU3R1ZmYodXBkYXRlTW9kdWxlSWQpIHtcclxuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFxyXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKGlkKSB7XHJcbiBcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXHJcbiBcdFx0XHRcdFx0aWQ6IGlkXHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XHJcbiBcdFx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKG1vZHVsZS5ob3QuX21haW4pIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRpZighcGFyZW50KSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHtcclxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcclxuIFx0XHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxyXG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcclxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXHJcbiBcdFx0XHR9O1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xyXG4gXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xyXG4gXHRcdFx0XHRpZihhLmluZGV4T2YoaXRlbSkgPCAwKVxyXG4gXHRcdFx0XHRcdGEucHVzaChpdGVtKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXHJcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxyXG4gXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKCkge1xyXG4gXHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiKTtcclxuIFx0XHR9O1xyXG4gXHRcclxuIFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XHJcbiBcdFx0XHRcdHZhciByZXN1bHQ7XHJcbiBcdFx0XHRcdGlmKGhvdFVwZGF0ZVtpZF0pIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XHJcbiBcdFx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogaWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcclxuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XHJcbiBcdFx0XHRcdGlmKHJlc3VsdC5jaGFpbikge1xyXG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRzd2l0Y2gocmVzdWx0LnR5cGUpIHtcclxuIFx0XHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIiBpbiBcIiArIHJlc3VsdC5wYXJlbnRJZCArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vblVuYWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25BY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRpc3Bvc2VkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRkZWZhdWx0OlxyXG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihhYm9ydEVycm9yKSB7XHJcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvQXBwbHkpIHtcclxuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHRcdFx0XHRmb3IobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcclxuIFx0XHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLCByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoZG9EaXNwb3NlKSB7XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cclxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0Zm9yKGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcclxuIFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdICYmIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XHJcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXHJcbiBcdFx0XHRcdH0pO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcclxuIFx0XHRPYmplY3Qua2V5cyhob3RBdmFpbGFibGVGaWxlc01hcCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSA9PT0gZmFsc2UpIHtcclxuIFx0XHRcdFx0aG90RGlzcG9zZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH0pO1xyXG4gXHRcclxuIFx0XHR2YXIgaWR4O1xyXG4gXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xyXG4gXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdG1vZHVsZUlkID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdGlmKCFtb2R1bGUpIGNvbnRpbnVlO1xyXG4gXHRcclxuIFx0XHRcdHZhciBkYXRhID0ge307XHJcbiBcdFxyXG4gXHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXHJcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG4gXHRcdFx0XHRjYihkYXRhKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcclxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHJcbiBcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdHZhciBjaGlsZCA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcclxuIFx0XHRcdFx0aWYoIWNoaWxkKSBjb250aW51ZTtcclxuIFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcclxuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG4gXHRcdHZhciBkZXBlbmRlbmN5O1xyXG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUpIHtcclxuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHRmb3IoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG4gXHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XHJcbiBcdFx0XHRcdFx0XHRpZihpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm90IGluIFwiYXBwbHlcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImFwcGx5XCIpO1xyXG4gXHRcclxuIFx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XHJcbiBcdFx0XHRcdFx0XHRjYiA9IG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xyXG4gXHRcdFx0XHRcdFx0aWYoY2IpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoY2FsbGJhY2tzLmluZGV4T2YoY2IpID49IDApIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYik7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBjYWxsYmFja3NbaV07XHJcbiBcdFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XHJcbiBcdFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV0sXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xyXG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gXHRcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZXJyMikge1xyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG9yZ2luYWxFcnJvcjogZXJyLCAvLyBUT0RPIHJlbW92ZSBpbiB3ZWJwYWNrIDRcclxuIFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcclxuIFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjI7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXHJcbiBcdFx0aWYoZXJyb3IpIHtcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcImZhaWxcIik7XHJcbiBcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xyXG4gXHRcdFx0cmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aG90OiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpLFxuIFx0XHRcdHBhcmVudHM6IChob3RDdXJyZW50UGFyZW50c1RlbXAgPSBob3RDdXJyZW50UGFyZW50cywgaG90Q3VycmVudFBhcmVudHMgPSBbXSwgaG90Q3VycmVudFBhcmVudHNUZW1wKSxcbiBcdFx0XHRjaGlsZHJlbjogW11cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkpO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBob3RDcmVhdGVSZXF1aXJlKDg5KShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA4OSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMWVkMjBlZThlOGJiY2YwYzMwNGIiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG5sZXQgdmFsaWRhdGVGb3JtYXQgPSAoKSA9PiB7fTtcblxuaWYgKF9fREVWX18pIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgbGV0IGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIGxldCBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL2ludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxubGV0IHdhcm5pbmdXaXRob3V0U3RhY2sgPSAoKSA9PiB7fTtcblxuaWYgKF9fREVWX18pIHtcbiAgd2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZ1dpdGhvdXRTdGFjayhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCcsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPiA4KSB7XG4gICAgICAvLyBDaGVjayBiZWZvcmUgdGhlIGNvbmRpdGlvbiB0byBjYXRjaCB2aW9sYXRpb25zIGVhcmx5LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnd2FybmluZ1dpdGhvdXRTdGFjaygpIGN1cnJlbnRseSBzdXBwb3J0cyBhdCBtb3N0IDggYXJndW1lbnRzLicsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoaXRlbSA9PiAnJyArIGl0ZW0pO1xuICAgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7XG5cbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmVycm9yLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgbGV0IGFyZ0luZGV4ID0gMDtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCAoKSA9PiBhcmdzW2FyZ0luZGV4KytdKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3YXJuaW5nV2l0aG91dFN0YWNrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2suanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5pbXBvcnQgUmVhY3RTaGFyZWRJbnRlcm5hbHMgZnJvbSAnc2hhcmVkL1JlYWN0U2hhcmVkSW50ZXJuYWxzJztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxubGV0IHdhcm5pbmcgPSB3YXJuaW5nV2l0aG91dFN0YWNrO1xuXG5pZiAoX19ERVZfXykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGNvbnN0IHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3dhcm5pbmctYW5kLWludmFyaWFudC1hcmdzXG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhmYWxzZSwgZm9ybWF0ICsgJyVzJywgLi4uYXJncywgc3RhY2spO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3YXJuaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL3dhcm5pbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93IHN0cmljdFxuICovXG5cbmV4cG9ydCBjb25zdCBlbmFibGVVc2VyVGltaW5nQVBJID0gX19ERVZfXztcblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG5leHBvcnQgY29uc3QgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuZXhwb3J0IGNvbnN0IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgPSBfX0RFVl9fO1xuXG4vLyBUbyBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBkZWJ1Z2dlciwgd2Vcbi8vIHJlcGxheSB0aGUgYmVnaW4gcGhhc2Ugb2YgYSBmYWlsZWQgY29tcG9uZW50IGluc2lkZSBpbnZva2VHdWFyZGVkQ2FsbGJhY2suXG5leHBvcnQgY29uc3QgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBfX0RFVl9fO1xuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcbmV4cG9ydCBjb25zdCB3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IGZhbHNlO1xuXG4vLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuZXhwb3J0IGNvbnN0IGVuYWJsZVByb2ZpbGVyVGltZXIgPSBfX1BST0ZJTEVfXztcblxuLy8gVHJhY2Ugd2hpY2ggaW50ZXJhY3Rpb25zIHRyaWdnZXIgZWFjaCBjb21taXQuXG5leHBvcnQgY29uc3QgZW5hYmxlU2NoZWR1bGVyVHJhY2luZyA9IF9fUFJPRklMRV9fO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cbmV4cG9ydCBjb25zdCBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyID0gZmFsc2U7IC8vIFRPRE86IF9fREVWX18/IEhlcmUgaXQgbWlnaHQganVzdCBiZSBmYWxzZS5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5leHBvcnQgY29uc3QgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuZXhwb3J0IGZ1bmN0aW9uIGFkZFVzZXJUaW1pbmdMaXN0ZW5lcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG59XG5cbi8vIFJlYWN0IEZpcmU6IHByZXZlbnQgdGhlIHZhbHVlIGFuZCBjaGVja2VkIGF0dHJpYnV0ZXMgZnJvbSBzeW5jaW5nXG4vLyB3aXRoIHRoZWlyIHJlbGF0ZWQgRE9NIHByb3BlcnRpZXNcbmV4cG9ydCBjb25zdCBkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nID0gZmFsc2U7XG5cbi8vIFRoZXNlIEFQSXMgd2lsbCBubyBsb25nZXIgYmUgXCJ1bnN0YWJsZVwiIGluIHRoZSB1cGNvbWluZyAxNi43IHJlbGVhc2UsXG4vLyBDb250cm9sIHRoaXMgYmVoYXZpb3Igd2l0aCBhIGZsYWcgdG8gc3VwcG9ydCAxNi42IG1pbm9yIHJlbGVhc2VzIGluIHRoZSBtZWFud2hpbGUuXG5leHBvcnQgY29uc3QgZW5hYmxlU3RhYmxlQ29uY3VycmVudE1vZGVBUElzID0gZmFsc2U7XG5cbmV4cG9ydCBjb25zdCB3YXJuQWJvdXRTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbiA9IGZhbHNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCB0eXBlIFdvcmtUYWcgPVxuICB8IDBcbiAgfCAxXG4gIHwgMlxuICB8IDNcbiAgfCA0XG4gIHwgNVxuICB8IDZcbiAgfCA3XG4gIHwgOFxuICB8IDlcbiAgfCAxMFxuICB8IDExXG4gIHwgMTJcbiAgfCAxM1xuICB8IDE0XG4gIHwgMTVcbiAgfCAxNlxuICB8IDE3XG4gIHwgMTg7XG5cbmV4cG9ydCBjb25zdCBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG5leHBvcnQgY29uc3QgQ2xhc3NDb21wb25lbnQgPSAxO1xuZXhwb3J0IGNvbnN0IEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5leHBvcnQgY29uc3QgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbmV4cG9ydCBjb25zdCBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbmV4cG9ydCBjb25zdCBIb3N0Q29tcG9uZW50ID0gNTtcbmV4cG9ydCBjb25zdCBIb3N0VGV4dCA9IDY7XG5leHBvcnQgY29uc3QgRnJhZ21lbnQgPSA3O1xuZXhwb3J0IGNvbnN0IE1vZGUgPSA4O1xuZXhwb3J0IGNvbnN0IENvbnRleHRDb25zdW1lciA9IDk7XG5leHBvcnQgY29uc3QgQ29udGV4dFByb3ZpZGVyID0gMTA7XG5leHBvcnQgY29uc3QgRm9yd2FyZFJlZiA9IDExO1xuZXhwb3J0IGNvbnN0IFByb2ZpbGVyID0gMTI7XG5leHBvcnQgY29uc3QgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbmV4cG9ydCBjb25zdCBNZW1vQ29tcG9uZW50ID0gMTQ7XG5leHBvcnQgY29uc3QgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xuZXhwb3J0IGNvbnN0IExhenlDb21wb25lbnQgPSAxNjtcbmV4cG9ydCBjb25zdCBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbmV4cG9ydCBjb25zdCBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQgPSAxODtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9SZWFjdFdvcmtUYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtMYXp5Q29tcG9uZW50fSBmcm9tICdzaGFyZWQvUmVhY3RMYXp5Q29tcG9uZW50JztcblxuaW1wb3J0IHdhcm5pbmdXaXRob3V0U3RhY2sgZnJvbSAnc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2snO1xuaW1wb3J0IHtcbiAgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUsXG4gIFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSxcbiAgUkVBQ1RfUE9SVEFMX1RZUEUsXG4gIFJFQUNUX01FTU9fVFlQRSxcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSxcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSxcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSxcbiAgUkVBQ1RfTEFaWV9UWVBFLFxufSBmcm9tICdzaGFyZWQvUmVhY3RTeW1ib2xzJztcbmltcG9ydCB7cmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50fSBmcm9tICdzaGFyZWQvUmVhY3RMYXp5Q29tcG9uZW50JztcblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUoXG4gIG91dGVyVHlwZTogbWl4ZWQsXG4gIGlubmVyVHlwZTogYW55LFxuICB3cmFwcGVyTmFtZTogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gKFxuICAgIChvdXRlclR5cGU6IGFueSkuZGlzcGxheU5hbWUgfHxcbiAgICAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IGAke3dyYXBwZXJOYW1lfSgke2Z1bmN0aW9uTmFtZX0pYCA6IHdyYXBwZXJOYW1lKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGU6IG1peGVkKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoX19ERVZfXykge1xuICAgIGlmICh0eXBlb2YgKHR5cGU6IGFueSkudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgK1xuICAgICAgICAgICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdDb25jdXJyZW50TW9kZSc7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gYFByb2ZpbGVyYDtcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuQ29uc3VtZXInO1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuUHJvdmlkZXInO1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOiB7XG4gICAgICAgIGNvbnN0IHRoZW5hYmxlOiBMYXp5Q29tcG9uZW50PG1peGVkPiA9ICh0eXBlOiBhbnkpO1xuICAgICAgICBjb25zdCByZXNvbHZlZFRoZW5hYmxlID0gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KHRoZW5hYmxlKTtcbiAgICAgICAgaWYgKHJlc29sdmVkVGhlbmFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShyZXNvbHZlZFRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0Q29tcG9uZW50TmFtZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9nZXRDb21wb25lbnROYW1lLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5jb25zdCBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2xcbiAgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JylcbiAgOiAweGVhYzc7XG5leHBvcnQgY29uc3QgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2xcbiAgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKVxuICA6IDB4ZWFjYTtcbmV4cG9ydCBjb25zdCBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKVxuICA6IDB4ZWFjYjtcbmV4cG9ydCBjb25zdCBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKVxuICA6IDB4ZWFjYztcbmV4cG9ydCBjb25zdCBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKVxuICA6IDB4ZWFkMjtcbmV4cG9ydCBjb25zdCBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKVxuICA6IDB4ZWFjZDtcbmV4cG9ydCBjb25zdCBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2xcbiAgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JylcbiAgOiAweGVhY2U7XG5leHBvcnQgY29uc3QgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpXG4gIDogMHhlYWNmO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJylcbiAgOiAweGVhY2Y7XG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbFxuICA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJylcbiAgOiAweGVhZDA7XG5leHBvcnQgY29uc3QgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbFxuICA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJylcbiAgOiAweGVhZDE7XG5leHBvcnQgY29uc3QgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcblxuY29uc3QgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5jb25zdCBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZTogP2FueSk6ID8oKSA9PiA/SXRlcmF0b3I8Kj4ge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXliZUl0ZXJhdG9yID1cbiAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9zaGFyZWQvUmVhY3RTeW1ib2xzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcblxuaW1wb3J0IFJlYWN0U2hhcmVkSW50ZXJuYWxzIGZyb20gJ3NoYXJlZC9SZWFjdFNoYXJlZEludGVybmFscyc7XG5pbXBvcnQge1xuICBIb3N0Um9vdCxcbiAgSG9zdFBvcnRhbCxcbiAgSG9zdFRleHQsXG4gIEZyYWdtZW50LFxuICBDb250ZXh0UHJvdmlkZXIsXG4gIENvbnRleHRDb25zdW1lcixcbn0gZnJvbSAnc2hhcmVkL1JlYWN0V29ya1RhZ3MnO1xuaW1wb3J0IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgZnJvbSAnc2hhcmVkL2Rlc2NyaWJlQ29tcG9uZW50RnJhbWUnO1xuaW1wb3J0IGdldENvbXBvbmVudE5hbWUgZnJvbSAnc2hhcmVkL2dldENvbXBvbmVudE5hbWUnO1xuXG5cbmNvbnN0IFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG50eXBlIExpZmVDeWNsZVBoYXNlID0gJ3JlbmRlcicgfCAnZ2V0Q2hpbGRDb250ZXh0JztcblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcjogRmliZXIpOiBzdHJpbmcge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiAnJztcbiAgICBkZWZhdWx0OlxuICAgICAgY29uc3Qgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpO1xuICAgICAgbGV0IG93bmVyTmFtZSA9IG51bGw7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgb3duZXJOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzOiBGaWJlcik6IHN0cmluZyB7XG4gIGxldCBpbmZvID0gJyc7XG4gIGxldCBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG4gIGRvIHtcbiAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGluZm87XG59XG5cbmV4cG9ydCBsZXQgY3VycmVudDogRmliZXIgfCBudWxsID0gbnVsbDtcbmV4cG9ydCBsZXQgcGhhc2U6IExpZmVDeWNsZVBoYXNlIHwgbnVsbCA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG93bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpOiBzdHJpbmcge1xuICBpZiAoX19ERVZfXykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgY3VycmVudCA9IG51bGw7XG4gICAgcGhhc2UgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXI6IEZpYmVyKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgIGN1cnJlbnQgPSBmaWJlcjtcbiAgICBwaGFzZSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShsaWZlQ3ljbGVQaGFzZTogTGlmZUN5Y2xlUGhhc2UgfCBudWxsKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgcGhhc2UgPSBsaWZlQ3ljbGVQaGFzZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RDdXJyZW50RmliZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZXhwb3J0IHR5cGUgU2lkZUVmZmVjdFRhZyA9IG51bWJlcjtcblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG5leHBvcnQgY29uc3QgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8gMGIwMDAwMDAwMDAwMDA7XG5leHBvcnQgY29uc3QgUGVyZm9ybWVkV29yayA9IC8qICAgICAgICAgKi8gMGIwMDAwMDAwMDAwMDE7XG5cbi8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxuZXhwb3J0IGNvbnN0IFBsYWNlbWVudCA9IC8qICAgICAgICAgICAgICovIDBiMDAwMDAwMDAwMDEwO1xuZXhwb3J0IGNvbnN0IFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovIDBiMDAwMDAwMDAwMTAwO1xuZXhwb3J0IGNvbnN0IFBsYWNlbWVudEFuZFVwZGF0ZSA9IC8qICAgICovIDBiMDAwMDAwMDAwMTEwO1xuZXhwb3J0IGNvbnN0IERlbGV0aW9uID0gLyogICAgICAgICAgICAgICovIDBiMDAwMDAwMDAxMDAwO1xuZXhwb3J0IGNvbnN0IENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovIDBiMDAwMDAwMDEwMDAwO1xuZXhwb3J0IGNvbnN0IENhbGxiYWNrID0gLyogICAgICAgICAgICAgICovIDBiMDAwMDAwMTAwMDAwO1xuZXhwb3J0IGNvbnN0IERpZENhcHR1cmUgPSAvKiAgICAgICAgICAgICovIDBiMDAwMDAxMDAwMDAwO1xuZXhwb3J0IGNvbnN0IFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovIDBiMDAwMDEwMDAwMDAwO1xuZXhwb3J0IGNvbnN0IFNuYXBzaG90ID0gLyogICAgICAgICAgICAgICovIDBiMDAwMTAwMDAwMDAwO1xuZXhwb3J0IGNvbnN0IFBhc3NpdmUgPSAvKiAgICAgICAgICAgICAgICovIDBiMDAxMDAwMDAwMDAwO1xuXG4vLyBQYXNzaXZlICYgVXBkYXRlICYgQ2FsbGJhY2sgJiBSZWYgJiBTbmFwc2hvdFxuZXhwb3J0IGNvbnN0IExpZmVjeWNsZUVmZmVjdE1hc2sgPSAvKiAgICovIDBiMDAxMTEwMTAwMTAwO1xuXG4vLyBVbmlvbiBvZiBhbGwgaG9zdCBlZmZlY3RzXG5leHBvcnQgY29uc3QgSG9zdEVmZmVjdE1hc2sgPSAvKiAgICAgICAgKi8gMGIwMDExMTExMTExMTE7XG5cbmV4cG9ydCBjb25zdCBJbmNvbXBsZXRlID0gLyogICAgICAgICAgICAqLyAwYjAxMDAwMDAwMDAwMDtcbmV4cG9ydCBjb25zdCBTaG91bGRDYXB0dXJlID0gLyogICAgICAgICAqLyAwYjEwMDAwMDAwMDAwMDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9SZWFjdFNpZGVFZmZlY3RUYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgZnJvbSAnLi9tYXhTaWduZWQzMUJpdEludCc7XG5cbmV4cG9ydCB0eXBlIEV4cGlyYXRpb25UaW1lID0gbnVtYmVyO1xuXG5leHBvcnQgY29uc3QgTm9Xb3JrID0gMDtcbmV4cG9ydCBjb25zdCBOZXZlciA9IDE7XG5leHBvcnQgY29uc3QgU3luYyA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuY29uc3QgVU5JVF9TSVpFID0gMTA7XG5jb25zdCBNQUdJQ19OVU1CRVJfT0ZGU0VUID0gTUFYX1NJR05FRF8zMV9CSVRfSU5UIC0gMTtcblxuLy8gMSB1bml0IG9mIGV4cGlyYXRpb24gdGltZSByZXByZXNlbnRzIDEwbXMuXG5leHBvcnQgZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zOiBudW1iZXIpOiBFeHBpcmF0aW9uVGltZSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiBNQUdJQ19OVU1CRVJfT0ZGU0VUIC0gKChtcyAvIFVOSVRfU0laRSkgfCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUpOiBudW1iZXIge1xuICByZXR1cm4gKE1BR0lDX05VTUJFUl9PRkZTRVQgLSBleHBpcmF0aW9uVGltZSkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtOiBudW1iZXIsIHByZWNpc2lvbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuICgoKG51bSAvIHByZWNpc2lvbikgfCAwKSArIDEpICogcHJlY2lzaW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChcbiAgY3VycmVudFRpbWUsXG4gIGV4cGlyYXRpb25Jbk1zLFxuICBidWNrZXRTaXplTXMsXG4pOiBFeHBpcmF0aW9uVGltZSB7XG4gIHJldHVybiAoXG4gICAgTUFHSUNfTlVNQkVSX09GRlNFVCAtXG4gICAgY2VpbGluZyhcbiAgICAgIE1BR0lDX05VTUJFUl9PRkZTRVQgLSBjdXJyZW50VGltZSArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLFxuICAgICAgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFLFxuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IExPV19QUklPUklUWV9FWFBJUkFUSU9OID0gNTAwMDtcbmV4cG9ydCBjb25zdCBMT1dfUFJJT1JJVFlfQkFUQ0hfU0laRSA9IDI1MDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oXG4gIGN1cnJlbnRUaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IEV4cGlyYXRpb25UaW1lIHtcbiAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KFxuICAgIGN1cnJlbnRUaW1lLFxuICAgIExPV19QUklPUklUWV9FWFBJUkFUSU9OLFxuICAgIExPV19QUklPUklUWV9CQVRDSF9TSVpFLFxuICApO1xufVxuXG4vLyBXZSBpbnRlbnRpb25hbGx5IHNldCBhIGhpZ2hlciBleHBpcmF0aW9uIHRpbWUgZm9yIGludGVyYWN0aXZlIHVwZGF0ZXMgaW5cbi8vIGRldiB0aGFuIGluIHByb2R1Y3Rpb24uXG4vL1xuLy8gSWYgdGhlIG1haW4gdGhyZWFkIGlzIGJlaW5nIGJsb2NrZWQgc28gbG9uZyB0aGF0IHlvdSBoaXQgdGhlIGV4cGlyYXRpb24sXG4vLyBpdCdzIGEgcHJvYmxlbSB0aGF0IGNvdWxkIGJlIHNvbHZlZCB3aXRoIGJldHRlciBzY2hlZHVsaW5nLlxuLy9cbi8vIFBlb3BsZSB3aWxsIGJlIG1vcmUgbGlrZWx5IHRvIG5vdGljZSB0aGlzIGFuZCBmaXggaXQgd2l0aCB0aGUgbG9uZ1xuLy8gZXhwaXJhdGlvbiB0aW1lIGluIGRldmVsb3BtZW50LlxuLy9cbi8vIEluIHByb2R1Y3Rpb24gd2Ugb3B0IGZvciBiZXR0ZXIgVVggYXQgdGhlIHJpc2sgb2YgbWFza2luZyBzY2hlZHVsaW5nXG4vLyBwcm9ibGVtcywgYnkgZXhwaXJpbmcgZmFzdC5cbmV4cG9ydCBjb25zdCBISUdIX1BSSU9SSVRZX0VYUElSQVRJT04gPSBfX0RFVl9fID8gNTAwIDogMTUwO1xuZXhwb3J0IGNvbnN0IEhJR0hfUFJJT1JJVFlfQkFUQ0hfU0laRSA9IDEwMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcmFjdGl2ZUV4cGlyYXRpb24oY3VycmVudFRpbWU6IEV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChcbiAgICBjdXJyZW50VGltZSxcbiAgICBISUdIX1BSSU9SSVRZX0VYUElSQVRJT04sXG4gICAgSElHSF9QUklPUklUWV9CQVRDSF9TSVpFLFxuICApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckV4cGlyYXRpb25UaW1lLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHNzcyBmcm9tICcuLi9yZWFjdC9zcmMvUmVhY3RTaGFyZWRJbnRlcm5hbHMnXG5cbmNvbnN0IFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbi8vIFByZXZlbnQgbmV3ZXIgcmVuZGVyZXJzIGZyb20gUlRFIHdoZW4gdXNlZCB3aXRoIG9sZGVyIHJlYWN0IHBhY2thZ2UgdmVyc2lvbnMuXG4vLyBDdXJyZW50IG93bmVyIGFuZCBkaXNwYXRjaGVyIHVzZWQgdG8gc2hhcmUgdGhlIHNhbWUgcmVmLFxuLy8gYnV0IFBSICMxNDU0OCBzcGxpdCB0aGVtIG91dCB0byBiZXR0ZXIgc3VwcG9ydCB0aGUgcmVhY3QtZGVidWctdG9vbHMgcGFja2FnZS5cbi8vIGlmICghUmVhY3RTaGFyZWRJbnRlcm5hbHMuaGFzT3duUHJvcGVydHkoJ1JlYWN0Q3VycmVudERpc3BhdGNoZXInKSkge1xuLy8gICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuLy8gICAgIGN1cnJlbnQ6IG51bGwsXG4vLyAgIH07XG4vLyB9XG5cbmV4cG9ydCBkZWZhdWx0IHNzcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9SZWFjdFNoYXJlZEludGVybmFscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuXG4vLyBXZSBleHBlY3QgdGhhdCBvdXIgUm9sbHVwLCBKZXN0LCBhbmQgRmxvdyBjb25maWd1cmF0aW9uc1xuLy8gYWx3YXlzIHNoaW0gdGhpcyBtb2R1bGUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBob3N0IGNvbmZpZ1xuLy8gKGVpdGhlciBwcm92aWRlZCBieSBhIHJlbmRlcmVyLCBvciBhIGdlbmVyaWMgc2hpbSBmb3IgbnBtKS5cbi8vXG4vLyBXZSBzaG91bGQgbmV2ZXIgcmVzb2x2ZSB0byB0aGlzIGZpbGUsIGJ1dCBpdCBleGlzdHMgdG8gbWFrZVxuLy8gc3VyZSB0aGF0IGlmIHdlICpkbyogYWNjaWRlbnRhbGx5IGJyZWFrIHRoZSBjb25maWd1cmF0aW9uLFxuLy8gdGhlIGZhaWx1cmUgaXNuJ3Qgc2lsZW50LlxuXG4vLyBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIG1vZHVsZSBtdXN0IGJlIHNoaW1tZWQgYnkgYSBzcGVjaWZpYyByZW5kZXJlci4nKTtcblxuZXhwb3J0ICogZnJvbSAnLi9mb3Jrcy9SZWFjdEZpYmVySG9zdENvbmZpZy5kb20nXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVySG9zdENvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmdXaXRob3V0U3RhY2sgZnJvbSAnc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2snO1xuXG5jb25zdCBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuY29uc3QgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsLFxufTtcblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoXG4gIGRpc3BhdGNoQ29uZmlnLFxuICB0YXJnZXRJbnN0LFxuICBuYXRpdmVFdmVudCxcbiAgbmF0aXZlRXZlbnRUYXJnZXQsXG4pIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gICAgZGVsZXRlIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkO1xuICAgIGRlbGV0ZSB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIGNvbnN0IEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQcmV2ZW50ZWQgPVxuICAgIG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbFxuICAgICAgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgICA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5PYmplY3QuYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHRoaXMuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgICB0aGlzLl9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgJ25hdGl2ZUV2ZW50JyxcbiAgICAgICAgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignbmF0aXZlRXZlbnQnLCBudWxsKSxcbiAgICAgICk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgICdpc0RlZmF1bHRQcmV2ZW50ZWQnLFxuICAgICAgICBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKFxuICAgICAgICAgICdpc0RlZmF1bHRQcmV2ZW50ZWQnLFxuICAgICAgICAgIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsXG4gICAgICAgIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oXG4gICAgICAgICAgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJyxcbiAgICAgICAgICBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICAncHJldmVudERlZmF1bHQnLFxuICAgICAgICBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsICgpID0+IHt9KSxcbiAgICAgICk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgICdzdG9wUHJvcGFnYXRpb24nLFxuICAgICAgICBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCAoKSA9PiB7fSksXG4gICAgICApO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqL1xuU3ludGhldGljRXZlbnQuZXh0ZW5kID0gZnVuY3Rpb24oSW50ZXJmYWNlKSB7XG4gIGNvbnN0IFN1cGVyID0gdGhpcztcblxuICBjb25zdCBFID0gZnVuY3Rpb24oKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIGNvbnN0IHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgZnVuY3Rpb24gQ2xhc3MoKSB7XG4gICAgcmV0dXJuIFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gT2JqZWN0LmFzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gIGFkZEV2ZW50UG9vbGluZ1RvKENsYXNzKTtcblxuICByZXR1cm4gQ2xhc3M7XG59O1xuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIGNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldCxcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgY29uc3QgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgY29uc3QgYWN0aW9uID0gaXNGdW5jdGlvblxuICAgICAgPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnXG4gICAgICA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICBjb25zdCByZXN1bHQgPSBpc0Z1bmN0aW9uXG4gICAgICA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nXG4gICAgICA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIGNvbnN0IHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgd2FybmluZ0NvbmRpdGlvbixcbiAgICAgIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICtcbiAgICAgICAgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArXG4gICAgICAgICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICtcbiAgICAgICAgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgIGFjdGlvbixcbiAgICAgIHByb3BOYW1lLFxuICAgICAgcmVzdWx0LFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9vbGVkRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KSB7XG4gIGNvbnN0IEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIGRpc3BhdGNoQ29uZmlnLFxuICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlSW5zdCxcbiAgICApO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gbmV3IEV2ZW50Q29uc3RydWN0b3IoXG4gICAgZGlzcGF0Y2hDb25maWcsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVJbnN0LFxuICApO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGludmFyaWFudChcbiAgICBldmVudCBpbnN0YW5jZW9mIEV2ZW50Q29uc3RydWN0b3IsXG4gICAgJ1RyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJyxcbiAgKTtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRoZXRpY0V2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvZXZlbnRzL1N5bnRoZXRpY0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5leHBvcnQgdHlwZSBUeXBlT2ZNb2RlID0gbnVtYmVyO1xuXG5leHBvcnQgY29uc3QgTm9Db250ZXh0ID0gMGIwMDA7XG5leHBvcnQgY29uc3QgQ29uY3VycmVudE1vZGUgPSAwYjAwMTtcbmV4cG9ydCBjb25zdCBTdHJpY3RNb2RlID0gMGIwMTA7XG5leHBvcnQgY29uc3QgUHJvZmlsZU1vZGUgPSAwYjEwMDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0VHlwZU9mTW9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7RE9NVG9wTGV2ZWxFdmVudFR5cGV9IGZyb20gJ2V2ZW50cy9Ub3BMZXZlbEV2ZW50VHlwZXMnO1xuXG5pbXBvcnQge1xuICB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUsXG4gIHVuc2FmZUNhc3RET01Ub3BMZXZlbFR5cGVUb1N0cmluZyxcbn0gZnJvbSAnZXZlbnRzL1RvcExldmVsRXZlbnRUeXBlcyc7XG5pbXBvcnQgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgZnJvbSAnLi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSc7XG5cbi8qKlxuICogVG8gaWRlbnRpZnkgdG9wIGxldmVsIGV2ZW50cyBpbiBSZWFjdERPTSwgd2UgdXNlIGNvbnN0YW50cyBkZWZpbmVkIGJ5IHRoaXNcbiAqIG1vZHVsZS4gVGhpcyBpcyB0aGUgb25seSBtb2R1bGUgdGhhdCB1c2VzIHRoZSB1bnNhZmUqIG1ldGhvZHMgdG8gZXhwcmVzc1xuICogdGhhdCB0aGUgY29uc3RhbnRzIGFjdHVhbGx5IGNvcnJlc3BvbmQgdG8gdGhlIGJyb3dzZXIgZXZlbnQgbmFtZXMuIFRoaXMgbGV0c1xuICogdXMgc2F2ZSBzb21lIGJ1bmRsZSBzaXplIGJ5IGF2b2lkaW5nIGEgdG9wIGxldmVsIHR5cGUgLT4gZXZlbnQgbmFtZSBtYXAuXG4gKiBUaGUgcmVzdCBvZiBSZWFjdERPTSBjb2RlIHNob3VsZCBpbXBvcnQgdG9wIGxldmVsIHR5cGVzIGZyb20gdGhpcyBmaWxlLlxuICovXG5leHBvcnQgY29uc3QgVE9QX0FCT1JUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdhYm9ydCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9BTklNQVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJyksXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9BTklNQVRJT05fSVRFUkFUSU9OID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyksXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9BTklNQVRJT05fU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoXG4gIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfQkxVUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnYmx1cicpO1xuZXhwb3J0IGNvbnN0IFRPUF9DQU5fUExBWSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2FucGxheScpO1xuZXhwb3J0IGNvbnN0IFRPUF9DQU5fUExBWV9USFJPVUdIID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICAnY2FucGxheXRocm91Z2gnLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfQ0FOQ0VMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjYW5jZWwnKTtcbmV4cG9ydCBjb25zdCBUT1BfQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjaGFuZ2UnKTtcbmV4cG9ydCBjb25zdCBUT1BfQ0xJQ0sgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NsaWNrJyk7XG5leHBvcnQgY29uc3QgVE9QX0NMT1NFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjbG9zZScpO1xuZXhwb3J0IGNvbnN0IFRPUF9DT01QT1NJVElPTl9FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoXG4gICdjb21wb3NpdGlvbmVuZCcsXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9DT01QT1NJVElPTl9TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ2NvbXBvc2l0aW9uc3RhcnQnLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfQ09NUE9TSVRJT05fVVBEQVRFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICAnY29tcG9zaXRpb251cGRhdGUnLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfQ09OVEVYVF9NRU5VID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICAnY29udGV4dG1lbnUnLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfQ09QWSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29weScpO1xuZXhwb3J0IGNvbnN0IFRPUF9DVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2N1dCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9ET1VCTEVfQ0xJQ0sgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RibGNsaWNrJyk7XG5leHBvcnQgY29uc3QgVE9QX0FVWF9DTElDSyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnYXV4Y2xpY2snKTtcbmV4cG9ydCBjb25zdCBUT1BfRFJBRyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZycpO1xuZXhwb3J0IGNvbnN0IFRPUF9EUkFHX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2VuZCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9EUkFHX0VOVEVSID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnZW50ZXInKTtcbmV4cG9ydCBjb25zdCBUT1BfRFJBR19FWElUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnZXhpdCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9EUkFHX0xFQVZFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnbGVhdmUnKTtcbmV4cG9ydCBjb25zdCBUT1BfRFJBR19PVkVSID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnb3ZlcicpO1xuZXhwb3J0IGNvbnN0IFRPUF9EUkFHX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnc3RhcnQnKTtcbmV4cG9ydCBjb25zdCBUT1BfRFJPUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJvcCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9EVVJBVElPTl9DSEFOR0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoXG4gICdkdXJhdGlvbmNoYW5nZScsXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9FTVBUSUVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbXB0aWVkJyk7XG5leHBvcnQgY29uc3QgVE9QX0VOQ1JZUFRFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW5jcnlwdGVkJyk7XG5leHBvcnQgY29uc3QgVE9QX0VOREVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbmRlZCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9FUlJPUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZXJyb3InKTtcbmV4cG9ydCBjb25zdCBUT1BfRk9DVVMgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2ZvY3VzJyk7XG5leHBvcnQgY29uc3QgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoXG4gICdnb3Rwb2ludGVyY2FwdHVyZScsXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9JTlBVVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnaW5wdXQnKTtcbmV4cG9ydCBjb25zdCBUT1BfSU5WQUxJRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnaW52YWxpZCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9LRVlfRE9XTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5ZG93bicpO1xuZXhwb3J0IGNvbnN0IFRPUF9LRVlfUFJFU1MgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2tleXByZXNzJyk7XG5leHBvcnQgY29uc3QgVE9QX0tFWV9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5dXAnKTtcbmV4cG9ydCBjb25zdCBUT1BfTE9BRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9hZCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9MT0FEX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2Fkc3RhcnQnKTtcbmV4cG9ydCBjb25zdCBUT1BfTE9BREVEX0RBVEEgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRlZGRhdGEnKTtcbmV4cG9ydCBjb25zdCBUT1BfTE9BREVEX01FVEFEQVRBID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICAnbG9hZGVkbWV0YWRhdGEnLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfTE9TVF9QT0lOVEVSX0NBUFRVUkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoXG4gICdsb3N0cG9pbnRlcmNhcHR1cmUnLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfTU9VU0VfRE9XTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2Vkb3duJyk7XG5leHBvcnQgY29uc3QgVE9QX01PVVNFX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlbW92ZScpO1xuZXhwb3J0IGNvbnN0IFRPUF9NT1VTRV9PVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3V0Jyk7XG5leHBvcnQgY29uc3QgVE9QX01PVVNFX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3ZlcicpO1xuZXhwb3J0IGNvbnN0IFRPUF9NT1VTRV9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2V1cCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9QQVNURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGFzdGUnKTtcbmV4cG9ydCBjb25zdCBUT1BfUEFVU0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BhdXNlJyk7XG5leHBvcnQgY29uc3QgVE9QX1BMQVkgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BsYXknKTtcbmV4cG9ydCBjb25zdCBUT1BfUExBWUlORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGxheWluZycpO1xuZXhwb3J0IGNvbnN0IFRPUF9QT0lOVEVSX0NBTkNFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ3BvaW50ZXJjYW5jZWwnLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfUE9JTlRFUl9ET1dOID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICAncG9pbnRlcmRvd24nLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfUE9JTlRFUl9FTlRFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ3BvaW50ZXJlbnRlcicsXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9QT0lOVEVSX0xFQVZFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICAncG9pbnRlcmxlYXZlJyxcbik7XG5leHBvcnQgY29uc3QgVE9QX1BPSU5URVJfTU9WRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ3BvaW50ZXJtb3ZlJyxcbik7XG5leHBvcnQgY29uc3QgVE9QX1BPSU5URVJfT1VUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVyb3V0Jyk7XG5leHBvcnQgY29uc3QgVE9QX1BPSU5URVJfT1ZFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ3BvaW50ZXJvdmVyJyxcbik7XG5leHBvcnQgY29uc3QgVE9QX1BPSU5URVJfVVAgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJ1cCcpO1xuZXhwb3J0IGNvbnN0IFRPUF9QUk9HUkVTUyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncHJvZ3Jlc3MnKTtcbmV4cG9ydCBjb25zdCBUT1BfUkFURV9DSEFOR0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3JhdGVjaGFuZ2UnKTtcbmV4cG9ydCBjb25zdCBUT1BfUkVTRVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3Jlc2V0Jyk7XG5leHBvcnQgY29uc3QgVE9QX1NDUk9MTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Nyb2xsJyk7XG5leHBvcnQgY29uc3QgVE9QX1NFRUtFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Vla2VkJyk7XG5leHBvcnQgY29uc3QgVE9QX1NFRUtJTkcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3NlZWtpbmcnKTtcbmV4cG9ydCBjb25zdCBUT1BfU0VMRUNUSU9OX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ3NlbGVjdGlvbmNoYW5nZScsXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9TVEFMTEVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzdGFsbGVkJyk7XG5leHBvcnQgY29uc3QgVE9QX1NVQk1JVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc3VibWl0Jyk7XG5leHBvcnQgY29uc3QgVE9QX1NVU1BFTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3N1c3BlbmQnKTtcbmV4cG9ydCBjb25zdCBUT1BfVEVYVF9JTlBVVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndGV4dElucHV0Jyk7XG5leHBvcnQgY29uc3QgVE9QX1RJTUVfVVBEQVRFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0aW1ldXBkYXRlJyk7XG5leHBvcnQgY29uc3QgVE9QX1RPR0dMRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG9nZ2xlJyk7XG5leHBvcnQgY29uc3QgVE9QX1RPVUNIX0NBTkNFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ3RvdWNoY2FuY2VsJyxcbik7XG5leHBvcnQgY29uc3QgVE9QX1RPVUNIX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2hlbmQnKTtcbmV4cG9ydCBjb25zdCBUT1BfVE9VQ0hfTU9WRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2htb3ZlJyk7XG5leHBvcnQgY29uc3QgVE9QX1RPVUNIX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b3VjaHN0YXJ0Jyk7XG5leHBvcnQgY29uc3QgVE9QX1RSQU5TSVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKFxuICBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpLFxuKTtcbmV4cG9ydCBjb25zdCBUT1BfVk9MVU1FX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShcbiAgJ3ZvbHVtZWNoYW5nZScsXG4pO1xuZXhwb3J0IGNvbnN0IFRPUF9XQUlUSU5HID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd3YWl0aW5nJyk7XG5leHBvcnQgY29uc3QgVE9QX1dIRUVMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd3aGVlbCcpO1xuXG4vLyBMaXN0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgaW5kaXZpZHVhbGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRzLlxuLy8gTm90ZSB0aGF0IGV2ZW50cyBpbiB0aGlzIGxpc3Qgd2lsbCAqbm90KiBiZSBsaXN0ZW5lZCB0byBhdCB0aGUgdG9wIGxldmVsXG4vLyB1bmxlc3MgdGhleSdyZSBleHBsaWNpdGx5IHdoaXRlbGlzdGVkIGluIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG9gLlxuZXhwb3J0IGNvbnN0IG1lZGlhRXZlbnRUeXBlcyA9IFtcbiAgVE9QX0FCT1JULFxuICBUT1BfQ0FOX1BMQVksXG4gIFRPUF9DQU5fUExBWV9USFJPVUdILFxuICBUT1BfRFVSQVRJT05fQ0hBTkdFLFxuICBUT1BfRU1QVElFRCxcbiAgVE9QX0VOQ1JZUFRFRCxcbiAgVE9QX0VOREVELFxuICBUT1BfRVJST1IsXG4gIFRPUF9MT0FERURfREFUQSxcbiAgVE9QX0xPQURFRF9NRVRBREFUQSxcbiAgVE9QX0xPQURfU1RBUlQsXG4gIFRPUF9QQVVTRSxcbiAgVE9QX1BMQVksXG4gIFRPUF9QTEFZSU5HLFxuICBUT1BfUFJPR1JFU1MsXG4gIFRPUF9SQVRFX0NIQU5HRSxcbiAgVE9QX1NFRUtFRCxcbiAgVE9QX1NFRUtJTkcsXG4gIFRPUF9TVEFMTEVELFxuICBUT1BfU1VTUEVORCxcbiAgVE9QX1RJTUVfVVBEQVRFLFxuICBUT1BfVk9MVU1FX0NIQU5HRSxcbiAgVE9QX1dBSVRJTkcsXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZTogRE9NVG9wTGV2ZWxFdmVudFR5cGUpOiBzdHJpbmcge1xuICByZXR1cm4gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKHRvcExldmVsVHlwZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9ET01Ub3BMZXZlbEV2ZW50VHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLyoqXG4gKiBIVE1MIG5vZGVUeXBlIHZhbHVlcyB0aGF0IHJlcHJlc2VudCB0aGUgdHlwZSBvZiB0aGUgbm9kZVxuICovXG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX05PREUgPSAxO1xuZXhwb3J0IGNvbnN0IFRFWFRfTk9ERSA9IDM7XG5leHBvcnQgY29uc3QgQ09NTUVOVF9OT0RFID0gODtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9OT0RFID0gOTtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9IVE1MTm9kZVR5cGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7SG9zdENvbXBvbmVudCwgSG9zdFRleHR9IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5cbmNvbnN0IHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKClcbiAgLnRvU3RyaW5nKDM2KVxuICAuc2xpY2UoMik7XG5jb25zdCBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG5jb25zdCBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50SGFuZGxlcnMkJyArIHJhbmRvbUtleTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBsZXQgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBjb25zdCBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gIGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgY29uc3QgY2FuVXNlRE9NOiBib29sZWFuID0gISEoXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5kb2N1bWVudCAmJlxuICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vLyBVcGRhdGVRdWV1ZSBpcyBhIGxpbmtlZCBsaXN0IG9mIHByaW9yaXRpemVkIHVwZGF0ZXMuXG4vL1xuLy8gTGlrZSBmaWJlcnMsIHVwZGF0ZSBxdWV1ZXMgY29tZSBpbiBwYWlyczogYSBjdXJyZW50IHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4vLyB0aGUgdmlzaWJsZSBzdGF0ZSBvZiB0aGUgc2NyZWVuLCBhbmQgYSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCB3aGljaCBjYW4gYmVcbi8vIG11dGF0ZWQgYW5kIHByb2Nlc3NlZCBhc3luY2hyb25vdXNseSBiZWZvcmUgaXQgaXMgY29tbWl0dGVkIOKAlCBhIGZvcm0gb2Zcbi8vIGRvdWJsZSBidWZmZXJpbmcuIElmIGEgd29yay1pbi1wcm9ncmVzcyByZW5kZXIgaXMgZGlzY2FyZGVkIGJlZm9yZSBmaW5pc2hpbmcsXG4vLyB3ZSBjcmVhdGUgYSBuZXcgd29yay1pbi1wcm9ncmVzcyBieSBjbG9uaW5nIHRoZSBjdXJyZW50IHF1ZXVlLlxuLy9cbi8vIEJvdGggcXVldWVzIHNoYXJlIGEgcGVyc2lzdGVudCwgc2luZ2x5LWxpbmtlZCBsaXN0IHN0cnVjdHVyZS4gVG8gc2NoZWR1bGUgYW5cbi8vIHVwZGF0ZSwgd2UgYXBwZW5kIGl0IHRvIHRoZSBlbmQgb2YgYm90aCBxdWV1ZXMuIEVhY2ggcXVldWUgbWFpbnRhaW5zIGFcbi8vIHBvaW50ZXIgdG8gZmlyc3QgdXBkYXRlIGluIHRoZSBwZXJzaXN0ZW50IGxpc3QgdGhhdCBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQuXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBwb2ludGVyIGFsd2F5cyBoYXMgYSBwb3NpdGlvbiBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cbi8vIHRoZSBjdXJyZW50IHF1ZXVlLCBzaW5jZSB3ZSBhbHdheXMgd29yayBvbiB0aGF0IG9uZS4gVGhlIGN1cnJlbnQgcXVldWUnc1xuLy8gcG9pbnRlciBpcyBvbmx5IHVwZGF0ZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdoZW4gd2Ugc3dhcCBpbiB0aGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MuXG4vL1xuLy8gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICBDdXJyZW50IHBvaW50ZXI6ICAgICAgICAgICBBIC0gQiAtIEMgLSBEIC0gRSAtIEZcbi8vICAgV29yay1pbi1wcm9ncmVzcyBwb2ludGVyOiAgICAgICAgICAgICAgRCAtIEUgLSBGXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaGFzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCBtb3JlIHVwZGF0ZXMgdGhhbiBjdXJyZW50LlxuLy9cbi8vIFRoZSByZWFzb24gd2UgYXBwZW5kIHRvIGJvdGggcXVldWVzIGlzIGJlY2F1c2Ugb3RoZXJ3aXNlIHdlIG1pZ2h0IGRyb3Bcbi8vIHVwZGF0ZXMgd2l0aG91dCBldmVyIHByb2Nlc3NpbmcgdGhlbS4gRm9yIGV4YW1wbGUsIGlmIHdlIG9ubHkgYWRkIHVwZGF0ZXMgdG9cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBzb21lIHVwZGF0ZXMgY291bGQgYmUgbG9zdCB3aGVuZXZlciBhIHdvcmstaW5cbi8vIC1wcm9ncmVzcyByZW5kZXIgcmVzdGFydHMgYnkgY2xvbmluZyBmcm9tIGN1cnJlbnQuIFNpbWlsYXJseSwgaWYgd2Ugb25seSBhZGRcbi8vIHVwZGF0ZXMgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHRoZSB1cGRhdGVzIHdpbGwgYmUgbG9zdCB3aGVuZXZlciBhbiBhbHJlYWR5XG4vLyBpbi1wcm9ncmVzcyBxdWV1ZSBjb21taXRzIGFuZCBzd2FwcyB3aXRoIHRoZSBjdXJyZW50IHF1ZXVlLiBIb3dldmVyLCBieVxuLy8gYWRkaW5nIHRvIGJvdGggcXVldWVzLCB3ZSBndWFyYW50ZWUgdGhhdCB0aGUgdXBkYXRlIHdpbGwgYmUgcGFydCBvZiB0aGUgbmV4dFxuLy8gd29yay1pbi1wcm9ncmVzcy4gKEFuZCBiZWNhdXNlIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGJlY29tZXMgdGhlXG4vLyBjdXJyZW50IHF1ZXVlIG9uY2UgaXQgY29tbWl0cywgdGhlcmUncyBubyBkYW5nZXIgb2YgYXBwbHlpbmcgdGhlIHNhbWVcbi8vIHVwZGF0ZSB0d2ljZS4pXG4vL1xuLy8gUHJpb3JpdGl6YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gVXBkYXRlcyBhcmUgbm90IHNvcnRlZCBieSBwcmlvcml0eSwgYnV0IGJ5IGluc2VydGlvbjsgbmV3IHVwZGF0ZXMgYXJlIGFsd2F5c1xuLy8gYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbi8vXG4vLyBUaGUgcHJpb3JpdHkgaXMgc3RpbGwgaW1wb3J0YW50LCB0aG91Z2guIFdoZW4gcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlXG4vLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgb25seSB0aGUgdXBkYXRlcyB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkgYXJlXG4vLyBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0LiBJZiB3ZSBza2lwIGFuIHVwZGF0ZSBiZWNhdXNlIGl0IGhhcyBpbnN1ZmZpY2llbnRcbi8vIHByaW9yaXR5LCBpdCByZW1haW5zIGluIHRoZSBxdWV1ZSB0byBiZSBwcm9jZXNzZWQgbGF0ZXIsIGR1cmluZyBhIGxvd2VyXG4vLyBwcmlvcml0eSByZW5kZXIuIENydWNpYWxseSwgYWxsIHVwZGF0ZXMgc3Vic2VxdWVudCB0byBhIHNraXBwZWQgdXBkYXRlIGFsc29cbi8vIHJlbWFpbiBpbiB0aGUgcXVldWUgKnJlZ2FyZGxlc3Mgb2YgdGhlaXIgcHJpb3JpdHkqLiBUaGF0IG1lYW5zIGhpZ2ggcHJpb3JpdHlcbi8vIHVwZGF0ZXMgYXJlIHNvbWV0aW1lcyBwcm9jZXNzZWQgdHdpY2UsIGF0IHR3byBzZXBhcmF0ZSBwcmlvcml0aWVzLiBXZSBhbHNvXG4vLyBrZWVwIHRyYWNrIG9mIGEgYmFzZSBzdGF0ZSwgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBiZWZvcmUgdGhlIGZpcnN0XG4vLyB1cGRhdGUgaW4gdGhlIHF1ZXVlIGlzIGFwcGxpZWQuXG4vL1xuLy8gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICBHaXZlbiBhIGJhc2Ugc3RhdGUgb2YgJycsIGFuZCB0aGUgZm9sbG93aW5nIHF1ZXVlIG9mIHVwZGF0ZXNcbi8vXG4vLyAgICAgQTEgLSBCMiAtIEMxIC0gRDJcbi8vXG4vLyAgIHdoZXJlIHRoZSBudW1iZXIgaW5kaWNhdGVzIHRoZSBwcmlvcml0eSwgYW5kIHRoZSB1cGRhdGUgaXMgYXBwbGllZCB0byB0aGVcbi8vICAgcHJldmlvdXMgc3RhdGUgYnkgYXBwZW5kaW5nIGEgbGV0dGVyLCBSZWFjdCB3aWxsIHByb2Nlc3MgdGhlc2UgdXBkYXRlcyBhc1xuLy8gICB0d28gc2VwYXJhdGUgcmVuZGVycywgb25lIHBlciBkaXN0aW5jdCBwcmlvcml0eSBsZXZlbDpcbi8vXG4vLyAgIEZpcnN0IHJlbmRlciwgYXQgcHJpb3JpdHkgMTpcbi8vICAgICBCYXNlIHN0YXRlOiAnJ1xuLy8gICAgIFVwZGF0ZXM6IFtBMSwgQzFdXG4vLyAgICAgUmVzdWx0IHN0YXRlOiAnQUMnXG4vL1xuLy8gICBTZWNvbmQgcmVuZGVyLCBhdCBwcmlvcml0eSAyOlxuLy8gICAgIEJhc2Ugc3RhdGU6ICdBJyAgICAgICAgICAgIDwtICBUaGUgYmFzZSBzdGF0ZSBkb2VzIG5vdCBpbmNsdWRlIEMxLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWNhdXNlIEIyIHdhcyBza2lwcGVkLlxuLy8gICAgIFVwZGF0ZXM6IFtCMiwgQzEsIEQyXSAgICAgIDwtICBDMSB3YXMgcmViYXNlZCBvbiB0b3Agb2YgQjJcbi8vICAgICBSZXN1bHQgc3RhdGU6ICdBQkNEJ1xuLy9cbi8vIEJlY2F1c2Ugd2UgcHJvY2VzcyB1cGRhdGVzIGluIGluc2VydGlvbiBvcmRlciwgYW5kIHJlYmFzZSBoaWdoIHByaW9yaXR5XG4vLyB1cGRhdGVzIHdoZW4gcHJlY2VkaW5nIHVwZGF0ZXMgYXJlIHNraXBwZWQsIHRoZSBmaW5hbCByZXN1bHQgaXMgZGV0ZXJtaW5pc3RpY1xuLy8gcmVnYXJkbGVzcyBvZiBwcmlvcml0eS4gSW50ZXJtZWRpYXRlIHN0YXRlIG1heSB2YXJ5IGFjY29yZGluZyB0byBzeXN0ZW1cbi8vIHJlc291cmNlcywgYnV0IHRoZSBmaW5hbCBzdGF0ZSBpcyBhbHdheXMgdGhlIHNhbWUuXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcbmltcG9ydCB0eXBlIHtFeHBpcmF0aW9uVGltZX0gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuXG5pbXBvcnQge05vV29ya30gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuaW1wb3J0IHtcbiAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVixcbiAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWLFxufSBmcm9tICcuL1JlYWN0RmliZXJOZXdDb250ZXh0JztcbmltcG9ydCB7Q2FsbGJhY2ssIFNob3VsZENhcHR1cmUsIERpZENhcHR1cmV9IGZyb20gJ3NoYXJlZC9SZWFjdFNpZGVFZmZlY3RUYWdzJztcbmltcG9ydCB7Q2xhc3NDb21wb25lbnR9IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcblxuaW1wb3J0IHtcbiAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzLFxuICBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlLFxufSBmcm9tICdzaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MnO1xuXG5pbXBvcnQge1N0cmljdE1vZGV9IGZyb20gJy4vUmVhY3RUeXBlT2ZNb2RlJztcblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuZXhwb3J0IHR5cGUgVXBkYXRlPFN0YXRlPiA9IHtcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuXG4gIHRhZzogMCB8IDEgfCAyIHwgMyxcbiAgcGF5bG9hZDogYW55LFxuICBjYWxsYmFjazogKCgpID0+IG1peGVkKSB8IG51bGwsXG5cbiAgbmV4dDogVXBkYXRlPFN0YXRlPiB8IG51bGwsXG4gIG5leHRFZmZlY3Q6IFVwZGF0ZTxTdGF0ZT4gfCBudWxsLFxufTtcblxuZXhwb3J0IHR5cGUgVXBkYXRlUXVldWU8U3RhdGU+ID0ge1xuICBiYXNlU3RhdGU6IFN0YXRlLFxuXG4gIGZpcnN0VXBkYXRlOiBVcGRhdGU8U3RhdGU+IHwgbnVsbCxcbiAgbGFzdFVwZGF0ZTogVXBkYXRlPFN0YXRlPiB8IG51bGwsXG5cbiAgZmlyc3RDYXB0dXJlZFVwZGF0ZTogVXBkYXRlPFN0YXRlPiB8IG51bGwsXG4gIGxhc3RDYXB0dXJlZFVwZGF0ZTogVXBkYXRlPFN0YXRlPiB8IG51bGwsXG5cbiAgZmlyc3RFZmZlY3Q6IFVwZGF0ZTxTdGF0ZT4gfCBudWxsLFxuICBsYXN0RWZmZWN0OiBVcGRhdGU8U3RhdGU+IHwgbnVsbCxcblxuICBmaXJzdENhcHR1cmVkRWZmZWN0OiBVcGRhdGU8U3RhdGU+IHwgbnVsbCxcbiAgbGFzdENhcHR1cmVkRWZmZWN0OiBVcGRhdGU8U3RhdGU+IHwgbnVsbCxcbn07XG5cbmV4cG9ydCBjb25zdCBVcGRhdGVTdGF0ZSA9IDA7XG5leHBvcnQgY29uc3QgUmVwbGFjZVN0YXRlID0gMTtcbmV4cG9ydCBjb25zdCBGb3JjZVVwZGF0ZSA9IDI7XG5leHBvcnQgY29uc3QgQ2FwdHVyZVVwZGF0ZSA9IDM7XG5cbi8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5sZXQgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxubGV0IGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG5sZXQgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuZXhwb3J0IGxldCByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTtcbmlmIChfX0RFVl9fKSB7XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgcmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSAoKSA9PiB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVF1ZXVlPFN0YXRlPihiYXNlU3RhdGU6IFN0YXRlKTogVXBkYXRlUXVldWU8U3RhdGU+IHtcbiAgY29uc3QgcXVldWU6IFVwZGF0ZVF1ZXVlPFN0YXRlPiA9IHtcbiAgICBiYXNlU3RhdGUsXG4gICAgZmlyc3RVcGRhdGU6IG51bGwsXG4gICAgbGFzdFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuICAgIGxhc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIGZpcnN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkRWZmZWN0OiBudWxsLFxuICB9O1xuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWU8U3RhdGU+KFxuICBjdXJyZW50UXVldWU6IFVwZGF0ZVF1ZXVlPFN0YXRlPixcbik6IFVwZGF0ZVF1ZXVlPFN0YXRlPiB7XG4gIGNvbnN0IHF1ZXVlOiBVcGRhdGVRdWV1ZTxTdGF0ZT4gPSB7XG4gICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgIGZpcnN0VXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RVcGRhdGUsXG4gICAgbGFzdFVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RVcGRhdGUsXG5cbiAgICAvLyBUT0RPOiBXaXRoIHJlc3VtaW5nLCBpZiB3ZSBiYWlsIG91dCBhbmQgcmVzdXNlIHRoZSBjaGlsZCB0cmVlLCB3ZSBzaG91bGRcbiAgICAvLyBrZWVwIHRoZXNlIGVmZmVjdHMuXG4gICAgZmlyc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG5cbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuXG4gICAgZmlyc3RDYXB0dXJlZEVmZmVjdDogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gIH07XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUpOiBVcGRhdGU8Kj4ge1xuICByZXR1cm4ge1xuICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcblxuICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgcGF5bG9hZDogbnVsbCxcbiAgICBjYWxsYmFjazogbnVsbCxcblxuICAgIG5leHQ6IG51bGwsXG4gICAgbmV4dEVmZmVjdDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kVXBkYXRlVG9RdWV1ZTxTdGF0ZT4oXG4gIHF1ZXVlOiBVcGRhdGVRdWV1ZTxTdGF0ZT4sXG4gIHVwZGF0ZTogVXBkYXRlPFN0YXRlPixcbikge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3RVcGRhdGUgPSBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlPFN0YXRlPihmaWJlcjogRmliZXIsIHVwZGF0ZTogVXBkYXRlPFN0YXRlPikge1xuICAvLyBVcGRhdGUgcXVldWVzIGFyZSBjcmVhdGVkIGxhemlseS5cbiAgY29uc3QgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBsZXQgcXVldWUxO1xuICBsZXQgcXVldWUyO1xuICBpZiAoYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBvbmx5IG9uZSBmaWJlci5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICBxdWV1ZTIgPSBudWxsO1xuICAgIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoZmliZXIubWVtb2l6ZWRTdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gb3duZXJzLlxuICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZS51cGRhdGVRdWV1ZTtcbiAgICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5laXRoZXIgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ3JlYXRlIG5ldyBvbmVzLlxuICAgICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKGZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgICAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShcbiAgICAgICAgICBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9ubHkgb25lIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENsb25lIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY2xvbmVVcGRhdGVRdWV1ZShxdWV1ZTIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgICAgIC8vIE9ubHkgb25lIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENsb25lIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZS51cGRhdGVRdWV1ZSA9IGNsb25lVXBkYXRlUXVldWUocXVldWUxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJvdGggb3duZXJzIGhhdmUgYW4gdXBkYXRlIHF1ZXVlLlxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocXVldWUyID09PSBudWxsIHx8IHF1ZXVlMSA9PT0gcXVldWUyKSB7XG4gICAgLy8gVGhlcmUncyBvbmx5IGEgc2luZ2xlIHF1ZXVlLlxuICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gcXVldWVzLiBXZSBuZWVkIHRvIGFwcGVuZCB0aGUgdXBkYXRlIHRvIGJvdGggcXVldWVzLFxuICAgIC8vIHdoaWxlIGFjY291bnRpbmcgZm9yIHRoZSBwZXJzaXN0ZW50IHN0cnVjdHVyZSBvZiB0aGUgbGlzdCDigJQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRoZSBzYW1lIHVwZGF0ZSB0byBiZSBhZGRlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICBpZiAocXVldWUxLmxhc3RVcGRhdGUgPT09IG51bGwgfHwgcXVldWUyLmxhc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIE9uZSBvZiB0aGUgcXVldWVzIGlzIG5vdCBlbXB0eS4gV2UgbXVzdCBhZGQgdGhlIHVwZGF0ZSB0byBib3RoIHF1ZXVlcy5cbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTIsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggcXVldWVzIGFyZSBub24tZW1wdHkuIFRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBpbiBib3RoIGxpc3RzLFxuICAgICAgLy8gYmVjYXVzZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuIFNvLCBvbmx5IGFwcGVuZCB0byBvbmUgb2YgdGhlIGxpc3RzLlxuICAgICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0VXBkYXRlYCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgICAgIHF1ZXVlMi5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKFxuICAgICAgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJlxuICAgICAgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gcXVldWUxIHx8XG4gICAgICAgIChxdWV1ZTIgIT09IG51bGwgJiYgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSBxdWV1ZTIpKSAmJlxuICAgICAgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGVcbiAgICApIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICtcbiAgICAgICAgICAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICtcbiAgICAgICAgICAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArXG4gICAgICAgICAgJ2NhbGxiYWNrLicsXG4gICAgICApO1xuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGU8U3RhdGU+KFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIHVwZGF0ZTogVXBkYXRlPFN0YXRlPixcbikge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGdvIGludG8gYSBzZXBhcmF0ZSBsaXN0LCBhbmQgb25seSBvbiB0aGUgd29yay1pbi1cbiAgLy8gcHJvZ3Jlc3MgcXVldWUuXG4gIGxldCB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1F1ZXVlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETzogSSBwdXQgdGhpcyBoZXJlIHJhdGhlciB0aGFuIGNyZWF0ZVdvcmtJblByb2dyZXNzIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBjbG9uZSB0aGUgcXVldWUgdW5uZWNlc3NhcmlseS4gVGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG9cbiAgICAvLyBzdHJ1Y3R1cmUgdGhpcy5cbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLFxuICAgICk7XG4gIH1cblxuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAod29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgcGhhc2UgdXBkYXRlXG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlID0gd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IHVwZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmU8U3RhdGU+KFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIHF1ZXVlOiBVcGRhdGVRdWV1ZTxTdGF0ZT4sXG4pOiBVcGRhdGVRdWV1ZTxTdGF0ZT4ge1xuICBjb25zdCBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIElmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IHF1ZXVlLFxuICAgIC8vIHdlIG5lZWQgdG8gY2xvbmUgaXQgZmlyc3QuXG4gICAgaWYgKHF1ZXVlID09PSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSB7XG4gICAgICBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY2xvbmVVcGRhdGVRdWV1ZShxdWV1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlPFN0YXRlPihcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICBxdWV1ZTogVXBkYXRlUXVldWU8U3RhdGU+LFxuICB1cGRhdGU6IFVwZGF0ZTxTdGF0ZT4sXG4gIHByZXZTdGF0ZTogU3RhdGUsXG4gIG5leHRQcm9wczogYW55LFxuICBpbnN0YW5jZTogYW55LFxuKTogYW55IHtcbiAgc3dpdGNoICh1cGRhdGUudGFnKSB7XG4gICAgY2FzZSBSZXBsYWNlU3RhdGU6IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fFxuICAgICAgICAgICAgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiZcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIFN0YXRlIG9iamVjdFxuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZToge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlKSB8IERpZENhcHR1cmU7XG4gICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBVcGRhdGVTdGF0ZToge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgbGV0IHBhcnRpYWxTdGF0ZTtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fFxuICAgICAgICAgICAgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiZcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFydGlhbFN0YXRlID0gcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IHBheWxvYWQ7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE51bGwgYW5kIHVuZGVmaW5lZCBhcmUgdHJlYXRlZCBhcyBuby1vcHMuXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9XG4gICAgY2FzZSBGb3JjZVVwZGF0ZToge1xuICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZTxTdGF0ZT4oXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgcXVldWU6IFVwZGF0ZVF1ZXVlPFN0YXRlPixcbiAgcHJvcHM6IGFueSxcbiAgaW5zdGFuY2U6IGFueSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogdm9pZCB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgcXVldWUgPSBlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlKTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlO1xuICB9XG5cbiAgLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG4gIGxldCBuZXdCYXNlU3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIGxldCBuZXdGaXJzdFVwZGF0ZSA9IG51bGw7XG4gIGxldCBuZXdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gIGxldCB1cGRhdGUgPSBxdWV1ZS5maXJzdFVwZGF0ZTtcbiAgbGV0IHJlc3VsdFN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgY29uc3QgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIGlmIChuZXdGaXJzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBza2lwcGVkIHVwZGF0ZS4gSXQgd2lsbCBiZSB0aGUgZmlyc3QgdXBkYXRlIGluXG4gICAgICAgIC8vIHRoZSBuZXcgbGlzdC5cbiAgICAgICAgbmV3Rmlyc3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZSB0aGF0IHdhcyBza2lwcGVkLCB0aGUgY3VycmVudCByZXN1bHRcbiAgICAgICAgLy8gaXMgdGhlIG5ldyBiYXNlIHN0YXRlLlxuICAgICAgICBuZXdCYXNlU3RhdGUgPSByZXN1bHRTdGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHRoaXMgdXBkYXRlIHdpbGwgcmVtYWluIGluIHRoZSBsaXN0LCB1cGRhdGUgdGhlIHJlbWFpbmluZ1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5ld0V4cGlyYXRpb25UaW1lIDwgdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFByb2Nlc3MgaXQgYW5kIGNvbXB1dGVcbiAgICAgIC8vIGEgbmV3IHJlc3VsdC5cbiAgICAgIHJlc3VsdFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgcXVldWUsXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgcmVzdWx0U3RhdGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICk7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gICAgICAgIC8vIFNldCB0aGlzIHRvIG51bGwsIGluIGNhc2UgaXQgd2FzIG11dGF0ZWQgZHVyaW5nIGFuIGFib3J0ZWQgcmVuZGVyLlxuICAgICAgICB1cGRhdGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgIGlmIChxdWV1ZS5sYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcXVldWUuZmlyc3RFZmZlY3QgPSBxdWV1ZS5sYXN0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXVlLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHVwZGF0ZTtcbiAgICAgICAgICBxdWV1ZS5sYXN0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgfVxuXG4gIC8vIFNlcGFyYXRlbHksIGl0ZXJhdGUgdGhvdWdoIHRoZSBsaXN0IG9mIGNhcHR1cmVkIHVwZGF0ZXMuXG4gIGxldCBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID0gbnVsbDtcbiAgdXBkYXRlID0gcXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICBpZiAobmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBza2lwcGVkIGNhcHR1cmVkIHVwZGF0ZS4gSXQgd2lsbCBiZSB0aGUgZmlyc3RcbiAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBuZXcgbGlzdC5cbiAgICAgICAgbmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHRoYXQgd2FzIHNraXBwZWQsIHRoZSBjdXJyZW50IHJlc3VsdCBpc1xuICAgICAgICAvLyB0aGUgbmV3IGJhc2Ugc3RhdGUuXG4gICAgICAgIGlmIChuZXdGaXJzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSB0aGlzIHVwZGF0ZSB3aWxsIHJlbWFpbiBpbiB0aGUgbGlzdCwgdXBkYXRlIHRoZSByZW1haW5pbmdcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChuZXdFeHBpcmF0aW9uVGltZSA8IHVwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBQcm9jZXNzIGl0IGFuZCBjb21wdXRlXG4gICAgICAvLyBhIG5ldyByZXN1bHQuXG4gICAgICByZXN1bHRTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHF1ZXVlLFxuICAgICAgICB1cGRhdGUsXG4gICAgICAgIHJlc3VsdFN0YXRlLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICApO1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICAgICAgICAvLyBTZXQgdGhpcyB0byBudWxsLCBpbiBjYXNlIGl0IHdhcyBtdXRhdGVkIGR1cmluZyBhbiBhYm9ydGVkIHJlbmRlci5cbiAgICAgICAgdXBkYXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICBpZiAocXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdCA9IHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9IHVwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QubmV4dEVmZmVjdCA9IHVwZGF0ZTtcbiAgICAgICAgICBxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5sYXN0VXBkYXRlID0gbnVsbDtcbiAgfVxuICBpZiAobmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9XG4gIGlmIChuZXdGaXJzdFVwZGF0ZSA9PT0gbnVsbCAmJiBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgLy8gV2UgcHJvY2Vzc2VkIGV2ZXJ5IHVwZGF0ZSwgd2l0aG91dCBza2lwcGluZy4gVGhhdCBtZWFucyB0aGUgbmV3IGJhc2VcbiAgICAvLyBzdGF0ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcmVzdWx0IHN0YXRlLlxuICAgIG5ld0Jhc2VTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuICB9XG5cbiAgcXVldWUuYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICBxdWV1ZS5maXJzdFVwZGF0ZSA9IG5ld0ZpcnN0VXBkYXRlO1xuICBxdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlID0gbmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZTtcblxuICAvLyBTZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgd2hhdGV2ZXIgaXMgcmVtYWluaW5nIGluIHRoZSBxdWV1ZS5cbiAgLy8gVGhpcyBzaG91bGQgYmUgZmluZSBiZWNhdXNlIHRoZSBvbmx5IHR3byBvdGhlciB0aGluZ3MgdGhhdCBjb250cmlidXRlIHRvXG4gIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgLy8gYmVnaW4gcGhhc2UgYnkgdGhlIHRpbWUgd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgcXVldWUsIHNvIHdlJ3ZlIGFscmVhZHlcbiAgLy8gZGVhbHQgd2l0aCB0aGUgcHJvcHMuIENvbnRleHQgaW4gY29tcG9uZW50cyB0aGF0IHNwZWNpZnlcbiAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgLy8gdGhhdCByZWdhcmRsZXNzLlxuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IG5ld0V4cGlyYXRpb25UaW1lO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcmVzdWx0U3RhdGU7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLFxuICAgICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCAnICtcbiAgICAgICdyZWNlaXZlZDogJXMnLFxuICAgIGNhbGxiYWNrLFxuICApO1xuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZTxTdGF0ZT4oXG4gIGZpbmlzaGVkV29yazogRmliZXIsXG4gIGZpbmlzaGVkUXVldWU6IFVwZGF0ZVF1ZXVlPFN0YXRlPixcbiAgaW5zdGFuY2U6IGFueSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogdm9pZCB7XG4gIC8vIElmIHRoZSBmaW5pc2hlZCByZW5kZXIgaW5jbHVkZWQgY2FwdHVyZWQgdXBkYXRlcywgYW5kIHRoZXJlIGFyZSBzdGlsbFxuICAvLyBsb3dlciBwcmlvcml0eSB1cGRhdGVzIGxlZnQgb3Zlciwgd2UgbmVlZCB0byBrZWVwIHRoZSBjYXB0dXJlZCB1cGRhdGVzXG4gIC8vIGluIHRoZSBxdWV1ZSBzbyB0aGF0IHRoZXkgYXJlIHJlYmFzZWQgYW5kIG5vdCBkcm9wcGVkIG9uY2Ugd2UgcHJvY2VzcyB0aGVcbiAgLy8gcXVldWUgYWdhaW4gYXQgdGhlIGxvd2VyIHByaW9yaXR5LlxuICBpZiAoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSm9pbiB0aGUgY2FwdHVyZWQgdXBkYXRlIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgbm9ybWFsIGxpc3QuXG4gICAgaWYgKGZpbmlzaGVkUXVldWUubGFzdFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRRdWV1ZS5sYXN0VXBkYXRlLm5leHQgPSBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGU7XG4gICAgICBmaW5pc2hlZFF1ZXVlLmxhc3RVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgICBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgY29tbWl0VXBkYXRlRWZmZWN0cyhmaW5pc2hlZFF1ZXVlLmZpcnN0RWZmZWN0LCBpbnN0YW5jZSk7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFF1ZXVlLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIGNvbW1pdFVwZGF0ZUVmZmVjdHMoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkRWZmZWN0LCBpbnN0YW5jZSk7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdCA9IGZpbmlzaGVkUXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0VXBkYXRlRWZmZWN0czxTdGF0ZT4oXG4gIGVmZmVjdDogVXBkYXRlPFN0YXRlPiB8IG51bGwsXG4gIGluc3RhbmNlOiBhbnksXG4pOiB2b2lkIHtcbiAgd2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZWZmZWN0LmNhbGxiYWNrO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgZWZmZWN0LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7UmVhY3RDb250ZXh0fSBmcm9tICdzaGFyZWQvUmVhY3RUeXBlcyc7XG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJy4vUmVhY3RGaWJlcic7XG5pbXBvcnQgdHlwZSB7U3RhY2tDdXJzb3J9IGZyb20gJy4vUmVhY3RGaWJlclN0YWNrJztcbmltcG9ydCB0eXBlIHtFeHBpcmF0aW9uVGltZX0gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuXG5leHBvcnQgdHlwZSBDb250ZXh0RGVwZW5kZW5jeUxpc3QgPSB7XG4gIGZpcnN0OiBDb250ZXh0RGVwZW5kZW5jeTxtaXhlZD4sXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbn07XG5cbnR5cGUgQ29udGV4dERlcGVuZGVuY3k8VD4gPSB7XG4gIGNvbnRleHQ6IFJlYWN0Q29udGV4dDxUPixcbiAgb2JzZXJ2ZWRCaXRzOiBudW1iZXIsXG4gIG5leHQ6IENvbnRleHREZXBlbmRlbmN5PG1peGVkPiB8IG51bGwsXG59O1xuXG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5pbXBvcnQge2lzUHJpbWFyeVJlbmRlcmVyfSBmcm9tICcuL1JlYWN0RmliZXJIb3N0Q29uZmlnJztcbmltcG9ydCB7Y3JlYXRlQ3Vyc29yLCBwdXNoLCBwb3B9IGZyb20gJy4vUmVhY3RGaWJlclN0YWNrJztcbmltcG9ydCBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgZnJvbSAnLi9tYXhTaWduZWQzMUJpdEludCc7XG5pbXBvcnQge1xuICBDb250ZXh0UHJvdmlkZXIsXG4gIENsYXNzQ29tcG9uZW50LFxuICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3NoYXJlZC93YXJuaW5nJztcbmltcG9ydCBpcyBmcm9tICdzaGFyZWQvb2JqZWN0SXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVXBkYXRlLFxuICBlbnF1ZXVlVXBkYXRlLFxuICBGb3JjZVVwZGF0ZSxcbn0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RVcGRhdGVRdWV1ZSc7XG5pbXBvcnQge05vV29ya30gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuaW1wb3J0IHttYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZX0gZnJvbSAnLi9SZWFjdEZpYmVyQmVnaW5Xb3JrJztcbmltcG9ydCB7ZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcn0gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcblxuY29uc3QgdmFsdWVDdXJzb3I6IFN0YWNrQ3Vyc29yPG1peGVkPiA9IGNyZWF0ZUN1cnNvcihudWxsKTtcblxubGV0IHJlbmRlcmVyU2lnaWw7XG5pZiAoX19ERVZfXykge1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG5sZXQgY3VycmVudGx5UmVuZGVyaW5nRmliZXI6IEZpYmVyIHwgbnVsbCA9IG51bGw7XG5sZXQgbGFzdENvbnRleHREZXBlbmRlbmN5OiBDb250ZXh0RGVwZW5kZW5jeTxtaXhlZD4gfCBudWxsID0gbnVsbDtcbmxldCBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQ6IFJlYWN0Q29udGV4dDxhbnk+IHwgbnVsbCA9IG51bGw7XG5cbmxldCBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWOiBib29sZWFuID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNlcygpOiB2b2lkIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk6IHZvaWQge1xuICBpZiAoX19ERVZfXykge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTogdm9pZCB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXNoUHJvdmlkZXI8VD4ocHJvdmlkZXJGaWJlcjogRmliZXIsIG5leHRWYWx1ZTogVCk6IHZvaWQge1xuICBjb25zdCBjb250ZXh0OiBSZWFjdENvbnRleHQ8VD4gPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IG51bGwgfHxcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IHJlbmRlcmVyU2lnaWwsXG4gICAgICAgICdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArXG4gICAgICAgICAgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyxcbiAgICAgICk7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWU7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IG51bGwgfHxcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID09PSByZW5kZXJlclNpZ2lsLFxuICAgICAgICAnRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgK1xuICAgICAgICAgICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicsXG4gICAgICApO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BQcm92aWRlcihwcm92aWRlckZpYmVyOiBGaWJlcik6IHZvaWQge1xuICBjb25zdCBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuXG4gIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG5cbiAgY29uc3QgY29udGV4dDogUmVhY3RDb250ZXh0PGFueT4gPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG4gIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDaGFuZ2VkQml0czxUPihcbiAgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+LFxuICBuZXdWYWx1ZTogVCxcbiAgb2xkVmFsdWU6IFQsXG4pIHtcbiAgaWYgKGlzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAvLyBObyBjaGFuZ2VcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaGFuZ2VkQml0cyA9XG4gICAgICB0eXBlb2YgY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpXG4gICAgICAgIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIChjaGFuZ2VkQml0cyAmIE1BWF9TSUdORURfMzFfQklUX0lOVCkgPT09IGNoYW5nZWRCaXRzLFxuICAgICAgICAnY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICtcbiAgICAgICAgICAnMzEtYml0IGludGVnZXIuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJyxcbiAgICAgICAgY2hhbmdlZEJpdHMsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZEJpdHMgfCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya09uUGFyZW50UGF0aChcbiAgcGFyZW50OiBGaWJlciB8IG51bGwsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbikge1xuICAvLyBVcGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZSBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nXG4gIC8vIHRoZSBhbHRlcm5hdGVzLlxuICBsZXQgbm9kZSA9IHBhcmVudDtcbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBsZXQgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgaWYgKG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChcbiAgICAgICAgYWx0ZXJuYXRlICE9PSBudWxsICYmXG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICkge1xuICAgICAgICBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhbHRlcm5hdGUgIT09IG51bGwgJiZcbiAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICApIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgYWx0ZXJuYXRlIHdhcyB1cGRhdGVkLCB3aGljaCBtZWFucyB0aGUgcmVzdCBvZiB0aGVcbiAgICAgIC8vIGFuY2VzdG9yIHBhdGggYWxyZWFkeSBoYXMgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2UoXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgY29udGV4dDogUmVhY3RDb250ZXh0PG1peGVkPixcbiAgY2hhbmdlZEJpdHM6IG51bWJlcixcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogdm9pZCB7XG4gIGxldCBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBsZXQgbmV4dEZpYmVyO1xuXG4gICAgLy8gVmlzaXQgdGhpcyBmaWJlci5cbiAgICBjb25zdCBsaXN0ID0gZmliZXIuY29udGV4dERlcGVuZGVuY2llcztcbiAgICBpZiAobGlzdCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIGxldCBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdDtcbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQgJiZcbiAgICAgICAgICAoZGVwZW5kZW5jeS5vYnNlcnZlZEJpdHMgJiBjaGFuZ2VkQml0cykgIT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gTWF0Y2ghIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGlzIGZpYmVyLlxuXG4gICAgICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gY3JlYXRlVXBkYXRlKHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICAgIC8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbiAgICAgICAgICAgIC8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3NcbiAgICAgICAgICAgIC8vIHdvcnRoIGZpeGluZy5cbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpYmVyLmV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWx0ZXJuYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPCByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgICAgICAgLy8gTWFyayB0aGUgZXhwaXJhdGlvbiB0aW1lIG9uIHRoZSBsaXN0LCB0b28uXG4gICAgICAgICAgaWYgKGxpc3QuZXhwaXJhdGlvblRpbWUgPCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgbGlzdC5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAvLyBEb24ndCBzY2FuIGRlZXBlciBpZiB0aGlzIGlzIGEgbWF0Y2hpbmcgcHJvdmlkZXJcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLnR5cGUgPyBudWxsIDogZmliZXIuY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgJiZcbiAgICAgIGZpYmVyLnRhZyA9PT0gRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50XG4gICAgKSB7XG4gICAgICAvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IGlzIGluIHRoaXMgc3VidHJlZSwgd2UgZG9uJ3Qga25vd1xuICAgICAgLy8gaWYgaXQgd2lsbCBoYXZlIGFueSBjb250ZXh0IGNvbnN1bWVycyBpbiBpdC4gVGhlIGJlc3Qgd2UgY2FuIGRvIGlzXG4gICAgICAvLyBtYXJrIGl0IGFzIGhhdmluZyB1cGRhdGVzIG9uIGl0cyBjaGlsZHJlbi5cbiAgICAgIGlmIChmaWJlci5leHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBsZXQgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgaWYgKFxuICAgICAgICBhbHRlcm5hdGUgIT09IG51bGwgJiZcbiAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICkge1xuICAgICAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBwYXNzaW5nIHRoaXMgZmliZXIgYXMgdGhlIHBhcmVudFxuICAgICAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIHNjaGVkdWxlIHRoaXMgZmliZXIgYXMgaGF2aW5nIHdvcmtcbiAgICAgIC8vIG9uIGl0cyBjaGlsZHJlbi4gV2UnbGwgdXNlIHRoZSBjaGlsZEV4cGlyYXRpb25UaW1lIG9uXG4gICAgICAvLyB0aGlzIGZpYmVyIHRvIGluZGljYXRlIHRoYXQgYSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgICAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNoaWxkLiBUcmF2ZXJzZSB0byBuZXh0IHNpYmxpbmcuXG4gICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgIHdoaWxlIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IHZvaWQge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG4gIGNvbnN0IGN1cnJlbnREZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5jb250ZXh0RGVwZW5kZW5jaWVzO1xuICBpZiAoXG4gICAgY3VycmVudERlcGVuZGVuY2llcyAhPT0gbnVsbCAmJlxuICAgIGN1cnJlbnREZXBlbmRlbmNpZXMuZXhwaXJhdGlvblRpbWUgPj0gcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKSB7XG4gICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuICB3b3JrSW5Qcm9ncmVzcy5jb250ZXh0RGVwZW5kZW5jaWVzID0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRDb250ZXh0PFQ+KFxuICBjb250ZXh0OiBSZWFjdENvbnRleHQ8VD4sXG4gIG9ic2VydmVkQml0czogdm9pZCB8IG51bWJlciB8IGJvb2xlYW4sXG4pOiBUIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG4gICAgd2FybmluZyhcbiAgICAgICFpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWLFxuICAgICAgJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgK1xuICAgICAgICAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArXG4gICAgICAgICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArXG4gICAgICAgICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPT09IGNvbnRleHQpIHtcbiAgICAvLyBOb3RoaW5nIHRvIGRvLiBXZSBhbHJlYWR5IG9ic2VydmUgZXZlcnl0aGluZyBpbiB0aGlzIGNvbnRleHQuXG4gIH0gZWxzZSBpZiAob2JzZXJ2ZWRCaXRzID09PSBmYWxzZSB8fCBvYnNlcnZlZEJpdHMgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgb2JzZXJ2ZSBhbnkgdXBkYXRlcy5cbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzb2x2ZWRPYnNlcnZlZEJpdHM7IC8vIEF2b2lkIGRlb3B0aW5nIG9uIG9ic2VydmFibGUgYXJndW1lbnRzIG9yIGhldGVyb2dlbmVvdXMgdHlwZXMuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9ic2VydmVkQml0cyAhPT0gJ251bWJlcicgfHxcbiAgICAgIG9ic2VydmVkQml0cyA9PT0gTUFYX1NJR05FRF8zMV9CSVRfSU5UXG4gICAgKSB7XG4gICAgICAvLyBPYnNlcnZlIGFsbCB1cGRhdGVzLlxuICAgICAgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gKChjb250ZXh0OiBhbnkpOiBSZWFjdENvbnRleHQ8bWl4ZWQ+KTtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlZE9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cztcbiAgICB9XG5cbiAgICBsZXQgY29udGV4dEl0ZW0gPSB7XG4gICAgICBjb250ZXh0OiAoKGNvbnRleHQ6IGFueSk6IFJlYWN0Q29udGV4dDxtaXhlZD4pLFxuICAgICAgb2JzZXJ2ZWRCaXRzOiByZXNvbHZlZE9ic2VydmVkQml0cyxcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgfTtcblxuICAgIGlmIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPT09IG51bGwpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgIT09IG51bGwsXG4gICAgICAgICdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICtcbiAgICAgICAgICAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArXG4gICAgICAgICAgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICtcbiAgICAgICAgICAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nLFxuICAgICAgKTtcblxuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY29udGV4dEl0ZW07XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5jb250ZXh0RGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBmaXJzdDogY29udGV4dEl0ZW0sXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgYSBuZXcgY29udGV4dCBpdGVtLlxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0SXRlbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzUHJpbWFyeVJlbmRlcmVyID8gY29udGV4dC5fY3VycmVudFZhbHVlIDogY29udGV4dC5fY3VycmVudFZhbHVlMjtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJOZXdDb250ZXh0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge1xuICBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlLFxufSBmcm9tICdzaGFyZWQvUmVhY3RUcmVlVHJhdmVyc2FsJztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuaW1wb3J0IHtnZXRMaXN0ZW5lcn0gZnJvbSAnLi9FdmVudFBsdWdpbkh1Yic7XG5pbXBvcnQgYWNjdW11bGF0ZUludG8gZnJvbSAnLi9hY2N1bXVsYXRlSW50byc7XG5pbXBvcnQgZm9yRWFjaEFjY3VtdWxhdGVkIGZyb20gJy4vZm9yRWFjaEFjY3VtdWxhdGVkJztcblxudHlwZSBQcm9wYWdhdGlvblBoYXNlcyA9ICdidWJibGVkJyB8ICdjYXB0dXJlZCc7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlOiBQcm9wYWdhdGlvblBoYXNlcykge1xuICBjb25zdCByZWdpc3RyYXRpb25OYW1lID1cbiAgICBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKTtcbiAgfVxuICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyxcbiAgICAgIGxpc3RlbmVyLFxuICAgICk7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBjb25zdCB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgY29uc3QgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBnZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgdHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgY29uc3QgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKFxuICAgICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsXG4gICAgICAgIGxpc3RlbmVyLFxuICAgICAgKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL2V2ZW50cy9FdmVudFByb3BhZ2F0b3JzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcbmltcG9ydCB0eXBlIHtTdGFja0N1cnNvcn0gZnJvbSAnLi9SZWFjdEZpYmVyU3RhY2snO1xuXG5pbXBvcnQge2lzRmliZXJNb3VudGVkfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3JlZmxlY3Rpb24nO1xuaW1wb3J0IHtDbGFzc0NvbXBvbmVudCwgSG9zdFJvb3R9IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCBnZXRDb21wb25lbnROYW1lIGZyb20gJ3NoYXJlZC9nZXRDb21wb25lbnROYW1lJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5pbXBvcnQgY2hlY2tQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcyc7XG5cbmltcG9ydCB7c2V0Q3VycmVudFBoYXNlLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2fSBmcm9tICcuL1JlYWN0Q3VycmVudEZpYmVyJztcbmltcG9ydCB7c3RhcnRQaGFzZVRpbWVyLCBzdG9wUGhhc2VUaW1lcn0gZnJvbSAnLi9SZWFjdERlYnVnRmliZXJQZXJmJztcbmltcG9ydCB7Y3JlYXRlQ3Vyc29yLCBwdXNoLCBwb3B9IGZyb20gJy4vUmVhY3RGaWJlclN0YWNrJztcblxubGV0IHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxuaWYgKF9fREVWX18pIHtcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbmV4cG9ydCBjb25zdCBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcbmlmIChfX0RFVl9fKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbmxldCBjb250ZXh0U3RhY2tDdXJzb3I6IFN0YWNrQ3Vyc29yPE9iamVjdD4gPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5sZXQgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcjogU3RhY2tDdXJzb3I8Ym9vbGVhbj4gPSBjcmVhdGVDdXJzb3IoZmFsc2UpO1xuLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxubGV0IHByZXZpb3VzQ29udGV4dDogT2JqZWN0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQoXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgQ29tcG9uZW50OiBGdW5jdGlvbixcbiAgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyOiBib29sZWFuLFxuKTogT2JqZWN0IHtcbiAgaWYgKGRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlciAmJiBpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnRleHQoXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgdW5tYXNrZWRDb250ZXh0OiBPYmplY3QsXG4gIG1hc2tlZENvbnRleHQ6IE9iamVjdCxcbik6IHZvaWQge1xuICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQgPSBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIHVubWFza2VkQ29udGV4dDogT2JqZWN0LFxuKTogT2JqZWN0IHtcbiAgY29uc3QgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIGNvbnN0IGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKFxuICAgIGluc3RhbmNlICYmXG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0XG4gICkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIGNvbnN0IGNvbnRleHQgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICBjb250ZXh0VHlwZXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgJ2NvbnRleHQnLFxuICAgICAgbmFtZSxcbiAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYsXG4gICAgKTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZTogRnVuY3Rpb24pOiBib29sZWFuIHtcbiAgY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dChmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXI6IEZpYmVyKTogdm9pZCB7XG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChcbiAgZmliZXI6IEZpYmVyLFxuICBjb250ZXh0OiBPYmplY3QsXG4gIGRpZENoYW5nZTogYm9vbGVhbixcbik6IHZvaWQge1xuICBpbnZhcmlhbnQoXG4gICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiAnICtcbiAgICAgICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICk7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChcbiAgZmliZXI6IEZpYmVyLFxuICB0eXBlOiBhbnksXG4gIHBhcmVudENvbnRleHQ6IE9iamVjdCxcbik6IE9iamVjdCB7XG4gIGNvbnN0IGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICBjb25zdCBjaGlsZENvbnRleHRUeXBlcyA9IHR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBjb25zdCBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgK1xuICAgICAgICAgICAgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICtcbiAgICAgICAgICAgICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsXG4gICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIGxldCBjaGlsZENvbnRleHQ7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgc2V0Q3VycmVudFBoYXNlKCdnZXRDaGlsZENvbnRleHQnKTtcbiAgfVxuICBzdGFydFBoYXNlVGltZXIoZmliZXIsICdnZXRDaGlsZENvbnRleHQnKTtcbiAgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAobGV0IGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLFxuICAgICAgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bicsXG4gICAgICBjb250ZXh0S2V5LFxuICAgICk7XG4gIH1cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICBjaGlsZENvbnRleHRUeXBlcyxcbiAgICAgIGNoaWxkQ29udGV4dCxcbiAgICAgICdjaGlsZCBjb250ZXh0JyxcbiAgICAgIG5hbWUsXG4gICAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgICAgLy8gY29udGV4dCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlLiBUaGUgc3RhY2sgd2lsbCBiZSBtaXNzaW5nXG4gICAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2LFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gey4uLnBhcmVudENvbnRleHQsIC4uLmNoaWxkQ29udGV4dH07XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3M6IEZpYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIGNvbnN0IG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID1cbiAgICAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQpIHx8XG4gICAgZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHVzaChcbiAgICBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLFxuICAgIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcihcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICB0eXBlOiBhbnksXG4gIGRpZENoYW5nZTogYm9vbGVhbixcbik6IHZvaWQge1xuICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW52YXJpYW50KFxuICAgIGluc3RhbmNlLFxuICAgICdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuICcgK1xuICAgICAgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgKTtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgY29uc3QgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHR5cGUsXG4gICAgICBwcmV2aW91c0NvbnRleHQsXG4gICAgKTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyOiBGaWJlcik6IE9iamVjdCB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgaW52YXJpYW50KFxuICAgIGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50LFxuICAgICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiAnICtcbiAgICAgICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICk7XG5cbiAgbGV0IG5vZGUgPSBmaWJlcjtcbiAgZG8ge1xuICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDoge1xuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBub2RlLnR5cGU7XG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH0gd2hpbGUgKG5vZGUgIT09IG51bGwpO1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuICcgK1xuICAgICAgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgKTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0VW5tYXNrZWRDb250ZXh0LFxuICBjYWNoZUNvbnRleHQsXG4gIGdldE1hc2tlZENvbnRleHQsXG4gIGhhc0NvbnRleHRDaGFuZ2VkLFxuICBwb3BDb250ZXh0LFxuICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QsXG4gIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QsXG4gIHByb2Nlc3NDaGlsZENvbnRleHQsXG4gIGlzQ29udGV4dFByb3ZpZGVyLFxuICBwdXNoQ29udGV4dFByb3ZpZGVyLFxuICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyLFxuICBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyQ29udGV4dC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvbnN0IFJlYWN0ID0gcmVxdWlyZSgnLi9zcmMvUmVhY3QnKTtcbmltcG9ydCBSZWFjdCBmcm9tICcuL3NyYy9SZWFjdCdcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmRlZmF1bHQgfHwgUmVhY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vc3JjL1RyYWNpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvVHJhY2luZ1N1YnNjcmlwdGlvbnMnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2NoZWR1bGVyL3RyYWNpbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge3JldGhyb3dDYXVnaHRFcnJvcn0gZnJvbSAnc2hhcmVkL1JlYWN0RXJyb3JVdGlscyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuXG5pbXBvcnQge1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUsXG4gIHBsdWdpbnMsXG59IGZyb20gJy4vRXZlbnRQbHVnaW5SZWdpc3RyeSc7XG5pbXBvcnQge1xuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUsXG59IGZyb20gJy4vRXZlbnRQbHVnaW5VdGlscyc7XG5pbXBvcnQgYWNjdW11bGF0ZUludG8gZnJvbSAnLi9hY2N1bXVsYXRlSW50byc7XG5pbXBvcnQgZm9yRWFjaEFjY3VtdWxhdGVkIGZyb20gJy4vZm9yRWFjaEFjY3VtdWxhdGVkJztcblxuaW1wb3J0IHR5cGUge1BsdWdpbk1vZHVsZX0gZnJvbSAnLi9QbHVnaW5Nb2R1bGVUeXBlJztcbmltcG9ydCB0eXBlIHtSZWFjdFN5bnRoZXRpY0V2ZW50fSBmcm9tICcuL1JlYWN0U3ludGhldGljRXZlbnRUeXBlJztcbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlcic7XG5pbXBvcnQgdHlwZSB7QW55TmF0aXZlRXZlbnR9IGZyb20gJy4vUGx1Z2luTW9kdWxlVHlwZSc7XG5pbXBvcnQgdHlwZSB7VG9wTGV2ZWxUeXBlfSBmcm9tICcuL1RvcExldmVsRXZlbnRUeXBlcyc7XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG5sZXQgZXZlbnRRdWV1ZTogPyhBcnJheTxSZWFjdFN5bnRoZXRpY0V2ZW50PiB8IFJlYWN0U3ludGhldGljRXZlbnQpID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbihldmVudDogUmVhY3RTeW50aGV0aWNFdmVudCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gKFxuICAgIHRhZyA9PT0gJ2J1dHRvbicgfHxcbiAgICB0YWcgPT09ICdpbnB1dCcgfHxcbiAgICB0YWcgPT09ICdzZWxlY3QnIHx8XG4gICAgdGFnID09PSAndGV4dGFyZWEnXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBpbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0OiBGaWJlciwgcmVnaXN0cmF0aW9uTmFtZTogc3RyaW5nKSB7XG4gIGxldCBsaXN0ZW5lcjtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgY29uc3Qgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0LnR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGludmFyaWFudChcbiAgICAhbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nLFxuICAgICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsXG4gICAgcmVnaXN0cmF0aW9uTmFtZSxcbiAgICB0eXBlb2YgbGlzdGVuZXIsXG4gICk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gKlxuICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyhcbiAgdG9wTGV2ZWxUeXBlOiBUb3BMZXZlbFR5cGUsXG4gIHRhcmdldEluc3Q6IG51bGwgfCBGaWJlcixcbiAgbmF0aXZlRXZlbnQ6IEFueU5hdGl2ZUV2ZW50LFxuICBuYXRpdmVFdmVudFRhcmdldDogRXZlbnRUYXJnZXQsXG4pOiBBcnJheTxSZWFjdFN5bnRoZXRpY0V2ZW50PiB8IFJlYWN0U3ludGhldGljRXZlbnQgfCBudWxsIHtcbiAgbGV0IGV2ZW50cyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICBjb25zdCBwb3NzaWJsZVBsdWdpbjogUGx1Z2luTW9kdWxlPEFueU5hdGl2ZUV2ZW50PiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICBjb25zdCBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKFxuICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgIHRhcmdldEluc3QsXG4gICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgICAgICk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkV2ZW50c0luQmF0Y2goXG4gIGV2ZW50czogQXJyYXk8UmVhY3RTeW50aGV0aWNFdmVudD4gfCBSZWFjdFN5bnRoZXRpY0V2ZW50IHwgbnVsbCxcbikge1xuICBpZiAoZXZlbnRzICE9PSBudWxsKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cblxuICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgY29uc3QgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gIGludmFyaWFudChcbiAgICAhZXZlbnRRdWV1ZSxcbiAgICAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgK1xuICAgICAgJ2FuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJyxcbiAgKTtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIHJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaChcbiAgdG9wTGV2ZWxUeXBlOiBUb3BMZXZlbFR5cGUsXG4gIHRhcmdldEluc3Q6IG51bGwgfCBGaWJlcixcbiAgbmF0aXZlRXZlbnQ6IEFueU5hdGl2ZUV2ZW50LFxuICBuYXRpdmVFdmVudFRhcmdldDogRXZlbnRUYXJnZXQsXG4pIHtcbiAgY29uc3QgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyhcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgKTtcbiAgcnVuRXZlbnRzSW5CYXRjaChldmVudHMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvZXZlbnRzL0V2ZW50UGx1Z2luSHViLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtEaXNwYXRjaENvbmZpZ30gZnJvbSAnLi9SZWFjdFN5bnRoZXRpY0V2ZW50VHlwZSc7XG5pbXBvcnQgdHlwZSB7XG4gIEFueU5hdGl2ZUV2ZW50LFxuICBQbHVnaW5OYW1lLFxuICBQbHVnaW5Nb2R1bGUsXG59IGZyb20gJy4vUGx1Z2luTW9kdWxlVHlwZSc7XG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5cbnR5cGUgTmFtZXNUb1BsdWdpbnMgPSB7W2tleTogUGx1Z2luTmFtZV06IFBsdWdpbk1vZHVsZTxBbnlOYXRpdmVFdmVudD59O1xudHlwZSBFdmVudFBsdWdpbk9yZGVyID0gbnVsbCB8IEFycmF5PFBsdWdpbk5hbWU+O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xubGV0IGV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG5jb25zdCBuYW1lc1RvUGx1Z2luczogTmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk6IHZvaWQge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgY29uc3QgcGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgY29uc3QgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgaW52YXJpYW50KFxuICAgICAgcGx1Z2luSW5kZXggPiAtMSxcbiAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gJyArXG4gICAgICAgICd0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsXG4gICAgICBwbHVnaW5OYW1lLFxuICAgICk7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgcGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMsXG4gICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgJyArXG4gICAgICAgICdtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsXG4gICAgICBwbHVnaW5OYW1lLFxuICAgICk7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgY29uc3QgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHB1Ymxpc2hFdmVudEZvclBsdWdpbihcbiAgICAgICAgICBwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSxcbiAgICAgICAgICBwbHVnaW5Nb2R1bGUsXG4gICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICApLFxuICAgICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJyxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBwbHVnaW5OYW1lLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKFxuICBkaXNwYXRjaENvbmZpZzogRGlzcGF0Y2hDb25maWcsXG4gIHBsdWdpbk1vZHVsZTogUGx1Z2luTW9kdWxlPEFueU5hdGl2ZUV2ZW50PixcbiAgZXZlbnROYW1lOiBzdHJpbmcsXG4pOiBib29sZWFuIHtcbiAgaW52YXJpYW50KFxuICAgICFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSxcbiAgICAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgK1xuICAgICAgJ2V2ZW50IG5hbWUsIGAlc2AuJyxcbiAgICBldmVudE5hbWUsXG4gICk7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgY29uc3QgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yIChjb25zdCBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShcbiAgICAgICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lLFxuICAgICAgICAgIHBsdWdpbk1vZHVsZSxcbiAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShcbiAgICAgIGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICBwbHVnaW5Nb2R1bGUsXG4gICAgICBldmVudE5hbWUsXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoXG4gIHJlZ2lzdHJhdGlvbk5hbWU6IHN0cmluZyxcbiAgcGx1Z2luTW9kdWxlOiBQbHVnaW5Nb2R1bGU8QW55TmF0aXZlRXZlbnQ+LFxuICBldmVudE5hbWU6IHN0cmluZyxcbik6IHZvaWQge1xuICBpbnZhcmlhbnQoXG4gICAgIXJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdLFxuICAgICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArXG4gICAgICAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJyxcbiAgICByZWdpc3RyYXRpb25OYW1lLFxuICApO1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9XG4gICAgcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbmV4cG9ydCBjb25zdCBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiBfX0RFVl9fLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBfX0RFVl9fID8ge30gOiAobnVsbDogYW55KTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiBfX0RFVl9fXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbk9yZGVyKFxuICBpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luT3JkZXIsXG4pOiB2b2lkIHtcbiAgaW52YXJpYW50KFxuICAgICFldmVudFBsdWdpbk9yZGVyLFxuICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArXG4gICAgICAnb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicsXG4gICk7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKFxuICBpbmplY3RlZE5hbWVzVG9QbHVnaW5zOiBOYW1lc1RvUGx1Z2lucyxcbik6IHZvaWQge1xuICBsZXQgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAoY29uc3QgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICBpZiAoXG4gICAgICAhbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHxcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBwbHVnaW5Nb2R1bGVcbiAgICApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdLFxuICAgICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgJyArXG4gICAgICAgICAgJ3VzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJyxcbiAgICAgICAgcGx1Z2luTmFtZSxcbiAgICAgICk7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9ldmVudHMvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbnR5cGUgUHJvcGVydHlUeXBlID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNjtcblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5leHBvcnQgY29uc3QgUkVTRVJWRUQgPSAwO1xuXG4vLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd2hpdGVsaXN0IGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cbmV4cG9ydCBjb25zdCBTVFJJTkcgPSAxO1xuXG4vLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cbmV4cG9ydCBjb25zdCBCT09MRUFOSVNIX1NUUklORyA9IDI7XG5cbi8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuZXhwb3J0IGNvbnN0IEJPT0xFQU4gPSAzO1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBPVkVSTE9BREVEX0JPT0xFQU4gPSA0O1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5leHBvcnQgY29uc3QgTlVNRVJJQyA9IDU7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbmV4cG9ydCBjb25zdCBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlJbmZvID0ge3xcbiAgK2FjY2VwdHNCb29sZWFuczogYm9vbGVhbixcbiAgK2F0dHJpYnV0ZU5hbWU6IHN0cmluZyxcbiAgK2F0dHJpYnV0ZU5hbWVzcGFjZTogc3RyaW5nIHwgbnVsbCxcbiAgK211c3RVc2VQcm9wZXJ0eTogYm9vbGVhbixcbiAgK3Byb3BlcnR5TmFtZTogc3RyaW5nLFxuICArdHlwZTogUHJvcGVydHlUeXBlLFxufH07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbmV4cG9ydCBjb25zdCBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID1cbiAgJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5leHBvcnQgY29uc3QgQVRUUklCVVRFX05BTUVfQ0hBUiA9XG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnO1xuXG5leHBvcnQgY29uc3QgSURfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdGlkJztcbmV4cG9ydCBjb25zdCBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbmV4cG9ydCBjb25zdCBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoXG4gICdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyxcbik7XG5cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmNvbnN0IHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShcbiAgbmFtZTogc3RyaW5nLFxuICBwcm9wZXJ0eUluZm86IFByb3BlcnR5SW5mbyB8IG51bGwsXG4gIGlzQ3VzdG9tQ29tcG9uZW50VGFnOiBib29sZWFuLFxuKTogYm9vbGVhbiB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoXG4gICAgbmFtZS5sZW5ndGggPiAyICYmXG4gICAgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmXG4gICAgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKFxuICBuYW1lOiBzdHJpbmcsXG4gIHZhbHVlOiBtaXhlZCxcbiAgcHJvcGVydHlJbmZvOiBQcm9wZXJ0eUluZm8gfCBudWxsLFxuICBpc0N1c3RvbUNvbXBvbmVudFRhZzogYm9vbGVhbixcbik6IGJvb2xlYW4ge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuICAgIGNhc2UgJ3N5bWJvbCc6IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOiB7XG4gICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgIHJldHVybiBwcmVmaXggIT09ICdkYXRhLScgJiYgcHJlZml4ICE9PSAnYXJpYS0nO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGUoXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IG1peGVkLFxuICBwcm9wZXJ0eUluZm86IFByb3BlcnR5SW5mbyB8IG51bGwsXG4gIGlzQ3VzdG9tQ29tcG9uZW50VGFnOiBib29sZWFuLFxuKTogYm9vbGVhbiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgcHJvcGVydHlJbmZvLFxuICAgICAgaXNDdXN0b21Db21wb25lbnRUYWcsXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAocHJvcGVydHlJbmZvLnR5cGUpIHtcbiAgICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuICAgICAgY2FzZSBQT1NJVElWRV9OVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpIHx8ICh2YWx1ZTogYW55KSA8IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lOiBzdHJpbmcpOiBQcm9wZXJ0eUluZm8gfCBudWxsIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKFxuICBuYW1lOiBzdHJpbmcsXG4gIHR5cGU6IFByb3BlcnR5VHlwZSxcbiAgbXVzdFVzZVByb3BlcnR5OiBib29sZWFuLFxuICBhdHRyaWJ1dGVOYW1lOiBzdHJpbmcsXG4gIGF0dHJpYnV0ZU5hbWVzcGFjZTogc3RyaW5nIHwgbnVsbCxcbikge1xuICB0aGlzLmFjY2VwdHNCb29sZWFucyA9XG4gICAgdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHxcbiAgICB0eXBlID09PSBCT09MRUFOIHx8XG4gICAgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgdGhpcy5tdXN0VXNlUHJvcGVydHkgPSBtdXN0VXNlUHJvcGVydHk7XG4gIHRoaXMucHJvcGVydHlOYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5jb25zdCBwcm9wZXJ0aWVzID0ge307XG5cbi8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuW1xuICAnY2hpbGRyZW4nLFxuICAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICAvLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4gIC8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4gIC8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4gICdkZWZhdWx0VmFsdWUnLFxuICAnZGVmYXVsdENoZWNrZWQnLFxuICAnaW5uZXJIVE1MJyxcbiAgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICAnc3R5bGUnLFxuXS5mb3JFYWNoKG5hbWUgPT4ge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChcbiAgICBuYW1lLFxuICAgIFJFU0VSVkVELFxuICAgIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gICAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gICk7XG59KTtcblxuLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5bXG4gIFsnYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLFxuICBbJ2NsYXNzTmFtZScsICdjbGFzcyddLFxuICBbJ2h0bWxGb3InLCAnZm9yJ10sXG4gIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXSxcbl0uZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZU5hbWVdKSA9PiB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKFxuICAgIG5hbWUsXG4gICAgU1RSSU5HLFxuICAgIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gICAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gICk7XG59KTtcblxuLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChuYW1lID0+IHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoXG4gICAgbmFtZSxcbiAgICBCT09MRUFOSVNIX1NUUklORyxcbiAgICBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gICAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gICAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gICk7XG59KTtcblxuLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuW1xuICAnYXV0b1JldmVyc2UnLFxuICAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICdmb2N1c2FibGUnLFxuICAncHJlc2VydmVBbHBoYScsXG5dLmZvckVhY2gobmFtZSA9PiB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKFxuICAgIG5hbWUsXG4gICAgQk9PTEVBTklTSF9TVFJJTkcsXG4gICAgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICAgIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5bXG4gICdhbGxvd0Z1bGxTY3JlZW4nLFxuICAnYXN5bmMnLFxuICAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4gIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgJ2F1dG9Gb2N1cycsXG4gICdhdXRvUGxheScsXG4gICdjb250cm9scycsXG4gICdkZWZhdWx0JyxcbiAgJ2RlZmVyJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgJ2hpZGRlbicsXG4gICdsb29wJyxcbiAgJ25vTW9kdWxlJyxcbiAgJ25vVmFsaWRhdGUnLFxuICAnb3BlbicsXG4gICdwbGF5c0lubGluZScsXG4gICdyZWFkT25seScsXG4gICdyZXF1aXJlZCcsXG4gICdyZXZlcnNlZCcsXG4gICdzY29wZWQnLFxuICAnc2VhbWxlc3MnLFxuICAvLyBNaWNyb2RhdGFcbiAgJ2l0ZW1TY29wZScsXG5dLmZvckVhY2gobmFtZSA9PiB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKFxuICAgIG5hbWUsXG4gICAgQk9PTEVBTixcbiAgICBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gICAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gICAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gICk7XG59KTtcblxuLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5bXG4gICdjaGVja2VkJyxcbiAgLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuICAnbXVsdGlwbGUnLFxuICAnbXV0ZWQnLFxuICAnc2VsZWN0ZWQnLFxuXG4gIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuICAvLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbiAgLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChuYW1lID0+IHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoXG4gICAgbmFtZSxcbiAgICBCT09MRUFOLFxuICAgIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICAgIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cbltcbiAgJ2NhcHR1cmUnLFxuICAnZG93bmxvYWQnLFxuXG4gIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuICAvLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbiAgLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChuYW1lID0+IHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoXG4gICAgbmFtZSxcbiAgICBPVkVSTE9BREVEX0JPT0xFQU4sXG4gICAgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICAgIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuW1xuICAnY29scycsXG4gICdyb3dzJyxcbiAgJ3NpemUnLFxuICAnc3BhbicsXG5cbiAgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4gIC8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuICAvLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKG5hbWUgPT4ge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChcbiAgICBuYW1lLFxuICAgIFBPU0lUSVZFX05VTUVSSUMsXG4gICAgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICAgIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChuYW1lID0+IHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoXG4gICAgbmFtZSxcbiAgICBOVU1FUklDLFxuICAgIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgKTtcbn0pO1xuXG5jb25zdCBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcbmNvbnN0IGNhcGl0YWxpemUgPSB0b2tlbiA9PiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCB3aGl0ZWxpc3QuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcHBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuW1xuICAnYWNjZW50LWhlaWdodCcsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICAnYXJhYmljLWZvcm0nLFxuICAnYmFzZWxpbmUtc2hpZnQnLFxuICAnY2FwLWhlaWdodCcsXG4gICdjbGlwLXBhdGgnLFxuICAnY2xpcC1ydWxlJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgJ2NvbG9yLXByb2ZpbGUnLFxuICAnY29sb3ItcmVuZGVyaW5nJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcbiAgJ2ZpbGwtb3BhY2l0eScsXG4gICdmaWxsLXJ1bGUnLFxuICAnZmxvb2QtY29sb3InLFxuICAnZmxvb2Qtb3BhY2l0eScsXG4gICdmb250LWZhbWlseScsXG4gICdmb250LXNpemUnLFxuICAnZm9udC1zaXplLWFkanVzdCcsXG4gICdmb250LXN0cmV0Y2gnLFxuICAnZm9udC1zdHlsZScsXG4gICdmb250LXZhcmlhbnQnLFxuICAnZm9udC13ZWlnaHQnLFxuICAnZ2x5cGgtbmFtZScsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgJ2hvcml6LWFkdi14JyxcbiAgJ2hvcml6LW9yaWdpbi14JyxcbiAgJ2ltYWdlLXJlbmRlcmluZycsXG4gICdsZXR0ZXItc3BhY2luZycsXG4gICdsaWdodGluZy1jb2xvcicsXG4gICdtYXJrZXItZW5kJyxcbiAgJ21hcmtlci1taWQnLFxuICAnbWFya2VyLXN0YXJ0JyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcycsXG4gICdwYWludC1vcmRlcicsXG4gICdwYW5vc2UtMScsXG4gICdwb2ludGVyLWV2ZW50cycsXG4gICdyZW5kZXJpbmctaW50ZW50JyxcbiAgJ3NoYXBlLXJlbmRlcmluZycsXG4gICdzdG9wLWNvbG9yJyxcbiAgJ3N0b3Atb3BhY2l0eScsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgJ3N0cm9rZS13aWR0aCcsXG4gICd0ZXh0LWFuY2hvcicsXG4gICd0ZXh0LWRlY29yYXRpb24nLFxuICAndGV4dC1yZW5kZXJpbmcnLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnLFxuICAndW5pY29kZS1iaWRpJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnLFxuICAndW5pdHMtcGVyLWVtJyxcbiAgJ3YtYWxwaGFiZXRpYycsXG4gICd2LWhhbmdpbmcnLFxuICAndi1pZGVvZ3JhcGhpYycsXG4gICd2LW1hdGhlbWF0aWNhbCcsXG4gICd2ZWN0b3ItZWZmZWN0JyxcbiAgJ3ZlcnQtYWR2LXknLFxuICAndmVydC1vcmlnaW4teCcsXG4gICd2ZXJ0LW9yaWdpbi15JyxcbiAgJ3dvcmQtc3BhY2luZycsXG4gICd3cml0aW5nLW1vZGUnLFxuICAneG1sbnM6eGxpbmsnLFxuICAneC1oZWlnaHQnLFxuXG4gIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuICAvLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbiAgLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChhdHRyaWJ1dGVOYW1lID0+IHtcbiAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKFxuICAgIG5hbWUsXG4gICAgU1RSSU5HLFxuICAgIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgICBhdHRyaWJ1dGVOYW1lLFxuICAgIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICApO1xufSk7XG5cbi8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5bXG4gICd4bGluazphY3R1YXRlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnLFxuICAneGxpbms6aHJlZicsXG4gICd4bGluazpyb2xlJyxcbiAgJ3hsaW5rOnNob3cnLFxuICAneGxpbms6dGl0bGUnLFxuICAneGxpbms6dHlwZScsXG5cbiAgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4gIC8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuICAvLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGF0dHJpYnV0ZU5hbWUgPT4ge1xuICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoXG4gICAgbmFtZSxcbiAgICBTVFJJTkcsXG4gICAgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICApO1xufSk7XG5cbi8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuW1xuICAneG1sOmJhc2UnLFxuICAneG1sOmxhbmcnLFxuICAneG1sOnNwYWNlJyxcblxuICAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbiAgLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIC8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goYXR0cmlidXRlTmFtZSA9PiB7XG4gIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChcbiAgICBuYW1lLFxuICAgIFNUUklORyxcbiAgICBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gICAgYXR0cmlidXRlTmFtZSxcbiAgICAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyxcbiAgKTtcbn0pO1xuXG4vLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblsndGFiSW5kZXgnLCAnY3Jvc3NPcmlnaW4nXS5mb3JFYWNoKGF0dHJpYnV0ZU5hbWUgPT4ge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChcbiAgICBhdHRyaWJ1dGVOYW1lLFxuICAgIFNUUklORyxcbiAgICBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gICAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gICAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gICk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0RPTVByb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgU3ludGhldGljVUlFdmVudCBmcm9tICcuL1N5bnRoZXRpY1VJRXZlbnQnO1xuaW1wb3J0IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSBmcm9tICcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZSc7XG5cbmxldCBwcmV2aW91c1NjcmVlblggPSAwO1xubGV0IHByZXZpb3VzU2NyZWVuWSA9IDA7XG4vLyBVc2UgZmxhZ3MgdG8gc2lnbmFsIG1vdmVtZW50WC9ZIGhhcyBhbHJlYWR5IGJlZW4gc2V0XG5sZXQgaXNNb3ZlbWVudFhTZXQgPSBmYWxzZTtcbmxldCBpc01vdmVtZW50WVNldCA9IGZhbHNlO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbmNvbnN0IFN5bnRoZXRpY01vdXNlRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIHBhZ2VYOiBudWxsLFxuICBwYWdlWTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IG51bGwsXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHxcbiAgICAgIChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudFxuICAgICAgICA/IGV2ZW50LnRvRWxlbWVudFxuICAgICAgICA6IGV2ZW50LmZyb21FbGVtZW50KVxuICAgICk7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFg7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NyZWVuWCA9IHByZXZpb3VzU2NyZWVuWDtcbiAgICBwcmV2aW91c1NjcmVlblggPSBldmVudC5zY3JlZW5YO1xuXG4gICAgaWYgKCFpc01vdmVtZW50WFNldCkge1xuICAgICAgaXNNb3ZlbWVudFhTZXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnID8gZXZlbnQuc2NyZWVuWCAtIHNjcmVlblggOiAwO1xuICB9LFxuICBtb3ZlbWVudFk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFknIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRZO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcmVlblkgPSBwcmV2aW91c1NjcmVlblk7XG4gICAgcHJldmlvdXNTY3JlZW5ZID0gZXZlbnQuc2NyZWVuWTtcblxuICAgIGlmICghaXNNb3ZlbWVudFlTZXQpIHtcbiAgICAgIGlzTW92ZW1lbnRZU2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGV2ZW50LnNjcmVlblkgLSBzY3JlZW5ZIDogMDtcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTeW50aGV0aWNNb3VzZUV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljTW91c2VFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IFN5bnRoZXRpY0V2ZW50IGZyb20gJ2V2ZW50cy9TeW50aGV0aWNFdmVudCc7XG5cbmNvbnN0IFN5bnRoZXRpY1VJRXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGwsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU3ludGhldGljVUlFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY1VJRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuXG5pbXBvcnQge2VuYWJsZVVzZXJUaW1pbmdBUEl9IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5pbXBvcnQgZ2V0Q29tcG9uZW50TmFtZSBmcm9tICdzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZSc7XG5pbXBvcnQge1xuICBIb3N0Um9vdCxcbiAgSG9zdENvbXBvbmVudCxcbiAgSG9zdFRleHQsXG4gIEhvc3RQb3J0YWwsXG4gIEZyYWdtZW50LFxuICBDb250ZXh0UHJvdmlkZXIsXG4gIENvbnRleHRDb25zdW1lcixcbiAgTW9kZSxcbiAgU3VzcGVuc2VDb21wb25lbnQsXG4gIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0V29ya1RhZ3MnO1xuXG50eXBlIE1lYXN1cmVtZW50UGhhc2UgPVxuICB8ICdjb21wb25lbnRXaWxsTW91bnQnXG4gIHwgJ2NvbXBvbmVudFdpbGxVbm1vdW50J1xuICB8ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJ1xuICB8ICdzaG91bGRDb21wb25lbnRVcGRhdGUnXG4gIHwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnXG4gIHwgJ2NvbXBvbmVudERpZFVwZGF0ZSdcbiAgfCAnY29tcG9uZW50RGlkTW91bnQnXG4gIHwgJ2dldENoaWxkQ29udGV4dCdcbiAgfCAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUnO1xuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxuY29uc3QgcmVhY3RFbW9qaSA9ICdcXHUyNjlCJztcbmNvbnN0IHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbmNvbnN0IHN1cHBvcnRzVXNlclRpbWluZyA9XG4gIHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xubGV0IGN1cnJlbnRGaWJlcjogRmliZXIgfCBudWxsID0gbnVsbDtcbi8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgdXNlciBjb2RlLCB3aGljaCBmaWJlciBhbmQgbWV0aG9kIGlzIGl0P1xuLy8gUmV1c2luZyBgY3VycmVudEZpYmVyYCB3b3VsZCBiZSBjb25mdXNpbmcgZm9yIHRoaXMgYmVjYXVzZSB1c2VyIGNvZGUgZmliZXJcbi8vIGNhbiBjaGFuZ2UgZHVyaW5nIGNvbW1pdCBwaGFzZSB0b28sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHVud2luZCBpdCAoc2luY2Vcbi8vIGxpZmVjeWNsZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSBkb24ndCByZXNlbWJsZSBhIHRyZWUpLlxubGV0IGN1cnJlbnRQaGFzZTogTWVhc3VyZW1lbnRQaGFzZSB8IG51bGwgPSBudWxsO1xubGV0IGN1cnJlbnRQaGFzZUZpYmVyOiBGaWJlciB8IG51bGwgPSBudWxsO1xuLy8gRGlkIGxpZmVjeWNsZSBob29rIHNjaGVkdWxlIGFuIHVwZGF0ZT8gVGhpcyBpcyBvZnRlbiBhIHBlcmZvcm1hbmNlIHByb2JsZW0sXG4vLyBzbyB3ZSB3aWxsIGtlZXAgdHJhY2sgb2YgaXQsIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXBvcnQuXG4vLyBUcmFjayBjb21taXRzIGNhdXNlZCBieSBjYXNjYWRpbmcgdXBkYXRlcy5cbmxldCBpc0NvbW1pdHRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbmxldCBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQ6IGJvb2xlYW4gPSBmYWxzZTtcbmxldCBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZTogYm9vbGVhbiA9IGZhbHNlO1xubGV0IGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3A6IG51bWJlciA9IDA7XG5sZXQgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ6IG51bWJlciA9IDA7XG5sZXQgaXNXYWl0aW5nRm9yQ2FsbGJhY2s6IGJvb2xlYW4gPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG5jb25zdCBsYWJlbHNJbkN1cnJlbnRDb21taXQ6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG5jb25zdCBmb3JtYXRNYXJrTmFtZSA9IChtYXJrTmFtZTogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBgJHtyZWFjdEVtb2ppfSAke21hcmtOYW1lfWA7XG59O1xuXG5jb25zdCBmb3JtYXRMYWJlbCA9IChsYWJlbDogc3RyaW5nLCB3YXJuaW5nOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gIGNvbnN0IHByZWZpeCA9IHdhcm5pbmcgPyBgJHt3YXJuaW5nRW1vaml9IGAgOiBgJHtyZWFjdEVtb2ppfSBgO1xuICBjb25zdCBzdWZmaXggPSB3YXJuaW5nID8gYCBXYXJuaW5nOiAke3dhcm5pbmd9YCA6ICcnO1xuICByZXR1cm4gYCR7cHJlZml4fSR7bGFiZWx9JHtzdWZmaXh9YDtcbn07XG5cbmNvbnN0IGJlZ2luTWFyayA9IChtYXJrTmFtZTogc3RyaW5nKSA9PiB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbmNvbnN0IGNsZWFyTWFyayA9IChtYXJrTmFtZTogc3RyaW5nKSA9PiB7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbmNvbnN0IGVuZE1hcmsgPSAobGFiZWw6IHN0cmluZywgbWFya05hbWU6IHN0cmluZywgd2FybmluZzogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICBjb25zdCBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgY29uc3QgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAgIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gICAgLy8gRG9uJ3QgcGlsZSBvbiB3aXRoIG1vcmUgZXJyb3JzLlxuICB9XG4gIC8vIENsZWFyIG1hcmtzIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGdyb3dpbmcgYnVmZmVyLlxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhmb3JtYXR0ZWRMYWJlbCk7XG59O1xuXG5jb25zdCBnZXRGaWJlck1hcmtOYW1lID0gKGxhYmVsOiBzdHJpbmcsIGRlYnVnSUQ6IG51bWJlcikgPT4ge1xuICByZXR1cm4gYCR7bGFiZWx9ICgjJHtkZWJ1Z0lEfSlgO1xufTtcblxuY29uc3QgZ2V0RmliZXJMYWJlbCA9IChcbiAgY29tcG9uZW50TmFtZTogc3RyaW5nLFxuICBpc01vdW50ZWQ6IGJvb2xlYW4sXG4gIHBoYXNlOiBNZWFzdXJlbWVudFBoYXNlIHwgbnVsbCxcbikgPT4ge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gYCR7Y29tcG9uZW50TmFtZX0gWyR7aXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnfV1gO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBvc2l0ZSBjb21wb25lbnQgbWV0aG9kcy5cbiAgICByZXR1cm4gYCR7Y29tcG9uZW50TmFtZX0uJHtwaGFzZX1gO1xuICB9XG59O1xuXG5jb25zdCBiZWdpbkZpYmVyTWFyayA9IChcbiAgZmliZXI6IEZpYmVyLFxuICBwaGFzZTogTWVhc3VyZW1lbnRQaGFzZSB8IG51bGwsXG4pOiBib29sZWFuID0+IHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuICBjb25zdCBkZWJ1Z0lEID0gKChmaWJlci5fZGVidWdJRDogYW55KTogbnVtYmVyKTtcbiAgY29uc3QgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICBjb25zdCBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICBjb25zdCBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGNsZWFyRmliZXJNYXJrID0gKGZpYmVyOiBGaWJlciwgcGhhc2U6IE1lYXN1cmVtZW50UGhhc2UgfCBudWxsKSA9PiB7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJztcbiAgY29uc3QgZGVidWdJRCA9ICgoZmliZXIuX2RlYnVnSUQ6IGFueSk6IG51bWJlcik7XG4gIGNvbnN0IGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgY29uc3QgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICBjb25zdCBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxuY29uc3QgZW5kRmliZXJNYXJrID0gKFxuICBmaWJlcjogRmliZXIsXG4gIHBoYXNlOiBNZWFzdXJlbWVudFBoYXNlIHwgbnVsbCxcbiAgd2FybmluZzogc3RyaW5nIHwgbnVsbCxcbikgPT4ge1xuICBjb25zdCBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG4gIGNvbnN0IGRlYnVnSUQgPSAoKGZpYmVyLl9kZWJ1Z0lEOiBhbnkpOiBudW1iZXIpO1xuICBjb25zdCBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIGNvbnN0IGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgY29uc3QgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmcpO1xufTtcblxuY29uc3Qgc2hvdWxkSWdub3JlRmliZXIgPSAoZmliZXI6IEZpYmVyKTogYm9vbGVhbiA9PiB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSAoKSA9PiB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG5jb25zdCBwYXVzZVRpbWVycyA9ICgpID0+IHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIGxldCBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxufTtcblxuY29uc3QgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkgPSAoZmliZXI6IEZpYmVyKSA9PiB7XG4gIGlmIChmaWJlci5yZXR1cm4gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlci5yZXR1cm4pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxuY29uc3QgcmVzdW1lVGltZXJzID0gKCkgPT4ge1xuICAvLyBSZXN1bWVzIGFsbCBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGFjdGl2ZSBkdXJpbmcgdGhlIGxhc3QgZGVmZXJyZWQgbG9vcC5cbiAgaWYgKGN1cnJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5KGN1cnJlbnRGaWJlcik7XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRFZmZlY3QoKTogdm9pZCB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKTogdm9pZCB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgY3VycmVudFBoYXNlICE9PSBudWxsICYmXG4gICAgICBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmXG4gICAgICBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJ1xuICAgICkge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoXG4gIGRpZEV4cGlyZTogYm9vbGVhbixcbiAgZXhwaXJhdGlvblRpbWU6IG51bWJlcixcbik6IHZvaWQge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4gICAgICBjb25zdCB3YXJuaW5nID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKFxuICAgICAgICBgKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uIHdpbGwgZm9yY2UgZmx1c2ggaW4gJHtleHBpcmF0aW9uVGltZX0gbXMpYCxcbiAgICAgICAgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLFxuICAgICAgICB3YXJuaW5nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyOiBGaWJlcik6IHZvaWQge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXI6IEZpYmVyKTogdm9pZCB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY29uc3Qgd2FybmluZyA9XG4gICAgICBmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50IHx8XG4gICAgICBmaWJlci50YWcgPT09IERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudFxuICAgICAgICA/ICdSZW5kZXJpbmcgd2FzIHN1c3BlbmRlZCdcbiAgICAgICAgOiAnQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgdGhpcyBlcnJvciBib3VuZGFyeSc7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCB3YXJuaW5nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyOiBGaWJlciwgcGhhc2U6IE1lYXN1cmVtZW50UGhhc2UpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQaGFzZVRpbWVyKCk6IHZvaWQge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHdhcm5pbmcgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZVxuICAgICAgICA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJ1xuICAgICAgICA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcms6IEZpYmVyIHwgbnVsbCk6IHZvaWQge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcFdvcmtMb29wVGltZXIoXG4gIGludGVycnVwdGVkQnk6IEZpYmVyIHwgbnVsbCxcbiAgZGlkQ29tcGxldGVSb290OiBib29sZWFuLFxuKTogdm9pZCB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHdhcm5pbmcgPSBudWxsO1xuICAgIGlmIChpbnRlcnJ1cHRlZEJ5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaW50ZXJydXB0ZWRCeS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHdhcm5pbmcgPSAnQSB0b3AtbGV2ZWwgdXBkYXRlIGludGVycnVwdGVkIHRoZSBwcmV2aW91cyByZW5kZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeS50eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmcgPSBgQW4gdXBkYXRlIHRvICR7Y29tcG9uZW50TmFtZX0gaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcmA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgbGV0IGxhYmVsID0gZGlkQ29tcGxldGVSb290XG4gICAgICA/ICcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbjogQ29tcGxldGVkIFJvb3QpJ1xuICAgICAgOiAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb246IFlpZWxkZWQpJztcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKGxhYmVsLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKTogdm9pZCB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BDb21taXRUaW1lcigpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB3YXJuaW5nID0gbnVsbDtcbiAgICBpZiAoaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0KSB7XG4gICAgICB3YXJuaW5nID0gJ0xpZmVjeWNsZSBob29rIHNjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDApIHtcbiAgICAgIHdhcm5pbmcgPSAnQ2F1c2VkIGJ5IGEgY2FzY2FkaW5nIHVwZGF0ZSBpbiBlYXJsaWVyIGNvbW1pdCc7XG4gICAgfVxuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3ArKztcbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcblxuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJywgJyhDb21taXR0aW5nIENoYW5nZXMpJywgd2FybmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTogdm9pZCB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgU25hcHNob3QgRWZmZWN0cyknKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCk6IHZvaWQge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoXG4gICAgICBgKENvbW1pdHRpbmcgU25hcHNob3QgRWZmZWN0czogJHtjb3VudH0gVG90YWwpYCxcbiAgICAgICcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzKScsXG4gICAgICBudWxsLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk6IHZvaWQge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoXG4gICAgICBgKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzOiAke2NvdW50fSBUb3RhbClgLFxuICAgICAgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLFxuICAgICAgbnVsbCxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpOiB2b2lkIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKFxuICAgICAgYChDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAke2NvdW50fSBUb3RhbClgLFxuICAgICAgJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScsXG4gICAgICBudWxsLFxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RGVidWdGaWJlclBlcmYuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1JlYWN0RWxlbWVudCwgU291cmNlfSBmcm9tICdzaGFyZWQvUmVhY3RFbGVtZW50VHlwZSc7XG5pbXBvcnQgdHlwZSB7UmVhY3RGcmFnbWVudCwgUmVhY3RQb3J0YWwsIFJlZk9iamVjdH0gZnJvbSAnc2hhcmVkL1JlYWN0VHlwZXMnO1xuaW1wb3J0IHR5cGUge1dvcmtUYWd9IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCB0eXBlIHtUeXBlT2ZNb2RlfSBmcm9tICcuL1JlYWN0VHlwZU9mTW9kZSc7XG5pbXBvcnQgdHlwZSB7U2lkZUVmZmVjdFRhZ30gZnJvbSAnc2hhcmVkL1JlYWN0U2lkZUVmZmVjdFRhZ3MnO1xuaW1wb3J0IHR5cGUge0V4cGlyYXRpb25UaW1lfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQgdHlwZSB7VXBkYXRlUXVldWV9IGZyb20gJy4vUmVhY3RVcGRhdGVRdWV1ZSc7XG5pbXBvcnQgdHlwZSB7Q29udGV4dERlcGVuZGVuY3lMaXN0fSBmcm9tICcuL1JlYWN0RmliZXJOZXdDb250ZXh0JztcblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcbmltcG9ydCB7ZW5hYmxlUHJvZmlsZXJUaW1lcn0gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcbmltcG9ydCB7Tm9FZmZlY3R9IGZyb20gJ3NoYXJlZC9SZWFjdFNpZGVFZmZlY3RUYWdzJztcbmltcG9ydCB7XG4gIEluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gIENsYXNzQ29tcG9uZW50LFxuICBIb3N0Um9vdCxcbiAgSG9zdENvbXBvbmVudCxcbiAgSG9zdFRleHQsXG4gIEhvc3RQb3J0YWwsXG4gIEZvcndhcmRSZWYsXG4gIEZyYWdtZW50LFxuICBNb2RlLFxuICBDb250ZXh0UHJvdmlkZXIsXG4gIENvbnRleHRDb25zdW1lcixcbiAgUHJvZmlsZXIsXG4gIFN1c3BlbnNlQ29tcG9uZW50LFxuICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgTWVtb0NvbXBvbmVudCxcbiAgTGF6eUNvbXBvbmVudCxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0V29ya1RhZ3MnO1xuaW1wb3J0IGdldENvbXBvbmVudE5hbWUgZnJvbSAnc2hhcmVkL2dldENvbXBvbmVudE5hbWUnO1xuXG5pbXBvcnQge2lzRGV2VG9vbHNQcmVzZW50fSBmcm9tICcuL1JlYWN0RmliZXJEZXZUb29sc0hvb2snO1xuaW1wb3J0IHtOb1dvcmt9IGZyb20gJy4vUmVhY3RGaWJlckV4cGlyYXRpb25UaW1lJztcbmltcG9ydCB7XG4gIE5vQ29udGV4dCxcbiAgQ29uY3VycmVudE1vZGUsXG4gIFByb2ZpbGVNb2RlLFxuICBTdHJpY3RNb2RlLFxufSBmcm9tICcuL1JlYWN0VHlwZU9mTW9kZSc7XG5pbXBvcnQge1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuICBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICBSRUFDVF9DT05URVhUX1RZUEUsXG4gIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFLFxuICBSRUFDVF9TVVNQRU5TRV9UWVBFLFxuICBSRUFDVF9NRU1PX1RZUEUsXG4gIFJFQUNUX0xBWllfVFlQRSxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5cbmxldCBoYXNCYWRNYXBQb2x5ZmlsbDtcblxuaWYgKF9fREVWX18pIHtcbiAgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICBjb25zdCB0ZXN0TWFwID0gbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgY29uc3QgdGVzdFNldCA9IG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgUm9sbHVwIHRvIG5vdCBjb25zaWRlciB0aGVzZSB1bnVzZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE3NzFcbiAgICAvLyBUT0RPOiB3ZSBjYW4gcmVtb3ZlIHRoZXNlIGlmIFJvbGx1cCBmaXhlcyB0aGUgYnVnLlxuICAgIHRlc3RNYXAuc2V0KDAsIDApO1xuICAgIHRlc3RTZXQuYWRkKDApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuZXhwb3J0IHR5cGUgRmliZXIgPSB7fFxuICAvLyBUaGVzZSBmaXJzdCBmaWVsZHMgYXJlIGNvbmNlcHR1YWxseSBtZW1iZXJzIG9mIGFuIEluc3RhbmNlLiBUaGlzIHVzZWQgdG9cbiAgLy8gYmUgc3BsaXQgaW50byBhIHNlcGFyYXRlIHR5cGUgYW5kIGludGVyc2VjdGVkIHdpdGggdGhlIG90aGVyIEZpYmVyIGZpZWxkcyxcbiAgLy8gYnV0IHVudGlsIEZsb3cgZml4ZXMgaXRzIGludGVyc2VjdGlvbiBidWdzLCB3ZSd2ZSBtZXJnZWQgdGhlbSBpbnRvIGFcbiAgLy8gc2luZ2xlIHR5cGUuXG5cbiAgLy8gQW4gSW5zdGFuY2UgaXMgc2hhcmVkIGJldHdlZW4gYWxsIHZlcnNpb25zIG9mIGEgY29tcG9uZW50LiBXZSBjYW4gZWFzaWx5XG4gIC8vIGJyZWFrIHRoaXMgb3V0IGludG8gYSBzZXBhcmF0ZSBvYmplY3QgdG8gYXZvaWQgY29weWluZyBzbyBtdWNoIHRvIHRoZVxuICAvLyBhbHRlcm5hdGUgdmVyc2lvbnMgb2YgdGhlIHRyZWUuIFdlIHB1dCB0aGlzIG9uIGEgc2luZ2xlIG9iamVjdCBmb3Igbm93IHRvXG4gIC8vIG1pbmltaXplIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIuXG5cbiAgLy8gVGFnIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIGZpYmVyLlxuICB0YWc6IFdvcmtUYWcsXG5cbiAgLy8gVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhpcyBjaGlsZC5cbiAga2V5OiBudWxsIHwgc3RyaW5nLFxuXG4gIC8vIFRoZSB2YWx1ZSBvZiBlbGVtZW50LnR5cGUgd2hpY2ggaXMgdXNlZCB0byBwcmVzZXJ2ZSB0aGUgaWRlbnRpdHkgZHVyaW5nXG4gIC8vIHJlY29uY2lsaWF0aW9uIG9mIHRoaXMgY2hpbGQuXG4gIGVsZW1lbnRUeXBlOiBhbnksXG5cbiAgLy8gVGhlIHJlc29sdmVkIGZ1bmN0aW9uL2NsYXNzLyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWJlci5cbiAgdHlwZTogYW55LFxuXG4gIC8vIFRoZSBsb2NhbCBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWJlci5cbiAgc3RhdGVOb2RlOiBhbnksXG5cbiAgLy8gQ29uY2VwdHVhbCBhbGlhc2VzXG4gIC8vIHBhcmVudCA6IEluc3RhbmNlIC0+IHJldHVybiBUaGUgcGFyZW50IGhhcHBlbnMgdG8gYmUgdGhlIHNhbWUgYXMgdGhlXG4gIC8vIHJldHVybiBmaWJlciBzaW5jZSB3ZSd2ZSBtZXJnZWQgdGhlIGZpYmVyIGFuZCBpbnN0YW5jZS5cblxuICAvLyBSZW1haW5pbmcgZmllbGRzIGJlbG9uZyB0byBGaWJlclxuXG4gIC8vIFRoZSBGaWJlciB0byByZXR1cm4gdG8gYWZ0ZXIgZmluaXNoaW5nIHByb2Nlc3NpbmcgdGhpcyBvbmUuXG4gIC8vIFRoaXMgaXMgZWZmZWN0aXZlbHkgdGhlIHBhcmVudCwgYnV0IHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBwYXJlbnRzICh0d28pXG4gIC8vIHNvIHRoaXMgaXMgb25seSB0aGUgcGFyZW50IG9mIHRoZSB0aGluZyB3ZSdyZSBjdXJyZW50bHkgcHJvY2Vzc2luZy5cbiAgLy8gSXQgaXMgY29uY2VwdHVhbGx5IHRoZSBzYW1lIGFzIHRoZSByZXR1cm4gYWRkcmVzcyBvZiBhIHN0YWNrIGZyYW1lLlxuICByZXR1cm46IEZpYmVyIHwgbnVsbCxcblxuICAvLyBTaW5nbHkgTGlua2VkIExpc3QgVHJlZSBTdHJ1Y3R1cmUuXG4gIGNoaWxkOiBGaWJlciB8IG51bGwsXG4gIHNpYmxpbmc6IEZpYmVyIHwgbnVsbCxcbiAgaW5kZXg6IG51bWJlcixcblxuICAvLyBUaGUgcmVmIGxhc3QgdXNlZCB0byBhdHRhY2ggdGhpcyBub2RlLlxuICAvLyBJJ2xsIGF2b2lkIGFkZGluZyBhbiBvd25lciBmaWVsZCBmb3IgcHJvZCBhbmQgbW9kZWwgdGhhdCBhcyBmdW5jdGlvbnMuXG4gIHJlZjogbnVsbCB8ICgoKGhhbmRsZTogbWl4ZWQpID0+IHZvaWQpICYge19zdHJpbmdSZWY6ID9zdHJpbmd9KSB8IFJlZk9iamVjdCxcblxuICAvLyBJbnB1dCBpcyB0aGUgZGF0YSBjb21pbmcgaW50byBwcm9jZXNzIHRoaXMgZmliZXIuIEFyZ3VtZW50cy4gUHJvcHMuXG4gIHBlbmRpbmdQcm9wczogYW55LCAvLyBUaGlzIHR5cGUgd2lsbCBiZSBtb3JlIHNwZWNpZmljIG9uY2Ugd2Ugb3ZlcmxvYWQgdGhlIHRhZy5cbiAgbWVtb2l6ZWRQcm9wczogYW55LCAvLyBUaGUgcHJvcHMgdXNlZCB0byBjcmVhdGUgdGhlIG91dHB1dC5cblxuICAvLyBBIHF1ZXVlIG9mIHN0YXRlIHVwZGF0ZXMgYW5kIGNhbGxiYWNrcy5cbiAgdXBkYXRlUXVldWU6IFVwZGF0ZVF1ZXVlPGFueT4gfCBudWxsLFxuXG4gIC8vIFRoZSBzdGF0ZSB1c2VkIHRvIGNyZWF0ZSB0aGUgb3V0cHV0XG4gIG1lbW9pemVkU3RhdGU6IGFueSxcblxuICAvLyBBIGxpbmtlZC1saXN0IG9mIGNvbnRleHRzIHRoYXQgdGhpcyBmaWJlciBkZXBlbmRzIG9uXG4gIGNvbnRleHREZXBlbmRlbmNpZXM6IENvbnRleHREZXBlbmRlbmN5TGlzdCB8IG51bGwsXG5cbiAgLy8gQml0ZmllbGQgdGhhdCBkZXNjcmliZXMgcHJvcGVydGllcyBhYm91dCB0aGUgZmliZXIgYW5kIGl0cyBzdWJ0cmVlLiBFLmcuXG4gIC8vIHRoZSBDb25jdXJyZW50TW9kZSBmbGFnIGluZGljYXRlcyB3aGV0aGVyIHRoZSBzdWJ0cmVlIHNob3VsZCBiZSBhc3luYy1ieS1cbiAgLy8gZGVmYXVsdC4gV2hlbiBhIGZpYmVyIGlzIGNyZWF0ZWQsIGl0IGluaGVyaXRzIHRoZSBtb2RlIG9mIGl0c1xuICAvLyBwYXJlbnQuIEFkZGl0aW9uYWwgZmxhZ3MgY2FuIGJlIHNldCBhdCBjcmVhdGlvbiB0aW1lLCBidXQgYWZ0ZXIgdGhhdCB0aGVcbiAgLy8gdmFsdWUgc2hvdWxkIHJlbWFpbiB1bmNoYW5nZWQgdGhyb3VnaG91dCB0aGUgZmliZXIncyBsaWZldGltZSwgcGFydGljdWxhcmx5XG4gIC8vIGJlZm9yZSBpdHMgY2hpbGQgZmliZXJzIGFyZSBjcmVhdGVkLlxuICBtb2RlOiBUeXBlT2ZNb2RlLFxuXG4gIC8vIEVmZmVjdFxuICBlZmZlY3RUYWc6IFNpZGVFZmZlY3RUYWcsXG5cbiAgLy8gU2luZ2x5IGxpbmtlZCBsaXN0IGZhc3QgcGF0aCB0byB0aGUgbmV4dCBmaWJlciB3aXRoIHNpZGUtZWZmZWN0cy5cbiAgbmV4dEVmZmVjdDogRmliZXIgfCBudWxsLFxuXG4gIC8vIFRoZSBmaXJzdCBhbmQgbGFzdCBmaWJlciB3aXRoIHNpZGUtZWZmZWN0IHdpdGhpbiB0aGlzIHN1YnRyZWUuIFRoaXMgYWxsb3dzXG4gIC8vIHVzIHRvIHJldXNlIGEgc2xpY2Ugb2YgdGhlIGxpbmtlZCBsaXN0IHdoZW4gd2UgcmV1c2UgdGhlIHdvcmsgZG9uZSB3aXRoaW5cbiAgLy8gdGhpcyBmaWJlci5cbiAgZmlyc3RFZmZlY3Q6IEZpYmVyIHwgbnVsbCxcbiAgbGFzdEVmZmVjdDogRmliZXIgfCBudWxsLFxuXG4gIC8vIFJlcHJlc2VudHMgYSB0aW1lIGluIHRoZSBmdXR1cmUgYnkgd2hpY2ggdGhpcyB3b3JrIHNob3VsZCBiZSBjb21wbGV0ZWQuXG4gIC8vIERvZXMgbm90IGluY2x1ZGUgd29yayBmb3VuZCBpbiBpdHMgc3VidHJlZS5cbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuXG4gIC8vIFRoaXMgaXMgdXNlZCB0byBxdWlja2x5IGRldGVybWluZSBpZiBhIHN1YnRyZWUgaGFzIG5vIHBlbmRpbmcgY2hhbmdlcy5cbiAgY2hpbGRFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG5cbiAgLy8gVGhpcyBpcyBhIHBvb2xlZCB2ZXJzaW9uIG9mIGEgRmliZXIuIEV2ZXJ5IGZpYmVyIHRoYXQgZ2V0cyB1cGRhdGVkIHdpbGxcbiAgLy8gZXZlbnR1YWxseSBoYXZlIGEgcGFpci4gVGhlcmUgYXJlIGNhc2VzIHdoZW4gd2UgY2FuIGNsZWFuIHVwIHBhaXJzIHRvIHNhdmVcbiAgLy8gbWVtb3J5IGlmIHdlIG5lZWQgdG8uXG4gIGFsdGVybmF0ZTogRmliZXIgfCBudWxsLFxuXG4gIC8vIFRpbWUgc3BlbnQgcmVuZGVyaW5nIHRoaXMgRmliZXIgYW5kIGl0cyBkZXNjZW5kYW50cyBmb3IgdGhlIGN1cnJlbnQgdXBkYXRlLlxuICAvLyBUaGlzIHRlbGxzIHVzIGhvdyB3ZWxsIHRoZSB0cmVlIG1ha2VzIHVzZSBvZiBzQ1UgZm9yIG1lbW9pemF0aW9uLlxuICAvLyBJdCBpcyByZXNldCB0byAwIGVhY2ggdGltZSB3ZSByZW5kZXIgYW5kIG9ubHkgdXBkYXRlZCB3aGVuIHdlIGRvbid0IGJhaWxvdXQuXG4gIC8vIFRoaXMgZmllbGQgaXMgb25seSBzZXQgd2hlbiB0aGUgZW5hYmxlUHJvZmlsZXJUaW1lciBmbGFnIGlzIGVuYWJsZWQuXG4gIGFjdHVhbER1cmF0aW9uPzogbnVtYmVyLFxuXG4gIC8vIElmIHRoZSBGaWJlciBpcyBjdXJyZW50bHkgYWN0aXZlIGluIHRoZSBcInJlbmRlclwiIHBoYXNlLFxuICAvLyBUaGlzIG1hcmtzIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSB3b3JrIGJlZ2FuLlxuICAvLyBUaGlzIGZpZWxkIGlzIG9ubHkgc2V0IHdoZW4gdGhlIGVuYWJsZVByb2ZpbGVyVGltZXIgZmxhZyBpcyBlbmFibGVkLlxuICBhY3R1YWxTdGFydFRpbWU/OiBudW1iZXIsXG5cbiAgLy8gRHVyYXRpb24gb2YgdGhlIG1vc3QgcmVjZW50IHJlbmRlciB0aW1lIGZvciB0aGlzIEZpYmVyLlxuICAvLyBUaGlzIHZhbHVlIGlzIG5vdCB1cGRhdGVkIHdoZW4gd2UgYmFpbG91dCBmb3IgbWVtb2l6YXRpb24gcHVycG9zZXMuXG4gIC8vIFRoaXMgZmllbGQgaXMgb25seSBzZXQgd2hlbiB0aGUgZW5hYmxlUHJvZmlsZXJUaW1lciBmbGFnIGlzIGVuYWJsZWQuXG4gIHNlbGZCYXNlRHVyYXRpb24/OiBudW1iZXIsXG5cbiAgLy8gU3VtIG9mIGJhc2UgdGltZXMgZm9yIGFsbCBkZXNjZWRlbnRzIG9mIHRoaXMgRmliZXIuXG4gIC8vIFRoaXMgdmFsdWUgYnViYmxlcyB1cCBkdXJpbmcgdGhlIFwiY29tcGxldGVcIiBwaGFzZS5cbiAgLy8gVGhpcyBmaWVsZCBpcyBvbmx5IHNldCB3aGVuIHRoZSBlbmFibGVQcm9maWxlclRpbWVyIGZsYWcgaXMgZW5hYmxlZC5cbiAgdHJlZUJhc2VEdXJhdGlvbj86IG51bWJlcixcblxuICAvLyBDb25jZXB0dWFsIGFsaWFzZXNcbiAgLy8gd29ya0luUHJvZ3Jlc3MgOiBGaWJlciAtPiAgYWx0ZXJuYXRlIFRoZSBhbHRlcm5hdGUgdXNlZCBmb3IgcmV1c2UgaGFwcGVuc1xuICAvLyB0byBiZSB0aGUgc2FtZSBhcyB3b3JrIGluIHByb2dyZXNzLlxuICAvLyBfX0RFVl9fIG9ubHlcbiAgX2RlYnVnSUQ/OiBudW1iZXIsXG4gIF9kZWJ1Z1NvdXJjZT86IFNvdXJjZSB8IG51bGwsXG4gIF9kZWJ1Z093bmVyPzogRmliZXIgfCBudWxsLFxuICBfZGVidWdJc0N1cnJlbnRseVRpbWluZz86IGJvb2xlYW4sXG58fTtcblxubGV0IGRlYnVnQ291bnRlcjtcblxuaWYgKF9fREVWX18pIHtcbiAgZGVidWdDb3VudGVyID0gMTtcbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKFxuICB0YWc6IFdvcmtUYWcsXG4gIHBlbmRpbmdQcm9wczogbWl4ZWQsXG4gIGtleTogbnVsbCB8IHN0cmluZyxcbiAgbW9kZTogVHlwZU9mTW9kZSxcbikge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuZWxlbWVudFR5cGUgPSBudWxsO1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgLy8gRmliZXJcbiAgdGhpcy5yZXR1cm4gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG5cbiAgdGhpcy5yZWYgPSBudWxsO1xuXG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0RGVwZW5kZW5jaWVzID0gbnVsbDtcblxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB0aGlzLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuXG4gICAgLy8gSXQncyBva2F5IHRvIHJlcGxhY2UgdGhlIGluaXRpYWwgZG91YmxlcyB3aXRoIHNtaXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgLy8gVGhpcyB3b24ndCB0cmlnZ2VyIHRoZSBwZXJmb3JtYW5jZSBjbGlmZiBtZW50aW9uZWQgYWJvdmUsXG4gICAgLy8gYW5kIGl0IHNpbXBsaWZpZXMgb3RoZXIgcHJvZmlsZXIgY29kZSAoaW5jbHVkaW5nIERldlRvb2xzKS5cbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuY29uc3QgY3JlYXRlRmliZXIgPSBmdW5jdGlvbihcbiAgdGFnOiBXb3JrVGFnLFxuICBwZW5kaW5nUHJvcHM6IG1peGVkLFxuICBrZXk6IG51bGwgfCBzdHJpbmcsXG4gIG1vZGU6IFR5cGVPZk1vZGUsXG4pOiBGaWJlciB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQ6IEZ1bmN0aW9uKSB7XG4gIGNvbnN0IHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlOiBhbnkpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiZcbiAgICB0eXBlLmRlZmF1bHRQcm9wcyA9PT0gdW5kZWZpbmVkXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQ6IEZ1bmN0aW9uKTogV29ya1RhZyB7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpID8gQ2xhc3NDb21wb25lbnQgOiBGdW5jdGlvbkNvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChDb21wb25lbnQgIT09IHVuZGVmaW5lZCAmJiBDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICBjb25zdCAkJHR5cGVvZiA9IENvbXBvbmVudC4kJHR5cGVvZjtcbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAgIHJldHVybiBGb3J3YXJkUmVmO1xuICAgIH1cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBJbmRldGVybWluYXRlQ29tcG9uZW50O1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKFxuICBjdXJyZW50OiBGaWJlcixcbiAgcGVuZGluZ1Byb3BzOiBhbnksXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IEZpYmVyIHtcbiAgbGV0IHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoXG4gICAgICBjdXJyZW50LnRhZyxcbiAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgIGN1cnJlbnQua2V5LFxuICAgICAgY3VycmVudC5tb2RlLFxuICAgICk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPSBjdXJyZW50LmVsZW1lbnRUeXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgcmVzZXQsIHJhdGhlciB0aGFuIGNvcHksIGFjdHVhbER1cmF0aW9uICYgYWN0dWFsU3RhcnRUaW1lLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aW1lIGZyb20gZW5kbGVzc2x5IGFjY3VtdWxhdGluZyBpbiBuZXcgY29tbWl0cy5cbiAgICAgIC8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcbiAgICAgIC8vIEJ1dCB3b3JrcyBmb3IgeWllbGRpbmcgKHRoZSBjb21tb24gY2FzZSkgYW5kIHNob3VsZCBzdXBwb3J0IHJlc3VtaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRFeHBpcmF0aW9uVGltZSA9IGN1cnJlbnQuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBjdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy5jb250ZXh0RGVwZW5kZW5jaWVzID0gY3VycmVudC5jb250ZXh0RGVwZW5kZW5jaWVzO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKGlzQ29uY3VycmVudDogYm9vbGVhbik6IEZpYmVyIHtcbiAgbGV0IG1vZGUgPSBpc0NvbmN1cnJlbnQgPyBDb25jdXJyZW50TW9kZSB8IFN0cmljdE1vZGUgOiBOb0NvbnRleHQ7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gIHR5cGU6IGFueSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcbiAga2V5OiBudWxsIHwgc3RyaW5nLFxuICBwZW5kaW5nUHJvcHM6IGFueSxcbiAgb3duZXI6IG51bGwgfCBGaWJlcixcbiAgbW9kZTogVHlwZU9mTW9kZSxcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogRmliZXIge1xuICBsZXQgZmliZXI7XG5cbiAgbGV0IGZpYmVyVGFnID0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbiAgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG4gIGxldCByZXNvbHZlZFR5cGUgPSB0eXBlO1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgIHBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21Nb2RlKFxuICAgICAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgICAgICBtb2RlIHwgQ29uY3VycmVudE1vZGUgfCBTdHJpY3RNb2RlLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU1vZGUoXG4gICAgICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgICAgIG1vZGUgfCBTdHJpY3RNb2RlLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29uc3VtZXJcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSBNZW1vQ29tcG9uZW50O1xuICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpbmZvID0gJyc7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIHR5cGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaW5mbyArPVxuICAgICAgICAgICAgICAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgK1xuICAgICAgICAgICAgICBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgK1xuICAgICAgICAgICAgICAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkgOiBudWxsO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiAnICtcbiAgICAgICAgICAgICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgK1xuICAgICAgICAgICAgJ2J1dCBnb3Q6ICVzLiVzJyxcbiAgICAgICAgICB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICBlbGVtZW50OiBSZWFjdEVsZW1lbnQsXG4gIG1vZGU6IFR5cGVPZk1vZGUsXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IEZpYmVyIHtcbiAgbGV0IG93bmVyID0gbnVsbDtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIGNvbnN0IGtleSA9IGVsZW1lbnQua2V5O1xuICBjb25zdCBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICBjb25zdCBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICB0eXBlLFxuICAgIGtleSxcbiAgICBwZW5kaW5nUHJvcHMsXG4gICAgb3duZXIsXG4gICAgbW9kZSxcbiAgICBleHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuICByZXR1cm4gZmliZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgZWxlbWVudHM6IFJlYWN0RnJhZ21lbnQsXG4gIG1vZGU6IFR5cGVPZk1vZGUsXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAga2V5OiBudWxsIHwgc3RyaW5nLFxuKTogRmliZXIge1xuICBjb25zdCBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihcbiAgcGVuZGluZ1Byb3BzOiBhbnksXG4gIG1vZGU6IFR5cGVPZk1vZGUsXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAga2V5OiBudWxsIHwgc3RyaW5nLFxuKTogRmliZXIge1xuICBpZiAoX19ERVZfXykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgcGVuZGluZ1Byb3BzLm9uUmVuZGVyICE9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgc3RyaW5nIGFuZCBcIm9uUmVuZGVyXCIgZnVuY3Rpb24gYXMgcHJvcHMnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTtcbiAgLy8gVE9ETzogVGhlIFByb2ZpbGVyIGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tTW9kZShcbiAgcGVuZGluZ1Byb3BzOiBhbnksXG4gIG1vZGU6IFR5cGVPZk1vZGUsXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAga2V5OiBudWxsIHwgc3RyaW5nLFxuKTogRmliZXIge1xuICBjb25zdCBmaWJlciA9IGNyZWF0ZUZpYmVyKE1vZGUsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcblxuICAvLyBUT0RPOiBUaGUgTW9kZSBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgY29uc3QgdHlwZSA9XG4gICAgKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vQ29udGV4dFxuICAgICAgPyBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFXG4gICAgICA6IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IHR5cGU7XG4gIGZpYmVyLnR5cGUgPSB0eXBlO1xuXG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKFxuICBwZW5kaW5nUHJvcHM6IGFueSxcbiAgbW9kZTogVHlwZU9mTW9kZSxcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICBrZXk6IG51bGwgfCBzdHJpbmcsXG4pIHtcbiAgY29uc3QgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuXG4gIC8vIFRPRE86IFRoZSBTdXNwZW5zZUNvbXBvbmVudCBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgY29uc3QgdHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHR5cGU7XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgY29udGVudDogc3RyaW5nLFxuICBtb2RlOiBUeXBlT2ZNb2RlLFxuICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pOiBGaWJlciB7XG4gIGNvbnN0IGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpOiBGaWJlciB7XG4gIGNvbnN0IGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgLy8gVE9ETzogVGhlc2Ugc2hvdWxkIG5vdCBuZWVkIGEgdHlwZS5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSAnREVMRVRFRCc7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgcG9ydGFsOiBSZWFjdFBvcnRhbCxcbiAgbW9kZTogVHlwZU9mTW9kZSxcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogRmliZXIge1xuICBjb25zdCBwZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gIT09IG51bGwgPyBwb3J0YWwuY2hpbGRyZW4gOiBbXTtcbiAgY29uc3QgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb24sXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihcbiAgdGFyZ2V0OiBGaWJlciB8IG51bGwsXG4gIHNvdXJjZTogRmliZXIsXG4pOiBGaWJlciB7XG4gIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIEZpYmVyJ3MgaW5pdGlhbCBwcm9wZXJ0aWVzIHdpbGwgYWx3YXlzIGJlIG92ZXJ3cml0dGVuLlxuICAgIC8vIFdlIG9ubHkgdXNlIGEgRmliZXIgdG8gZW5zdXJlIHRoZSBzYW1lIGhpZGRlbiBjbGFzcyBzbyBERVYgaXNuJ3Qgc2xvdy5cbiAgICB0YXJnZXQgPSBjcmVhdGVGaWJlcihJbmRldGVybWluYXRlQ29tcG9uZW50LCBudWxsLCBudWxsLCBOb0NvbnRleHQpO1xuICB9XG5cbiAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cbiAgdGFyZ2V0LnRhZyA9IHNvdXJjZS50YWc7XG4gIHRhcmdldC5rZXkgPSBzb3VyY2Uua2V5O1xuICB0YXJnZXQuZWxlbWVudFR5cGUgPSBzb3VyY2UuZWxlbWVudFR5cGU7XG4gIHRhcmdldC50eXBlID0gc291cmNlLnR5cGU7XG4gIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuICB0YXJnZXQucmV0dXJuID0gc291cmNlLnJldHVybjtcbiAgdGFyZ2V0LmNoaWxkID0gc291cmNlLmNoaWxkO1xuICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuICB0YXJnZXQuaW5kZXggPSBzb3VyY2UuaW5kZXg7XG4gIHRhcmdldC5yZWYgPSBzb3VyY2UucmVmO1xuICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcbiAgdGFyZ2V0Lm1lbW9pemVkUHJvcHMgPSBzb3VyY2UubWVtb2l6ZWRQcm9wcztcbiAgdGFyZ2V0LnVwZGF0ZVF1ZXVlID0gc291cmNlLnVwZGF0ZVF1ZXVlO1xuICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICB0YXJnZXQuY29udGV4dERlcGVuZGVuY2llcyA9IHNvdXJjZS5jb250ZXh0RGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZWZmZWN0VGFnID0gc291cmNlLmVmZmVjdFRhZztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQuZXhwaXJhdGlvblRpbWUgPSBzb3VyY2UuZXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5jaGlsZEV4cGlyYXRpb25UaW1lID0gc291cmNlLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHRhcmdldC5hY3R1YWxEdXJhdGlvbiA9IHNvdXJjZS5hY3R1YWxEdXJhdGlvbjtcbiAgICB0YXJnZXQuYWN0dWFsU3RhcnRUaW1lID0gc291cmNlLmFjdHVhbFN0YXJ0VGltZTtcbiAgICB0YXJnZXQuc2VsZkJhc2VEdXJhdGlvbiA9IHNvdXJjZS5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHRhcmdldC50cmVlQmFzZUR1cmF0aW9uID0gc291cmNlLnRyZWVCYXNlRHVyYXRpb247XG4gIH1cbiAgdGFyZ2V0Ll9kZWJ1Z0lEID0gc291cmNlLl9kZWJ1Z0lEO1xuICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcbiAgdGFyZ2V0Ll9kZWJ1Z093bmVyID0gc291cmNlLl9kZWJ1Z093bmVyO1xuICB0YXJnZXQuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBzb3VyY2UuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmc7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcbmltcG9ydCB0eXBlIHtCYXRjaCwgRmliZXJSb290fSBmcm9tICcuL1JlYWN0RmliZXJSb290JztcbmltcG9ydCB0eXBlIHtFeHBpcmF0aW9uVGltZX0gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuaW1wb3J0IHR5cGUge0ludGVyYWN0aW9ufSBmcm9tICdzY2hlZHVsZXIvc3JjL1RyYWNpbmcnO1xuXG5pbXBvcnQge1xuICBfX2ludGVyYWN0aW9uc1JlZixcbiAgX19zdWJzY3JpYmVyUmVmLFxuICB1bnN0YWJsZV93cmFwIGFzIFNjaGVkdWxlcl90cmFjaW5nX3dyYXAsXG59IGZyb20gJ3NjaGVkdWxlci90cmFjaW5nJztcbmltcG9ydCB7XG4gIHVuc3RhYmxlX25leHQgYXMgU2NoZWR1bGVyX25leHQsXG4gIHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsIGFzIGdldEN1cnJlbnRQcmlvcml0eUxldmVsLFxuICB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgYXMgcnVuV2l0aFByaW9yaXR5LFxuICB1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSBhcyBJbW1lZGlhdGVQcmlvcml0eSxcbiAgdW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgYXMgVXNlckJsb2NraW5nUHJpb3JpdHksXG4gIHVuc3RhYmxlX05vcm1hbFByaW9yaXR5IGFzIE5vcm1hbFByaW9yaXR5LFxuICB1bnN0YWJsZV9Mb3dQcmlvcml0eSBhcyBMb3dQcmlvcml0eSxcbiAgdW5zdGFibGVfSWRsZVByaW9yaXR5IGFzIElkbGVQcmlvcml0eSxcbn0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjayxcbiAgaGFzQ2F1Z2h0RXJyb3IsXG4gIGNsZWFyQ2F1Z2h0RXJyb3IsXG59IGZyb20gJ3NoYXJlZC9SZWFjdEVycm9yVXRpbHMnO1xuaW1wb3J0IFJlYWN0U2hhcmVkSW50ZXJuYWxzIGZyb20gJ3NoYXJlZC9SZWFjdFNoYXJlZEludGVybmFscyc7XG5pbXBvcnQgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgZnJvbSAnLi9SZWFjdFN0cmljdE1vZGVXYXJuaW5ncyc7XG5pbXBvcnQge1xuICBOb0VmZmVjdCxcbiAgUGVyZm9ybWVkV29yayxcbiAgUGxhY2VtZW50LFxuICBVcGRhdGUsXG4gIFNuYXBzaG90LFxuICBQbGFjZW1lbnRBbmRVcGRhdGUsXG4gIERlbGV0aW9uLFxuICBDb250ZW50UmVzZXQsXG4gIENhbGxiYWNrLFxuICBEaWRDYXB0dXJlLFxuICBSZWYsXG4gIEluY29tcGxldGUsXG4gIEhvc3RFZmZlY3RNYXNrLFxuICBQYXNzaXZlLFxufSBmcm9tICdzaGFyZWQvUmVhY3RTaWRlRWZmZWN0VGFncyc7XG5pbXBvcnQge1xuICBDbGFzc0NvbXBvbmVudCxcbiAgSG9zdENvbXBvbmVudCxcbiAgQ29udGV4dFByb3ZpZGVyLFxuICBGb3J3YXJkUmVmLFxuICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgSG9zdFBvcnRhbCxcbiAgSG9zdFJvb3QsXG4gIE1lbW9Db21wb25lbnQsXG4gIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gIFN1c3BlbnNlQ29tcG9uZW50LFxuICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCB7XG4gIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcsXG4gIGVuYWJsZVByb2ZpbGVyVGltZXIsXG4gIGVuYWJsZVVzZXJUaW1pbmdBUEksXG4gIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrLFxuICB3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyxcbiAgZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcixcbn0gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcbmltcG9ydCBnZXRDb21wb25lbnROYW1lIGZyb20gJ3NoYXJlZC9nZXRDb21wb25lbnROYW1lJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5cbmltcG9ydCBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uIGZyb20gJy4vUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbic7XG5pbXBvcnQge1xuICBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QsXG4gIHBoYXNlIGFzIFJlYWN0Q3VycmVudEZpYmVyUGhhc2UsXG4gIHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXIsXG59IGZyb20gJy4vUmVhY3RDdXJyZW50RmliZXInO1xuaW1wb3J0IHtcbiAgbm93LFxuICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssXG4gIGNhbmNlbERlZmVycmVkQ2FsbGJhY2ssXG4gIHNob3VsZFlpZWxkLFxuICBwcmVwYXJlRm9yQ29tbWl0LFxuICByZXNldEFmdGVyQ29tbWl0LFxuICBzY2hlZHVsZVRpbWVvdXQsXG4gIGNhbmNlbFRpbWVvdXQsXG4gIG5vVGltZW91dCxcbiAgc2NoZWR1bGVQYXNzaXZlRWZmZWN0cyxcbiAgY2FuY2VsUGFzc2l2ZUVmZmVjdHMsXG59IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb25maWcnO1xuaW1wb3J0IHtcbiAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsLFxuICBtYXJrQ29tbWl0dGVkUHJpb3JpdHlMZXZlbHMsXG4gIG1hcmtTdXNwZW5kZWRQcmlvcml0eUxldmVsLFxuICBtYXJrUGluZ2VkUHJpb3JpdHlMZXZlbCxcbiAgaGFzTG93ZXJQcmlvcml0eVdvcmssXG4gIGlzUHJpb3JpdHlMZXZlbFN1c3BlbmRlZCxcbiAgZmluZEVhcmxpZXN0T3V0c3RhbmRpbmdQcmlvcml0eUxldmVsLFxuICBkaWRFeHBpcmVBdEV4cGlyYXRpb25UaW1lLFxufSBmcm9tICcuL1JlYWN0RmliZXJQZW5kaW5nUHJpb3JpdHknO1xuaW1wb3J0IHtcbiAgcmVjb3JkRWZmZWN0LFxuICByZWNvcmRTY2hlZHVsZVVwZGF0ZSxcbiAgc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcixcbiAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyLFxuICBzdGFydFdvcmtUaW1lcixcbiAgc3RvcFdvcmtUaW1lcixcbiAgc3RvcEZhaWxlZFdvcmtUaW1lcixcbiAgc3RhcnRXb3JrTG9vcFRpbWVyLFxuICBzdG9wV29ya0xvb3BUaW1lcixcbiAgc3RhcnRDb21taXRUaW1lcixcbiAgc3RvcENvbW1pdFRpbWVyLFxuICBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyLFxuICBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIsXG4gIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcixcbiAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIsXG4gIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyLFxuICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyLFxufSBmcm9tICcuL1JlYWN0RGVidWdGaWJlclBlcmYnO1xuaW1wb3J0IHtjcmVhdGVXb3JrSW5Qcm9ncmVzcywgYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVZ9IGZyb20gJy4vUmVhY3RGaWJlcic7XG5pbXBvcnQge29uQ29tbWl0Um9vdH0gZnJvbSAnLi9SZWFjdEZpYmVyRGV2VG9vbHNIb29rJztcbmltcG9ydCB7XG4gIE5vV29yayxcbiAgU3luYyxcbiAgTmV2ZXIsXG4gIG1zVG9FeHBpcmF0aW9uVGltZSxcbiAgZXhwaXJhdGlvblRpbWVUb01zLFxuICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICBjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uLFxufSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQge0NvbmN1cnJlbnRNb2RlLCBQcm9maWxlTW9kZSwgTm9Db250ZXh0fSBmcm9tICcuL1JlYWN0VHlwZU9mTW9kZSc7XG5pbXBvcnQge2VucXVldWVVcGRhdGUsIHJlc2V0Q3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlfSBmcm9tICcuL1JlYWN0VXBkYXRlUXVldWUnO1xuaW1wb3J0IHtjcmVhdGVDYXB0dXJlZFZhbHVlfSBmcm9tICcuL1JlYWN0Q2FwdHVyZWRWYWx1ZSc7XG5pbXBvcnQge1xuICBpc0NvbnRleHRQcm92aWRlciBhcyBpc0xlZ2FjeUNvbnRleHRQcm92aWRlcixcbiAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0IGFzIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdCxcbiAgcG9wQ29udGV4dCBhcyBwb3BMZWdhY3lDb250ZXh0LFxufSBmcm9tICcuL1JlYWN0RmliZXJDb250ZXh0JztcbmltcG9ydCB7cG9wUHJvdmlkZXIsIHJlc2V0Q29udGV4dERlcGVuZGVuY2VzfSBmcm9tICcuL1JlYWN0RmliZXJOZXdDb250ZXh0JztcbmltcG9ydCB7cmVzZXRIb29rc30gZnJvbSAnLi9SZWFjdEZpYmVySG9va3MnO1xuaW1wb3J0IHtwb3BIb3N0Q29udGV4dCwgcG9wSG9zdENvbnRhaW5lcn0gZnJvbSAnLi9SZWFjdEZpYmVySG9zdENvbnRleHQnO1xuaW1wb3J0IHtcbiAgcmVjb3JkQ29tbWl0VGltZSxcbiAgc3RhcnRQcm9maWxlclRpbWVyLFxuICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhLFxufSBmcm9tICcuL1JlYWN0UHJvZmlsZXJUaW1lcic7XG5pbXBvcnQge1xuICBjaGVja1RoYXRTdGFja0lzRW1wdHksXG4gIHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldixcbn0gZnJvbSAnLi9SZWFjdEZpYmVyU3RhY2snO1xuaW1wb3J0IHtiZWdpbldvcmt9IGZyb20gJy4vUmVhY3RGaWJlckJlZ2luV29yayc7XG5pbXBvcnQge2NvbXBsZXRlV29ya30gZnJvbSAnLi9SZWFjdEZpYmVyQ29tcGxldGVXb3JrJztcbmltcG9ydCB7XG4gIHRocm93RXhjZXB0aW9uLFxuICB1bndpbmRXb3JrLFxuICB1bndpbmRJbnRlcnJ1cHRlZFdvcmssXG4gIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSxcbiAgY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSxcbn0gZnJvbSAnLi9SZWFjdEZpYmVyVW53aW5kV29yayc7XG5pbXBvcnQge1xuICBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMsXG4gIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gIGNvbW1pdFBsYWNlbWVudCxcbiAgY29tbWl0RGVsZXRpb24sXG4gIGNvbW1pdFdvcmssXG4gIGNvbW1pdExpZmVDeWNsZXMsXG4gIGNvbW1pdEF0dGFjaFJlZixcbiAgY29tbWl0RGV0YWNoUmVmLFxuICBjb21taXRQYXNzaXZlSG9va0VmZmVjdHMsXG59IGZyb20gJy4vUmVhY3RGaWJlckNvbW1pdFdvcmsnO1xuaW1wb3J0IHtDb250ZXh0T25seURpc3BhdGNoZXJ9IGZyb20gJy4vUmVhY3RGaWJlckhvb2tzJztcblxuZXhwb3J0IHR5cGUgVGhlbmFibGUgPSB7XG4gIHRoZW4ocmVzb2x2ZTogKCkgPT4gbWl4ZWQsIHJlamVjdD86ICgpID0+IG1peGVkKTogbWl4ZWQsXG59O1xuXG5jb25zdCB7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgUmVhY3RDdXJyZW50T3duZXJ9ID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5cbmxldCBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb247XG5sZXQgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0O1xubGV0IHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkO1xubGV0IHdhcm5BYm91dEludmFsaWRVcGRhdGVzO1xuXG5pZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAvLyBQcm92aWRlIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2Ugd2hlbiBwcm9kdWN0aW9uK3Byb2ZpbGluZyBidW5kbGUgb2YgZS5nLiByZWFjdC1kb21cbiAgLy8gaXMgdXNlZCB3aXRoIHByb2R1Y3Rpb24gKG5vbi1wcm9maWxpbmcpIGJ1bmRsZSBvZiBzY2hlZHVsZXIvdHJhY2luZ1xuICBpbnZhcmlhbnQoXG4gICAgX19pbnRlcmFjdGlvbnNSZWYgIT0gbnVsbCAmJiBfX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ICE9IG51bGwsXG4gICAgJ0l0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gcnVuIHRoZSBwcm9maWxpbmcgdmVyc2lvbiBvZiBhIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgYHJlYWN0LWRvbS9wcm9maWxpbmdgKSAnICtcbiAgICAgICd3aXRob3V0IGFsc28gcmVwbGFjaW5nIHRoZSBgc2NoZWR1bGVyL3RyYWNpbmdgIG1vZHVsZSB3aXRoIGBzY2hlZHVsZXIvdHJhY2luZy1wcm9maWxpbmdgLiAnICtcbiAgICAgICdZb3VyIGJ1bmRsZXIgbWlnaHQgaGF2ZSBhIHNldHRpbmcgZm9yIGFsaWFzaW5nIGJvdGggbW9kdWxlcy4gJyArXG4gICAgICAnTGVhcm4gbW9yZSBhdCBodHRwOi8vZmIubWUvcmVhY3QtcHJvZmlsaW5nJyxcbiAgKTtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IGZhbHNlO1xuICBjb25zdCBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uKGZpYmVyOiBGaWJlciwgaXNDbGFzczogYm9vbGVhbikge1xuICAgIC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdSZWFjdENvbXBvbmVudCc7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICBcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBcIiArXG4gICAgICAgICdpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gJyArXG4gICAgICAgICdmaXgsIGNhbmNlbCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluICVzLiVzJyxcbiAgICAgIGlzQ2xhc3NcbiAgICAgICAgPyAndGhlIGNvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZCdcbiAgICAgICAgOiAnYSB1c2VFZmZlY3QgY2xlYW51cCBmdW5jdGlvbicsXG4gICAgICBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoZmliZXIpLFxuICAgICk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uKGluc3RhbmNlOiBSZWFjdCRDb21wb25lbnQ8YW55Pikge1xuICAgIHN3aXRjaCAoUmVhY3RDdXJyZW50RmliZXJQaGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScsXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgaWYgKGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICtcbiAgICAgICAgICAgICdgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicsXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVXNlZCB0byBlbnN1cmUgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbiBpcyBtb25vdG9uaWNhbGx5IGRlY3JlYXNpbmcuXG5sZXQgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbjogbnVtYmVyID0gU3luYyAtIDE7XG5cbmxldCBpc1dvcmtpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuLy8gVGhlIG5leHQgd29yayBpbiBwcm9ncmVzcyBmaWJlciB0aGF0IHdlJ3JlIGN1cnJlbnRseSB3b3JraW5nIG9uLlxubGV0IG5leHRVbml0T2ZXb3JrOiBGaWJlciB8IG51bGwgPSBudWxsO1xubGV0IG5leHRSb290OiBGaWJlclJvb3QgfCBudWxsID0gbnVsbDtcbi8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbmxldCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xubGV0IG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNczogbnVtYmVyID0gLTE7XG5sZXQgbmV4dFJlbmRlckRpZEVycm9yOiBib29sZWFuID0gZmFsc2U7XG5cbi8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG5sZXQgbmV4dEVmZmVjdDogRmliZXIgfCBudWxsID0gbnVsbDtcblxubGV0IGlzQ29tbWl0dGluZzogYm9vbGVhbiA9IGZhbHNlO1xubGV0IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzOiBGaWJlclJvb3QgfCBudWxsID0gbnVsbDtcbmxldCBwYXNzaXZlRWZmZWN0Q2FsbGJhY2tIYW5kbGU6ICogPSBudWxsO1xubGV0IHBhc3NpdmVFZmZlY3RDYWxsYmFjazogKiA9IG51bGw7XG5cbmxldCBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZDogU2V0PG1peGVkPiB8IG51bGwgPSBudWxsO1xuXG4vLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbmxldCBpbnRlcnJ1cHRlZEJ5OiBGaWJlciB8IG51bGwgPSBudWxsO1xuXG5sZXQgc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcztcbmxldCByZXBsYXlVbml0T2ZXb3JrO1xubGV0IG1heVJlcGxheUZhaWxlZFVuaXRPZldvcms7XG5sZXQgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrO1xubGV0IG9yaWdpbmFsUmVwbGF5RXJyb3I7XG5sZXQgcmV0aHJvd09yaWdpbmFsRXJyb3I7XG5pZiAoX19ERVZfXyAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgbWF5UmVwbGF5RmFpbGVkVW5pdE9mV29yayA9IHRydWU7XG4gIGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yayA9IGZhbHNlO1xuICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgcmVwbGF5VW5pdE9mV29yayA9IChcbiAgICBmYWlsZWRVbml0T2ZXb3JrOiBGaWJlcixcbiAgICB0aHJvd25WYWx1ZTogbWl4ZWQsXG4gICAgaXNZaWVsZHk6IGJvb2xlYW4sXG4gICkgPT4ge1xuICAgIGlmIChcbiAgICAgIHRocm93blZhbHVlICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgdGhyb3duVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgIC8vIFRPRE86IE5lZWQgdG8gZmlndXJlIG91dCBhIGRpZmZlcmVudCBzdHJhdGVneSBpZi93aGVuIHdlIGFkZFxuICAgICAgLy8gc3VwcG9ydCBmb3IgY2F0Y2hpbmcgb3RoZXIgdHlwZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3NcbiAgICBpZiAoc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiBEb24ndCB0aHJvdyBiZWNhdXNlIHRoaXMgY29kZSBpcyBERVYtb25seS5cbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnQ291bGQgbm90IHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiAnICtcbiAgICAgICAgICAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKFxuICAgICAgZmFpbGVkVW5pdE9mV29yayxcbiAgICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMsXG4gICAgKTtcblxuICAgIHN3aXRjaCAoZmFpbGVkVW5pdE9mV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdChmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gZmFpbGVkVW5pdE9mV29yay50eXBlO1xuICAgICAgICBpZiAoaXNMZWdhY3lDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcExlZ2FjeUNvbnRleHQoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgIHBvcFByb3ZpZGVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVwbGF5IHRoZSBiZWdpbiBwaGFzZS5cbiAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSB0cnVlO1xuICAgIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSB0aHJvd25WYWx1ZTtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgd29ya0xvb3AsIG51bGwsIGlzWWllbGR5KTtcbiAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgY29uc3QgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAocmVwbGF5RXJyb3IgIT0gbnVsbCAmJiB0aHJvd25WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gUmVhZGluZyB0aGUgZXhwYW5kbyBwcm9wZXJ0eSBpcyBpbnRlbnRpb25hbGx5XG4gICAgICAgICAgLy8gaW5zaWRlIGB0cnlgIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBnZXR0ZXIgb3IgUHJveHkuXG4gICAgICAgICAgaWYgKHJlcGxheUVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgICAgIC8vIEFsc28gc3VwcHJlc3MgbG9nZ2luZyBmb3IgdGhlIG9yaWdpbmFsIGVycm9yLlxuICAgICAgICAgICAgKHRocm93blZhbHVlOiBhbnkpLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHtcbiAgICAgICAgICAvLyBJZ25vcmUuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGJlZ2luIHBoYXNlIGRpZCBub3QgZmFpbCB0aGUgc2Vjb25kIHRpbWUsIHNldCB0aGlzIHBvaW50ZXJcbiAgICAgIC8vIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAgbmV4dFVuaXRPZldvcmsgPSBmYWlsZWRVbml0T2ZXb3JrO1xuICAgIH1cbiAgfTtcbiAgcmV0aHJvd09yaWdpbmFsRXJyb3IgPSAoKSA9PiB7XG4gICAgdGhyb3cgb3JpZ2luYWxSZXBsYXlFcnJvcjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdGFjaygpIHtcbiAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgbGV0IGludGVycnVwdGVkV29yayA9IG5leHRVbml0T2ZXb3JrLnJldHVybjtcbiAgICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCk7XG4gIH1cblxuICBuZXh0Um9vdCA9IG51bGw7XG4gIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gLTE7XG4gIG5leHRSZW5kZXJEaWRFcnJvciA9IGZhbHNlO1xuICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEFsbEhvc3RFZmZlY3RzKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgfVxuICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgY29uc3QgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAvLyBlZmZlY3QgdGFnIGFuZCBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cbiAgICBsZXQgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIChQbGFjZW1lbnQgfCBVcGRhdGUgfCBEZWxldGlvbik7XG4gICAgc3dpdGNoIChwcmltYXJ5RWZmZWN0VGFnKSB7XG4gICAgICBjYXNlIFBsYWNlbWVudDoge1xuICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgLy8gZG9lcyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlXG4gICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZToge1xuICAgICAgICAvLyBQbGFjZW1lbnRcbiAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICBjb25zdCBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdFdvcmsoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBVcGRhdGU6IHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBjb21taXRXb3JrKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgRGVsZXRpb246IHtcbiAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGNvbnN0IGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgIGlmIChlZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICBjb25zdCBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRBbGxMaWZlQ3ljbGVzKFxuICBmaW5pc2hlZFJvb3Q6IEZpYmVyUm9vdCxcbiAgY29tbWl0dGVkRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG5cbiAgICBpZiAod2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ3MoKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIH1cbiAgICBjb25zdCBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgIGlmIChlZmZlY3RUYWcgJiAoVXBkYXRlIHwgQ2FsbGJhY2spKSB7XG4gICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgbmV4dEVmZmVjdCxcbiAgICAgICAgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBQYXNzaXZlKSB7XG4gICAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IGZpbmlzaGVkUm9vdDtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICB9XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlRWZmZWN0cyhyb290OiBGaWJlclJvb3QsIGZpcnN0RWZmZWN0OiBGaWJlcik6IHZvaWQge1xuICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG4gIHBhc3NpdmVFZmZlY3RDYWxsYmFja0hhbmRsZSA9IG51bGw7XG4gIHBhc3NpdmVFZmZlY3RDYWxsYmFjayA9IG51bGw7XG5cbiAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSB0byBwcmV2ZW50IHJlLWVudHJhbmN5XG4gIGNvbnN0IHByZXZpb3VzSXNSZW5kZXJpbmcgPSBpc1JlbmRlcmluZztcbiAgaXNSZW5kZXJpbmcgPSB0cnVlO1xuXG4gIGxldCBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgZG8ge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoZWZmZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoZWZmZWN0LmVmZmVjdFRhZyAmIFBhc3NpdmUpIHtcbiAgICAgIGxldCBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdFBhc3NpdmVIb29rRWZmZWN0cywgbnVsbCwgZWZmZWN0KTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29tbWl0UGFzc2l2ZUhvb2tFZmZlY3RzKGVmZmVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZWZmZWN0LCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0RWZmZWN0O1xuICB9IHdoaWxlIChlZmZlY3QgIT09IG51bGwpO1xuICBpZiAoX19ERVZfXykge1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cblxuICBpc1JlbmRlcmluZyA9IHByZXZpb3VzSXNSZW5kZXJpbmc7XG5cbiAgLy8gQ2hlY2sgaWYgd29yayB3YXMgc2NoZWR1bGVkIGJ5IG9uZSBvZiB0aGUgZWZmZWN0c1xuICBjb25zdCByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICBpZiAocm9vdEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICByZXF1ZXN0V29yayhyb290LCByb290RXhwaXJhdGlvblRpbWUpO1xuICB9XG4gIC8vIEZsdXNoIGFueSBzeW5jIHdvcmsgdGhhdCB3YXMgc2NoZWR1bGVkIGJ5IGVmZmVjdHNcbiAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlOiBtaXhlZCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKVxuICApO1xufVxuXG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlOiBtaXhlZCkge1xuICBpZiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPT09IG51bGwpIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICBpZiAocGFzc2l2ZUVmZmVjdENhbGxiYWNrSGFuZGxlICE9PSBudWxsKSB7XG4gICAgY2FuY2VsUGFzc2l2ZUVmZmVjdHMocGFzc2l2ZUVmZmVjdENhbGxiYWNrSGFuZGxlKTtcbiAgfVxuICBpZiAocGFzc2l2ZUVmZmVjdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgLy8gV2UgY2FsbCB0aGUgc2NoZWR1bGVkIGNhbGxiYWNrIGluc3RlYWQgb2YgY29tbWl0UGFzc2l2ZUVmZmVjdHMgZGlyZWN0bHlcbiAgICAvLyB0byBlbnN1cmUgdHJhY2luZyB3b3JrcyBjb3JyZWN0bHkuXG4gICAgcGFzc2l2ZUVmZmVjdENhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290OiBGaWJlclJvb3QsIGZpbmlzaGVkV29yazogRmliZXIpOiB2b2lkIHtcbiAgaXNXb3JraW5nID0gdHJ1ZTtcbiAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gIGludmFyaWFudChcbiAgICByb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yayxcbiAgICAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyAnICtcbiAgICAgICdyZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICtcbiAgICAgICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgKTtcbiAgY29uc3QgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUgPSByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTtcbiAgaW52YXJpYW50KFxuICAgIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmssXG4gICAgJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSAnICtcbiAgICAgICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICk7XG4gIHJvb3QucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBwcmlvcml0eSBsZXZlbHMgdG8gYWNjb3VudCBmb3IgdGhlIHdvcmsgdGhhdCB3ZSBhcmVcbiAgLy8gYWJvdXQgdG8gY29tbWl0LiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgY2FsbGluZyB0aGUgbGlmZWN5Y2xlcywgc2luY2VcbiAgLy8gdGhleSBtYXkgc2NoZWR1bGUgYWRkaXRpb25hbCB1cGRhdGVzLlxuICBjb25zdCB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA9IGZpbmlzaGVkV29yay5leHBpcmF0aW9uVGltZTtcbiAgY29uc3QgY2hpbGRFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA9IGZpbmlzaGVkV29yay5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICBjb25zdCBlYXJsaWVzdFJlbWFpbmluZ1RpbWVCZWZvcmVDb21taXQgPVxuICAgIGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgPiB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdFxuICAgICAgPyBjaGlsZEV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0XG4gICAgICA6IHVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0O1xuICBtYXJrQ29tbWl0dGVkUHJpb3JpdHlMZXZlbHMocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lQmVmb3JlQ29tbWl0KTtcblxuICBsZXQgcHJldkludGVyYWN0aW9uczogU2V0PEludGVyYWN0aW9uPiA9IChudWxsOiBhbnkpO1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIC8vIFJlc3RvcmUgYW55IHBlbmRpbmcgaW50ZXJhY3Rpb25zIGF0IHRoaXMgcG9pbnQsXG4gICAgLy8gU28gdGhhdCBjYXNjYWRpbmcgd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhY2NvdW50ZWQgZm9yLlxuICAgIHByZXZJbnRlcmFjdGlvbnMgPSBfX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgIF9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcbiAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgbGV0IGZpcnN0RWZmZWN0O1xuICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICB9XG5cbiAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gIC8vIEludm9rZSBpbnN0YW5jZXMgb2YgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgYmVmb3JlIG11dGF0aW9uLlxuICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICBsZXQgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3I7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVjeWNsZXMsIG51bGwpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlY3ljbGVzKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbmV4dEVmZmVjdCAhPT0gbnVsbCxcbiAgICAgICAgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArXG4gICAgICAgICAgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgIC8vIENsZWFuLXVwXG4gICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpcyBiYXRjaC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgfVxuXG4gIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gIC8vIHJlZiB1bm1vdW50cy5cbiAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICBsZXQgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3I7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21taXRBbGxIb3N0RWZmZWN0cygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIG5leHRFZmZlY3QgIT09IG51bGwsXG4gICAgICAgICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgK1xuICAgICAgICAgICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICAgICk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBlcnJvcik7XG4gICAgICAvLyBDbGVhbi11cFxuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcblxuICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG5cbiAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgLy8gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGNvbW1pdCBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbFxuICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG5cbiAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gIC8vIGFuZCBkZWxldGlvbnMgaW4gdGhlIGVudGlyZSB0cmVlIGhhdmUgYWxyZWFkeSBiZWVuIGludm9rZWQuXG4gIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICBsZXQgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3I7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY29tbWl0QWxsTGlmZUN5Y2xlcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tbWl0QWxsTGlmZUN5Y2xlcyhyb290LCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbmV4dEVmZmVjdCAhPT0gbnVsbCxcbiAgICAgICAgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArXG4gICAgICAgICAgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpcnN0RWZmZWN0ICE9PSBudWxsICYmIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaW5jbHVkZWQgYSBwYXNzaXZlIGVmZmVjdC4gVGhlc2UgZG8gbm90IG5lZWQgdG8gZmlyZSB1bnRpbFxuICAgIC8vIGFmdGVyIHRoZSBuZXh0IHBhaW50LiBTY2hlZHVsZSBhbiBjYWxsYmFjayB0byBmaXJlIHRoZW0gaW4gYW4gYXN5bmNcbiAgICAvLyBldmVudC4gVG8gZW5zdXJlIHNlcmlhbCBleGVjdXRpb24sIHRoZSBjYWxsYmFjayB3aWxsIGJlIGZsdXNoZWQgZWFybHkgaWZcbiAgICAvLyB3ZSBlbnRlciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyBjb21taXQgcGhhc2UgYmVmb3JlIHRoZW4uXG4gICAgbGV0IGNhbGxiYWNrID0gY29tbWl0UGFzc2l2ZUVmZmVjdHMuYmluZChudWxsLCByb290LCBmaXJzdEVmZmVjdCk7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAgIC8vIFRPRE86IEF2b2lkIHRoaXMgZXh0cmEgY2FsbGJhY2sgYnkgbXV0YXRpbmcgdGhlIHRyYWNpbmcgcmVmIGRpcmVjdGx5LFxuICAgICAgLy8gbGlrZSB3ZSBkbyBhdCB0aGUgYmVnaW5uaW5nIG9mIGNvbW1pdFJvb3QuIEkndmUgb3B0ZWQgbm90IHRvIGRvIHRoYXRcbiAgICAgIC8vIGhlcmUgYmVjYXVzZSB0aGF0IGNvZGUgaXMgc3RpbGwgaW4gZmx1eC5cbiAgICAgIGNhbGxiYWNrID0gU2NoZWR1bGVyX3RyYWNpbmdfd3JhcChjYWxsYmFjayk7XG4gICAgfVxuICAgIHBhc3NpdmVFZmZlY3RDYWxsYmFja0hhbmRsZSA9IHJ1bldpdGhQcmlvcml0eShOb3JtYWxQcmlvcml0eSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlUGFzc2l2ZUVmZmVjdHMoY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIHBhc3NpdmVFZmZlY3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIGlzV29ya2luZyA9IGZhbHNlO1xuICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gIHN0b3BDb21taXRUaW1lcigpO1xuICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gIGlmIChfX0RFVl9fICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24uZGVidWdUb29sKSB7XG4gICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Db21taXRXb3JrKGZpbmlzaGVkV29yayk7XG4gIH1cblxuICBjb25zdCB1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID0gZmluaXNoZWRXb3JrLmV4cGlyYXRpb25UaW1lO1xuICBjb25zdCBjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQgPSBmaW5pc2hlZFdvcmsuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgY29uc3QgZWFybGllc3RSZW1haW5pbmdUaW1lQWZ0ZXJDb21taXQgPVxuICAgIGNoaWxkRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXRcbiAgICAgID8gY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0XG4gICAgICA6IHVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQ7XG4gIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuICBvbkNvbW1pdChyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCk7XG5cbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICBfX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcblxuICAgIGxldCBzdWJzY3JpYmVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIgPSBfX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgdGhyZWFkSUQgPSBjb21wdXRlVGhyZWFkSUQoXG4gICAgICAgICAgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgcm9vdC5pbnRlcmFjdGlvblRocmVhZElELFxuICAgICAgICApO1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQocm9vdC5tZW1vaXplZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJdCdzIG5vdCBzYWZlIGZvciBjb21taXRSb290KCkgdG8gdGhyb3cuXG4gICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIG5vdyBhbmQgd2UnbGwgcmUtdGhyb3cgaW4gZmluaXNoUmVuZGVyaW5nKCkuXG4gICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQ2xlYXIgY29tcGxldGVkIGludGVyYWN0aW9ucyBmcm9tIHRoZSBwZW5kaW5nIE1hcC5cbiAgICAgIC8vIFVubGVzcyB0aGUgcmVuZGVyIHdhcyBzdXNwZW5kZWQgb3IgY2FzY2FkaW5nIHdvcmsgd2FzIHNjaGVkdWxlZCxcbiAgICAgIC8vIEluIHdoaWNoIGNhc2XigJMgbGVhdmUgcGVuZGluZyBpbnRlcmFjdGlvbnMgdW50aWwgdGhlIHN1YnNlcXVlbnQgcmVuZGVyLlxuICAgICAgY29uc3QgcGVuZGluZ0ludGVyYWN0aW9uTWFwID0gcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXA7XG4gICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXAuZm9yRWFjaChcbiAgICAgICAgKHNjaGVkdWxlZEludGVyYWN0aW9ucywgc2NoZWR1bGVkRXhwaXJhdGlvblRpbWUpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IGRlY3JlbWVudCB0aGUgcGVuZGluZyBpbnRlcmFjdGlvbiBjb3VudCBpZiB3ZSdyZSBkb25lLlxuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgc3RpbGwgd29yayBhdCB0aGUgY3VycmVudCBwcmlvcml0eSxcbiAgICAgICAgICAvLyBUaGF0IGluZGljYXRlcyB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBzdXNwZW5zZSBkYXRhLlxuICAgICAgICAgIGlmIChzY2hlZHVsZWRFeHBpcmF0aW9uVGltZSA+IGVhcmxpZXN0UmVtYWluaW5nVGltZUFmdGVyQ29tbWl0KSB7XG4gICAgICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXAuZGVsZXRlKHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICAgICAgc2NoZWR1bGVkSW50ZXJhY3Rpb25zLmZvckVhY2goaW50ZXJhY3Rpb24gPT4ge1xuICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgc2FmZSBmb3IgY29tbWl0Um9vdCgpIHRvIHRocm93LlxuICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGVycm9yIGZvciBub3cgYW5kIHdlJ2xsIHJlLXRocm93IGluIGZpbmlzaFJlbmRlcmluZygpLlxuICAgICAgICAgICAgICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldENoaWxkRXhwaXJhdGlvblRpbWUoXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgcmVuZGVyVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgIC8vIGV4cGlyYXRpb24gdGltZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgIC8vIFdlJ3JlIGluIHByb2ZpbGluZyBtb2RlLlxuICAgIC8vIExldCdzIHVzZSB0aGlzIHNhbWUgdHJhdmVyc2FsIHRvIHVwZGF0ZSB0aGUgcmVuZGVyIGR1cmF0aW9ucy5cbiAgICBsZXQgYWN0dWFsRHVyYXRpb24gPSB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbjtcbiAgICBsZXQgdHJlZUJhc2VEdXJhdGlvbiA9IHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb247XG5cbiAgICAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC5cbiAgICAvLyBUaGlzIHZhbHVlIHdpbGwgb25seSBiZSB1cGRhdGVkIGlmIHdvcmsgaXMgZG9uZSBvbiB0aGUgZmliZXIgKGkuZS4gaXQgZG9lc24ndCBiYWlsb3V0KS5cbiAgICAvLyBXaGVuIHdvcmsgaXMgZG9uZSwgaXQgc2hvdWxkIGJ1YmJsZSB0byB0aGUgcGFyZW50J3MgYWN0dWFsRHVyYXRpb24uXG4gICAgLy8gSWYgdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSxcbiAgICAvLyBUaGVuIHRoaXMgdmFsdWUgd2lsbCByZWZsZWN0IHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCB3b3JraW5nIG9uIGEgcHJldmlvdXMgcmVuZGVyLlxuICAgIC8vIEluIHRoYXQgY2FzZSBpdCBzaG91bGQgbm90IGJ1YmJsZS5cbiAgICAvLyBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXMgY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cbiAgICBjb25zdCBzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMgPVxuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID09PSBudWxsIHx8XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlLmNoaWxkO1xuXG4gICAgbGV0IGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICBjb25zdCBjaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPSBjaGlsZC5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgPiBuZXdDaGlsZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSA+IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMpIHtcbiAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG4gICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV0IGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICBjb25zdCBjaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPSBjaGlsZC5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgPiBuZXdDaGlsZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSA+IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lID0gbmV3Q2hpbGRFeHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzOiBGaWJlcik6IEZpYmVyIHwgbnVsbCB7XG4gIC8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlXG4gIC8vIG5leHQgc2libGluZy4gSWYgdGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3MsIHJldHVybiB0byB0aGVcbiAgLy8gcGFyZW50IGZpYmVyLlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIGNvbnN0IGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgY29uc3Qgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgSW5jb21wbGV0ZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICBpZiAoX19ERVZfXyAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAvLyBEb24ndCByZXBsYXkgaWYgaXQgZmFpbHMgZHVyaW5nIGNvbXBsZXRpb24gcGhhc2UuXG4gICAgICAgIG1heVJlcGxheUZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgZmliZXIgY29tcGxldGVkLlxuICAgICAgLy8gUmVtZW1iZXIgd2UncmUgY29tcGxldGluZyB0aGlzIHVuaXQgc28gd2UgY2FuIGZpbmQgYSBib3VuZGFyeSBpZiBpdCBmYWlscy5cbiAgICAgIG5leHRVbml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VW5pdE9mV29yayA9IGNvbXBsZXRlV29yayhcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBjb21wbGV0ZVdvcmsoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoX19ERVZfXyAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAvLyBXZSdyZSBvdXQgb2YgY29tcGxldGlvbiBwaGFzZSBzbyByZXBsYXlpbmcgaXMgZmluZSBub3cuXG4gICAgICAgIG1heVJlcGxheUZhaWxlZFVuaXRPZldvcmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXNldENoaWxkRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcmV0dXJuRmliZXIgIT09IG51bGwgJiZcbiAgICAgICAgLy8gRG8gbm90IGFwcGVuZCBlZmZlY3RzIHRvIHBhcmVudHMgaWYgYSBzaWJsaW5nIGZhaWxlZCB0byBjb21wbGV0ZVxuICAgICAgICAocmV0dXJuRmliZXIuZWZmZWN0VGFnICYgSW5jb21wbGV0ZSkgPT09IE5vRWZmZWN0XG4gICAgICApIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmXG4gICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgIC8vIHRvIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgY29uc3QgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9fREVWX18gJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGZvciB0aGUgZmliZXIgdGhhdCBlcnJvcmVkLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKHdvcmtJblByb2dyZXNzLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgbGV0IGFjdHVhbER1cmF0aW9uID0gd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIGxldCBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIGNvbnN0IG5leHQgPSB1bndpbmRXb3JrKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkge1xuICAgICAgICAvLyBSZXN0YXJ0aW5nIGFuIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoX19ERVZfXyAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAgIC8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG4gICAgICAgIG5leHQuZWZmZWN0VGFnICY9IEhvc3RFZmZlY3RNYXNrO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgZWZmZWN0IGxpc3QuXG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybkZpYmVyLmVmZmVjdFRhZyB8PSBJbmNvbXBsZXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX19ERVZfXyAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBleHBsaWNpdCBudWxsIHJldHVybiBGbG93IGNvbXBsYWlucyBvZiBpbnZhbGlkIHJldHVybiB0eXBlXG4gIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3M6IEZpYmVyKTogRmliZXIgfCBudWxsIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgLy8gcHJvZ3Jlc3MuXG4gIGNvbnN0IGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoX19ERVZfXykge1xuICAgIHNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBpZiAoX19ERVZfXyAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihcbiAgICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICApO1xuICB9XG5cbiAgbGV0IG5leHQ7XG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgc3RhcnRQcm9maWxlclRpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgYmFpbG91dCAob3IgZXJyb3IpLlxuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICBpZiAoaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBDdXJyZW50bHkgcmVwbGF5aW5nIGEgZmFpbGVkIHVuaXQgb2Ygd29yay4gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUsXG4gICAgICAvLyBiZWNhdXNlIHRoZSByZW5kZXIgcGhhc2UgaXMgbWVhbnQgdG8gYmUgaWRlbXBvdGVudCwgYW5kIGl0IHNob3VsZFxuICAgICAgLy8gaGF2ZSB0aHJvd24gYWdhaW4uIFNpbmNlIGl0IGRpZG4ndCwgcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IsIHNvXG4gICAgICAvLyBSZWFjdCdzIGludGVybmFsIHN0YWNrIGlzIG5vdCBtaXNhbGlnbmVkLlxuICAgICAgcmV0aHJvd09yaWdpbmFsRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9fREVWX18gJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wpIHtcbiAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChpc1lpZWxkeSkge1xuICBpZiAoIWlzWWllbGR5KSB7XG4gICAgLy8gRmx1c2ggd29yayB3aXRob3V0IHlpZWxkaW5nXG4gICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlcmUncyBhIGhpZ2hlciBwcmlvcml0eSBldmVudFxuICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGRUb1JlbmRlcmVyKCkpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290KHJvb3Q6IEZpYmVyUm9vdCwgaXNZaWVsZHk6IGJvb2xlYW4pOiB2b2lkIHtcbiAgaW52YXJpYW50KFxuICAgICFpc1dvcmtpbmcsXG4gICAgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkICcgK1xuICAgICAgJ2J5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICApO1xuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpc1dvcmtpbmcgPSB0cnVlO1xuICBjb25zdCBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBjb25zdCBleHBpcmF0aW9uVGltZSA9IHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT247XG5cbiAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICBpZiAoXG4gICAgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fFxuICAgIHJvb3QgIT09IG5leHRSb290IHx8XG4gICAgbmV4dFVuaXRPZldvcmsgPT09IG51bGxcbiAgKSB7XG4gICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgcmVzZXRTdGFjaygpO1xuICAgIG5leHRSb290ID0gcm9vdDtcbiAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKFxuICAgICAgbmV4dFJvb3QuY3VycmVudCxcbiAgICAgIG51bGwsXG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaW50ZXJhY3Rpb25zIHRoaXMgYmF0Y2ggb2Ygd29yayBjdXJyZW50bHkgaW5jbHVkZXMsXG4gICAgICAvLyBTbyB0aGF0IHdlIGNhbiBhY2N1cmF0ZWx5IGF0dHJpYnV0ZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gaXQsXG4gICAgICAvLyBBbmQgc28gdGhhdCBjYXNjYWRpbmcgd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBjb25zdCBpbnRlcmFjdGlvbnM6IFNldDxJbnRlcmFjdGlvbj4gPSBuZXcgU2V0KCk7XG4gICAgICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKFxuICAgICAgICAoc2NoZWR1bGVkSW50ZXJhY3Rpb25zLCBzY2hlZHVsZWRFeHBpcmF0aW9uVGltZSkgPT4ge1xuICAgICAgICAgIGlmIChzY2hlZHVsZWRFeHBpcmF0aW9uVGltZSA+PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgc2NoZWR1bGVkSW50ZXJhY3Rpb25zLmZvckVhY2goaW50ZXJhY3Rpb24gPT5cbiAgICAgICAgICAgICAgaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbiksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHNldCBvZiBpbnRlcmFjdGlvbnMgb24gdGhlIEZpYmVyUm9vdCBmb3IgYSBmZXcgcmVhc29uczpcbiAgICAgIC8vIFdlIGNhbiByZS11c2UgaXQgaW4gaG90IGZ1bmN0aW9ucyBsaWtlIHJlbmRlclJvb3QoKSB3aXRob3V0IGhhdmluZyB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICAgIC8vIFdlIHdpbGwgYWxzbyB1c2UgaXQgaW4gY29tbWl0V29yaygpIHRvIHBhc3MgdG8gYW55IFByb2ZpbGVyIG9uUmVuZGVyKCkgaG9va3MuXG4gICAgICAvLyBUaGlzIGFsc28gcHJvdmlkZXMgRGV2VG9vbHMgd2l0aCBhIHdheSB0byBhY2Nlc3MgaXQgd2hlbiB0aGUgb25Db21taXRSb290KCkgaG9vayBpcyBjYWxsZWQuXG4gICAgICByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25zO1xuXG4gICAgICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBfX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgcm9vdC5pbnRlcmFjdGlvblRocmVhZElELFxuICAgICAgICAgICk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gV29yayB0aHJvd24gYnkgYW4gaW50ZXJhY3Rpb24gdHJhY2luZyBzdWJzY3JpYmVyIHNob3VsZCBiZSByZXRocm93bixcbiAgICAgICAgICAgIC8vIEJ1dCBvbmx5IG9uY2UgaXQncyBzYWZlICh0byBhdm9pZCBsZWF2aW5nIHRoZSBzY2hlZHVsZXIgaW4gYW4gaW52YWxpZCBzdGF0ZSkuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIG5vdyBhbmQgd2UnbGwgcmUtdGhyb3cgaW4gZmluaXNoUmVuZGVyaW5nKCkuXG4gICAgICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcHJldkludGVyYWN0aW9uczogU2V0PEludGVyYWN0aW9uPiA9IChudWxsOiBhbnkpO1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIC8vIFdlJ3JlIGFib3V0IHRvIHN0YXJ0IG5ldyB0cmFjZWQgd29yay5cbiAgICAvLyBSZXN0b3JlIHBlbmRpbmcgaW50ZXJhY3Rpb25zIHNvIGNhc2NhZGluZyB3b3JrIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSB3aWxsIGJlIGFjY291bnRlZCBmb3IuXG4gICAgcHJldkludGVyYWN0aW9ucyA9IF9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnM7XG4gIH1cblxuICBsZXQgZGlkRmF0YWwgPSBmYWxzZTtcblxuICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3AoaXNZaWVsZHkpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNlcygpO1xuICAgICAgcmVzZXRIb29rcygpO1xuXG4gICAgICAvLyBSZXNldCBpbiBjYXNlIGNvbXBsZXRpb24gdGhyb3dzLlxuICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgaW4gREVWIGFuZCB3aGVuIHJlcGxheWluZyBpcyBvbi5cbiAgICAgIGxldCBtYXlSZXBsYXk7XG4gICAgICBpZiAoX19ERVZfXyAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICBtYXlSZXBsYXkgPSBtYXlSZXBsYXlGYWlsZWRVbml0T2ZXb3JrO1xuICAgICAgICBtYXlSZXBsYXlGYWlsZWRVbml0T2ZXb3JrID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICBvblVuY2F1Z2h0RXJyb3IodGhyb3duVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgbmV4dFVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgLy8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi5cbiAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhIHN1c3BlbmRlZCByZW5kZXIuXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShuZXh0VW5pdE9mV29yaywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgIC8vIFJlc2V0IGdsb2JhbCBkZWJ1ZyBzdGF0ZVxuICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGlzIGlzIGRlZmluZWQgaW4gREVWXG4gICAgICAgICAgKHJlc2V0Q3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlOiBhbnkpKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX19ERVZfXyAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAgIGlmIChtYXlSZXBsYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZFVuaXRPZldvcms6IEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgICAgICAgICByZXBsYXlVbml0T2ZXb3JrKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc1lpZWxkeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogd2UgYWxyZWFkeSBrbm93IHRoaXMgaXNuJ3QgdHJ1ZSBpbiBzb21lIGNhc2VzLlxuICAgICAgICAvLyBBdCBsZWFzdCB0aGlzIHNob3dzIGEgbmljZXIgZXJyb3IgbWVzc2FnZSB1bnRpbCB3ZSBmaWd1cmUgb3V0IHRoZSBjYXVzZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjQ0OSNpc3N1ZWNvbW1lbnQtMzg2NzI3NDMxXG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayAhPT0gbnVsbCxcbiAgICAgICAgICAnRmFpbGVkIHRvIHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgJyArXG4gICAgICAgICAgICAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgJyArXG4gICAgICAgICAgICAnd2l0aCBhIHJlcHJvZHVjaW5nIGNhc2UgdG8gaGVscCB1cyBmaW5kIGl0LicsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3Qgc291cmNlRmliZXI6IEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgICAgIGxldCByZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcm9vdC4gVGhlIHJvb3QgY291bGQgY2FwdHVyZSBpdHMgb3duIGVycm9ycy4gSG93ZXZlcixcbiAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0IGVycm9ycyBiZWZvcmUgb3IgYWZ0ZXIgd2UgcHVzaGVkIHRoZSBob3N0XG4gICAgICAgICAgLy8gY29udGV4dC4gVGhpcyBpbmZvcm1hdGlvbiBpcyBuZWVkZWQgdG8gYXZvaWQgYSBzdGFjayBtaXNtYXRjaC5cbiAgICAgICAgICAvLyBCZWNhdXNlIHdlJ3JlIG5vdCBzdXJlLCB0cmVhdCB0aGlzIGFzIGEgZmF0YWwgZXJyb3IuIFdlIGNvdWxkIHRyYWNrXG4gICAgICAgICAgLy8gd2hpY2ggcGhhc2UgaXQgZmFpbHMgaW4sIGJ1dCBkb2Vzbid0IHNlZW0gd29ydGggaXQuIEF0IGxlYXN0XG4gICAgICAgICAgLy8gZm9yIG5vdy5cbiAgICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IGNvbXBsZXRlVW5pdE9mV29yayhzb3VyY2VGaWJlcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgLy8gVHJhY2VkIHdvcmsgaXMgZG9uZSBmb3Igbm93OyByZXN0b3JlIHRoZSBwcmV2aW91cyBpbnRlcmFjdGlvbnMuXG4gICAgX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG4gIH1cblxuICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgaXNXb3JraW5nID0gZmFsc2U7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jZXMoKTtcbiAgcmVzZXRIb29rcygpO1xuXG4gIC8vIFlpZWxkIGJhY2sgdG8gbWFpbiB0aHJlYWQuXG4gIGlmIChkaWRGYXRhbCkge1xuICAgIGNvbnN0IGRpZENvbXBsZXRlUm9vdCA9IGZhbHNlO1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgLy8gVGhlcmUgd2FzIGEgZmF0YWwgZXJyb3IuXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldigpO1xuICAgIH1cbiAgICAvLyBgbmV4dFJvb3RgIHBvaW50cyB0byB0aGUgaW4tcHJvZ3Jlc3Mgcm9vdC4gQSBub24tbnVsbCB2YWx1ZSBpbmRpY2F0ZXNcbiAgICAvLyB0aGF0IHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYW4gYXN5bmMgcmVuZGVyLiBTZXQgaXQgdG8gbnVsbCB0byBpbmRpY2F0ZVxuICAgIC8vIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIHRvIGJlIGRvbmUgaW4gdGhlIGN1cnJlbnQgYmF0Y2guXG4gICAgbmV4dFJvb3QgPSBudWxsO1xuICAgIG9uRmF0YWwocm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBzdGlsbCByZW1haW5pbmcgYXN5bmMgd29yayBpbiB0aGlzIHRyZWUsIGJ1dCB3ZSByYW4gb3V0IG9mIHRpbWVcbiAgICAvLyBpbiB0aGUgY3VycmVudCBmcmFtZS4gWWllbGQgYmFjayB0byB0aGUgcmVuZGVyZXIuIFVubGVzcyB3ZSdyZVxuICAgIC8vIGludGVycnVwdGVkIGJ5IGEgaGlnaGVyIHByaW9yaXR5IHVwZGF0ZSwgd2UnbGwgY29udGludWUgbGF0ZXIgZnJvbSB3aGVyZVxuICAgIC8vIHdlIGxlZnQgb2ZmLlxuICAgIGNvbnN0IGRpZENvbXBsZXRlUm9vdCA9IGZhbHNlO1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgb25ZaWVsZChyb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXZSBjb21wbGV0ZWQgdGhlIHdob2xlIHRyZWUuXG4gIGNvbnN0IGRpZENvbXBsZXRlUm9vdCA9IHRydWU7XG4gIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gIGNvbnN0IHJvb3RXb3JrSW5Qcm9ncmVzcyA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gIGludmFyaWFudChcbiAgICByb290V29ya0luUHJvZ3Jlc3MgIT09IG51bGwsXG4gICAgJ0ZpbmlzaGVkIHJvb3Qgc2hvdWxkIGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICtcbiAgICAgICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICk7XG5cbiAgLy8gYG5leHRSb290YCBwb2ludHMgdG8gdGhlIGluLXByb2dyZXNzIHJvb3QuIEEgbm9uLW51bGwgdmFsdWUgaW5kaWNhdGVzXG4gIC8vIHRoYXQgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhbiBhc3luYyByZW5kZXIuIFNldCBpdCB0byBudWxsIHRvIGluZGljYXRlXG4gIC8vIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIHRvIGJlIGRvbmUgaW4gdGhlIGN1cnJlbnQgYmF0Y2guXG4gIG5leHRSb290ID0gbnVsbDtcbiAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG5cbiAgaWYgKG5leHRSZW5kZXJEaWRFcnJvcikge1xuICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvclxuICAgIGlmIChoYXNMb3dlclByaW9yaXR5V29yayhyb290LCBleHBpcmF0aW9uVGltZSkpIHtcbiAgICAgIC8vIFRoZXJlJ3MgbG93ZXIgcHJpb3JpdHkgd29yay4gSWYgc28sIGl0IG1heSBoYXZlIHRoZSBlZmZlY3Qgb2YgZml4aW5nXG4gICAgICAvLyB0aGUgZXhjZXB0aW9uIHRoYXQgd2FzIGp1c3QgdGhyb3duLiBFeGl0IHdpdGhvdXQgY29tbWl0dGluZy4gVGhpcyBpc1xuICAgICAgLy8gc2ltaWxhciB0byBhIHN1c3BlbmQsIGJ1dCB3aXRob3V0IGEgdGltZW91dCBiZWNhdXNlIHdlJ3JlIG5vdCB3YWl0aW5nXG4gICAgICAvLyBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUuIFJlYWN0IHdpbGwgcmVzdGFydCBhdCB0aGUgbG93ZXJcbiAgICAgIC8vIHByaW9yaXR5IGxldmVsLlxuICAgICAgbWFya1N1c3BlbmRlZFByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY29uc3Qgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIGNvbnN0IHJvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgICBvblN1c3BlbmQoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3RXb3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHJvb3RFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgLTEsIC8vIEluZGljYXRlcyBubyB0aW1lb3V0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBUaGVyZSdzIG5vIGxvd2VyIHByaW9yaXR5IHdvcmssIGJ1dCB3ZSdyZSByZW5kZXJpbmcgYXN5bmNocm9ub3VzbHkuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBzYW1lIGxldmVsIG9uZSBtb3JlIHRpbWUuIFRoaXMgaXNcbiAgICAgIC8vIHNpbWlsYXIgdG8gYSBzdXNwZW5kLCBidXQgd2l0aG91dCBhIHRpbWVvdXQgYmVjYXVzZSB3ZSdyZSBub3Qgd2FpdGluZ1xuICAgICAgLy8gZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlLlxuICAgICAgIXJvb3QuZGlkRXJyb3IgJiZcbiAgICAgIGlzWWllbGR5XG4gICAgKSB7XG4gICAgICByb290LmRpZEVycm9yID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lID0gKHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjb25zdCByb290RXhwaXJhdGlvblRpbWUgPSAocm9vdC5leHBpcmF0aW9uVGltZSA9IFN5bmMpO1xuICAgICAgb25TdXNwZW5kKFxuICAgICAgICByb290LFxuICAgICAgICByb290V29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lLFxuICAgICAgICByb290RXhwaXJhdGlvblRpbWUsXG4gICAgICAgIC0xLCAvLyBJbmRpY2F0ZXMgbm8gdGltZW91dFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNZaWVsZHkgJiYgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zICE9PSAtMSkge1xuICAgIC8vIFRoZSB0cmVlIHdhcyBzdXNwZW5kZWQuXG4gICAgY29uc3Qgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAvLyBGaW5kIHRoZSBlYXJsaWVzdCB1bmNvbW1pdHRlZCBleHBpcmF0aW9uIHRpbWUgaW4gdGhlIHRyZWUsIGluY2x1ZGluZ1xuICAgIC8vIHdvcmsgdGhhdCBpcyBzdXNwZW5kZWQuIFRoZSB0aW1lb3V0IHRocmVzaG9sZCBjYW5ub3QgYmUgbG9uZ2VyIHRoYW5cbiAgICAvLyB0aGUgb3ZlcmFsbCBleHBpcmF0aW9uLlxuICAgIGNvbnN0IGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwoXG4gICAgICByb290LFxuICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgICBjb25zdCBlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZWFybGllc3RFeHBpcmF0aW9uVGltZSk7XG4gICAgaWYgKGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyA8IG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcykge1xuICAgICAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gZWFybGllc3RFeHBpcmF0aW9uVGltZU1zO1xuICAgIH1cblxuICAgIC8vIFN1YnRyYWN0IHRoZSBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYWJzb2x1dGUgdGltZW91dCB0byBnZXQgdGhlIG51bWJlclxuICAgIC8vIG9mIG1pbGxpc2Vjb25kcyB1bnRpbCB0aGUgdGltZW91dC4gSW4gb3RoZXIgd29yZHMsIGNvbnZlcnQgYW4gYWJzb2x1dGVcbiAgICAvLyB0aW1lc3RhbXAgdG8gYSByZWxhdGl2ZSB0aW1lLiBUaGlzIGlzIHRoZSB2YWx1ZSB0aGF0IGlzIHBhc3NlZFxuICAgIC8vIHRvIGBzZXRUaW1lb3V0YC5cbiAgICBjb25zdCBjdXJyZW50VGltZU1zID0gZXhwaXJhdGlvblRpbWVUb01zKHJlcXVlc3RDdXJyZW50VGltZSgpKTtcbiAgICBsZXQgbXNVbnRpbFRpbWVvdXQgPSBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMgLSBjdXJyZW50VGltZU1zO1xuICAgIG1zVW50aWxUaW1lb3V0ID0gbXNVbnRpbFRpbWVvdXQgPCAwID8gMCA6IG1zVW50aWxUaW1lb3V0O1xuXG4gICAgLy8gVE9ETzogQWNjb3VudCBmb3IgdGhlIEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlXG5cbiAgICBjb25zdCByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgIG9uU3VzcGVuZChcbiAgICAgIHJvb3QsXG4gICAgICByb290V29ya0luUHJvZ3Jlc3MsXG4gICAgICBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSxcbiAgICAgIHJvb3RFeHBpcmF0aW9uVGltZSxcbiAgICAgIG1zVW50aWxUaW1lb3V0LFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVhZHkgdG8gY29tbWl0LlxuICBvbkNvbXBsZXRlKHJvb3QsIHJvb3RXb3JrSW5Qcm9ncmVzcywgZXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlcjogRmliZXIsIHZhbHVlOiBtaXhlZCkge1xuICBjb25zdCBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gIGxldCBmaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIGNvbnN0IGN0b3IgPSBmaWJlci50eXBlO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICAgIGNvbnN0IGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgY29uc3Qgcm9vdEZpYmVyID0gc291cmNlRmliZXI7XG4gICAgY29uc3QgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgcm9vdEZpYmVyKTtcbiAgICBjb25zdCB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKTtcbiAgICBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsocm9vdEZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRocmVhZElEKFxuICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIGludGVyYWN0aW9uVGhyZWFkSUQ6IG51bWJlcixcbik6IG51bWJlciB7XG4gIC8vIEludGVyYWN0aW9uIHRocmVhZHMgYXJlIHVuaXF1ZSBwZXIgcm9vdCBhbmQgZXhwaXJhdGlvbiB0aW1lLlxuICByZXR1cm4gZXhwaXJhdGlvblRpbWUgKiAxMDAwICsgaW50ZXJhY3Rpb25UaHJlYWRJRDtcbn1cblxuLy8gQ3JlYXRlcyBhIHVuaXF1ZSBhc3luYyBleHBpcmF0aW9uIHRpbWUuXG5mdW5jdGlvbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uKCk6IEV4cGlyYXRpb25UaW1lIHtcbiAgY29uc3QgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgbGV0IHJlc3VsdCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICBpZiAocmVzdWx0ID49IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24pIHtcbiAgICAvLyBTaW5jZSB3ZSBhc3N1bWUgdGhlIGN1cnJlbnQgdGltZSBtb25vdG9uaWNhbGx5IGluY3JlYXNlcywgd2Ugb25seSBoaXRcbiAgICAvLyB0aGlzIGJyYW5jaCB3aGVuIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24gaXMgZmlyZWQgbXVsdGlwbGUgdGltZXNcbiAgICAvLyB3aXRoaW4gYSAyMDBtcyB3aW5kb3cgKG9yIHdoYXRldmVyIHRoZSBhc3luYyBidWNrZXQgc2l6ZSBpcykuXG4gICAgcmVzdWx0ID0gbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiAtIDE7XG4gIH1cbiAgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IHJlc3VsdDtcbiAgcmV0dXJuIGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWU6IEV4cGlyYXRpb25UaW1lLCBmaWJlcjogRmliZXIpIHtcbiAgY29uc3QgcHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG5cbiAgbGV0IGV4cGlyYXRpb25UaW1lO1xuICBpZiAoKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vQ29udGV4dCkge1xuICAgIC8vIE91dHNpZGUgb2YgY29uY3VycmVudCBtb2RlLCB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMuXG4gICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICB9IGVsc2UgaWYgKGlzV29ya2luZyAmJiAhaXNDb21taXR0aW5nKSB7XG4gICAgLy8gRHVyaW5nIHJlbmRlciBwaGFzZSwgdXBkYXRlcyBleHBpcmUgZHVyaW5nIGFzIHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICBleHBpcmF0aW9uVGltZSA9IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVJbnRlcmFjdGl2ZUV4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAgIC8vIFRoaXMgaXMgYSBub3JtYWwsIGNvbmN1cnJlbnQgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnVW5rbm93biBwcmlvcml0eSBsZXZlbC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcgK1xuICAgICAgICAgICAgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nIGEgdHJlZSwgZG8gbm90IHVwZGF0ZSBhdCB0aGUgc2FtZVxuICAgIC8vIGV4cGlyYXRpb24gdGltZSB0aGF0IGlzIGFscmVhZHkgcmVuZGVyaW5nLlxuICAgIGlmIChuZXh0Um9vdCAhPT0gbnVsbCAmJiBleHBpcmF0aW9uVGltZSA9PT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxvd2VzdCBwZW5kaW5nIGludGVyYWN0aXZlIGV4cGlyYXRpb24gdGltZS4gVGhpc1xuICAvLyBhbGxvd3MgdXMgdG8gc3luY2hyb25vdXNseSBmbHVzaCBhbGwgaW50ZXJhY3RpdmUgdXBkYXRlc1xuICAvLyB3aGVuIG5lZWRlZC5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIHJlbmRlcmVyP1xuICBpZiAoXG4gICAgcHJpb3JpdHlMZXZlbCA9PT0gVXNlckJsb2NraW5nUHJpb3JpdHkgJiZcbiAgICAobG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICBleHBpcmF0aW9uVGltZSA8IGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUpXG4gICkge1xuICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIHJldHVybiBleHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZChcbiAgcm9vdDogRmliZXJSb290LFxuICBhYnNvbHV0ZVRpbWVvdXRNczogbnVtYmVyLFxuICBzdXNwZW5kZWRUaW1lOiBFeHBpcmF0aW9uVGltZSxcbikge1xuICAvLyBTY2hlZHVsZSB0aGUgdGltZW91dC5cbiAgaWYgKFxuICAgIGFic29sdXRlVGltZW91dE1zID49IDAgJiZcbiAgICBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMgPCBhYnNvbHV0ZVRpbWVvdXRNc1xuICApIHtcbiAgICBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMgPSBhYnNvbHV0ZVRpbWVvdXRNcztcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcigpIHtcbiAgbmV4dFJlbmRlckRpZEVycm9yID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3QoXG4gIHJvb3Q6IEZpYmVyUm9vdCxcbiAgdGhlbmFibGU6IFRoZW5hYmxlLFxuICBwaW5nVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgLy8gQSBwcm9taXNlIHRoYXQgcHJldmlvdXNseSBzdXNwZW5kZWQgUmVhY3QgZnJvbSBjb21taXR0aW5nIGhhcyByZXNvbHZlZC5cbiAgLy8gSWYgUmVhY3QgaXMgc3RpbGwgc3VzcGVuZGVkLCB0cnkgYWdhaW4gYXQgdGhlIHByZXZpb3VzIGxldmVsIChwaW5nVGltZSkuXG5cbiAgY29uc3QgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIGlmIChwaW5nQ2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgdGhlbmFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICBwaW5nQ2FjaGUuZGVsZXRlKHRoZW5hYmxlKTtcbiAgfVxuXG4gIGlmIChuZXh0Um9vdCAhPT0gbnVsbCAmJiBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IHBpbmdUaW1lKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgIG5leHRSb290ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb25maXJtIHRoYXQgdGhlIHJvb3QgaXMgc3RpbGwgc3VzcGVuZGVkIGF0IHRoaXMgbGV2ZWwuIE90aGVyd2lzZSBleGl0LlxuICAgIGlmIChpc1ByaW9yaXR5TGV2ZWxTdXNwZW5kZWQocm9vdCwgcGluZ1RpbWUpKSB7XG4gICAgICAvLyBQaW5nIGF0IHRoZSBvcmlnaW5hbCBsZXZlbFxuICAgICAgbWFya1BpbmdlZFByaW9yaXR5TGV2ZWwocm9vdCwgcGluZ1RpbWUpO1xuICAgICAgY29uc3Qgcm9vdEV4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyb290RXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgICByZXF1ZXN0V29yayhyb290LCByb290RXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlcjogRmliZXIsIHRoZW5hYmxlOiBUaGVuYWJsZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50KSBwcmV2aW91c2x5IHRpbWVkIG91dCBhbmQgd2FzXG4gIC8vIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0IHN1c3BlbmRlZCBpdCBoYXNcbiAgLy8gcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzIGxpa2VseSB1bmJsb2NrZWQuIFRyeVxuICAvLyByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGV4cGlyYXRpb24gdGltZS5cblxuICBsZXQgcmV0cnlDYWNoZTogV2Vha1NldDxUaGVuYWJsZT4gfCBTZXQ8VGhlbmFibGU+IHwgbnVsbDtcbiAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiAnICtcbiAgICAgICAgICAgICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicsXG4gICAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuICBpZiAocmV0cnlDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB0aGVuYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHJldHJ5Q2FjaGUuZGVsZXRlKHRoZW5hYmxlKTtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gIGNvbnN0IHJldHJ5VGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGJvdW5kYXJ5RmliZXIpO1xuICBjb25zdCByb290ID0gc2NoZWR1bGVXb3JrVG9Sb290KGJvdW5kYXJ5RmliZXIsIHJldHJ5VGltZSk7XG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIHJldHJ5VGltZSk7XG4gICAgY29uc3Qgcm9vdEV4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAocm9vdEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIHJlcXVlc3RXb3JrKHJvb3QsIHJvb3RFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya1RvUm9vdChmaWJlcjogRmliZXIsIGV4cGlyYXRpb25UaW1lKTogRmliZXJSb290IHwgbnVsbCB7XG4gIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyhpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBzb3VyY2UgZmliZXIncyBleHBpcmF0aW9uIHRpbWVcbiAgaWYgKGZpYmVyLmV4cGlyYXRpb25UaW1lIDwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9XG4gIGxldCBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lIDwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgfVxuICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIHRoZSBjaGlsZCBleHBpcmF0aW9uIHRpbWUuXG4gIGxldCBub2RlID0gZmliZXIucmV0dXJuO1xuICBsZXQgcm9vdCA9IG51bGw7XG4gIGlmIChub2RlID09PSBudWxsICYmIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICByb290ID0gZmliZXIuc3RhdGVOb2RlO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcbiAgICAgIGlmIChub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPCBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFsdGVybmF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lIDwgZXhwaXJhdGlvblRpbWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgYWx0ZXJuYXRlICE9PSBudWxsICYmXG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lIDwgZXhwaXJhdGlvblRpbWVcbiAgICAgICkge1xuICAgICAgICBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsICYmIG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGludGVyYWN0aW9ucyA9IF9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgICAgICBjb25zdCBwZW5kaW5nSW50ZXJhY3Rpb25zID0gcGVuZGluZ0ludGVyYWN0aW9uTWFwLmdldChleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChwZW5kaW5nSW50ZXJhY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChpbnRlcmFjdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAoIXBlbmRpbmdJbnRlcmFjdGlvbnMuaGFzKGludGVyYWN0aW9uKSkge1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgcHJldmlvdXNseSB1bnNjaGVkdWxlZCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLnNldChleHBpcmF0aW9uVGltZSwgbmV3IFNldChpbnRlcmFjdGlvbnMpKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gICAgICAgICAgaW50ZXJhY3Rpb25zLmZvckVhY2goaW50ZXJhY3Rpb24gPT4ge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IF9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgICByb290LmludGVyYWN0aW9uVGhyZWFkSUQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5JZk5vdEN1cnJlbnRseUJhdGNoaW5nSW5EZXYoZmliZXI6IEZpYmVyKTogdm9pZCB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGlzUmVuZGVyaW5nID09PSBmYWxzZSAmJiBpc0JhdGNoaW5nVXBkYXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnQW4gdXBkYXRlIHRvICVzIGluc2lkZSBhIHRlc3Qgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgK1xuICAgICAgICAgICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicgK1xuICAgICAgICAgICdhY3QoKCkgPT4ge1xcbicgK1xuICAgICAgICAgICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArXG4gICAgICAgICAgJ30pO1xcbicgK1xuICAgICAgICAgICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgK1xuICAgICAgICAgIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBpbiB0aGUgYnJvd3Nlci5cIiArXG4gICAgICAgICAgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vZmIubWUvcmVhY3Qtd3JhcC10ZXN0cy13aXRoLWFjdCcgK1xuICAgICAgICAgICclcycsXG4gICAgICAgIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSksXG4gICAgICAgIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChmaWJlciksXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXI6IEZpYmVyLCBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUpIHtcbiAgY29uc3Qgcm9vdCA9IHNjaGVkdWxlV29ya1RvUm9vdChmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkKGZpYmVyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZChmaWJlciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoXG4gICAgIWlzV29ya2luZyAmJlxuICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmXG4gICAgZXhwaXJhdGlvblRpbWUgPiBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgIHJlc2V0U3RhY2soKTtcbiAgfVxuICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAoXG4gICAgLy8gSWYgd2UncmUgaW4gdGhlIHJlbmRlciBwaGFzZSwgd2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHJvb3RcbiAgICAvLyBmb3IgYW4gdXBkYXRlLCBiZWNhdXNlIHdlJ2xsIGRvIGl0IGJlZm9yZSB3ZSBleGl0Li4uXG4gICAgIWlzV29ya2luZyB8fFxuICAgIGlzQ29tbWl0dGluZyB8fFxuICAgIC8vIC4uLnVubGVzcyB0aGlzIGlzIGEgZGlmZmVyZW50IHJvb3QgdGhhbiB0aGUgb25lIHdlJ3JlIHJlbmRlcmluZy5cbiAgICBuZXh0Um9vdCAhPT0gcm9vdFxuICApIHtcbiAgICBjb25zdCByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgIHJlcXVlc3RXb3JrKHJvb3QsIHJvb3RFeHBpcmF0aW9uVGltZSk7XG4gIH1cbiAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgIC8vIFJlc2V0IHRoaXMgYmFjayB0byB6ZXJvIHNvIHN1YnNlcXVlbnQgdXBkYXRlcyBkb24ndCB0aHJvdy5cbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgJyArXG4gICAgICAgICdjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgJyArXG4gICAgICAgICdjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzICcgK1xuICAgICAgICAndGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLicsXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jVXBkYXRlczxBLCBCLCBDMCwgRCwgUj4oXG4gIGZuOiAoQSwgQiwgQzAsIEQpID0+IFIsXG4gIGE6IEEsXG4gIGI6IEIsXG4gIGM6IEMwLFxuICBkOiBELFxuKTogUiB7XG4gIHJldHVybiBydW5XaXRoUHJpb3JpdHkoSW1tZWRpYXRlUHJpb3JpdHksICgpID0+IHtcbiAgICByZXR1cm4gZm4oYSwgYiwgYywgZCk7XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4vLyByZW5kZXJlcnMuIEknbGwgZG8gdGhpcyBpbiBhIGZvbGxvdy11cC5cblxuLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbmxldCBmaXJzdFNjaGVkdWxlZFJvb3Q6IEZpYmVyUm9vdCB8IG51bGwgPSBudWxsO1xubGV0IGxhc3RTY2hlZHVsZWRSb290OiBGaWJlclJvb3QgfCBudWxsID0gbnVsbDtcblxubGV0IGNhbGxiYWNrRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xubGV0IGNhbGxiYWNrSUQ6ICo7XG5sZXQgaXNSZW5kZXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbmxldCBuZXh0Rmx1c2hlZFJvb3Q6IEZpYmVyUm9vdCB8IG51bGwgPSBudWxsO1xubGV0IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xubGV0IGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xubGV0IGhhc1VuaGFuZGxlZEVycm9yOiBib29sZWFuID0gZmFsc2U7XG5sZXQgdW5oYW5kbGVkRXJyb3I6IG1peGVkIHwgbnVsbCA9IG51bGw7XG5cbmxldCBpc0JhdGNoaW5nVXBkYXRlczogYm9vbGVhbiA9IGZhbHNlO1xubGV0IGlzVW5iYXRjaGluZ1VwZGF0ZXM6IGJvb2xlYW4gPSBmYWxzZTtcblxubGV0IGNvbXBsZXRlZEJhdGNoZXM6IEFycmF5PEJhdGNoPiB8IG51bGwgPSBudWxsO1xuXG5sZXQgb3JpZ2luYWxTdGFydFRpbWVNczogbnVtYmVyID0gbm93KCk7XG5sZXQgY3VycmVudFJlbmRlcmVyVGltZTogRXhwaXJhdGlvblRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUoXG4gIG9yaWdpbmFsU3RhcnRUaW1lTXMsXG4pO1xubGV0IGN1cnJlbnRTY2hlZHVsZXJUaW1lOiBFeHBpcmF0aW9uVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG5cbi8vIFVzZSB0aGVzZSB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgbmVzdGVkIHVwZGF0ZXNcbmNvbnN0IE5FU1RFRF9VUERBVEVfTElNSVQgPSA1MDtcbmxldCBuZXN0ZWRVcGRhdGVDb3VudDogbnVtYmVyID0gMDtcbmxldCBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaDogRmliZXJSb290IHwgbnVsbCA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKSB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lTXMgPSBub3coKSAtIG9yaWdpbmFsU3RhcnRUaW1lTXM7XG4gIGN1cnJlbnRSZW5kZXJlclRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUoY3VycmVudFRpbWVNcyk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvblRpbWUoXG4gIHJvb3Q6IEZpYmVyUm9vdCxcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPCBjYWxsYmFja0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FsbGJhY2tJRCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgcmVxdWVzdCBjYWxsYmFjayB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcuIERvbid0IHN0YXJ0IGEgbmV3IG9uZS5cbiAgfSBlbHNlIHtcbiAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gIH1cblxuICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGNvbnN0IGN1cnJlbnRNcyA9IG5vdygpIC0gb3JpZ2luYWxTdGFydFRpbWVNcztcbiAgY29uc3QgZXhwaXJhdGlvblRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gIGNvbnN0IHRpbWVvdXQgPSBleHBpcmF0aW9uVGltZU1zIC0gY3VycmVudE1zO1xuICBjYWxsYmFja0lEID0gc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrKHBlcmZvcm1Bc3luY1dvcmssIHt0aW1lb3V0fSk7XG59XG5cbi8vIEZvciBldmVyeSBjYWxsIHRvIHJlbmRlclJvb3QsIG9uZSBvZiBvbkZhdGFsLCBvbkNvbXBsZXRlLCBvblN1c3BlbmQsIGFuZFxuLy8gb25ZaWVsZCBpcyBjYWxsZWQgdXBvbiBleGl0aW5nLiBXZSB1c2UgdGhlc2UgaW4gbGlldSBvZiByZXR1cm5pbmcgYSB0dXBsZS5cbi8vIEkndmUgYWxzbyBjaG9zZW4gbm90IHRvIGlubGluZSB0aGVtIGludG8gcmVuZGVyUm9vdCBiZWNhdXNlIHRoZXNlIHdpbGxcbi8vIGV2ZW50dWFsbHkgYmUgbGlmdGVkIGludG8gdGhlIHJlbmRlcmVyLlxuZnVuY3Rpb24gb25GYXRhbChyb290KSB7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gb25Db21wbGV0ZShcbiAgcm9vdDogRmliZXJSb290LFxuICBmaW5pc2hlZFdvcms6IEZpYmVyLFxuICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG59XG5cbmZ1bmN0aW9uIG9uU3VzcGVuZChcbiAgcm9vdDogRmliZXJSb290LFxuICBmaW5pc2hlZFdvcms6IEZpYmVyLFxuICBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIHJvb3RFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIG1zVW50aWxUaW1lb3V0OiBudW1iZXIsXG4pOiB2b2lkIHtcbiAgcm9vdC5leHBpcmF0aW9uVGltZSA9IHJvb3RFeHBpcmF0aW9uVGltZTtcbiAgaWYgKG1zVW50aWxUaW1lb3V0ID09PSAwICYmICFzaG91bGRZaWVsZFRvUmVuZGVyZXIoKSkge1xuICAgIC8vIERvbid0IHdhaXQgYW4gYWRkaXRpb25hbCB0aWNrLiBDb21taXQgdGhlIHRyZWUgaW1tZWRpYXRlbHkuXG4gICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZTtcbiAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgfSBlbHNlIGlmIChtc1VudGlsVGltZW91dCA+IDApIHtcbiAgICAvLyBXYWl0IGBtc1VudGlsVGltZW91dGAgbWlsbGlzZWNvbmRzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChcbiAgICAgIG9uVGltZW91dC5iaW5kKG51bGwsIHJvb3QsIGZpbmlzaGVkV29yaywgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUpLFxuICAgICAgbXNVbnRpbFRpbWVvdXQsXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbllpZWxkKHJvb3QpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBvblRpbWVvdXQocm9vdCwgZmluaXNoZWRXb3JrLCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSkge1xuICAvLyBUaGUgcm9vdCB0aW1lZCBvdXQuIENvbW1pdCBpdC5cbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIC8vIFJlYWQgdGhlIGN1cnJlbnQgdGltZSBiZWZvcmUgZW50ZXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gV2UgY2FuIGJlXG4gIC8vIGNlcnRhaW4gdGhpcyB3b24ndCBjYXVzZSB0ZWFyaW5nIHJlbGF0ZWQgdG8gYmF0Y2hpbmcgb2YgZXZlbnQgdXBkYXRlc1xuICAvLyBiZWNhdXNlIHdlJ3JlIGF0IHRoZSB0b3Agb2YgYSB0aW1lciBldmVudC5cbiAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gIGZsdXNoUm9vdChyb290LCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSk7XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRpbWUoKSB7XG4gIC8vIHJlcXVlc3RDdXJyZW50VGltZSBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBjb21wdXRlIGFuIGV4cGlyYXRpb25cbiAgLy8gdGltZS5cbiAgLy9cbiAgLy8gRXhwaXJhdGlvbiB0aW1lcyBhcmUgY29tcHV0ZWQgYnkgYWRkaW5nIHRvIHRoZSBjdXJyZW50IHRpbWUgKHRoZSBzdGFydFxuICAvLyB0aW1lKS4gSG93ZXZlciwgaWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlXG4gIC8vIHNob3VsZCB0cmVhdCB0aGVpciBzdGFydCB0aW1lcyBhcyBzaW11bHRhbmVvdXMsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjbG9ja1xuICAvLyB0aW1lIGhhcyBhZHZhbmNlZCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNhbGwuXG5cbiAgLy8gSW4gb3RoZXIgd29yZHMsIGJlY2F1c2UgZXhwaXJhdGlvbiB0aW1lcyBkZXRlcm1pbmUgaG93IHVwZGF0ZXMgYXJlIGJhdGNoZWQsXG4gIC8vIHdlIHdhbnQgYWxsIHVwZGF0ZXMgb2YgbGlrZSBwcmlvcml0eSB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgc2FtZSBldmVudCB0b1xuICAvLyByZWNlaXZlIHRoZSBzYW1lIGV4cGlyYXRpb24gdGltZS4gT3RoZXJ3aXNlIHdlIGdldCB0ZWFyaW5nLlxuICAvL1xuICAvLyBXZSBrZWVwIHRyYWNrIG9mIHR3byBzZXBhcmF0ZSB0aW1lczogdGhlIGN1cnJlbnQgXCJyZW5kZXJlclwiIHRpbWUgYW5kIHRoZVxuICAvLyBjdXJyZW50IFwic2NoZWR1bGVyXCIgdGltZS4gVGhlIHJlbmRlcmVyIHRpbWUgY2FuIGJlIHVwZGF0ZWQgd2hlbmV2ZXI7IGl0XG4gIC8vIG9ubHkgZXhpc3RzIHRvIG1pbmltaXplIHRoZSBjYWxscyBwZXJmb3JtYW5jZS5ub3cuXG4gIC8vXG4gIC8vIEJ1dCB0aGUgc2NoZWR1bGVyIHRpbWUgY2FuIG9ubHkgYmUgdXBkYXRlZCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yaywgb3JcbiAgLy8gaWYgd2Uga25vdyBmb3IgY2VydGFpbiB0aGF0IHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGFuIGV2ZW50LlxuXG4gIGlmIChpc1JlbmRlcmluZykge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgcmVuZGVyaW5nLiBSZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgcmVhZCB0aW1lLlxuICAgIHJldHVybiBjdXJyZW50U2NoZWR1bGVyVGltZTtcbiAgfVxuICAvLyBDaGVjayBpZiB0aGVyZSdzIHBlbmRpbmcgd29yay5cbiAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgaWYgKFxuICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyXG4gICkge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrLCBvciBpZiB0aGUgcGVuZGluZyB3b3JrIGlzIG9mZnNjcmVlbiwgd2UgY2FuXG4gICAgLy8gcmVhZCB0aGUgY3VycmVudCB0aW1lIHdpdGhvdXQgcmlzayBvZiB0ZWFyaW5nLlxuICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gICAgcmV0dXJuIGN1cnJlbnRTY2hlZHVsZXJUaW1lO1xuICB9XG4gIC8vIFRoZXJlJ3MgYWxyZWFkeSBwZW5kaW5nIHdvcmsuIFdlIG1pZ2h0IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBicm93c2VyXG4gIC8vIGV2ZW50LiBJZiB3ZSB3ZXJlIHRvIHJlYWQgdGhlIGN1cnJlbnQgdGltZSwgaXQgY291bGQgY2F1c2UgbXVsdGlwbGUgdXBkYXRlc1xuICAvLyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgdG8gcmVjZWl2ZSBkaWZmZXJlbnQgZXhwaXJhdGlvbiB0aW1lcywgbGVhZGluZyB0b1xuICAvLyB0ZWFyaW5nLiBSZXR1cm4gdGhlIGxhc3QgcmVhZCB0aW1lLiBEdXJpbmcgdGhlIG5leHQgaWRsZSBjYWxsYmFjaywgdGhlXG4gIC8vIHRpbWUgd2lsbCBiZSB1cGRhdGVkLlxuICByZXR1cm4gY3VycmVudFNjaGVkdWxlclRpbWU7XG59XG5cbi8vIHJlcXVlc3RXb3JrIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHdoZW5ldmVyIGEgcm9vdCByZWNlaXZlcyBhbiB1cGRhdGUuXG4vLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdDogRmliZXJSb290LCBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUpIHtcbiAgYWRkUm9vdFRvU2NoZWR1bGUocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBiYXRjaC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyAuLi51bmxlc3Mgd2UncmUgaW5zaWRlIHVuYmF0Y2hlZFVwZGF0ZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBTeW5jLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uVGltZShyb290LCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm9vdFRvU2NoZWR1bGUocm9vdDogRmliZXJSb290LCBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgLy8gQ2hlY2sgaWYgdGhpcyByb290IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgc2NoZWR1bGUuXG4gIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICBjb25zdCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID4gcmVtYWluaW5nRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICByb290LmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCkge1xuICBsZXQgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgbGV0IGhpZ2hlc3RQcmlvcml0eVJvb3QgPSBudWxsO1xuICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICBsZXQgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3Q7XG4gICAgbGV0IHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdCAhPT0gbnVsbCAmJiBsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCxcbiAgICAgICAgICAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICtcbiAgICAgICAgICAgICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBmaXJzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgIGNvbnN0IG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA+IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5V29yayA9PT0gU3luYykge1xuICAgICAgICAgIC8vIFN5bmMgaXMgaGlnaGVzdCBwcmlvcml0eSBieSBkZWZpbml0aW9uIHNvXG4gICAgICAgICAgLy8gd2UgY2FuIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5leHRGbHVzaGVkUm9vdCA9IGhpZ2hlc3RQcmlvcml0eVJvb3Q7XG4gIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBoaWdoZXN0UHJpb3JpdHlXb3JrO1xufVxuXG4vLyBUT0RPOiBUaGlzIHdyYXBwZXIgZXhpc3RzIGJlY2F1c2UgbWFueSBvZiB0aGUgb2xkZXIgdGVzdHMgKHRoZSBvbmVzIHRoYXQgdXNlXG4vLyBmbHVzaERlZmVycmVkUHJpKSByZWx5IG9uIHRoZSBudW1iZXIgb2YgdGltZXMgYHNob3VsZFlpZWxkYCBpcyBjYWxsZWQuIFdlXG4vLyBzaG91bGQgZ2V0IHJpZCBvZiBpdC5cbmxldCBkaWRZaWVsZDogYm9vbGVhbiA9IGZhbHNlO1xuZnVuY3Rpb24gc2hvdWxkWWllbGRUb1JlbmRlcmVyKCkge1xuICBpZiAoZGlkWWllbGQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc2hvdWxkWWllbGQoKSkge1xuICAgIGRpZFlpZWxkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFzaG91bGRZaWVsZFRvUmVuZGVyZXIoKSkge1xuICAgICAgLy8gVGhlIGNhbGxiYWNrIHRpbWVkIG91dC4gVGhhdCBtZWFucyBhdCBsZWFzdCBvbmUgdXBkYXRlIGhhcyBleHBpcmVkLlxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb290IHNjaGVkdWxlLiBJZiB0aGV5IGNvbnRhaW4gZXhwaXJlZCB3b3JrLCBzZXRcbiAgICAgIC8vIHRoZSBuZXh0IHJlbmRlciBleHBpcmF0aW9uIHRpbWUgdG8gdGhlIGN1cnJlbnQgdGltZS4gVGhpcyBoYXMgdGhlIGVmZmVjdFxuICAgICAgLy8gb2YgZmx1c2hpbmcgYWxsIGV4cGlyZWQgd29yayBpbiBhIHNpbmdsZSBiYXRjaCwgaW5zdGVhZCBvZiBmbHVzaGluZyBlYWNoXG4gICAgICAvLyBsZXZlbCBvbmUgYXQgYSB0aW1lLlxuICAgICAgaWYgKGZpcnN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICByZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lKCk7XG4gICAgICAgIGxldCByb290OiBGaWJlclJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBkaWRFeHBpcmVBdEV4cGlyYXRpb25UaW1lKHJvb3QsIGN1cnJlbnRSZW5kZXJlclRpbWUpO1xuICAgICAgICAgIC8vIFRoZSByb290IHNjaGVkdWxlIGlzIGNpcmN1bGFyLCBzbyB0aGlzIGlzIG5ldmVyIG51bGwuXG4gICAgICAgICAgcm9vdCA9IChyb290Lm5leHRTY2hlZHVsZWRSb290OiBhbnkpO1xuICAgICAgICB9IHdoaWxlIChyb290ICE9PSBmaXJzdFNjaGVkdWxlZFJvb3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBwZXJmb3JtV29yayhOb1dvcmssIHRydWUpO1xuICB9IGZpbmFsbHkge1xuICAgIGRpZFlpZWxkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrKCkge1xuICBwZXJmb3JtV29yayhTeW5jLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSwgaXNZaWVsZHk6IGJvb2xlYW4pIHtcbiAgLy8gS2VlcCB3b3JraW5nIG9uIHJvb3RzIHVudGlsIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrLCBvciB1bnRpbCB0aGVyZSdzIGEgaGlnaGVyXG4gIC8vIHByaW9yaXR5IGV2ZW50LlxuICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gIGlmIChpc1lpZWxkeSkge1xuICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG5cbiAgICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgICAgY29uc3QgZGlkRXhwaXJlID0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA+IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gZXhwaXJhdGlvblRpbWVUb01zKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKFxuICAgICAgbmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmXG4gICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiZcbiAgICAgIG1pbkV4cGlyYXRpb25UaW1lIDw9IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgJiZcbiAgICAgICEoZGlkWWllbGQgJiYgY3VycmVudFJlbmRlcmVyVGltZSA+IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpXG4gICAgKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChcbiAgICAgICAgbmV4dEZsdXNoZWRSb290LFxuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLFxuICAgICAgICBjdXJyZW50UmVuZGVyZXJUaW1lID4gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgICAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICAgICAgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoXG4gICAgICBuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiZcbiAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJlxuICAgICAgbWluRXhwaXJhdGlvblRpbWUgPD0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZVxuICAgICkge1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAvLyBvciB0aGVyZSdzIG5vIG1vcmUgd29yayBsZWZ0IHdpdGggc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gIGlmIChpc1lpZWxkeSkge1xuICAgIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgY2FsbGJhY2tJRCA9IG51bGw7XG4gIH1cbiAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gIGlmIChuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb25UaW1lKFxuICAgICAgKChuZXh0Rmx1c2hlZFJvb3Q6IGFueSk6IEZpYmVyUm9vdCksXG4gICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gIH1cblxuICAvLyBDbGVhbi11cC5cbiAgZmluaXNoUmVuZGVyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUm9vdChyb290OiBGaWJlclJvb3QsIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSkge1xuICBpbnZhcmlhbnQoXG4gICAgIWlzUmVuZGVyaW5nLFxuICAgICd3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSAnICtcbiAgICAgICdtZWFucyB5b3UgYXR0ZW1wdGVkIHRvIGNvbW1pdCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuJyxcbiAgKTtcbiAgLy8gUGVyZm9ybSB3b3JrIG9uIHJvb3QgYXMgaWYgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZSBpcyB0aGUgY3VycmVudCB0aW1lLlxuICAvLyBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mIHN5bmNocm9ub3VzbHkgZmx1c2hpbmcgYWxsIHdvcmsgdXAgdG8gYW5kXG4gIC8vIGluY2x1ZGluZyB0aGUgZ2l2ZW4gdGltZS5cbiAgbmV4dEZsdXNoZWRSb290ID0gcm9vdDtcbiAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBwZXJmb3JtV29ya09uUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICAvLyBGbHVzaCBhbnkgc3luYyB3b3JrIHRoYXQgd2FzIHNjaGVkdWxlZCBieSBsaWZlY3ljbGVzXG4gIHBlcmZvcm1TeW5jV29yaygpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmcoKSB7XG4gIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgbGFzdENvbW1pdHRlZFJvb3REdXJpbmdUaGlzQmF0Y2ggPSBudWxsO1xuXG4gIGlmIChjb21wbGV0ZWRCYXRjaGVzICE9PSBudWxsKSB7XG4gICAgY29uc3QgYmF0Y2hlcyA9IGNvbXBsZXRlZEJhdGNoZXM7XG4gICAgY29tcGxldGVkQmF0Y2hlcyA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICB0cnkge1xuICAgICAgICBiYXRjaC5fb25Db21wbGV0ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgY29uc3QgZXJyb3IgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChcbiAgcm9vdDogRmliZXJSb290LFxuICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIGlzWWllbGR5OiBib29sZWFuLFxuKSB7XG4gIGludmFyaWFudChcbiAgICAhaXNSZW5kZXJpbmcsXG4gICAgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCAnICtcbiAgICAgICdieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgKTtcblxuICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhc3luYyB3b3JrIG9yIHN5bmMvZXhwaXJlZCB3b3JrLlxuICBpZiAoIWlzWWllbGR5KSB7XG4gICAgLy8gRmx1c2ggd29yayB3aXRob3V0IHlpZWxkaW5nLlxuICAgIC8vIFRPRE86IE5vbi15aWVsZHkgd29yayBkb2VzIG5vdCBuZWNlc3NhcmlseSBpbXBseSBleHBpcmVkIHdvcmsuIEEgcmVuZGVyZXJcbiAgICAvLyBtYXkgd2FudCB0byBwZXJmb3JtIHNvbWUgd29yayB3aXRob3V0IHlpZWxkaW5nLCBidXQgYWxzbyB3aXRob3V0XG4gICAgLy8gcmVxdWlyaW5nIHRoZSByb290IHRvIGNvbXBsZXRlIChieSB0cmlnZ2VyaW5nIHBsYWNlaG9sZGVycykuXG5cbiAgICBsZXQgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIC8vIElmIHRoaXMgcm9vdCBwcmV2aW91c2x5IHN1c3BlbmRlZCwgY2xlYXIgaXRzIGV4aXN0aW5nIHRpbWVvdXQsIHNpbmNlXG4gICAgICAvLyB3ZSdyZSBhYm91dCB0byB0cnkgcmVuZGVyaW5nIGFnYWluLlxuICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgfVxuICAgICAgcmVuZGVyUm9vdChyb290LCBpc1lpZWxkeSk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICBsZXQgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIC8vIElmIHRoaXMgcm9vdCBwcmV2aW91c2x5IHN1c3BlbmRlZCwgY2xlYXIgaXRzIGV4aXN0aW5nIHRpbWVvdXQsIHNpbmNlXG4gICAgICAvLyB3ZSdyZSBhYm91dCB0byB0cnkgcmVuZGVyaW5nIGFnYWluLlxuICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgfVxuICAgICAgcmVuZGVyUm9vdChyb290LCBpc1lpZWxkeSk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDaGVjayB0aGUgaWYgd2Ugc2hvdWxkIHlpZWxkIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgIGlmICghc2hvdWxkWWllbGRUb1JlbmRlcmVyKCkpIHtcbiAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBubyB0aW1lIGxlZnQuIE1hcmsgdGhpcyByb290IGFzIGNvbXBsZXRlLiBXZSdsbCBjb21lXG4gICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVSb290KFxuICByb290OiBGaWJlclJvb3QsXG4gIGZpbmlzaGVkV29yazogRmliZXIsXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IHZvaWQge1xuICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgYmF0Y2ggdGhhdCBtYXRjaGVzIHRoaXMgZXhwaXJhdGlvbiB0aW1lLlxuICBjb25zdCBmaXJzdEJhdGNoID0gcm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCAhPT0gbnVsbCAmJiBmaXJzdEJhdGNoLl9leHBpcmF0aW9uVGltZSA+PSBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjb21wbGV0ZWRCYXRjaGVzID09PSBudWxsKSB7XG4gICAgICBjb21wbGV0ZWRCYXRjaGVzID0gW2ZpcnN0QmF0Y2hdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZWRCYXRjaGVzLnB1c2goZmlyc3RCYXRjaCk7XG4gICAgfVxuICAgIGlmIChmaXJzdEJhdGNoLl9kZWZlcikge1xuICAgICAgLy8gVGhpcyByb290IGlzIGJsb2NrZWQgZnJvbSBjb21taXR0aW5nIGJ5IGEgYmF0Y2guIFVuc2NoZWR1bGUgaXQgdW50aWxcbiAgICAgIC8vIHdlIHJlY2VpdmUgYW5vdGhlciB1cGRhdGUuXG4gICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tbWl0IHRoZSByb290LlxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5lc3RlZCB1cGRhdGUgKGEgc3luYyB1cGRhdGUgc2NoZWR1bGVkIGR1cmluZyB0aGVcbiAgLy8gY29tbWl0IHBoYXNlKS5cbiAgaWYgKHJvb3QgPT09IGxhc3RDb21taXR0ZWRSb290RHVyaW5nVGhpc0JhdGNoKSB7XG4gICAgLy8gSWYgdGhlIG5leHQgcm9vdCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcm9vdCwgdGhpcyBpcyBhIG5lc3RlZFxuICAgIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCB3aGVuZXZlciB3ZSBzd2l0Y2ggcm9vdHMuXG4gICAgbGFzdENvbW1pdHRlZFJvb3REdXJpbmdUaGlzQmF0Y2ggPSByb290O1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgfVxuICBydW5XaXRoUHJpb3JpdHkoSW1tZWRpYXRlUHJpb3JpdHksICgpID0+IHtcbiAgICBjb21taXRSb290KHJvb3QsIGZpbmlzaGVkV29yayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyb3I6IG1peGVkKSB7XG4gIGludmFyaWFudChcbiAgICBuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwsXG4gICAgJ1Nob3VsZCBiZSB3b3JraW5nIG9uIGEgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcgK1xuICAgICAgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICApO1xuICAvLyBVbnNjaGVkdWxlIHRoaXMgcm9vdCBzbyB3ZSBkb24ndCB3b3JrIG9uIGl0IGFnYWluIHVudGlsIHRoZXJlJ3NcbiAgLy8gYW5vdGhlciB1cGRhdGUuXG4gIG5leHRGbHVzaGVkUm9vdC5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbi8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXM8QSwgUj4oZm46IChhOiBBKSA9PiBSLCBhOiBBKTogUiB7XG4gIGNvbnN0IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIHVuYmF0Y2hlZFVwZGF0ZXM8QSwgUj4oZm46IChhOiBBKSA9PiBSLCBhOiBBKTogUiB7XG4gIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZuKGEpO1xufVxuXG4vLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIGZsdXNoU3luYzxBLCBSPihmbjogKGE6IEEpID0+IFIsIGE6IEEpOiBSIHtcbiAgaW52YXJpYW50KFxuICAgICFpc1JlbmRlcmluZyxcbiAgICAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgJyArXG4gICAgICAnY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJyxcbiAgKTtcbiAgY29uc3QgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuLCBhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzPEEsIEIsIFI+KGZuOiAoQSwgQikgPT4gUiwgYTogQSwgYjogQik6IFIge1xuICAvLyBJZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcywgc3luY2hyb25vdXNseSBmbHVzaCB0aGVtLlxuICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgd2UgcmVhZCBhbnkgaGFuZGxlcnMsIGJlY2F1c2UgdGhlIGVmZmVjdCBvZlxuICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgbWF5IGluZmx1ZW5jZSB3aGljaCBoYW5kbGVycyBhcmUgY2FsbGVkIGR1cmluZ1xuICAvLyB0aGlzIGV2ZW50LlxuICBpZiAoXG4gICAgIWlzQmF0Y2hpbmdVcGRhdGVzICYmXG4gICAgIWlzUmVuZGVyaW5nICYmXG4gICAgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrXG4gICkge1xuICAgIC8vIFN5bmNocm9ub3VzbHkgZmx1c2ggcGVuZGluZyBpbnRlcmFjdGl2ZSB1cGRhdGVzLlxuICAgIHBlcmZvcm1Xb3JrKGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgICBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB9XG4gIGNvbnN0IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBydW5XaXRoUHJpb3JpdHkoVXNlckJsb2NraW5nUHJpb3JpdHksICgpID0+IHtcbiAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaEludGVyYWN0aXZlVXBkYXRlcygpIHtcbiAgaWYgKFxuICAgICFpc1JlbmRlcmluZyAmJlxuICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgIT09IE5vV29ya1xuICApIHtcbiAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcy5cbiAgICBwZXJmb3JtV29yayhsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gICAgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENvbnRyb2xsZWQoZm46ICgpID0+IG1peGVkKTogdm9pZCB7XG4gIGNvbnN0IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICB0cnkge1xuICAgIHN5bmNVcGRhdGVzKGZuKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQge1xuICByZXF1ZXN0Q3VycmVudFRpbWUsXG4gIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gIGNhcHR1cmVDb21taXRQaGFzZUVycm9yLFxuICBvblVuY2F1Z2h0RXJyb3IsXG4gIHJlbmRlckRpZFN1c3BlbmQsXG4gIHJlbmRlckRpZEVycm9yLFxuICBwaW5nU3VzcGVuZGVkUm9vdCxcbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5LFxuICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkLFxuICBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5LFxuICBzY2hlZHVsZVdvcmssXG4gIHJlcXVlc3RXb3JrLFxuICBmbHVzaFJvb3QsXG4gIGJhdGNoZWRVcGRhdGVzLFxuICB1bmJhdGNoZWRVcGRhdGVzLFxuICBmbHVzaFN5bmMsXG4gIGZsdXNoQ29udHJvbGxlZCxcbiAgU2NoZWR1bGVyX25leHQgYXMgZGVmZXJyZWRVcGRhdGVzLFxuICBzeW5jVXBkYXRlcyxcbiAgaW50ZXJhY3RpdmVVcGRhdGVzLFxuICBmbHVzaEludGVyYWN0aXZlVXBkYXRlcyxcbiAgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbixcbiAgZmx1c2hQYXNzaXZlRWZmZWN0cyxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyU2NoZWR1bGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG5sZXQgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKF9fREVWX18pIHtcbiAgY29uc3QgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oZm9ybWF0LCAuLi5hcmdzKSB7XG4gICAgbGV0IGFyZ0luZGV4ID0gMDtcbiAgICBjb25zdCBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgKCkgPT4gYXJnc1thcmdJbmRleCsrXSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgbG93UHJpb3JpdHlXYXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAgICdtZXNzYWdlIGFyZ3VtZW50JyxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBwcmludFdhcm5pbmcoZm9ybWF0LCAuLi5hcmdzKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxvd1ByaW9yaXR5V2FybmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9sb3dQcmlvcml0eVdhcm5pbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgIClcblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsIGZyb20gJy4vaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCc7XG5cbi8vIFVzZWQgYnkgRmliZXIgdG8gc2ltdWxhdGUgYSB0cnktY2F0Y2guXG5sZXQgaGFzRXJyb3I6IGJvb2xlYW4gPSBmYWxzZTtcbmxldCBjYXVnaHRFcnJvcjogbWl4ZWQgPSBudWxsO1xuXG4vLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxubGV0IGhhc1JldGhyb3dFcnJvcjogYm9vbGVhbiA9IGZhbHNlO1xubGV0IHJldGhyb3dFcnJvcjogbWl4ZWQgPSBudWxsO1xuXG5jb25zdCByZXBvcnRlciA9IHtcbiAgb25FcnJvcihlcnJvcjogbWl4ZWQpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfSxcbn07XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2s8QSwgQiwgQywgRCwgRSwgRiwgQ29udGV4dD4oXG4gIG5hbWU6IHN0cmluZyB8IG51bGwsXG4gIGZ1bmM6IChhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCBlOiBFLCBmOiBGKSA9PiBtaXhlZCxcbiAgY29udGV4dDogQ29udGV4dCxcbiAgYTogQSxcbiAgYjogQixcbiAgYzogQyxcbiAgZDogRCxcbiAgZTogRSxcbiAgZjogRixcbik6IHZvaWQge1xuICBoYXNFcnJvciA9IGZhbHNlO1xuICBjYXVnaHRFcnJvciA9IG51bGw7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I8XG4gIEEsXG4gIEIsXG4gIEMsXG4gIEQsXG4gIEUsXG4gIEYsXG4gIENvbnRleHQsXG4+KFxuICBuYW1lOiBzdHJpbmcgfCBudWxsLFxuICBmdW5jOiAoYTogQSwgYjogQiwgYzogQywgZDogRCwgZTogRSwgZjogRikgPT4gdm9pZCxcbiAgY29udGV4dDogQ29udGV4dCxcbiAgYTogQSxcbiAgYjogQixcbiAgYzogQyxcbiAgZDogRCxcbiAgZTogRSxcbiAgZjogRixcbik6IHZvaWQge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgY29uc3QgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldGhyb3dDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc1JldGhyb3dFcnJvcikge1xuICAgIGNvbnN0IGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NhdWdodEVycm9yKCkge1xuICByZXR1cm4gaGFzRXJyb3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhdWdodEVycm9yKCkge1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICBjb25zdCBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciAnICtcbiAgICAgICAgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL1JlYWN0RXJyb3JVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgb3BhcXVlIHR5cGUgVG9TdHJpbmdWYWx1ZSA9XG4gIHwgYm9vbGVhblxuICB8IG51bWJlclxuICB8IE9iamVjdFxuICB8IHN0cmluZ1xuICB8IG51bGxcbiAgfCB2b2lkO1xuXG4vLyBGbG93IGRvZXMgbm90IGFsbG93IHN0cmluZyBjb25jYXRlbmF0aW9uIG9mIG1vc3Qgbm9uLXN0cmluZyB0eXBlcy4gVG8gd29ya1xuLy8gYXJvdW5kIHRoaXMgbGltaXRhdGlvbiwgd2UgdXNlIGFuIG9wYXF1ZSB0eXBlIHRoYXQgY2FuIG9ubHkgYmUgb2J0YWluZWQgYnlcbi8vIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggZ2V0VG9TdHJpbmdWYWx1ZSBmaXJzdC5cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZTogVG9TdHJpbmdWYWx1ZSk6IHN0cmluZyB7XG4gIHJldHVybiAnJyArICh2YWx1ZTogYW55KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvU3RyaW5nVmFsdWUodmFsdWU6IG1peGVkKTogVG9TdHJpbmdWYWx1ZSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbCBhcmUgYXNzaWduZWQgYXMgZW1wdHkgc3RyaW5nc1xuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9Ub1N0cmluZ1ZhbHVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0ICogZnJvbSAnLi9zcmMvUmVhY3RGaWJlclRyZWVSZWZsZWN0aW9uJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvcmVmbGVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5cbi8qKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlciA9IHZhbHVlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL1JlYWN0SW5zdGFuY2VNYXAuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuXG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5cbmV4cG9ydCB0eXBlIFN0YWNrQ3Vyc29yPFQ+ID0ge1xuICBjdXJyZW50OiBULFxufTtcblxuY29uc3QgdmFsdWVTdGFjazogQXJyYXk8YW55PiA9IFtdO1xuXG5sZXQgZmliZXJTdGFjazogQXJyYXk8RmliZXIgfCBudWxsPjtcblxuaWYgKF9fREVWX18pIHtcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG5sZXQgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yPFQ+KGRlZmF1bHRWYWx1ZTogVCk6IFN0YWNrQ3Vyc29yPFQ+IHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gIHJldHVybiBpbmRleCA9PT0gLTE7XG59XG5cbmZ1bmN0aW9uIHBvcDxUPihjdXJzb3I6IFN0YWNrQ3Vyc29yPFQ+LCBmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaDxUPihjdXJzb3I6IFN0YWNrQ3Vyc29yPFQ+LCB2YWx1ZTogVCwgZmliZXI6IEZpYmVyKTogdm9pZCB7XG4gIGluZGV4Kys7XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICBpZiAoX19ERVZfXykge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja1RoYXRTdGFja0lzRW1wdHkoKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdFeHBlY3RlZCBhbiBlbXB0eSBzdGFjay4gU29tZXRoaW5nIHdhcyBub3QgcmVzZXQgcHJvcGVybHkuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldigpIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpbmRleCA9IC0xO1xuICAgIHZhbHVlU3RhY2subGVuZ3RoID0gMDtcbiAgICBmaWJlclN0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgY3JlYXRlQ3Vyc29yLFxuICBpc0VtcHR5LFxuICBwb3AsXG4gIHB1c2gsXG4gIC8vIERFViBvbmx5OlxuICBjaGVja1RoYXRTdGFja0lzRW1wdHksXG4gIHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldixcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyU3RhY2suanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0ZpYmVyUm9vdH0gZnJvbSAnLi9SZWFjdEZpYmVyUm9vdCc7XG5cbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuZGVjbGFyZSB2YXIgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fOiBPYmplY3QgfCB2b2lkO1xuXG5sZXQgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xubGV0IG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbmxldCBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhcmcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKF9fREVWX18gJiYgIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJyxcbiAgICAgICAgICBlcnIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgaXNEZXZUb29sc1ByZXNlbnQgPVxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHM6IE9iamVjdCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgK1xuICAgICAgICAgICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgK1xuICAgICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyxcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKHJvb3QgPT5cbiAgICAgIGhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCksXG4gICAgKTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZpYmVyID0+XG4gICAgICBob29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKSxcbiAgICApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJyxcbiAgICAgICAgZXJyLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25Db21taXRSb290KHJvb3Q6IEZpYmVyUm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcjogRmliZXIpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50KGZpYmVyKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckRldlRvb2xzSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7UmVhY3RQcm92aWRlclR5cGUsIFJlYWN0Q29udGV4dH0gZnJvbSAnc2hhcmVkL1JlYWN0VHlwZXMnO1xuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0ZpYmVyUm9vdH0gZnJvbSAnLi9SZWFjdEZpYmVyUm9vdCc7XG5pbXBvcnQgdHlwZSB7RXhwaXJhdGlvblRpbWV9IGZyb20gJy4vUmVhY3RGaWJlckV4cGlyYXRpb25UaW1lJztcbmltcG9ydCB0eXBlIHtTdXNwZW5zZVN0YXRlfSBmcm9tICcuL1JlYWN0RmliZXJTdXNwZW5zZUNvbXBvbmVudCc7XG5cbmltcG9ydCBjaGVja1Byb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJztcblxuaW1wb3J0IHtcbiAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCxcbiAgRnVuY3Rpb25Db21wb25lbnQsXG4gIENsYXNzQ29tcG9uZW50LFxuICBIb3N0Um9vdCxcbiAgSG9zdENvbXBvbmVudCxcbiAgSG9zdFRleHQsXG4gIEhvc3RQb3J0YWwsXG4gIEZvcndhcmRSZWYsXG4gIEZyYWdtZW50LFxuICBNb2RlLFxuICBDb250ZXh0UHJvdmlkZXIsXG4gIENvbnRleHRDb25zdW1lcixcbiAgUHJvZmlsZXIsXG4gIFN1c3BlbnNlQ29tcG9uZW50LFxuICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG4gIE1lbW9Db21wb25lbnQsXG4gIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gIExhenlDb21wb25lbnQsXG4gIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0V29ya1RhZ3MnO1xuaW1wb3J0IHtcbiAgTm9FZmZlY3QsXG4gIFBlcmZvcm1lZFdvcmssXG4gIFBsYWNlbWVudCxcbiAgQ29udGVudFJlc2V0LFxuICBEaWRDYXB0dXJlLFxuICBVcGRhdGUsXG4gIFJlZixcbiAgRGVsZXRpb24sXG59IGZyb20gJ3NoYXJlZC9SZWFjdFNpZGVFZmZlY3RUYWdzJztcbmltcG9ydCBSZWFjdFNoYXJlZEludGVybmFscyBmcm9tICdzaGFyZWQvUmVhY3RTaGFyZWRJbnRlcm5hbHMnO1xuaW1wb3J0IHtcbiAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzLFxuICBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlLFxuICBlbmFibGVQcm9maWxlclRpbWVyLFxuICBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyLFxufSBmcm9tICdzaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnc2hhcmVkL3NoYWxsb3dFcXVhbCc7XG5pbXBvcnQgZ2V0Q29tcG9uZW50TmFtZSBmcm9tICdzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZSc7XG5pbXBvcnQgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgZnJvbSAnLi9SZWFjdFN0cmljdE1vZGVXYXJuaW5ncyc7XG5pbXBvcnQge3JlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudH0gZnJvbSAnc2hhcmVkL1JlYWN0TGF6eUNvbXBvbmVudCc7XG5pbXBvcnQge1JFQUNUX0xBWllfVFlQRX0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5pbXBvcnQge1xuICBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsLFxuICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2LFxufSBmcm9tICcuL1JlYWN0Q3VycmVudEZpYmVyJztcbmltcG9ydCB7c3RhcnRXb3JrVGltZXIsIGNhbmNlbFdvcmtUaW1lcn0gZnJvbSAnLi9SZWFjdERlYnVnRmliZXJQZXJmJztcblxuaW1wb3J0IHtcbiAgbW91bnRDaGlsZEZpYmVycyxcbiAgcmVjb25jaWxlQ2hpbGRGaWJlcnMsXG4gIGNsb25lQ2hpbGRGaWJlcnMsXG59IGZyb20gJy4vUmVhY3RDaGlsZEZpYmVyJztcbmltcG9ydCB7cHJvY2Vzc1VwZGF0ZVF1ZXVlfSBmcm9tICcuL1JlYWN0VXBkYXRlUXVldWUnO1xuaW1wb3J0IHtOb1dvcmssIE5ldmVyfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQge1xuICBDb25jdXJyZW50TW9kZSxcbiAgTm9Db250ZXh0LFxuICBQcm9maWxlTW9kZSxcbiAgU3RyaWN0TW9kZSxcbn0gZnJvbSAnLi9SZWFjdFR5cGVPZk1vZGUnO1xuaW1wb3J0IHtcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUsXG59IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb25maWcnO1xuaW1wb3J0IHtwdXNoSG9zdENvbnRleHQsIHB1c2hIb3N0Q29udGFpbmVyfSBmcm9tICcuL1JlYWN0RmliZXJIb3N0Q29udGV4dCc7XG5pbXBvcnQge1xuICBwdXNoUHJvdmlkZXIsXG4gIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2UsXG4gIHJlYWRDb250ZXh0LFxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCxcbiAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG59IGZyb20gJy4vUmVhY3RGaWJlck5ld0NvbnRleHQnO1xuaW1wb3J0IHtyZXNldEhvb2tzLCByZW5kZXJXaXRoSG9va3MsIGJhaWxvdXRIb29rc30gZnJvbSAnLi9SZWFjdEZpYmVySG9va3MnO1xuaW1wb3J0IHtzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ30gZnJvbSAnLi9SZWFjdFByb2ZpbGVyVGltZXInO1xuaW1wb3J0IHtcbiAgZ2V0TWFza2VkQ29udGV4dCxcbiAgZ2V0VW5tYXNrZWRDb250ZXh0LFxuICBoYXNDb250ZXh0Q2hhbmdlZCBhcyBoYXNMZWdhY3lDb250ZXh0Q2hhbmdlZCxcbiAgcHVzaENvbnRleHRQcm92aWRlciBhcyBwdXNoTGVnYWN5Q29udGV4dFByb3ZpZGVyLFxuICBpc0NvbnRleHRQcm92aWRlciBhcyBpc0xlZ2FjeUNvbnRleHRQcm92aWRlcixcbiAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCxcbiAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcixcbn0gZnJvbSAnLi9SZWFjdEZpYmVyQ29udGV4dCc7XG5pbXBvcnQge1xuICBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gIHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxufSBmcm9tICcuL1JlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0JztcbmltcG9ydCB7XG4gIGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gIG1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICB1cGRhdGVDbGFzc0luc3RhbmNlLFxufSBmcm9tICcuL1JlYWN0RmliZXJDbGFzc0NvbXBvbmVudCc7XG5pbXBvcnQge1xuICByZWFkTGF6eUNvbXBvbmVudFR5cGUsXG4gIHJlc29sdmVEZWZhdWx0UHJvcHMsXG59IGZyb20gJy4vUmVhY3RGaWJlckxhenlDb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgcmVzb2x2ZUxhenlDb21wb25lbnRUYWcsXG4gIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyxcbiAgY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQsXG4gIGNyZWF0ZVdvcmtJblByb2dyZXNzLFxuICBpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50LFxufSBmcm9tICcuL1JlYWN0RmliZXInO1xuXG5jb25zdCBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXG5sZXQgZGlkUmVjZWl2ZVVwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5sZXQgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG5sZXQgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50O1xubGV0IGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQ7XG5sZXQgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzO1xuZXhwb3J0IGxldCBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzO1xuXG5pZiAoX19ERVZfXykge1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnMgPSB7fTtcbiAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oXG4gIGN1cnJlbnQ6IEZpYmVyIHwgbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICBuZXh0Q2hpbGRyZW46IGFueSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbnVsbCxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAvLyBJZiB3ZSBoYWQgYW55IHByb2dyZXNzZWQgd29yayBhbHJlYWR5LCB0aGF0IGlzIGludmFsaWQgYXQgdGhpcyBwb2ludCBzb1xuICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKFxuICBjdXJyZW50OiBGaWJlcixcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICBuZXh0Q2hpbGRyZW46IGFueSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbi4gSXQncyB1c2VkIGluIGNhc2VzIHdoZXJlIHdlXG4gIC8vIHdhbnQgdG8gcmVjb25jaWxlIHdpdGhvdXQgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgZXhpc3Rpbmcgc2V0LiBUaGlzIGhhcyB0aGVcbiAgLy8gZWZmZWN0IG9mIGFsbCBjdXJyZW50IGNoaWxkcmVuIGJlaW5nIHVubW91bnRlZDsgZXZlbiBpZiB0aGUgdHlwZSBhbmQga2V5XG4gIC8vIGFyZSB0aGUgc2FtZSwgdGhlIG9sZCBjaGlsZCBpcyB1bm1vdW50ZWQgYW5kIGEgbmV3IGNoaWxkIGlzIGNyZWF0ZWQuXG4gIC8vXG4gIC8vIFRvIGRvIHRoaXMsIHdlJ3JlIGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIHJlY29uY2lsZSBhbGdvcml0aG0gdHdpY2UuIEluXG4gIC8vIHRoZSBmaXJzdCBwYXNzLCB3ZSBzY2hlZHVsZSBhIGRlbGV0aW9uIGZvciBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYnlcbiAgLy8gcGFzc2luZyBudWxsLlxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgbnVsbCxcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgLy8gSW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBtb3VudCB0aGUgbmV3IGNoaWxkcmVuLiBUaGUgdHJpY2sgaGVyZSBpcyB0aGF0IHdlXG4gIC8vIHBhc3MgbnVsbCBpbiBwbGFjZSBvZiB3aGVyZSB3ZSB1c3VhbGx5IHBhc3MgdGhlIGN1cnJlbnQgY2hpbGQgc2V0LiBUaGlzIGhhc1xuICAvLyB0aGUgZWZmZWN0IG9mIHJlbW91bnRpbmcgYWxsIGNoaWxkcmVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVpciB0aGVpclxuICAvLyBpZGVudGl0eSBtYXRjaGVzLlxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG51bGwsXG4gICAgbmV4dENoaWxkcmVuLFxuICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKFxuICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgQ29tcG9uZW50OiBhbnksXG4gIG5leHRQcm9wczogYW55LFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgLy8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcbiAgLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgY29uc3QgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIGlubmVyUHJvcFR5cGVzLFxuICAgICAgICAgIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgICAncHJvcCcsXG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpLFxuICAgICAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50LnJlbmRlcjtcbiAgY29uc3QgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuXG4gIC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuICBsZXQgbmV4dENoaWxkcmVuO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICBpZiAoX19ERVZfXykge1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlcixcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgaWYgKFxuICAgICAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8XG4gICAgICAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSlcbiAgICApIHtcbiAgICAgIC8vIE9ubHkgZG91YmxlLXJlbmRlciBjb21wb25lbnRzIHdpdGggSG9va3NcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlcixcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgcmVmLFxuICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyLFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVmLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICB9XG5cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgY3VycmVudCxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICBuZXh0Q2hpbGRyZW4sXG4gICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIENvbXBvbmVudDogYW55LFxuICBuZXh0UHJvcHM6IGFueSxcbiAgdXBkYXRlRXhwaXJhdGlvblRpbWUsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IG51bGwgfCBGaWJlciB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgbGV0IHR5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICBpZiAoXG4gICAgICBpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmXG4gICAgICBDb21wb25lbnQuY29tcGFyZSA9PT0gbnVsbCAmJlxuICAgICAgLy8gU2ltcGxlTWVtb0NvbXBvbmVudCBjb2RlcGF0aCBkb2Vzbid0IHJlc29sdmUgb3V0ZXIgcHJvcHMgZWl0aGVyLlxuICAgICAgQ29tcG9uZW50LmRlZmF1bHRQcm9wcyA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcbiAgICAgIC8vIGFuZCB3aXRoIG9ubHkgdGhlIGRlZmF1bHQgc2hhbGxvdyBjb21wYXJpc29uLCB3ZSB1cGdyYWRlIGl0XG4gICAgICAvLyB0byBhIFNpbXBsZU1lbW9Db21wb25lbnQgdG8gYWxsb3cgZmFzdCBwYXRoIHVwZGF0ZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBTaW1wbGVNZW1vQ29tcG9uZW50O1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHR5cGU7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB0eXBlLFxuICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgIHVwZGF0ZUV4cGlyYXRpb25UaW1lLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBjb25zdCBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIGlubmVyUHJvcFR5cGVzLFxuICAgICAgICAgIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgICAncHJvcCcsXG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSxcbiAgICAgICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2hpbGQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICBDb21wb25lbnQudHlwZSxcbiAgICAgIG51bGwsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgIGNvbnN0IGlubmVyUHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICBpbm5lclByb3BUeXBlcyxcbiAgICAgICAgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsXG4gICAgICAgIGdldENvbXBvbmVudE5hbWUodHlwZSksXG4gICAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgY3VycmVudENoaWxkID0gKChjdXJyZW50LmNoaWxkOiBhbnkpOiBGaWJlcik7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG4gIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBwcm9wcyB3aXRoIHJlc29sdmVkIGRlZmF1bHRQcm9wcyxcbiAgICAvLyB1bmxpa2UgY3VycmVudC5tZW1vaXplZFByb3BzIHdoaWNoIHdpbGwgYmUgdGhlIHVucmVzb2x2ZWQgb25lcy5cbiAgICBjb25zdCBwcmV2UHJvcHMgPSBjdXJyZW50Q2hpbGQubWVtb2l6ZWRQcm9wcztcbiAgICAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuICAgIGxldCBjb21wYXJlID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgIT09IG51bGwgPyBjb21wYXJlIDogc2hhbGxvd0VxdWFsO1xuICAgIGlmIChjb21wYXJlKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJiBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgbGV0IG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoXG4gICAgY3VycmVudENoaWxkLFxuICAgIG5leHRQcm9wcyxcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgQ29tcG9uZW50OiBhbnksXG4gIG5leHRQcm9wczogYW55LFxuICB1cGRhdGVFeHBpcmF0aW9uVGltZSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogbnVsbCB8IEZpYmVyIHtcbiAgLy8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcbiAgLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgaW5uZXIgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICBsZXQgb3V0ZXJNZW1vVHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuICAgICAgaWYgKG91dGVyTWVtb1R5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAvLyBXZSB3YXJuIHdoZW4geW91IGRlZmluZSBwcm9wVHlwZXMgb24gbGF6eSgpXG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3Qgc2tpcCBvdmVyIGl0IHRvIGZpbmQgbWVtbygpIG91dGVyIHdyYXBwZXIuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG4gICAgICAgIG91dGVyTWVtb1R5cGUgPSByZWZpbmVSZXNvbHZlZExhenlDb21wb25lbnQob3V0ZXJNZW1vVHlwZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRlclByb3BUeXBlcyA9IG91dGVyTWVtb1R5cGUgJiYgKG91dGVyTWVtb1R5cGU6IGFueSkucHJvcFR5cGVzO1xuICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIG91dGVyUHJvcFR5cGVzLFxuICAgICAgICAgIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgKFNpbXBsZU1lbW9Db21wb25lbnQgaGFzIG5vIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICAncHJvcCcsXG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShvdXRlck1lbW9UeXBlKSxcbiAgICAgICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2LFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gSW5uZXIgcHJvcFR5cGVzIHdpbGwgYmUgdmFsaWRhdGVkIGluIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcGF0aC5cbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKFxuICAgICAgc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZlxuICAgICkge1xuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoXG4gIGN1cnJlbnQ6IEZpYmVyIHwgbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgY29uc3QgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKFxuICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIGNvbnN0IG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgY3VycmVudCxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICBuZXh0Q2hpbGRyZW4sXG4gICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoXG4gIGN1cnJlbnQ6IEZpYmVyIHwgbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICB9XG4gIGNvbnN0IG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgY29uc3QgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQ6IEZpYmVyIHwgbnVsbCwgd29ya0luUHJvZ3Jlc3M6IEZpYmVyKSB7XG4gIGNvbnN0IHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgaWYgKFxuICAgIChjdXJyZW50ID09PSBudWxsICYmIHJlZiAhPT0gbnVsbCkgfHxcbiAgICAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gcmVmKVxuICApIHtcbiAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgQ29tcG9uZW50LFxuICBuZXh0UHJvcHM6IGFueSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICBjb25zdCBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgaW5uZXJQcm9wVHlwZXMsXG4gICAgICAgICAgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAgICdwcm9wJyxcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCksXG4gICAgICAgICAgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIGxldCBuZXh0Q2hpbGRyZW47XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgY29udGV4dCxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgaWYgKFxuICAgICAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8XG4gICAgICAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSlcbiAgICApIHtcbiAgICAgIC8vIE9ubHkgZG91YmxlLXJlbmRlciBjb21wb25lbnRzIHdpdGggSG9va3NcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIENvbXBvbmVudDogYW55LFxuICBuZXh0UHJvcHMsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbikge1xuICBpZiAoX19ERVZfXykge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIGNvbnN0IGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhcbiAgICAgICAgICBpbm5lclByb3BUeXBlcyxcbiAgICAgICAgICBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICAgJ3Byb3AnLFxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSxcbiAgICAgICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICBsZXQgaGFzQ29udGV4dDtcbiAgaWYgKGlzTGVnYWN5Q29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgbGV0IHNob3VsZFVwZGF0ZTtcbiAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIEFuIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLSBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0b1xuICAgICAgLy8gdHJlZSBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgfVxuICBjb25zdCBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIHNob3VsZFVwZGF0ZSxcbiAgICBoYXNDb250ZXh0LFxuICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICApO1xuICBpZiAoX19ERVZfXykge1xuICAgIGxldCBpbnN0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChpbnN0LnByb3BzICE9PSBuZXh0UHJvcHMpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMsXG4gICAgICAgICdJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gJyArXG4gICAgICAgICAgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJyxcbiAgICAgICAgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnYSBjb21wb25lbnQnLFxuICAgICAgKTtcbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KFxuICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgQ29tcG9uZW50OiBhbnksXG4gIHNob3VsZFVwZGF0ZTogYm9vbGVhbixcbiAgaGFzQ29udGV4dDogYm9vbGVhbixcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIGNvbnN0IGRpZENhcHR1cmVFcnJvciA9ICh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSAhPT0gTm9FZmZlY3Q7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAvLyBSZXJlbmRlclxuICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxldCBuZXh0Q2hpbGRyZW47XG4gIGlmIChcbiAgICBkaWRDYXB0dXJlRXJyb3IgJiZcbiAgICB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb20gY2F0Y2ggaXMgbm90IGRlZmluZWQsXG4gICAgLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuICAgIC8vIHJlLXJlbmRlciBhIGZhbGxiYWNrLiBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCB3ZSBtaWdyYXRlIGV2ZXJ5b25lIHRvXG4gICAgLy8gdGhlIG5ldyBBUEkuXG4gICAgLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgaWYgKFxuICAgICAgICBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHxcbiAgICAgICAgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSlcbiAgICAgICkge1xuICAgICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgd2l0aG91dCByZXVzaW5nIGFueSBvZlxuICAgIC8vIHRoZSBleGlzdGluZyBjaGlsZHJlbi4gQ29uY2VwdHVhbGx5LCB0aGUgbm9ybWFsIGNoaWxkcmVuIGFuZCB0aGUgY2hpbGRyZW5cbiAgICAvLyB0aGF0IGFyZSBzaG93biBvbiBlcnJvciBhcmUgdHdvIGRpZmZlcmVudCBzZXRzLCBzbyB3ZSBzaG91bGRuJ3QgcmV1c2VcbiAgICAvLyBub3JtYWwgY2hpbGRyZW4gZXZlbiBpZiB0aGVpciBpZGVudGl0aWVzIG1hdGNoLlxuICAgIGZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgfVxuXG4gIC8vIE1lbW9pemUgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgY29uc3Qgcm9vdCA9ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU6IEZpYmVyUm9vdCk7XG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcm9vdC5wZW5kaW5nQ29udGV4dCxcbiAgICAgIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCxcbiAgICApO1xuICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gIH1cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgY29uc3QgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaW52YXJpYW50KFxuICAgIHVwZGF0ZVF1ZXVlICE9PSBudWxsLFxuICAgICdJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5ICcgK1xuICAgICAgJ2JhaWxlZCBvdXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlICcgK1xuICAgICAgJ2ZpbGUgYW4gaXNzdWUuJyxcbiAgKTtcbiAgY29uc3QgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBjb25zdCBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBjb25zdCBwcmV2Q2hpbGRyZW4gPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuZWxlbWVudCA6IG51bGw7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICB1cGRhdGVRdWV1ZSxcbiAgICBuZXh0UHJvcHMsXG4gICAgbnVsbCxcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgY29uc3QgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIGNvbnN0IG5leHRDaGlsZHJlbiA9IG5leHRTdGF0ZS5lbGVtZW50O1xuICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgdGhlIHNhbWUgYXMgYmVmb3JlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2Ugd2UgaGFkXG4gICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gIH1cbiAgY29uc3Qgcm9vdDogRmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAoXG4gICAgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkgJiZcbiAgICByb290Lmh5ZHJhdGUgJiZcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICApIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgIC8vIGtub3cgdGhhdCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBtb3VudGluZyBzdGF0ZS4gVGhhdCB3YXkgaXNNb3VudGVkXG4gICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgIC8vIG5vZGVzIHRoYXQgd2lsbCBiZSBoeWRyYXRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG51bGwsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAvLyByb290LlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIGNvbnN0IG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgY29uc3QgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgbGV0IG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgY29uc3QgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ29udGVudFJlc2V0O1xuICB9XG5cbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gIGlmIChcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiZcbiAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUgJiZcbiAgICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcylcbiAgKSB7XG4gICAgLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoXG4gIF9jdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgZWxlbWVudFR5cGUsXG4gIHVwZGF0ZUV4cGlyYXRpb25UaW1lLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbikge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgIC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgY29uc3QgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIC8vIFdlIGNhbid0IHN0YXJ0IGEgVXNlciBUaW1pbmcgbWVhc3VyZW1lbnQgd2l0aCBjb3JyZWN0IGxhYmVsIHlldC5cbiAgLy8gQ2FuY2VsIGFuZCByZXN1bWUgcmlnaHQgYWZ0ZXIgd2Uga25vdyB0aGUgdGFnLlxuICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICBsZXQgQ29tcG9uZW50ID0gcmVhZExhenlDb21wb25lbnRUeXBlKGVsZW1lbnRUeXBlKTtcbiAgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIGNvbnN0IHJlc29sdmVkVGFnID0gKHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCkpO1xuICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gIGNvbnN0IHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICBsZXQgY2hpbGQ7XG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OiB7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICBudWxsLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDoge1xuICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgRm9yd2FyZFJlZjoge1xuICAgICAgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICBudWxsLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OiB7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICBjb25zdCBvdXRlclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG4gICAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhcbiAgICAgICAgICAgICAgb3V0ZXJQcm9wVHlwZXMsXG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJyxcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpLFxuICAgICAgICAgICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkID0gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQudHlwZSwgcmVzb2x2ZWRQcm9wcyksIC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xuICAgICAgICB1cGRhdGVFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxldCBoaW50ID0gJyc7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgQ29tcG9uZW50ICE9PSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBDb21wb25lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgICApIHtcbiAgICAgICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiAlcy4gJyArXG4gICAgICAgICAgJ0xhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLiVzJyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBoaW50LFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG5mdW5jdGlvbiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChcbiAgX2N1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQW4gaW5jb21wbGV0ZSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIC8vIFByb21vdGUgdGhlIGZpYmVyIHRvIGEgY2xhc3MgYW5kIHRyeSByZW5kZXJpbmcgYWdhaW4uXG4gIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gIC8vIFRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSBmb3JrIG9mIGB1cGRhdGVDbGFzc0NvbXBvbmVudGBcblxuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgbGV0IGhhc0NvbnRleHQ7XG4gIGlmIChpc0xlZ2FjeUNvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaExlZ2FjeUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZShcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICBDb21wb25lbnQsXG4gICAgbmV4dFByb3BzLFxuICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICApO1xuICBtb3VudENsYXNzSW5zdGFuY2UoXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgKTtcblxuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoXG4gICAgbnVsbCxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICBDb21wb25lbnQsXG4gICAgdHJ1ZSxcbiAgICBoYXNDb250ZXh0LFxuICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICApO1xufVxuXG5mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoXG4gIF9jdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgQ29tcG9uZW50LFxuICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbikge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgIC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgY29uc3QgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIGNvbnN0IHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBmYWxzZSk7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgbGV0IHZhbHVlO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKFxuICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBjb25zdCBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgK1xuICAgICAgICAgICAgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgKTtcbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgIG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgY29udGV4dCxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBwcm9wcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICB9XG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgIC8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG4gICAgcmVzZXRIb29rcygpO1xuXG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIGxldCBoYXNDb250ZXh0ID0gZmFsc2U7XG4gICAgaWYgKGlzTGVnYWN5Q29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgICAgcHVzaExlZ2FjeUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgIHZhbHVlLnN0YXRlICE9PSBudWxsICYmIHZhbHVlLnN0YXRlICE9PSB1bmRlZmluZWQgPyB2YWx1ZS5zdGF0ZSA6IG51bGw7XG5cbiAgICBjb25zdCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgICBwcm9wcyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KFxuICAgICAgbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgdHJ1ZSxcbiAgICAgIGhhc0NvbnRleHQsXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25Db21wb25lbnQ7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmIChcbiAgICAgICAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8XG4gICAgICAgIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpXG4gICAgICApIHtcbiAgICAgICAgLy8gT25seSBkb3VibGUtcmVuZGVyIGNvbXBvbmVudHMgd2l0aCBIb29rc1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihudWxsLCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzOiBGaWJlciwgQ29tcG9uZW50OiBhbnkpIHtcbiAgaWYgKENvbXBvbmVudCkge1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAhQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LicsXG4gICAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcsXG4gICAgKTtcbiAgfVxuICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgbGV0IGluZm8gPSAnJztcbiAgICBjb25zdCBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICB9XG5cbiAgICBsZXQgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICBjb25zdCBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgfVxuICAgIGlmICghZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICtcbiAgICAgICAgICAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4gJyArXG4gICAgICAgICAgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJyxcbiAgICAgICAgaW5mbyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsXG4gICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICApO1xuICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgQ29tcG9uZW50LmNvbnRleHRUeXBlICE9PSBudWxsXG4gICkge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJyxcbiAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICk7XG4gICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIGNvbnN0IG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICBjb25zdCBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgLy8gV2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHVubGVzcyB0aGlzIGJvdW5kYXJ5XG4gIC8vIGFscmVhZHkgc3VzcGVuZGVkIGR1cmluZyB0aGlzIHJlbmRlciAoYGFscmVhZHlDYXB0dXJlZGAgaXMgdHJ1ZSkuXG4gIGxldCBuZXh0U3RhdGU6IFN1c3BlbnNlU3RhdGUgfCBudWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBsZXQgbmV4dERpZFRpbWVvdXQ7XG4gIGlmICgod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAgICBuZXh0U3RhdGUgPSBudWxsO1xuICAgIG5leHREaWRUaW1lb3V0ID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoaXMgYm91bmRhcnkncyBzdWJ0cmVlIGFscmVhZHkgc3VzcGVuZGVkLiBTd2l0Y2ggdG9cbiAgICAvLyByZW5kZXJpbmcgdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgIG5leHRTdGF0ZSA9IHtcbiAgICAgIHRpbWVkT3V0QXQ6IG5leHRTdGF0ZSAhPT0gbnVsbCA/IG5leHRTdGF0ZS50aW1lZE91dEF0IDogTm9Xb3JrLFxuICAgIH07XG4gICAgbmV4dERpZFRpbWVvdXQgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+RGlkQ2FwdHVyZTtcbiAgfVxuXG4gIC8vIFRoaXMgbmV4dCBwYXJ0IGlzIGEgYml0IGNvbmZ1c2luZy4gSWYgdGhlIGNoaWxkcmVuIHRpbWVvdXQsIHdlIHN3aXRjaCB0b1xuICAvLyBzaG93aW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbiBpbiBwbGFjZSBvZiB0aGUgXCJwcmltYXJ5XCIgY2hpbGRyZW4uXG4gIC8vIEhvd2V2ZXIsIHdlIGRvbid0IHdhbnQgdG8gZGVsZXRlIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGJlY2F1c2UgdGhlbiB0aGVpclxuICAvLyBzdGF0ZSB3aWxsIGJlIGxvc3QgKGJvdGggdGhlIFJlYWN0IHN0YXRlIGFuZCB0aGUgaG9zdCBzdGF0ZSwgZS5nLlxuICAvLyB1bmNvbnRyb2xsZWQgZm9ybSBpbnB1dHMpLiBJbnN0ZWFkIHdlIGtlZXAgdGhlbSBtb3VudGVkIGFuZCBoaWRlIHRoZW0uXG4gIC8vIEJvdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuIEFORCB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhcmUgcmVuZGVyZWQgYXQgdGhlXG4gIC8vIHNhbWUgdGltZS4gT25jZSB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhcmUgdW4tc3VzcGVuZGVkLCB3ZSBjYW4gZGVsZXRlXG4gIC8vIHRoZSBmYWxsYmFjayBjaGlsZHJlbiDigJQgZG9uJ3QgbmVlZCB0byBwcmVzZXJ2ZSB0aGVpciBzdGF0ZS5cbiAgLy9cbiAgLy8gVGhlIHR3byBzZXRzIG9mIGNoaWxkcmVuIGFyZSBzaWJsaW5ncyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCwgYnV0XG4gIC8vIHNlbWFudGljYWxseSwgZm9yIHB1cnBvc2VzIG9mIHJlY29uY2lsaWF0aW9uLCB0aGV5IGFyZSB0d28gc2VwYXJhdGUgc2V0cy5cbiAgLy8gU28gd2Ugc3RvcmUgdGhlbSB1c2luZyB0d28gZnJhZ21lbnQgZmliZXJzLlxuICAvL1xuICAvLyBIb3dldmVyLCB3ZSB3YW50IHRvIGF2b2lkIGFsbG9jYXRpbmcgZXh0cmEgZmliZXJzIGZvciBldmVyeSBwbGFjZWhvbGRlci5cbiAgLy8gVGhleSdyZSBvbmx5IG5lY2Vzc2FyeSB3aGVuIHRoZSBjaGlsZHJlbiB0aW1lIG91dCwgYmVjYXVzZSB0aGF0J3MgdGhlXG4gIC8vIG9ubHkgdGltZSB3aGVuIGJvdGggc2V0cyBhcmUgbW91bnRlZC5cbiAgLy9cbiAgLy8gU28sIHRoZSBleHRyYSBmcmFnbWVudCBmaWJlcnMgYXJlIG9ubHkgdXNlZCBpZiB0aGUgY2hpbGRyZW4gdGltZSBvdXQuXG4gIC8vIE90aGVyd2lzZSwgd2UgcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGRpcmVjdGx5LiBUaGlzIHJlcXVpcmVzIHNvbWVcbiAgLy8gY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljIHRvIHByZXNlcnZlIHRoZSBzdGF0ZSBvZiB0aGUgcHJpbWFyeVxuICAvLyBjaGlsZHJlbi4gSXQncyBlc3NlbnRpYWxseSBhIHZlcnkgYmFzaWMgZm9ybSBvZiByZS1wYXJlbnRpbmcuXG5cbiAgLy8gYGNoaWxkYCBwb2ludHMgdG8gdGhlIGNoaWxkIGZpYmVyLiBJbiB0aGUgbm9ybWFsIGNhc2UsIHRoaXMgaXMgdGhlIGZpcnN0XG4gIC8vIGZpYmVyIG9mIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHNldC4gSW4gdGhlIHRpbWVkLW91dCBjYXNlLCBpdCdzIGFcbiAgLy8gYSBmcmFnbWVudCBmaWJlciBjb250YWluaW5nIHRoZSBwcmltYXJ5IGNoaWxkcmVuLlxuICBsZXQgY2hpbGQ7XG4gIC8vIGBuZXh0YCBwb2ludHMgdG8gdGhlIG5leHQgZmliZXIgUmVhY3Qgc2hvdWxkIHJlbmRlci4gSW4gdGhlIG5vcm1hbCBjYXNlLFxuICAvLyBpdCdzIHRoZSBzYW1lIGFzIGBjaGlsZGA6IHRoZSBmaXJzdCBmaWJlciBvZiB0aGUgcHJpbWFyeSBjaGlsZHJlbiBzZXQuXG4gIC8vIEluIHRoZSB0aW1lZC1vdXQgY2FzZSwgaXQncyBhIGZyYWdtZW50IGZpYmVyIGNvbnRhaW5pbmcgdGhlICpmYWxsYmFjaypcbiAgLy8gY2hpbGRyZW4gLS0gd2Ugc2tpcCBvdmVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGVudGlyZWx5LlxuICBsZXQgbmV4dDtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICAgIC8vIEJ1dCBvbmx5IGlmIHRoaXMgaGFzIGEgZmFsbGJhY2suXG4gICAgICBpZiAobmV4dFByb3BzLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAvLyBUaGlzIGNvdWxkJ3ZlIGNoYW5nZWQgdGhlIHRhZyBpZiB0aGlzIHdhcyBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudGFnID09PSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgbW91bnQuIFRoaXMgYnJhbmNoIGlzIHByZXR0eSBzaW1wbGUgYmVjYXVzZSB0aGVyZSdzXG4gICAgLy8gbm8gcHJldmlvdXMgc3RhdGUgdGhhdCBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQuXG4gICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAvLyBNb3VudCBzZXBhcmF0ZSBmcmFnbWVudHMgZm9yIHByaW1hcnkgYW5kIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgY29uc3QgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICBjb25zdCBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICBudWxsLFxuICAgICAgICBtb2RlLFxuICAgICAgICBOb1dvcmssXG4gICAgICAgIG51bGwsXG4gICAgICApO1xuXG4gICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgICAvLyBPdXRzaWRlIG9mIGNvbmN1cnJlbnQgbW9kZSwgd2UgY29tbWl0IHRoZSBlZmZlY3RzIGZyb20gdGhlXG4gICAgICAgIC8vIHBhcnRpYWxseSBjb21wbGV0ZWQsIHRpbWVkLW91dCB0cmVlLCB0b28uXG4gICAgICAgIGNvbnN0IHByb2dyZXNzZWRTdGF0ZTogU3VzcGVuc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzZWRQcmltYXJ5Q2hpbGQ6IEZpYmVyIHwgbnVsbCA9XG4gICAgICAgICAgcHJvZ3Jlc3NlZFN0YXRlICE9PSBudWxsXG4gICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZDogYW55KS5jaGlsZFxuICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQ6IGFueSk7XG4gICAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkID0gcHJvZ3Jlc3NlZFByaW1hcnlDaGlsZDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgIG5leHRGYWxsYmFja0NoaWxkcmVuLFxuICAgICAgICBtb2RlLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICk7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgICAgIC8vIFNraXAgdGhlIHByaW1hcnkgY2hpbGRyZW4sIGFuZCBjb250aW51ZSB3b3JraW5nIG9uIHRoZVxuICAgICAgLy8gZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICBuZXh0ID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgY2hpbGQucmV0dXJuID0gbmV4dC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW91bnQgdGhlIHByaW1hcnkgY2hpbGRyZW4gd2l0aG91dCBhbiBpbnRlcm1lZGlhdGUgZnJhZ21lbnQgZmliZXIuXG4gICAgICBjb25zdCBuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgY2hpbGQgPSBuZXh0ID0gbW91bnRDaGlsZEZpYmVycyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5leHRQcmltYXJ5Q2hpbGRyZW4sXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuIFRoaXMgYnJhbmNoIGlzIG1vcmUgY29tcGxpY2F0ZWQgYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgLy8gZW5zdXJlIHRoZSBzdGF0ZSBvZiB0aGUgcHJpbWFyeSBjaGlsZHJlbiBpcyBwcmVzZXJ2ZWQuXG4gICAgY29uc3QgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnN0IHByZXZEaWRUaW1lb3V0ID0gcHJldlN0YXRlICE9PSBudWxsO1xuICAgIGlmIChwcmV2RGlkVGltZW91dCkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdHJlZSBhbHJlYWR5IHRpbWVkIG91dC4gVGhhdCBtZWFucyBlYWNoIGNoaWxkIHNldCBpc1xuICAgICAgLy8gd3JhcHBlZCBpbiBhIGZyYWdtZW50IGZpYmVyLlxuICAgICAgY29uc3QgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50OiBGaWJlciA9IChjdXJyZW50LmNoaWxkOiBhbnkpO1xuICAgICAgY29uc3QgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudDogRmliZXIgPSAoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc6IGFueSk7XG4gICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgLy8gU3RpbGwgdGltZWQgb3V0LiBSZXVzZSB0aGUgY3VycmVudCBwcmltYXJ5IGNoaWxkcmVuIGJ5IGNsb25pbmdcbiAgICAgICAgLy8gaXRzIGZyYWdtZW50LiBXZSdyZSBnb2luZyB0byBza2lwIG92ZXIgdGhlc2UgZW50aXJlbHkuXG4gICAgICAgIGNvbnN0IG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICBjb25zdCBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKFxuICAgICAgICAgIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCxcbiAgICAgICAgICBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzLFxuICAgICAgICAgIE5vV29yayxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgICAgIC8vIE91dHNpZGUgb2YgY29uY3VycmVudCBtb2RlLCB3ZSBjb21taXQgdGhlIGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgICAgICAvLyBwYXJ0aWFsbHkgY29tcGxldGVkLCB0aW1lZC1vdXQgdHJlZSwgdG9vLlxuICAgICAgICAgIGNvbnN0IHByb2dyZXNzZWRTdGF0ZTogU3VzcGVuc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3NlZFByaW1hcnlDaGlsZDogRmliZXIgfCBudWxsID1cbiAgICAgICAgICAgIHByb2dyZXNzZWRTdGF0ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZDogYW55KS5jaGlsZFxuICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZDogYW55KTtcbiAgICAgICAgICBpZiAocHJvZ3Jlc3NlZFByaW1hcnlDaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkKSB7XG4gICAgICAgICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZCA9IHByb2dyZXNzZWRQcmltYXJ5Q2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVjYXVzZSBwcmltYXJ5Q2hpbGRGcmFnbWVudCBpcyBhIG5ldyBmaWJlciB0aGF0IHdlJ3JlIGluc2VydGluZyBhcyB0aGVcbiAgICAgICAgLy8gcGFyZW50IG9mIGEgbmV3IHRyZWUsIHdlIG5lZWQgdG8gc2V0IGl0cyB0cmVlQmFzZUR1cmF0aW9uLlxuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAvLyB0cmVlQmFzZUR1cmF0aW9uIGlzIHRoZSBzdW0gb2YgYWxsIHRoZSBjaGlsZCB0cmVlIGJhc2UgZHVyYXRpb25zLlxuICAgICAgICAgIGxldCB0cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICBsZXQgaGlkZGVuQ2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZDtcbiAgICAgICAgICB3aGlsZSAoaGlkZGVuQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gaGlkZGVuQ2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgIGhpZGRlbkNoaWxkID0gaGlkZGVuQ2hpbGQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9uZSB0aGUgZmFsbGJhY2sgY2hpbGQgZnJhZ21lbnQsIHRvby4gVGhlc2Ugd2UnbGwgY29udGludWVcbiAgICAgICAgLy8gd29ya2luZyBvbi5cbiAgICAgICAgY29uc3QgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gKHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhcbiAgICAgICAgICBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LFxuICAgICAgICAgIG5leHRGYWxsYmFja0NoaWxkcmVuLFxuICAgICAgICAgIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQuZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICkpO1xuICAgICAgICBjaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICAgICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgICAvLyBTa2lwIHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBhbmQgY29udGludWUgd29ya2luZyBvbiB0aGVcbiAgICAgICAgLy8gZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgIG5leHQgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgICAgIGNoaWxkLnJldHVybiA9IG5leHQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBsb25nZXIgc3VzcGVuZGVkLiBTd2l0Y2ggYmFjayB0byBzaG93aW5nIHRoZSBwcmltYXJ5IGNoaWxkcmVuLFxuICAgICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBpbnRlcm1lZGlhdGUgZnJhZ21lbnQgZmliZXIuXG4gICAgICAgIGNvbnN0IG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcmltYXJ5Q2hpbGQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGQ7XG4gICAgICAgIGNvbnN0IHByaW1hcnlDaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGN1cnJlbnRQcmltYXJ5Q2hpbGQsXG4gICAgICAgICAgbmV4dFByaW1hcnlDaGlsZHJlbixcbiAgICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiB0aGlzIHJlbmRlciBkb2Vzbid0IHN1c3BlbmQsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBmYWxsYmFja1xuICAgICAgICAvLyBjaGlsZHJlbi4gV2FpdCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UsIGFmdGVyIHdlJ3ZlIGNvbmZpcm1lZCB0aGVcbiAgICAgICAgLy8gZmFsbGJhY2sgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICAgICAgLy8gVE9ETzogV291bGQgaXQgYmUgYmV0dGVyIHRvIHN0b3JlIHRoZSBmYWxsYmFjayBmcmFnbWVudCBvblxuICAgICAgICAvLyB0aGUgc3RhdGVOb2RlP1xuXG4gICAgICAgIC8vIENvbnRpbnVlIHJlbmRlcmluZyB0aGUgY2hpbGRyZW4sIGxpa2Ugd2Ugbm9ybWFsbHkgZG8uXG4gICAgICAgIGNoaWxkID0gbmV4dCA9IHByaW1hcnlDaGlsZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdHJlZSBoYXMgbm90IGFscmVhZHkgdGltZWQgb3V0LiBUaGF0IG1lYW5zIHRoZSBwcmltYXJ5XG4gICAgICAvLyBjaGlsZHJlbiBhcmUgbm90IHdyYXBwZWQgaW4gYSBmcmFnbWVudCBmaWJlci5cbiAgICAgIGNvbnN0IGN1cnJlbnRQcmltYXJ5Q2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgIC8vIFRpbWVkIG91dC4gV3JhcCB0aGUgY2hpbGRyZW4gaW4gYSBmcmFnbWVudCBmaWJlciB0byBrZWVwIHRoZW1cbiAgICAgICAgLy8gc2VwYXJhdGUgZnJvbSB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICBjb25zdCBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgIC8vIEl0IHNob3VsZG4ndCBtYXR0ZXIgd2hhdCB0aGUgcGVuZGluZyBwcm9wcyBhcmUgYmVjYXVzZSB3ZSBhcmVuJ3RcbiAgICAgICAgICAvLyBnb2luZyB0byByZW5kZXIgdGhpcyBmcmFnbWVudC5cbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgTm9Xb3JrLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICk7XG4gICAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkID0gY3VycmVudFByaW1hcnlDaGlsZDtcblxuICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBjcmVhdGluZyBhIG5ldyBmaWJlciwgdGhlcmUgYXJlIG5vIG5ldyBjaGlsZHJlbixcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSdyZSByZXVzaW5nIGFuIGFscmVhZHkgbW91bnRlZCB0cmVlLiBTbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcGxhY2VtZW50LlxuICAgICAgICAvLyBwcmltYXJ5Q2hpbGRGcmFnbWVudC5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgICAgLy8gT3V0c2lkZSBvZiBjb25jdXJyZW50IG1vZGUsIHdlIGNvbW1pdCB0aGUgZWZmZWN0cyBmcm9tIHRoZVxuICAgICAgICAgIC8vIHBhcnRpYWxseSBjb21wbGV0ZWQsIHRpbWVkLW91dCB0cmVlLCB0b28uXG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3NlZFN0YXRlOiBTdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzc2VkUHJpbWFyeUNoaWxkOiBGaWJlciB8IG51bGwgPVxuICAgICAgICAgICAgcHJvZ3Jlc3NlZFN0YXRlICE9PSBudWxsXG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmNoaWxkOiBhbnkpLmNoaWxkXG4gICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkOiBhbnkpO1xuICAgICAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkID0gcHJvZ3Jlc3NlZFByaW1hcnlDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlY2F1c2UgcHJpbWFyeUNoaWxkRnJhZ21lbnQgaXMgYSBuZXcgZmliZXIgdGhhdCB3ZSdyZSBpbnNlcnRpbmcgYXMgdGhlXG4gICAgICAgIC8vIHBhcmVudCBvZiBhIG5ldyB0cmVlLCB3ZSBuZWVkIHRvIHNldCBpdHMgdHJlZUJhc2VEdXJhdGlvbi5cbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgLy8gdHJlZUJhc2VEdXJhdGlvbiBpcyB0aGUgc3VtIG9mIGFsbCB0aGUgY2hpbGQgdHJlZSBiYXNlIGR1cmF0aW9ucy5cbiAgICAgICAgICBsZXQgdHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgbGV0IGhpZGRlbkNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKGhpZGRlbkNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGhpZGRlbkNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgICAgICBoaWRkZW5DaGlsZCA9IGhpZGRlbkNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSB0cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgZnJhZ21lbnQgZnJvbSB0aGUgZmFsbGJhY2sgY2hpbGRyZW4sIHRvby5cbiAgICAgICAgY29uc3QgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gKHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICBuZXh0RmFsbGJhY2tDaGlsZHJlbixcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICkpO1xuICAgICAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICAgICAgY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgICAgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICBuZXh0ID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgICBjaGlsZC5yZXR1cm4gPSBuZXh0LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RpbGwgaGF2ZW4ndCB0aW1lZCBvdXQuICBDb250aW51ZSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLCBsaWtlIHdlXG4gICAgICAgIC8vIG5vcm1hbGx5IGRvLlxuICAgICAgICBjb25zdCBuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgICBuZXh0ID0gY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjdXJyZW50UHJpbWFyeUNoaWxkLFxuICAgICAgICAgIG5leHRQcmltYXJ5Q2hpbGRyZW4sXG4gICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbikge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIER1cmluZyB0aGUgZmlyc3QgcGFzcywgd2UnbGwgYmFpbCBvdXQgYW5kIG5vdCBkcmlsbCBpbnRvIHRoZSBjaGlsZHJlbi5cbiAgICAvLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB0aGUgY29udGVudCBpbiBwbGFjZSBhbmQgdHJ5IHRvIGh5ZHJhdGUgaXQgbGF0ZXIuXG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBXZSB1c2UgY2hpbGRFeHBpcmF0aW9uVGltZSB0byBpbmRpY2F0ZSB0aGF0IGEgY2hpbGQgbWlnaHQgZGVwZW5kIG9uIGNvbnRleHQsIHNvIGlmXG4gIC8vIGFueSBjb250ZXh0IGhhcyBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHRyZWF0IGlzIGFzIGlmIHRoZSBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQuXG4gIGNvbnN0IGhhc0NvbnRleHRDaGFuZ2VkID0gY3VycmVudC5jaGlsZEV4cGlyYXRpb25UaW1lID49IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICBpZiAoZGlkUmVjZWl2ZVVwZGF0ZSB8fCBoYXNDb250ZXh0Q2hhbmdlZCkge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGZpcnN0IHJlbmRlci4gVGhpcyBtZWFucyB0aGF0IHdlIGFyZSBub3cgdW5hYmxlIHRvXG4gICAgLy8gaHlkcmF0ZSBpdC4gV2UgbWlnaHQgc3RpbGwgYmUgYWJsZSB0byBoeWRyYXRlIGl0IHVzaW5nIGFuIGVhcmxpZXIgZXhwaXJhdGlvbiB0aW1lIGJ1dFxuICAgIC8vIGR1cmluZyB0aGlzIHJlbmRlciB3ZSBjYW4ndC4gSW5zdGVhZCwgd2UncmUgZ29pbmcgdG8gZGVsZXRlIHRoZSB3aG9sZSBzdWJ0cmVlIGFuZFxuICAgIC8vIGluc3RlYWQgaW5qZWN0IGEgbmV3IHJlYWwgU3VzcGVuc2UgYm91bmRhcnkgdG8gdGFrZSBpdHMgcGxhY2UsIHdoaWNoIG1heSByZW5kZXIgY29udGVudFxuICAgIC8vIG9yIGZhbGxiYWNrLiBUaGUgcmVhbCBTdXNwZW5zZSBib3VuZGFyeSB3aWxsIHN1c3BlbmQgZm9yIGEgd2hpbGUgc28gd2UgaGF2ZSBzb21lIHRpbWVcbiAgICAvLyB0byBlbnN1cmUgaXQgY2FuIHByb2R1Y2UgcmVhbCBjb250ZW50LCBidXQgYWxsIHN0YXRlIGFuZCBwZW5kaW5nIGV2ZW50cyB3aWxsIGJlIGxvc3QuXG5cbiAgICAvLyBEZXRhY2ggZnJvbSB0aGUgY3VycmVudCBkZWh5ZHJhdGVkIGJvdW5kYXJ5LlxuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gICAgLy8gSW5zZXJ0IGEgZGVsZXRpb24gaW4gdGhlIGVmZmVjdCBsaXN0LlxuICAgIGxldCByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXR1cm5GaWJlciAhPT0gbnVsbCxcbiAgICAgICdTdXNwZW5zZSBib3VuZGFyaWVzIGFyZSBuZXZlciBvbiB0aGUgcm9vdC4gJyArXG4gICAgICAgICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicsXG4gICAgKTtcbiAgICBjb25zdCBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY3VycmVudDtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGN1cnJlbnQuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBVcGdyYWRlIHRoaXMgd29yayBpbiBwcm9ncmVzcyB0byBhIHJlYWwgU3VzcGVuc2UgY29tcG9uZW50LlxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFN1c3BlbnNlQ29tcG9uZW50O1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgLy8gVGhpcyBpcyBub3cgYW4gaW5zZXJ0aW9uLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gICAgLy8gUmV0cnkgYXMgYSByZWFsIFN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG4gICAgcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICBjb25zdCBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgY29uc3QgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbnVsbCxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9IGVsc2Uge1xuICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQuIExlYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiBpbiBwbGFjZS5cbiAgICAvLyBUT0RPOiBJbiBub24tY29uY3VycmVudCBtb2RlLCBzaG91bGQgd2UgY29tbWl0IHRoZSBub2RlcyB3ZSBoYXZlIGh5ZHJhdGVkIHNvIGZhcj9cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KFxuICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKSB7XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gIGNvbnN0IG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG51bGwsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbikge1xuICBjb25zdCBwcm92aWRlclR5cGU6IFJlYWN0UHJvdmlkZXJUeXBlPGFueT4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICBjb25zdCBjb250ZXh0OiBSZWFjdENvbnRleHQ8YW55PiA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcblxuICBjb25zdCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIGNvbnN0IG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhcbiAgICAgICAgcHJvdmlkZXJQcm9wVHlwZXMsXG4gICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAncHJvcCcsXG4gICAgICAgICdDb250ZXh0LlByb3ZpZGVyJyxcbiAgICAgICAgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBuZXdWYWx1ZSk7XG5cbiAgaWYgKG9sZFByb3BzICE9PSBudWxsKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICBjb25zdCBjaGFuZ2VkQml0cyA9IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKGNvbnRleHQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgaWYgKGNoYW5nZWRCaXRzID09PSAwKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKFxuICAgICAgICBvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiZcbiAgICAgICAgIWhhc0xlZ2FjeUNvbnRleHRDaGFuZ2VkKClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoYW5nZWRCaXRzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxubGV0IGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoXG4gIGN1cnJlbnQ6IEZpYmVyIHwgbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgbGV0IGNvbnRleHQ6IFJlYWN0Q29udGV4dDxhbnk+ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuICBpZiAoX19ERVZfXykge1xuICAgIGlmICgoY29udGV4dDogYW55KS5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArXG4gICAgICAgICAgICAgICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gKGNvbnRleHQ6IGFueSkuX2NvbnRleHQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBjb25zdCByZW5kZXIgPSBuZXdQcm9wcy5jaGlsZHJlbjtcblxuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICB0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nLFxuICAgICAgJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICtcbiAgICAgICAgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICtcbiAgICAgICAgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICtcbiAgICAgICAgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJyxcbiAgICApO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgY29uc3QgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0LCBuZXdQcm9wcy51bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xuICBsZXQgbmV3Q2hpbGRyZW47XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogRmliZXIgfCBudWxsIHtcbiAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGNvbnRleHQgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzLmNvbnRleHREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmNvbnRleHREZXBlbmRlbmNpZXM7XG4gIH1cblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIGFueSBwZW5kaW5nIHdvcmsuXG4gIGNvbnN0IGNoaWxkRXhwaXJhdGlvblRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICBpZiAoY2hpbGRFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4gICAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5Xb3JrKFxuICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogRmliZXIgfCBudWxsIHtcbiAgY29uc3QgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZTtcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIGNvbnN0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBoYXNMZWdhY3lDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBJZiBwcm9wcyBvciBjb250ZXh0IGNoYW5nZWQsIG1hcmsgdGhlIGZpYmVyIGFzIGhhdmluZyBwZXJmb3JtZWQgd29yay5cbiAgICAgIC8vIFRoaXMgbWF5IGJlIHVuc2V0IGlmIHRoZSBwcm9wcyBhcmUgZGV0ZXJtaW5lZCB0byBiZSBlcXVhbCBsYXRlciAobWVtbykuXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgICAgIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAgICAgLy8gaW4gdGhpcyBvcHRpbWl6ZWQgcGF0aCwgbW9zdGx5IHB1c2hpbmcgc3R1ZmYgb250byB0aGUgc3RhY2suXG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgICAgICBjb25zdCBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChpc0xlZ2FjeUNvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICBwdXNoTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbnRleHRQcm92aWRlcjoge1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDoge1xuICAgICAgICAgIGNvbnN0IHN0YXRlOiBTdXNwZW5zZVN0YXRlIHwgbnVsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgY29uc3QgZGlkVGltZW91dCA9IHN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIGlmIChkaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGlzIGN1cnJlbnRseSB0aW1lZCBvdXQsIHdlIG5lZWQgdG8gZGVjaWRlXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgLy8gY2hpbGQgZnJhZ21lbnQuXG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5Q2hpbGRGcmFnbWVudDogRmliZXIgPSAod29ya0luUHJvZ3Jlc3MuY2hpbGQ6IGFueSk7XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5Q2hpbGRFeHBpcmF0aW9uVGltZSA9XG4gICAgICAgICAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByaW1hcnlDaGlsZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiZcbiAgICAgICAgICAgICAgcHJpbWFyeUNoaWxkRXhwaXJhdGlvblRpbWUgPj0gcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgICAvLyB0byBhdHRlbXB0IHRvIHJlbmRlciB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhZ2Fpbi5cbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBkbyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgd2l0aCBzdWZmaWNpZW50XG4gICAgICAgICAgICAgIC8vIHByaW9yaXR5LiBCYWlsb3V0LlxuICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSBjaGlsZHJlbiBhbmQgd29yayBvbiB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IHtcbiAgICAgICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGF0IHRoaXMgY29tcG9uZW50IHdpbGwgc3VzcGVuZCBhZ2FpbiBiZWNhdXNlIGlmIGl0IGhhc1xuICAgICAgICAgICAgLy8gYmVlbiB1bnN1c3BlbmRlZCBpdCBoYXMgY29tbWl0dGVkIGFzIGEgcmVndWxhciBTdXNwZW5zZSBjb21wb25lbnQuXG4gICAgICAgICAgICAvLyBJZiBpdCBuZWVkcyB0byBiZSByZXRyaWVkLCBpdCBzaG91bGQgaGF2ZSB3b3JrIHNjaGVkdWxlZCBvbiBpdC5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY2xlYXIgdGhlIGV4cGlyYXRpb24gdGltZS5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG4gICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgZWxlbWVudFR5cGUsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OiB7XG4gICAgICBjb25zdCBlbGVtZW50VHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIGVsZW1lbnRUeXBlLFxuICAgICAgICB1cGRhdGVFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OiB7XG4gICAgICBjb25zdCBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgY29uc3QgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgY29uc3QgcmVzb2x2ZWRQcm9wcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBDb21wb25lbnRcbiAgICAgICAgICA/IHVucmVzb2x2ZWRQcm9wc1xuICAgICAgICAgIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHVucmVzb2x2ZWRQcm9wcyk7XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDoge1xuICAgICAgY29uc3QgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIGNvbnN0IHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIGNvbnN0IHJlc29sdmVkUHJvcHMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gQ29tcG9uZW50XG4gICAgICAgICAgPyB1bnJlc29sdmVkUHJvcHNcbiAgICAgICAgICA6IHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCB1bnJlc29sdmVkUHJvcHMpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICBjYXNlIEZvcndhcmRSZWY6IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgY29uc3QgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgY29uc3QgcmVzb2x2ZWRQcm9wcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSB0eXBlXG4gICAgICAgICAgPyB1bnJlc29sdmVkUHJvcHNcbiAgICAgICAgICA6IHJlc29sdmVEZWZhdWx0UHJvcHModHlwZSwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgY29uc3QgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgLy8gUmVzb2x2ZSBvdXRlciBwcm9wcyBmaXJzdCwgdGhlbiByZXNvbHZlIGlubmVyIHByb3BzLlxuICAgICAgbGV0IHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKHR5cGUsIHVucmVzb2x2ZWRQcm9wcyk7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICBjb25zdCBvdXRlclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgICAgIG91dGVyUHJvcFR5cGVzLFxuICAgICAgICAgICAgICByZXNvbHZlZFByb3BzLCAvLyBSZXNvbHZlZCBmb3Igb3V0ZXIgb25seVxuICAgICAgICAgICAgICAncHJvcCcsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWUodHlwZSksXG4gICAgICAgICAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHModHlwZS50eXBlLCByZXNvbHZlZFByb3BzKTtcbiAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgdXBkYXRlRXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OiB7XG4gICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgdXBkYXRlRXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgIGNvbnN0IENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBjb25zdCB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBjb25zdCByZXNvbHZlZFByb3BzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IENvbXBvbmVudFxuICAgICAgICAgID8gdW5yZXNvbHZlZFByb3BzXG4gICAgICAgICAgOiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDoge1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gJyArXG4gICAgICAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICk7XG59XG5cbmV4cG9ydCB7YmVnaW5Xb3JrfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJCZWdpbldvcmsuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge1N0YWNrQ3Vyc29yfSBmcm9tICcuL1JlYWN0RmliZXJTdGFjayc7XG5pbXBvcnQgdHlwZSB7Q29udGFpbmVyLCBIb3N0Q29udGV4dH0gZnJvbSAnLi9SZWFjdEZpYmVySG9zdENvbmZpZyc7XG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5cbmltcG9ydCB7Z2V0Q2hpbGRIb3N0Q29udGV4dCwgZ2V0Um9vdEhvc3RDb250ZXh0fSBmcm9tICcuL1JlYWN0RmliZXJIb3N0Q29uZmlnJztcbmltcG9ydCB7Y3JlYXRlQ3Vyc29yLCBwdXNoLCBwb3B9IGZyb20gJy4vUmVhY3RGaWJlclN0YWNrJztcblxuZGVjbGFyZSBjbGFzcyBOb0NvbnRleHRUIHt9XG5jb25zdCBOT19DT05URVhUOiBOb0NvbnRleHRUID0gKHt9OiBhbnkpO1xuXG5sZXQgY29udGV4dFN0YWNrQ3Vyc29yOiBTdGFja0N1cnNvcjxIb3N0Q29udGV4dCB8IE5vQ29udGV4dFQ+ID0gY3JlYXRlQ3Vyc29yKFxuICBOT19DT05URVhULFxuKTtcbmxldCBjb250ZXh0RmliZXJTdGFja0N1cnNvcjogU3RhY2tDdXJzb3I8RmliZXIgfCBOb0NvbnRleHRUPiA9IGNyZWF0ZUN1cnNvcihcbiAgTk9fQ09OVEVYVCxcbik7XG5sZXQgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3I6IFN0YWNrQ3Vyc29yPENvbnRhaW5lciB8IE5vQ29udGV4dFQ+ID0gY3JlYXRlQ3Vyc29yKFxuICBOT19DT05URVhULFxuKTtcblxuZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0PFZhbHVlPihjOiBWYWx1ZSB8IE5vQ29udGV4dFQpOiBWYWx1ZSB7XG4gIGludmFyaWFudChcbiAgICBjICE9PSBOT19DT05URVhULFxuICAgICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICtcbiAgICAgICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgKTtcbiAgcmV0dXJuIChjOiBhbnkpO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpOiBDb250YWluZXIge1xuICBjb25zdCByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyOiBGaWJlciwgbmV4dFJvb3RJbnN0YW5jZTogQ29udGFpbmVyKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuXG4gIC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBOT19DT05URVhULCBmaWJlcik7XG4gIGNvbnN0IG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyOiBGaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKTogSG9zdENvbnRleHQge1xuICBjb25zdCBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgY29uc3Qgcm9vdEluc3RhbmNlOiBDb250YWluZXIgPSByZXF1aXJlZENvbnRleHQoXG4gICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgKTtcbiAgY29uc3QgY29udGV4dDogSG9zdENvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICBjb25zdCBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSwgcm9vdEluc3RhbmNlKTtcblxuICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0SG9zdENvbnRleHQsXG4gIGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICBwb3BIb3N0Q29udGFpbmVyLFxuICBwb3BIb3N0Q29udGV4dCxcbiAgcHVzaEhvc3RDb250YWluZXIsXG4gIHB1c2hIb3N0Q29udGV4dCxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVySG9zdENvbnRleHQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuLi8uLi9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyJztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbmNvbnN0IFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IChudWxsOiBudWxsIHwgRmliZXIpLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RDdXJyZW50T3duZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RDdXJyZW50T3duZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1JlYWN0RWxlbWVudH0gZnJvbSAnc2hhcmVkL1JlYWN0RWxlbWVudFR5cGUnO1xuXG5pbXBvcnQgZGVzY3JpYmVDb21wb25lbnRGcmFtZSBmcm9tICdzaGFyZWQvZGVzY3JpYmVDb21wb25lbnRGcmFtZSc7XG5pbXBvcnQgZ2V0Q29tcG9uZW50TmFtZSBmcm9tICdzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZSc7XG5cbmNvbnN0IFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxubGV0IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gKG51bGw6IG51bGwgfCBSZWFjdEVsZW1lbnQpO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudDogbnVsbCB8IFJlYWN0RWxlbWVudCkge1xuICBpZiAoX19ERVZfXykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgfVxufVxuXG5pZiAoX19ERVZfXykge1xuICAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSAobnVsbDogbnVsbCB8ICgoKSA9PiBzdHJpbmcpKTtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbigpOiBzdHJpbmcge1xuICAgIGxldCBzdGFjayA9ICcnO1xuXG4gICAgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQudHlwZSk7XG4gICAgICBjb25zdCBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsXG4gICAgICAgIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSksXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdERlYnVnQ3VycmVudEZyYW1lLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCB0eXBlIFRoZW5hYmxlPFQsIFI+ID0ge1xuICB0aGVuKHJlc29sdmU6IChUKSA9PiBtaXhlZCwgcmVqZWN0OiAobWl4ZWQpID0+IG1peGVkKTogUixcbn07XG5cbmV4cG9ydCB0eXBlIExhenlDb21wb25lbnQ8VD4gPSB7XG4gICQkdHlwZW9mOiBTeW1ib2wgfCBudW1iZXIsXG4gIF9jdG9yOiAoKSA9PiBUaGVuYWJsZTx7ZGVmYXVsdDogVH0sIG1peGVkPixcbiAgX3N0YXR1czogMCB8IDEgfCAyLFxuICBfcmVzdWx0OiBhbnksXG59O1xuXG50eXBlIFJlc29sdmVkTGF6eUNvbXBvbmVudDxUPiA9IHtcbiAgJCR0eXBlb2Y6IFN5bWJvbCB8IG51bWJlcixcbiAgX2N0b3I6ICgpID0+IFRoZW5hYmxlPHtkZWZhdWx0OiBUfSwgbWl4ZWQ+LFxuICBfc3RhdHVzOiAxLFxuICBfcmVzdWx0OiBhbnksXG59O1xuXG5leHBvcnQgY29uc3QgUGVuZGluZyA9IDA7XG5leHBvcnQgY29uc3QgUmVzb2x2ZWQgPSAxO1xuZXhwb3J0IGNvbnN0IFJlamVjdGVkID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudDxUPihcbiAgbGF6eUNvbXBvbmVudDogTGF6eUNvbXBvbmVudDxUPixcbik6IFJlc29sdmVkTGF6eUNvbXBvbmVudDxUPiB8IG51bGwge1xuICByZXR1cm4gbGF6eUNvbXBvbmVudC5fc3RhdHVzID09PSBSZXNvbHZlZCA/IGxhenlDb21wb25lbnQuX3Jlc3VsdCA6IG51bGw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9zaGFyZWQvUmVhY3RMYXp5Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmdXaXRob3V0U3RhY2sgZnJvbSAnc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2snO1xuaW1wb3J0IHtSRUFDVF9FTEVNRU5UX1RZUEV9IGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuaW1wb3J0IFJlYWN0Q3VycmVudE93bmVyIGZyb20gJy4vUmVhY3RDdXJyZW50T3duZXInO1xuXG5cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY29uc3QgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlLFxufTtcblxubGV0IHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIGNvbnN0IGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgY29uc3QgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICBjb25zdCB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgK1xuICAgICAgICAgICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgK1xuICAgICAgICAgICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgK1xuICAgICAgICAgICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsXG4gICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgY29uc3Qgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICtcbiAgICAgICAgICAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICtcbiAgICAgICAgICAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICtcbiAgICAgICAgICAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLFxuICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lcixcbiAgfTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGYsXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlLFxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgbGV0IHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgY29uc3QgcHJvcHMgPSB7fTtcblxuICBsZXQga2V5ID0gbnVsbDtcbiAgbGV0IHJlZiA9IG51bGw7XG4gIGxldCBzZWxmID0gbnVsbDtcbiAgbGV0IHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJlxuICAgICAgICAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpXG4gICAgICApIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgY29uc3QgZGlzcGxheU5hbWUgPVxuICAgICAgICB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nXG4gICAgICAgICAgOiB0eXBlO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgIHR5cGUsXG4gICAga2V5LFxuICAgIHJlZixcbiAgICBzZWxmLFxuICAgIHNvdXJjZSxcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LFxuICAgIHByb3BzLFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnkodHlwZSkge1xuICBjb25zdCBmYWN0b3J5ID0gY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIGA8Rm9vIC8+LnR5cGUgPT09IEZvb2AuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIGNvbnN0IG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQoXG4gICAgb2xkRWxlbWVudC50eXBlLFxuICAgIG5ld0tleSxcbiAgICBvbGRFbGVtZW50LnJlZixcbiAgICBvbGRFbGVtZW50Ll9zZWxmLFxuICAgIG9sZEVsZW1lbnQuX3NvdXJjZSxcbiAgICBvbGRFbGVtZW50Ll9vd25lcixcbiAgICBvbGRFbGVtZW50LnByb3BzLFxuICApO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGludmFyaWFudChcbiAgICAhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSxcbiAgICAnUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgJXMuJyxcbiAgICBlbGVtZW50LFxuICApO1xuXG4gIGxldCBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICBsZXQga2V5ID0gZWxlbWVudC5rZXk7XG4gIGxldCByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgY29uc3Qgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICBjb25zdCBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICBsZXQgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgbGV0IGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiZcbiAgICAgICAgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge2ludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcn0gZnJvbSAnc2hhcmVkL1JlYWN0RXJyb3JVdGlscyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmdXaXRob3V0U3RhY2sgZnJvbSAnc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2snO1xuXG5leHBvcnQgbGV0IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xuZXhwb3J0IGxldCBnZXRJbnN0YW5jZUZyb21Ob2RlID0gbnVsbDtcbmV4cG9ydCBsZXQgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb21wb25lbnRUcmVlKFxuICBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlSW1wbCxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZUltcGwsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2VJbXBsLFxuKSB7XG4gIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlSW1wbDtcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IGdldEluc3RhbmNlRnJvbU5vZGVJbXBsO1xuICBnZXROb2RlRnJvbUluc3RhbmNlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZUltcGw7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgICAgICdFdmVudFBsdWdpblV0aWxzLnNldENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArXG4gICAgICAgICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJyxcbiAgICApO1xuICB9XG59XG5cbmxldCB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmIChfX0RFVl9fKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjb25zdCBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICBjb25zdCBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIGNvbnN0IGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgY29uc3QgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnJcbiAgICAgID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoXG4gICAgICA6IGRpc3BhdGNoTGlzdGVuZXJzXG4gICAgICAgID8gMVxuICAgICAgICA6IDA7XG5cbiAgICBjb25zdCBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIGNvbnN0IGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyXG4gICAgICA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aFxuICAgICAgOiBkaXNwYXRjaEluc3RhbmNlc1xuICAgICAgICA/IDFcbiAgICAgICAgOiAwO1xuXG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgIGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbixcbiAgICAgICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJyxcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgY29uc3QgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQpIHtcbiAgY29uc3QgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIGNvbnN0IGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAoX19ERVZfXykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIGNvbnN0IGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICBjb25zdCBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKF9fREVWX18pIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlKGV2ZW50KSB7XG4gIGNvbnN0IHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZURpcmVjdERpc3BhdGNoKGV2ZW50KSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGNvbnN0IGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIGNvbnN0IGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGludmFyaWFudChcbiAgICAhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSxcbiAgICAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nLFxuICApO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZGlzcGF0Y2hMaXN0ZW5lclxuICAgID8gZ2V0Tm9kZUZyb21JbnN0YW5jZShkaXNwYXRjaEluc3RhbmNlKVxuICAgIDogbnVsbDtcbiAgY29uc3QgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9ldmVudHMvRXZlbnRQbHVnaW5VdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuXG5pbXBvcnQge1xuICBnZXRJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlLFxufSBmcm9tICcuL0V2ZW50UGx1Z2luVXRpbHMnO1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxubGV0IHJlc3RvcmVJbXBsID0gbnVsbDtcbmxldCByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbmxldCByZXN0b3JlUXVldWUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgLy8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuICAvLyBhbHdheXMgcmVjZWl2ZSB0aGUgY29ycmVjdCBmaWJlciBoZXJlXG4gIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIHJlc3RvcmVJbXBsID09PSAnZnVuY3Rpb24nLFxuICAgICdzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oKSBuZWVkcyB0byBiZSBjYWxsZWQgdG8gaGFuZGxlIGEgdGFyZ2V0IGZvciBjb250cm9sbGVkICcgK1xuICAgICAgJ2V2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICApO1xuICBjb25zdCBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpO1xuICByZXN0b3JlSW1wbChpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlLCBwcm9wcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oXG4gIGltcGw6IChkb21FbGVtZW50OiBFbGVtZW50LCB0YWc6IHN0cmluZywgcHJvcHM6IE9iamVjdCkgPT4gdm9pZCxcbik6IHZvaWQge1xuICByZXN0b3JlSW1wbCA9IGltcGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldDogRXZlbnRUYXJnZXQpOiB2b2lkIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKTogYm9vbGVhbiB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgY29uc3QgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbiAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvZXZlbnRzL1JlYWN0Q29udHJvbGxlZENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHtcbiAgbmVlZHNTdGF0ZVJlc3RvcmUsXG4gIHJlc3RvcmVTdGF0ZUlmTmVlZGVkLFxufSBmcm9tICcuL1JlYWN0Q29udHJvbGxlZENvbXBvbmVudCc7XG5cbi8vIFVzZWQgYXMgYSB3YXkgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcyB3aGVuIHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG9cbi8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuXG4vLyBEZWZhdWx0c1xubGV0IF9iYXRjaGVkVXBkYXRlc0ltcGwgPSBmdW5jdGlvbihmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5sZXQgX2ludGVyYWN0aXZlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbihmbiwgYSwgYikge1xuICByZXR1cm4gZm4oYSwgYik7XG59O1xubGV0IF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbigpIHt9O1xuXG5sZXQgaXNCYXRjaGluZyA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNCYXRjaGluZykge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLlxuICAgIHJldHVybiBmbihib29ra2VlcGluZyk7XG4gIH1cbiAgaXNCYXRjaGluZyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9iYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNCYXRjaGluZyA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzID0gbmVlZHNTdGF0ZVJlc3RvcmUoKTtcbiAgICBpZiAoY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMpIHtcbiAgICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgICAvLyB0aGUgRE9NIG5vZGUgYmFjayB0byB0aGUgY29udHJvbGxlZCB2YWx1ZS4gVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiBSZWFjdFxuICAgICAgLy8gYmFpbHMgb3V0IG9mIHRoZSB1cGRhdGUgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgICAgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCgpO1xuICAgICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyYWN0aXZlVXBkYXRlcyhmbiwgYSwgYikge1xuICByZXR1cm4gX2ludGVyYWN0aXZlVXBkYXRlc0ltcGwoZm4sIGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMoKSB7XG4gIHJldHVybiBfZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKFxuICBiYXRjaGVkVXBkYXRlc0ltcGwsXG4gIGludGVyYWN0aXZlVXBkYXRlc0ltcGwsXG4gIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCxcbikge1xuICBfYmF0Y2hlZFVwZGF0ZXNJbXBsID0gYmF0Y2hlZFVwZGF0ZXNJbXBsO1xuICBfaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGludGVyYWN0aXZlVXBkYXRlc0ltcGw7XG4gIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwgPSBmbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9ldmVudHMvUmVhY3RHZW5lcmljQmF0Y2hpbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxudHlwZSBWYWx1ZVRyYWNrZXIgPSB7XG4gIGdldFZhbHVlKCk6IHN0cmluZyxcbiAgc2V0VmFsdWUodmFsdWU6IHN0cmluZyk6IHZvaWQsXG4gIHN0b3BUcmFja2luZygpOiB2b2lkLFxufTtcbnR5cGUgV3JhcHBlclN0YXRlID0ge192YWx1ZVRyYWNrZXI/OiA/VmFsdWVUcmFja2VyfTtcbnR5cGUgRWxlbWVudFdpdGhWYWx1ZVRyYWNrZXIgPSBIVE1MSW5wdXRFbGVtZW50ICYgV3JhcHBlclN0YXRlO1xuXG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtOiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gIGNvbnN0IHR5cGUgPSBlbGVtLnR5cGU7XG4gIGNvbnN0IG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIChcbiAgICBub2RlTmFtZSAmJlxuICAgIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiZcbiAgICAodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGU6IEVsZW1lbnRXaXRoVmFsdWVUcmFja2VyKSB7XG4gIHJldHVybiBub2RlLl92YWx1ZVRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIGRldGFjaFRyYWNrZXIobm9kZTogRWxlbWVudFdpdGhWYWx1ZVRyYWNrZXIpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlOiBIVE1MSW5wdXRFbGVtZW50KTogc3RyaW5nIHtcbiAgbGV0IHZhbHVlID0gJyc7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZTogYW55KTogP1ZhbHVlVHJhY2tlciB7XG4gIGNvbnN0IHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLFxuICAgIHZhbHVlRmllbGQsXG4gICk7XG5cbiAgbGV0IGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChcbiAgICBub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8XG4gICAgdHlwZW9mIGRlc2NyaXB0b3IgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7Z2V0LCBzZXR9ID0gZGVzY3JpcHRvcjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfSxcbiAgfSk7XG4gIC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gIH0pO1xuXG4gIGNvbnN0IHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgIH0sXG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmcoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHRyYWNrZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFjayhub2RlOiBFbGVtZW50V2l0aFZhbHVlVHJhY2tlcikge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChub2RlOiBFbGVtZW50V2l0aFZhbHVlVHJhY2tlcikge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB0cmFja2VyID0gZ2V0VHJhY2tlcihub2RlKTtcbiAgLy8gaWYgdGhlcmUgaXMgbm8gdHJhY2tlciBhdCB0aGlzIHBvaW50IGl0J3MgdW5saWtlbHlcbiAgLy8gdGhhdCB0cnlpbmcgYWdhaW4gd2lsbCBzdWNjZWVkXG4gIGlmICghdHJhY2tlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICBjb25zdCBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcFRyYWNraW5nKG5vZGU6IEVsZW1lbnRXaXRoVmFsdWVUcmFja2VyKSB7XG4gIGNvbnN0IHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICBpZiAodHJhY2tlcikge1xuICAgIHRyYWNrZXIuc3RvcFRyYWNraW5nKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L2lucHV0VmFsdWVUcmFja2luZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNoZWNrUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnO1xuaW1wb3J0IFJlYWN0U2hhcmVkSW50ZXJuYWxzIGZyb20gJ3NoYXJlZC9SZWFjdFNoYXJlZEludGVybmFscyc7XG5cbmxldCBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gbnVsbDtcblxuY29uc3QgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsLFxufTtcblxuaWYgKF9fREVWX18pIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbiAgY29uc3QgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZSxcbiAgfTtcblxuICBjb25zdCBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgIHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAnWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgK1xuICAgICAgICAgICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgK1xuICAgICAgICAgICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgK1xuICAgICAgICAgICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nLFxuICAgICAgKTtcbiAgICB9LFxuICAgIGNoZWNrZWQ6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICBwcm9wcy5kaXNhYmxlZCB8fFxuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgK1xuICAgICAgICAgICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgK1xuICAgICAgICAgICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArXG4gICAgICAgICAgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicsXG4gICAgICApO1xuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbih0YWdOYW1lLCBwcm9wcykge1xuICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgcHJvcFR5cGVzLFxuICAgICAgcHJvcHMsXG4gICAgICAncHJvcCcsXG4gICAgICB0YWdOYW1lLFxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtLFxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55TmF0aXZlRXZlbnR9IGZyb20gJ2V2ZW50cy9QbHVnaW5Nb2R1bGVUeXBlJztcblxuY29uc3QgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5Jyxcbn07XG5cbi8vIE9sZGVyIGJyb3dzZXJzIChTYWZhcmkgPD0gMTAsIGlPUyBTYWZhcmkgPD0gMTAuMikgZG8gbm90IHN1cHBvcnRcbi8vIGdldE1vZGlmaWVyU3RhdGUuIElmIGdldE1vZGlmaWVyU3RhdGUgaXMgbm90IHN1cHBvcnRlZCwgd2UgbWFwIGl0IHRvIGEgc2V0IG9mXG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50LiBJbiB0aGlzIGNhc2UsIExvY2sta2V5cyBhcmUgbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3Qgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICBjb25zdCBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgY29uc3Qga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUoXG4gIG5hdGl2ZUV2ZW50OiBBbnlOYXRpdmVFdmVudCxcbik6IChrZXlBcmc6IHN0cmluZykgPT4gYm9vbGVhbiB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IGlzIGZyb20gJy4vb2JqZWN0SXMnO1xuXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakE6IG1peGVkLCBvYmpCOiBtaXhlZCk6IGJvb2xlYW4ge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHxcbiAgICBvYmpBID09PSBudWxsIHx8XG4gICAgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8XG4gICAgb2JqQiA9PT0gbnVsbFxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHxcbiAgICAgICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYWxsb3dFcXVhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9zaGFsbG93RXF1YWwuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeDogYW55LCB5OiBhbnkpIHtcbiAgcmV0dXJuIChcbiAgICAoeCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9vYmplY3RJcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICBsZXQgY2hhckNvZGU7XG4gIGNvbnN0IGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2dldEV2ZW50Q2hhckNvZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxuZXhwb3J0IGRlZmF1bHQgMTA3Mzc0MTgyMztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL21heFNpZ25lZDMxQml0SW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcblxuaW1wb3J0IHtnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2R9IGZyb20gJy4vUmVhY3RDdXJyZW50RmliZXInO1xuXG5pbXBvcnQgZ2V0Q29tcG9uZW50TmFtZSBmcm9tICdzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZSc7XG5pbXBvcnQge1N0cmljdE1vZGV9IGZyb20gJy4vUmVhY3RUeXBlT2ZNb2RlJztcbmltcG9ydCBsb3dQcmlvcml0eVdhcm5pbmcgZnJvbSAnc2hhcmVkL2xvd1ByaW9yaXR5V2FybmluZyc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5cbnR5cGUgTElGRUNZQ0xFID1cbiAgfCAnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCdcbiAgfCAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnXG4gIHwgJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbnR5cGUgTGlmZWN5Y2xlVG9Db21wb25lbnRzTWFwID0ge1tsaWZlY3ljbGU6IExJRkVDWUNMRV06IEFycmF5PEZpYmVyPn07XG50eXBlIEZpYmVyVG9MaWZlY3ljbGVNYXAgPSBNYXA8RmliZXIsIExpZmVjeWNsZVRvQ29tcG9uZW50c01hcD47XG50eXBlIEZpYmVyQXJyYXkgPSBBcnJheTxGaWJlcj47XG50eXBlIEZpYmVyVG9GaWJlckNvbXBvbmVudHNNYXAgPSBNYXA8RmliZXIsIEZpYmVyQXJyYXk+O1xuXG5jb25zdCBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpOiB2b2lkIHt9LFxuICBmbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzKCk6IHZvaWQge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk6IHZvaWQge30sXG4gIHJlY29yZERlcHJlY2F0aW9uV2FybmluZ3MoZmliZXI6IEZpYmVyLCBpbnN0YW5jZTogYW55KTogdm9pZCB7fSxcbiAgcmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoZmliZXI6IEZpYmVyLCBpbnN0YW5jZTogYW55KTogdm9pZCB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoZmliZXI6IEZpYmVyLCBpbnN0YW5jZTogYW55KTogdm9pZCB7fSxcbiAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpOiB2b2lkIHt9LFxufTtcblxuaWYgKF9fREVWX18pIHtcbiAgY29uc3QgTElGRUNZQ0xFX1NVR0dFU1RJT05TID0ge1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJyxcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gIH07XG5cbiAgbGV0IHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5nczogQXJyYXk8RmliZXI+ID0gW107XG4gIGxldCBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzOiBBcnJheTxGaWJlcj4gPSBbXTtcbiAgbGV0IHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3M6IEFycmF5PEZpYmVyPiA9IFtdO1xuICBsZXQgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBGaWJlclRvTGlmZWN5Y2xlTWFwID0gbmV3IE1hcCgpO1xuICBsZXQgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nOiBGaWJlclRvRmliZXJDb21wb25lbnRzTWFwID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG4gIGNvbnN0IGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICBjb25zdCBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICBjb25zdCBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIGNvbnN0IHNldFRvU29ydGVkU3RyaW5nID0gc2V0ID0+IHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIHNldC5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gKCkgPT4ge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9ICgpID0+IHtcbiAgICAoKHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogYW55KTogRmliZXJUb0xpZmVjeWNsZU1hcCkuZm9yRWFjaChcbiAgICAgIChsaWZlY3ljbGVXYXJuaW5nc01hcCwgc3RyaWN0Um9vdCkgPT4ge1xuICAgICAgICBjb25zdCBsaWZlY3ljbGVzV2FybmluZ01lc3NhZ2VzID0gW107XG5cbiAgICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2gobGlmZWN5Y2xlID0+IHtcbiAgICAgICAgICBjb25zdCBsaWZlY3ljbGVXYXJuaW5ncyA9IGxpZmVjeWNsZVdhcm5pbmdzTWFwW2xpZmVjeWNsZV07XG4gICAgICAgICAgaWYgKGxpZmVjeWNsZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGlmZWN5Y2xlV2FybmluZ3MuZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gbGlmZWN5Y2xlLnJlcGxhY2UoJ1VOU0FGRV8nLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0aW9uID0gTElGRUNZQ0xFX1NVR0dFU1RJT05TW2xpZmVjeWNsZV07XG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRDb21wb25lbnROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudE5hbWVzKTtcblxuICAgICAgICAgICAgbGlmZWN5Y2xlc1dhcm5pbmdNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICBgJHtmb3JtYXR0ZWR9OiBQbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50cyB0byB1c2UgYCArXG4gICAgICAgICAgICAgICAgYCR7c3VnZ2VzdGlvbn0gaW5zdGVhZDogJHtzb3J0ZWRDb21wb25lbnROYW1lc31gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChsaWZlY3ljbGVzV2FybmluZ01lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBzdHJpY3RSb290Q29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoXG4gICAgICAgICAgICBzdHJpY3RSb290LFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnVW5zYWZlIGxpZmVjeWNsZSBtZXRob2RzIHdlcmUgZm91bmQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZTolcycgK1xuICAgICAgICAgICAgICAnXFxuXFxuJXMnICtcbiAgICAgICAgICAgICAgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArXG4gICAgICAgICAgICAgICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLXdhcm5pbmdzJyxcbiAgICAgICAgICAgIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgIGxpZmVjeWNsZXNXYXJuaW5nTWVzc2FnZXMuam9pbignXFxuXFxuJyksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuXG4gICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICB9O1xuXG4gIGNvbnN0IGZpbmRTdHJpY3RSb290ID0gKGZpYmVyOiBGaWJlcik6IEZpYmVyIHwgbnVsbCA9PiB7XG4gICAgbGV0IG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG5cbiAgICBsZXQgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZVN0cmljdFJvb3Q7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncyA9ICgpID0+IHtcbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZmliZXIgPT4ge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArXG4gICAgICAgICAgJ1VzZSBjb21wb25lbnREaWRNb3VudCBpbnN0ZWFkLiBBcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLCAnICtcbiAgICAgICAgICAneW91IGNhbiByZW5hbWUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudC4nICtcbiAgICAgICAgICAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArXG4gICAgICAgICAgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArXG4gICAgICAgICAgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsXG4gICAgICAgIHNvcnRlZE5hbWVzLFxuICAgICAgKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZmliZXIgPT4ge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgK1xuICAgICAgICAgICdVc2Ugc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyBpbnN0ZWFkLicgK1xuICAgICAgICAgICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICtcbiAgICAgICAgICAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICtcbiAgICAgICAgICAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJyxcbiAgICAgICAgc29ydGVkTmFtZXMsXG4gICAgICApO1xuXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZmliZXIgPT4ge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2NvbXBvbmVudFdpbGxVcGRhdGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgK1xuICAgICAgICAgICdVc2UgY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuIEFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmQsICcgK1xuICAgICAgICAgICd5b3UgY2FuIHJlbmFtZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZS4nICtcbiAgICAgICAgICAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArXG4gICAgICAgICAgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArXG4gICAgICAgICAgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsXG4gICAgICAgIHNvcnRlZE5hbWVzLFxuICAgICAgKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmREZXByZWNhdGlvbldhcm5pbmdzID0gKFxuICAgIGZpYmVyOiBGaWJlcixcbiAgICBpbnN0YW5jZTogYW55LFxuICApID0+IHtcbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlXG4gICAgKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWVcbiAgICApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWVcbiAgICApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gKFxuICAgIGZpYmVyOiBGaWJlcixcbiAgICBpbnN0YW5jZTogYW55LFxuICApID0+IHtcbiAgICBjb25zdCBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgK1xuICAgICAgICAgICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICAvLyBUaGlzIGlzIGRpZmZpY3VsdCB0byB0cmFjayBhbnkgb3RoZXIgd2F5IHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICAgIC8vIGFyZSBvZnRlbiB2YWd1ZSBhbmQgYXJlIGxpa2VseSB0byBjb2xsaWRlIGJldHdlZW4gM3JkIHBhcnR5IGxpYnJhcmllcy5cbiAgICAvLyBBbiBleHBhbmQgcHJvcGVydHkgaXMgcHJvYmFibHkgb2theSB0byB1c2UgaGVyZSBzaW5jZSBpdCdzIERFVi1vbmx5LFxuICAgIC8vIGFuZCB3aWxsIG9ubHkgYmUgc2V0IGluIHRoZSBldmVudCBvZiBzZXJpb3VzIHdhcm5pbmdzLlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB3YXJuaW5nc0ZvclJvb3Q7XG4gICAgaWYgKCFwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuaGFzKHN0cmljdFJvb3QpKSB7XG4gICAgICB3YXJuaW5nc0ZvclJvb3QgPSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6IFtdLFxuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzLmdldChzdHJpY3RSb290KTtcbiAgICB9XG5cbiAgICBjb25zdCB1bnNhZmVMaWZlY3ljbGVzID0gW107XG4gICAgaWYgKFxuICAgICAgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09XG4gICAgICAgICAgdHJ1ZSkgfHxcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB8fFxuICAgICAgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB1bnNhZmVMaWZlY3ljbGVzLnB1c2goJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgfVxuXG4gICAgaWYgKHVuc2FmZUxpZmVjeWNsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5mb3JFYWNoKGxpZmVjeWNsZSA9PiB7XG4gICAgICAgICgod2FybmluZ3NGb3JSb290OiBhbnkpOiBMaWZlY3ljbGVUb0NvbXBvbmVudHNNYXApW2xpZmVjeWNsZV0ucHVzaChcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IChcbiAgICBmaWJlcjogRmliZXIsXG4gICAgaW5zdGFuY2U6IGFueSxcbiAgKSA9PiB7XG4gICAgY29uc3Qgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICtcbiAgICAgICAgICAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7XG5cbiAgICBpZiAoXG4gICAgICBmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8XG4gICAgICBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGwgfHxcbiAgICAgIChpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgaWYgKHdhcm5pbmdzRm9yUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IFtdO1xuICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSAoKSA9PiB7XG4gICAgKChwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmc6IGFueSk6IEZpYmVyVG9GaWJlckNvbXBvbmVudHNNYXApLmZvckVhY2goXG4gICAgICAoZmliZXJBcnJheTogRmliZXJBcnJheSwgc3RyaWN0Um9vdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZpYmVyID0+IHtcbiAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuICAgICAgICBjb25zdCBzdHJpY3RSb290Q29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoXG4gICAgICAgICAgc3RyaWN0Um9vdCxcbiAgICAgICAgKTtcblxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZTogJXMnICtcbiAgICAgICAgICAgICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICtcbiAgICAgICAgICAgICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgK1xuICAgICAgICAgICAgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3Qtc3RyaWN0LW1vZGUtd2FybmluZ3MnLFxuICAgICAgICAgIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayxcbiAgICAgICAgICBzb3J0ZWROYW1lcyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7TGF6eUNvbXBvbmVudCwgVGhlbmFibGV9IGZyb20gJ3NoYXJlZC9SZWFjdExhenlDb21wb25lbnQnO1xuXG5pbXBvcnQge1Jlc29sdmVkLCBSZWplY3RlZCwgUGVuZGluZ30gZnJvbSAnc2hhcmVkL1JlYWN0TGF6eUNvbXBvbmVudCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudDogYW55LCBiYXNlUHJvcHM6IE9iamVjdCk6IE9iamVjdCB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgY29uc3QgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRMYXp5Q29tcG9uZW50VHlwZTxUPihsYXp5Q29tcG9uZW50OiBMYXp5Q29tcG9uZW50PFQ+KTogVCB7XG4gIGNvbnN0IHN0YXR1cyA9IGxhenlDb21wb25lbnQuX3N0YXR1cztcbiAgY29uc3QgcmVzdWx0ID0gbGF6eUNvbXBvbmVudC5fcmVzdWx0O1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgUmVzb2x2ZWQ6IHtcbiAgICAgIGNvbnN0IENvbXBvbmVudDogVCA9IHJlc3VsdDtcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfVxuICAgIGNhc2UgUmVqZWN0ZWQ6IHtcbiAgICAgIGNvbnN0IGVycm9yOiBtaXhlZCA9IHJlc3VsdDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjYXNlIFBlbmRpbmc6IHtcbiAgICAgIGNvbnN0IHRoZW5hYmxlOiBUaGVuYWJsZTxULCBtaXhlZD4gPSByZXN1bHQ7XG4gICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGF6eUNvbXBvbmVudC5fc3RhdHVzID0gUGVuZGluZztcbiAgICAgIGNvbnN0IGN0b3IgPSBsYXp5Q29tcG9uZW50Ll9jdG9yO1xuICAgICAgY29uc3QgdGhlbmFibGUgPSBjdG9yKCk7XG4gICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICBtb2R1bGVPYmplY3QgPT4ge1xuICAgICAgICAgIGlmIChsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAnbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgK1xuICAgICAgICAgICAgICAgICAgICBcImNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcIixcbiAgICAgICAgICAgICAgICAgIG1vZHVsZU9iamVjdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgLy8gSGFuZGxlIHN5bmNocm9ub3VzIHRoZW5hYmxlcy5cbiAgICAgIHN3aXRjaCAobGF6eUNvbXBvbmVudC5fc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgUmVzb2x2ZWQ6XG4gICAgICAgICAgcmV0dXJuIGxhenlDb21wb25lbnQuX3Jlc3VsdDtcbiAgICAgICAgY2FzZSBSZWplY3RlZDpcbiAgICAgICAgICB0aHJvdyBsYXp5Q29tcG9uZW50Ll9yZXN1bHQ7XG4gICAgICB9XG4gICAgICBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckxhenlDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuXG5pbXBvcnQge2VuYWJsZVByb2ZpbGVyVGltZXJ9IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5cbmltcG9ydCB7bm93fSBmcm9tICcuL1JlYWN0RmliZXJIb3N0Q29uZmlnJztcblxuZXhwb3J0IHR5cGUgUHJvZmlsZXJUaW1lciA9IHtcbiAgZ2V0Q29tbWl0VGltZSgpOiBudW1iZXIsXG4gIHJlY29yZENvbW1pdFRpbWUoKTogdm9pZCxcbiAgc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyOiBGaWJlcik6IHZvaWQsXG4gIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKGZpYmVyOiBGaWJlcik6IHZvaWQsXG4gIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXI6IEZpYmVyKTogdm9pZCxcbn07XG5cbmxldCBjb21taXRUaW1lOiBudW1iZXIgPSAwO1xubGV0IHByb2ZpbGVyU3RhcnRUaW1lOiBudW1iZXIgPSAtMTtcblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpOiBudW1iZXIge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpOiB2b2lkIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbW1pdFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyOiBGaWJlcik6IHZvaWQge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdygpO1xuXG4gIGlmICgoKGZpYmVyLmFjdHVhbFN0YXJ0VGltZTogYW55KTogbnVtYmVyKSA8IDApIHtcbiAgICBmaWJlci5hY3R1YWxTdGFydFRpbWUgPSBub3coKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoXG4gIGZpYmVyOiBGaWJlcixcbiAgb3ZlcnJpZGVCYXNlVGltZTogYm9vbGVhbixcbik6IHZvaWQge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIGdldENvbW1pdFRpbWUsXG4gIHJlY29yZENvbW1pdFRpbWUsXG4gIHN0YXJ0UHJvZmlsZXJUaW1lcixcbiAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcsXG4gIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RQcm9maWxlclRpbWVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWU6IHN0cmluZywgcHJvcHM6IE9iamVjdCkge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQ3VzdG9tQ29tcG9uZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvaXNDdXN0b21Db21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNi44LjInO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL1JlYWN0VmVyc2lvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QtYXNzaWduJztcbmltcG9ydCB7XG4gIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrLFxuICB1bnN0YWJsZV9zaG91bGRZaWVsZCxcbiAgdW5zdGFibGVfbm93LFxuICB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksXG4gIHVuc3RhYmxlX25leHQsXG4gIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlLFxuICB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbixcbiAgdW5zdGFibGVfY29udGludWVFeGVjdXRpb24sXG4gIHVuc3RhYmxlX3dyYXBDYWxsYmFjayxcbiAgdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsXG59IGZyb20gJ3NjaGVkdWxlcic7XG5pbXBvcnQge1xuICBfX2ludGVyYWN0aW9uc1JlZixcbiAgX19zdWJzY3JpYmVyUmVmLFxuICB1bnN0YWJsZV9jbGVhcixcbiAgdW5zdGFibGVfZ2V0Q3VycmVudCxcbiAgdW5zdGFibGVfZ2V0VGhyZWFkSUQsXG4gIHVuc3RhYmxlX3N1YnNjcmliZSxcbiAgdW5zdGFibGVfdHJhY2UsXG4gIHVuc3RhYmxlX3Vuc3Vic2NyaWJlLFxuICB1bnN0YWJsZV93cmFwLFxufSBmcm9tICdzY2hlZHVsZXIvdHJhY2luZyc7XG5pbXBvcnQgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciBmcm9tICcuL1JlYWN0Q3VycmVudERpc3BhdGNoZXInO1xuaW1wb3J0IFJlYWN0Q3VycmVudE93bmVyIGZyb20gJy4vUmVhY3RDdXJyZW50T3duZXInO1xuaW1wb3J0IFJlYWN0RGVidWdDdXJyZW50RnJhbWUgZnJvbSAnLi9SZWFjdERlYnVnQ3VycmVudEZyYW1lJztcblxuY29uc3QgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudE93bmVyLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ24sXG59O1xuXG5pZiAoX19VTURfXykge1xuICAvLyBSZS1leHBvcnQgdGhlIHNjaGVkdWxlIEFQSShzKSBmb3IgVU1EIGJ1bmRsZXMuXG4gIC8vIFRoaXMgYXZvaWRzIGludHJvZHVjaW5nIGEgZGVwZW5kZW5jeSBvbiBhIG5ldyBVTUQgZ2xvYmFsIGluIGEgbWlub3IgdXBkYXRlLFxuICAvLyBTaW5jZSB0aGF0IHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlIChlLmcuIGZvciBhbGwgZXhpc3RpbmcgQ29kZVNhbmRib3hlcykuXG4gIC8vIFRoaXMgcmUtZXhwb3J0IGlzIG9ubHkgcmVxdWlyZWQgZm9yIFVNRCBidW5kbGVzO1xuICAvLyBDSlMgYnVuZGxlcyB1c2UgdGhlIHNoYXJlZCBOUE0gcGFja2FnZS5cbiAgT2JqZWN0LmFzc2lnbihSZWFjdFNoYXJlZEludGVybmFscywge1xuICAgIFNjaGVkdWxlcjoge1xuICAgICAgdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgICB1bnN0YWJsZV9zaG91bGRZaWVsZCxcbiAgICAgIHVuc3RhYmxlX25vdyxcbiAgICAgIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgICB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksXG4gICAgICB1bnN0YWJsZV9uZXh0LFxuICAgICAgdW5zdGFibGVfd3JhcENhbGxiYWNrLFxuICAgICAgdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUsXG4gICAgICB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbixcbiAgICAgIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uLFxuICAgICAgdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsXG4gICAgfSxcbiAgICBTY2hlZHVsZXJUcmFjaW5nOiB7XG4gICAgICBfX2ludGVyYWN0aW9uc1JlZixcbiAgICAgIF9fc3Vic2NyaWJlclJlZixcbiAgICAgIHVuc3RhYmxlX2NsZWFyLFxuICAgICAgdW5zdGFibGVfZ2V0Q3VycmVudCxcbiAgICAgIHVuc3RhYmxlX2dldFRocmVhZElELFxuICAgICAgdW5zdGFibGVfc3Vic2NyaWJlLFxuICAgICAgdW5zdGFibGVfdHJhY2UsXG4gICAgICB1bnN0YWJsZV91bnN1YnNjcmliZSxcbiAgICAgIHVuc3RhYmxlX3dyYXAsXG4gICAgfSxcbiAgfSk7XG59XG5cbmlmIChfX0RFVl9fKSB7XG4gIE9iamVjdC5hc3NpZ24oUmVhY3RTaGFyZWRJbnRlcm5hbHMsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9LFxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RTaGFyZWRJbnRlcm5hbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0ICogZnJvbSAnLi9zcmMvU2NoZWR1bGVyJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NjaGVkdWxlci9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge2VuYWJsZVNjaGVkdWxlclRyYWNpbmd9IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5cbmV4cG9ydCB0eXBlIEludGVyYWN0aW9uID0ge3xcbiAgX19jb3VudDogbnVtYmVyLFxuICBpZDogbnVtYmVyLFxuICBuYW1lOiBzdHJpbmcsXG4gIHRpbWVzdGFtcDogbnVtYmVyLFxufH07XG5cbmV4cG9ydCB0eXBlIFN1YnNjcmliZXIgPSB7XG4gIC8vIEEgbmV3IGludGVyYWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQgdmlhIHRoZSB0cmFjZSgpIG1ldGhvZC5cbiAgb25JbnRlcmFjdGlvblRyYWNlZDogKGludGVyYWN0aW9uOiBJbnRlcmFjdGlvbikgPT4gdm9pZCxcblxuICAvLyBBbGwgc2NoZWR1bGVkIGFzeW5jIHdvcmsgZm9yIGFuIGludGVyYWN0aW9uIGhhcyBmaW5pc2hlZC5cbiAgb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQ6IChpbnRlcmFjdGlvbjogSW50ZXJhY3Rpb24pID0+IHZvaWQsXG5cbiAgLy8gTmV3IGFzeW5jIHdvcmsgaGFzIGJlZW4gc2NoZWR1bGVkIGZvciBhIHNldCBvZiBpbnRlcmFjdGlvbnMuXG4gIC8vIFdoZW4gdGhpcyB3b3JrIGlzIGxhdGVyIHJ1biwgb25Xb3JrU3RhcnRlZC9vbldvcmtTdG9wcGVkIHdpbGwgYmUgY2FsbGVkLlxuICAvLyBBIGJhdGNoIG9mIGFzeW5jL3lpZWxkeSB3b3JrIG1heSBiZSBzY2hlZHVsZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIGNvbXBsZXRpbmcuXG4gIC8vIEluIHRoYXQgY2FzZSwgb25Xb3JrU2NoZWR1bGVkIG1heSBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgYmVmb3JlIG9uV29ya1N0b3BwZWQuXG4gIC8vIFdvcmsgaXMgc2NoZWR1bGVkIGJ5IGEgXCJ0aHJlYWRcIiB3aGljaCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIElELlxuICBvbldvcmtTY2hlZHVsZWQ6IChpbnRlcmFjdGlvbnM6IFNldDxJbnRlcmFjdGlvbj4sIHRocmVhZElEOiBudW1iZXIpID0+IHZvaWQsXG5cbiAgLy8gQSBiYXRjaCBvZiBzY2hlZHVsZWQgd29yayBoYXMgYmVlbiBjYW5jZWxlZC5cbiAgLy8gV29yayBpcyBkb25lIGJ5IGEgXCJ0aHJlYWRcIiB3aGljaCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIElELlxuICBvbldvcmtDYW5jZWxlZDogKGludGVyYWN0aW9uczogU2V0PEludGVyYWN0aW9uPiwgdGhyZWFkSUQ6IG51bWJlcikgPT4gdm9pZCxcblxuICAvLyBBIGJhdGNoIG9mIHdvcmsgaGFzIHN0YXJ0ZWQgZm9yIGEgc2V0IG9mIGludGVyYWN0aW9ucy5cbiAgLy8gV2hlbiB0aGlzIHdvcmsgaXMgY29tcGxldGUsIG9uV29ya1N0b3BwZWQgd2lsbCBiZSBjYWxsZWQuXG4gIC8vIFdvcmsgaXMgbm90IGFsd2F5cyBjb21wbGV0ZWQgc3luY2hyb25vdXNseTsgeWllbGRpbmcgbWF5IG9jY3VyIGluIGJldHdlZW4uXG4gIC8vIEEgYmF0Y2ggb2YgYXN5bmMveWllbGR5IHdvcmsgbWF5IGFsc28gYmUgcmUtc3RhcnRlZCBiZWZvcmUgY29tcGxldGluZy5cbiAgLy8gSW4gdGhhdCBjYXNlLCBvbldvcmtTdGFydGVkIG1heSBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgYmVmb3JlIG9uV29ya1N0b3BwZWQuXG4gIC8vIFdvcmsgaXMgZG9uZSBieSBhIFwidGhyZWFkXCIgd2hpY2ggaXMgaWRlbnRpZmllZCBieSBhIHVuaXF1ZSBJRC5cbiAgb25Xb3JrU3RhcnRlZDogKGludGVyYWN0aW9uczogU2V0PEludGVyYWN0aW9uPiwgdGhyZWFkSUQ6IG51bWJlcikgPT4gdm9pZCxcblxuICAvLyBBIGJhdGNoIG9mIHdvcmsgaGFzIGNvbXBsZXRlZCBmb3IgYSBzZXQgb2YgaW50ZXJhY3Rpb25zLlxuICAvLyBXb3JrIGlzIGRvbmUgYnkgYSBcInRocmVhZFwiIHdoaWNoIGlzIGlkZW50aWZpZWQgYnkgYSB1bmlxdWUgSUQuXG4gIG9uV29ya1N0b3BwZWQ6IChpbnRlcmFjdGlvbnM6IFNldDxJbnRlcmFjdGlvbj4sIHRocmVhZElEOiBudW1iZXIpID0+IHZvaWQsXG59O1xuXG5leHBvcnQgdHlwZSBJbnRlcmFjdGlvbnNSZWYgPSB7XG4gIGN1cnJlbnQ6IFNldDxJbnRlcmFjdGlvbj4sXG59O1xuXG5leHBvcnQgdHlwZSBTdWJzY3JpYmVyUmVmID0ge1xuICBjdXJyZW50OiBTdWJzY3JpYmVyIHwgbnVsbCxcbn07XG5cbmNvbnN0IERFRkFVTFRfVEhSRUFEX0lEID0gMDtcblxuLy8gQ291bnRlcnMgdXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLlxubGV0IGludGVyYWN0aW9uSURDb3VudGVyOiBudW1iZXIgPSAwO1xubGV0IHRocmVhZElEQ291bnRlcjogbnVtYmVyID0gMDtcblxuLy8gU2V0IG9mIGN1cnJlbnRseSB0cmFjZWQgaW50ZXJhY3Rpb25zLlxuLy8gSW50ZXJhY3Rpb25zIFwic3RhY2tcIuKAk1xuLy8gTWVhbmluZyB0aGF0IG5ld2x5IHRyYWNlZCBpbnRlcmFjdGlvbnMgYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBzZXQuXG4vLyBXaGVuIGFuIGludGVyYWN0aW9uIGdvZXMgb3V0IG9mIHNjb3BlLCB0aGUgcHJldmlvdXMgc2V0IChpZiBhbnkpIGlzIHJlc3RvcmVkLlxubGV0IGludGVyYWN0aW9uc1JlZjogSW50ZXJhY3Rpb25zUmVmID0gKG51bGw6IGFueSk7XG5cbi8vIExpc3RlbmVyKHMpIHRvIG5vdGlmeSB3aGVuIGludGVyYWN0aW9ucyBiZWdpbiBhbmQgZW5kLlxubGV0IHN1YnNjcmliZXJSZWY6IFN1YnNjcmliZXJSZWYgPSAobnVsbDogYW55KTtcblxuaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgaW50ZXJhY3Rpb25zUmVmID0ge1xuICAgIGN1cnJlbnQ6IG5ldyBTZXQoKSxcbiAgfTtcbiAgc3Vic2NyaWJlclJlZiA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuICB9O1xufVxuXG5leHBvcnQge2ludGVyYWN0aW9uc1JlZiBhcyBfX2ludGVyYWN0aW9uc1JlZiwgc3Vic2NyaWJlclJlZiBhcyBfX3N1YnNjcmliZXJSZWZ9O1xuXG5leHBvcnQgZnVuY3Rpb24gdW5zdGFibGVfY2xlYXIoY2FsbGJhY2s6IEZ1bmN0aW9uKTogYW55IHtcbiAgaWYgKCFlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBjb25zdCBwcmV2SW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIGludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgaW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50KCk6IFNldDxJbnRlcmFjdGlvbj4gfCBudWxsIHtcbiAgaWYgKCFlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV9nZXRUaHJlYWRJRCgpOiBudW1iZXIge1xuICByZXR1cm4gKyt0aHJlYWRJRENvdW50ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV90cmFjZShcbiAgbmFtZTogc3RyaW5nLFxuICB0aW1lc3RhbXA6IG51bWJlcixcbiAgY2FsbGJhY2s6IEZ1bmN0aW9uLFxuICB0aHJlYWRJRDogbnVtYmVyID0gREVGQVVMVF9USFJFQURfSUQsXG4pOiBhbnkge1xuICBpZiAoIWVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIGNvbnN0IGludGVyYWN0aW9uOiBJbnRlcmFjdGlvbiA9IHtcbiAgICBfX2NvdW50OiAxLFxuICAgIGlkOiBpbnRlcmFjdGlvbklEQ291bnRlcisrLFxuICAgIG5hbWUsXG4gICAgdGltZXN0YW1wLFxuICB9O1xuXG4gIGNvbnN0IHByZXZJbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcblxuICAvLyBUcmFjZWQgaW50ZXJhY3Rpb25zIHNob3VsZCBzdGFjay9hY2N1bXVsYXRlLlxuICAvLyBUbyBkbyB0aGF0LCBjbG9uZSB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFRoZSBwcmV2aW91cyBzZXQgd2lsbCBiZSByZXN0b3JlZCB1cG9uIGNvbXBsZXRpb24uXG4gIGNvbnN0IGludGVyYWN0aW9ucyA9IG5ldyBTZXQocHJldkludGVyYWN0aW9ucyk7XG4gIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICBpbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IGludGVyYWN0aW9ucztcblxuICBjb25zdCBzdWJzY3JpYmVyID0gc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICBsZXQgcmV0dXJuVmFsdWU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgLy8gSWYgbm8gYXN5bmMgd29yayB3YXMgc2NoZWR1bGVkIGZvciB0aGlzIGludGVyYWN0aW9uLFxuICAgICAgICAgIC8vIE5vdGlmeSBzdWJzY3JpYmVycyB0aGF0IGl0J3MgY29tcGxldGVkLlxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc3RhYmxlX3dyYXAoXG4gIGNhbGxiYWNrOiBGdW5jdGlvbixcbiAgdGhyZWFkSUQ6IG51bWJlciA9IERFRkFVTFRfVEhSRUFEX0lELFxuKTogRnVuY3Rpb24ge1xuICBpZiAoIWVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH1cblxuICBjb25zdCB3cmFwcGVkSW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG5cbiAgbGV0IHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG4gIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIGFzeW5jIHdvcmsgY291bnQgZm9yIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgLy8gVXBkYXRlIGFmdGVyIGNhbGxpbmcgc3Vic2NyaWJlcnMgaW4gY2FzZSBvZiBlcnJvci5cbiAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGludGVyYWN0aW9uID0+IHtcbiAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gIH0pO1xuXG4gIGxldCBoYXNSdW4gPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKCkge1xuICAgIGNvbnN0IHByZXZJbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICBpbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHdyYXBwZWRJbnRlcmFjdGlvbnM7XG5cbiAgICBzdWJzY3JpYmVyID0gc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXR1cm5WYWx1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghaGFzUnVuKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgZXhwZWN0IGEgd3JhcHBlZCBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlLFxuICAgICAgICAvLyBCdXQgaW4gdGhlIGV2ZW50IHRoYXQgaXQncyBleGVjdXRlZCBtb3JlIHRoYW4gb25jZeKAk1xuICAgICAgICAvLyBPbmx5IGRlY3JlbWVudCB0aGUgb3V0c3RhbmRpbmcgaW50ZXJhY3Rpb24gY291bnRzIG9uY2UuXG4gICAgICAgIGhhc1J1biA9IHRydWU7XG5cbiAgICAgICAgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IHNjaGVkdWxlZCBhc3luYyB3b3JrIGZvciBhbnkgb2YgdGhlbSxcbiAgICAgICAgLy8gTWFyayB0aGVtIGFzIGNvbXBsZXRlZC5cbiAgICAgICAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGludGVyYWN0aW9uID0+IHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdyYXBwZWQuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtDYW5jZWxlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFVwZGF0ZSBwZW5kaW5nIGFzeW5jIGNvdW50cyBmb3IgYWxsIHdyYXBwZWQgaW50ZXJhY3Rpb25zLlxuICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3Qgc2NoZWR1bGVkIGFzeW5jIHdvcmsgZm9yIGFueSBvZiB0aGVtLFxuICAgICAgLy8gTWFyayB0aGVtIGFzIGNvbXBsZXRlZC5cbiAgICAgIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChpbnRlcmFjdGlvbiA9PiB7XG4gICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICBpZiAoc3Vic2NyaWJlciAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NjaGVkdWxlci9zcmMvVHJhY2luZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7RGlzcGF0Y2hlcn0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckhvb2tzJztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG5jb25zdCBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IChudWxsOiBudWxsIHwgRGlzcGF0Y2hlciksXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0Q3VycmVudERpc3BhdGNoZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuY29uc3QgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXG4gIG5hbWU6IG51bGwgfCBzdHJpbmcsXG4gIHNvdXJjZTogYW55LFxuICBvd25lck5hbWU6IG51bGwgfCBzdHJpbmcsXG4pIHtcbiAgbGV0IHNvdXJjZUluZm8gPSAnJztcbiAgaWYgKHNvdXJjZSkge1xuICAgIGxldCBwYXRoID0gc291cmNlLmZpbGVOYW1lO1xuICAgIGxldCBmaWxlTmFtZSA9IHBhdGgucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgLy8gSW4gREVWLCBpbmNsdWRlIGNvZGUgZm9yIGEgY29tbW9uIHNwZWNpYWwgY2FzZTpcbiAgICAgIC8vIHByZWZlciBcImZvbGRlci9pbmRleC5qc1wiIGluc3RlYWQgb2YganVzdCBcImluZGV4LmpzXCIuXG4gICAgICBpZiAoL15pbmRleFxcLi8udGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IHBhdGhCZWZvcmVTbGFzaCA9IG1hdGNoWzFdO1xuICAgICAgICAgIGlmIChwYXRoQmVmb3JlU2xhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlck5hbWUgPSBwYXRoQmVmb3JlU2xhc2gucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZm9sZGVyTmFtZSArICcvJyArIGZpbGVOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VJbmZvID0gJyAoYXQgJyArIGZpbGVOYW1lICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKSc7XG4gIH0gZWxzZSBpZiAob3duZXJOYW1lKSB7XG4gICAgc291cmNlSW5mbyA9ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJztcbiAgfVxuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIHNvdXJjZUluZm87XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9zaGFyZWQvZGVzY3JpYmVDb21wb25lbnRGcmFtZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge1xuICBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSxcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuICBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICBSRUFDVF9TVVNQRU5TRV9UWVBFLFxuICBSRUFDVF9NRU1PX1RZUEUsXG4gIFJFQUNUX0xBWllfVFlQRSxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlOiBtaXhlZCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8XG4gICAgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHxcbiAgICB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8XG4gICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlICE9PSBudWxsICYmXG4gICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fFxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8XG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSlcbiAgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9pc1ZhbGlkRWxlbWVudFR5cGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50bzxUPihcbiAgY3VycmVudDogPyhBcnJheTxUPiB8IFQpLFxuICBuZXh0OiBUIHwgQXJyYXk8VD4sXG4pOiBUIHwgQXJyYXk8VD4ge1xuICBpbnZhcmlhbnQoXG4gICAgbmV4dCAhPSBudWxsLFxuICAgICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nLFxuICApO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFjY3VtdWxhdGVJbnRvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvZXZlbnRzL2FjY3VtdWxhdGVJbnRvLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayBpbnZva2VkIHdpdGggZWFjaCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7P30gW3Njb3BlXSBTY29wZSB1c2VkIGFzIGB0aGlzYCBpbiBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQ8VD4oXG4gIGFycjogPyhBcnJheTxUPiB8IFQpLFxuICBjYjogKGVsZW06IFQpID0+IHZvaWQsXG4gIHNjb3BlOiA/YW55LFxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvZXZlbnRzL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG5jb25zdCBzdXBwb3J0ZWRJbnB1dFR5cGVzOiB7W2tleTogc3RyaW5nXTogdHJ1ZSB8IHZvaWR9ID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWUsXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbTogP0hUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzWygoZWxlbTogYW55KTogSFRNTElucHV0RWxlbWVudCkudHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvc2hhcmVkL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHtURVhUX05PREV9IGZyb20gJy4uL3NoYXJlZC9IVE1MTm9kZVR5cGUnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICBsZXQgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRFdmVudFRhcmdldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2dldEV2ZW50VGFyZ2V0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge2NhblVzZURPTX0gZnJvbSAnc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50JztcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4KSB7XG4gIGlmICghY2FuVXNlRE9NKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgbGV0IGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFdmVudFN1cHBvcnRlZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxuaW1wb3J0IHtnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RDdXJyZW50RmliZXInO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3NoYXJlZC93YXJuaW5nJztcblxuaW1wb3J0IHtzZXRWYWx1ZUZvclByb3BlcnR5fSBmcm9tICcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucyc7XG5pbXBvcnQge2dldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGV9IGZyb20gJy4vUmVhY3RET01Db21wb25lbnRUcmVlJztcbmltcG9ydCB7Z2V0VG9TdHJpbmdWYWx1ZSwgdG9TdHJpbmd9IGZyb20gJy4vVG9TdHJpbmdWYWx1ZSc7XG5pbXBvcnQgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgZnJvbSAnLi4vc2hhcmVkL1JlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzJztcbmltcG9ydCB7dXBkYXRlVmFsdWVJZkNoYW5nZWR9IGZyb20gJy4vaW5wdXRWYWx1ZVRyYWNraW5nJztcbmltcG9ydCB7ZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZ30gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcblxuaW1wb3J0IHR5cGUge1RvU3RyaW5nVmFsdWV9IGZyb20gJy4vVG9TdHJpbmdWYWx1ZSc7XG5cbnR5cGUgSW5wdXRXaXRoV3JhcHBlclN0YXRlID0gSFRNTElucHV0RWxlbWVudCAmIHtcbiAgX3dyYXBwZXJTdGF0ZToge1xuICAgIGluaXRpYWxWYWx1ZTogVG9TdHJpbmdWYWx1ZSxcbiAgICBpbml0aWFsQ2hlY2tlZDogP2Jvb2xlYW4sXG4gICAgY29udHJvbGxlZD86IGJvb2xlYW4sXG4gIH0sXG59O1xuXG5sZXQgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5sZXQgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xubGV0IGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbmxldCBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICBjb25zdCB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPSBudWxsIDogcHJvcHMudmFsdWUgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudDogRWxlbWVudCwgcHJvcHM6IE9iamVjdCkge1xuICBjb25zdCBub2RlID0gKChlbGVtZW50OiBhbnkpOiBJbnB1dFdpdGhXcmFwcGVyU3RhdGUpO1xuICBjb25zdCBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICBjb25zdCBob3N0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMpO1xuXG4gICAgaWYgKFxuICAgICAgcHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZFxuICAgICkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArXG4gICAgICAgICAgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgK1xuICAgICAgICAgICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArXG4gICAgICAgICAgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgK1xuICAgICAgICAgICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgK1xuICAgICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsXG4gICAgICAgIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JyxcbiAgICAgICAgcHJvcHMudHlwZSxcbiAgICAgICk7XG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWVcbiAgICApIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArXG4gICAgICAgICAgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgK1xuICAgICAgICAgICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICtcbiAgICAgICAgICAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArXG4gICAgICAgICAgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyxcbiAgICAgICAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLFxuICAgICAgICBwcm9wcy50eXBlLFxuICAgICAgKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgbm9kZSA9ICgoZWxlbWVudDogYW55KTogSW5wdXRXaXRoV3JhcHBlclN0YXRlKTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6XG4gICAgICBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKFxuICAgICAgcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgICksXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudDogRWxlbWVudCwgcHJvcHM6IE9iamVjdCkge1xuICBjb25zdCBub2RlID0gKChlbGVtZW50OiBhbnkpOiBJbnB1dFdpdGhXcmFwcGVyU3RhdGUpO1xuICBjb25zdCBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkLCBmYWxzZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudDogRWxlbWVudCwgcHJvcHM6IE9iamVjdCkge1xuICBjb25zdCBub2RlID0gKChlbGVtZW50OiBhbnkpOiBJbnB1dFdpdGhXcmFwcGVyU3RhdGUpO1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKFxuICAgICAgIW5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmXG4gICAgICBjb250cm9sbGVkICYmXG4gICAgICAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZFxuICAgICkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICtcbiAgICAgICAgICAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgK1xuICAgICAgICAgICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgK1xuICAgICAgICAgICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsXG4gICAgICAgIHByb3BzLnR5cGUsXG4gICAgICApO1xuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmXG4gICAgICAhY29udHJvbGxlZCAmJlxuICAgICAgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWRcbiAgICApIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICtcbiAgICAgICAgICAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgK1xuICAgICAgICAgICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgK1xuICAgICAgICAgICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsXG4gICAgICAgIHByb3BzLnR5cGUsXG4gICAgICApO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgY29uc3QgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcbiAgY29uc3QgdHlwZSA9IHByb3BzLnR5cGU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB8fFxuICAgICAgICAvLyBXZSBleHBsaWNpdGx5IHdhbnQgdG8gY29lcmNlIHRvIG51bWJlciBoZXJlIGlmIHBvc3NpYmxlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgbm9kZS52YWx1ZSAhPSAodmFsdWU6IGFueSlcbiAgICAgICkge1xuICAgICAgICBub2RlLnZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gdG9TdHJpbmcodmFsdWUpKSB7XG4gICAgICBub2RlLnZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VibWl0JyB8fCB0eXBlID09PSAncmVzZXQnKSB7XG4gICAgLy8gU3VibWl0L3Jlc2V0IGlucHV0cyBuZWVkIHRoZSBhdHRyaWJ1dGUgcmVtb3ZlZCBjb21wbGV0ZWx5IHRvIGF2b2lkXG4gICAgLy8gYmxhbmstdGV4dCBidXR0b25zLlxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nKSB7XG4gICAgLy8gV2hlbiBub3Qgc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCBSZWFjdCBvbmx5IGFzc2lnbnMgYSBuZXcgdmFsdWVcbiAgICAvLyB3aGVuZXZlciB0aGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3AgaGFzIGNoYW5nZWQuIFdoZW4gbm90IHByZXNlbnQsXG4gICAgLy8gUmVhY3QgZG9lcyBub3RoaW5nXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIGdldFRvU3RyaW5nVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgY29tZXMgZnJvbSBhIGNhc2NhZGUgb2ZcbiAgICAvLyBwcm9wZXJ0aWVzOlxuICAgIC8vICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHlcbiAgICAvLyAgMi4gVGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAzLiBPdGhlcndpc2UgdGhlcmUgc2hvdWxkIGJlIG5vIGNoYW5nZVxuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIGdldFRvU3RyaW5nVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcpIHtcbiAgICAvLyBXaGVuIG5vdCBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgdGhlIGF0dHJpYnV0ZSBpcyBkaXJlY3RseVxuICAgIC8vIGNvbnRyb2xsYWJsZSBmcm9tIHRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkuIEl0IG5lZWRzIHRvIGJlXG4gICAgLy8gdXBkYXRlZCBhcyBuZXcgcHJvcHMgY29tZSBpbi5cbiAgICBpZiAocHJvcHMuZGVmYXVsdENoZWNrZWQgPT0gbnVsbCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGl0IG9ubHkgY2hhbmdlcyB3aGVuIGl0IG5lZWRzXG4gICAgLy8gdG8gYmUgcmVtb3ZlZCwgc3VjaCBhcyB0cmFuc2l0aW9uaW5nIGZyb20gYSBjaGVja2JveCBpbnRvIGEgdGV4dCBpbnB1dFxuICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBwcm9wczogT2JqZWN0LFxuICBpc0h5ZHJhdGluZzogYm9vbGVhbixcbikge1xuICBjb25zdCBub2RlID0gKChlbGVtZW50OiBhbnkpOiBJbnB1dFdpdGhXcmFwcGVyU3RhdGUpO1xuXG4gIC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gIC8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cbiAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpIHx8IHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgIGNvbnN0IHR5cGUgPSBwcm9wcy50eXBlO1xuICAgIGNvbnN0IGlzQnV0dG9uID0gdHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0JztcblxuICAgIC8vIEF2b2lkIHNldHRpbmcgdmFsdWUgYXR0cmlidXRlIG9uIHN1Ym1pdC9yZXNldCBpbnB1dHMgYXMgaXQgb3ZlcnJpZGVzIHRoZVxuICAgIC8vIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIuIFNlZTogIzEyODcyXG4gICAgaWYgKGlzQnV0dG9uICYmIChwcm9wcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BzLnZhbHVlID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuXG4gICAgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgaWYgKGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcblxuICAgICAgICAvLyBXaGVuIG5vdCBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBwcm9wZXJ0eSBwb2ludHNcbiAgICAgICAgLy8gZGlyZWN0bHkgdG8gdGhlIFJlYWN0IHByb3AuIE9ubHkgYXNzaWduIGl0IGlmIGl0IGV4aXN0cy5cbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBBbHdheXMgYXNzaWduIG9uIGJ1dHRvbnMgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBhc3NpZ24gYW5cbiAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgYnV0dG9uIHRleHQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGRvIG5vdCByZS1hc3NpZ24gdGhlIHZhbHVlIHByb3BlcnR5IGlmIGlzIGVtcHR5LiBUaGlzXG4gICAgICAgICAgLy8gcG90ZW50aWFsbHkgYXZvaWRzIGEgRE9NIHdyaXRlIGFuZCBwcmV2ZW50cyBGaXJlZm94ICh+NjAuMC4xKSBmcm9tXG4gICAgICAgICAgLy8gcHJlbWF0dXJlbHkgbWFya2luZyByZXF1aXJlZCBpbnB1dHMgYXMgaW52YWxpZC4gRXF1YWxpdHkgaXMgY29tcGFyZWRcbiAgICAgICAgICAvLyB0byB0aGUgY3VycmVudCB2YWx1ZSBpbiBjYXNlIHRoZSBicm93c2VyIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhblxuICAgICAgICAgIC8vIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICBpZiAoaXNCdXR0b24gfHwgdmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIHByb3BlcnR5IHNob3VsZCB1c2VcbiAgICAgICAgLy8gdGhlIHdyYXBwZXJTdGF0ZS5faW5pdGlhbFZhbHVlIHByb3BlcnR5LiBUaGlzIHVzZXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgICAgICAvLyAgIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMy4gQW4gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcpIHtcbiAgICAgIC8vIFdoZW4gbm90IHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGVcbiAgICAgIC8vIGRpcmVjdGx5IGZyb20gdGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eSAod2hlbiBwcmVzZW50KVxuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcoZGVmYXVsdFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHN5bmNocm9uaXplZCB0byB0aGUgcHJvcGVydHksXG4gICAgICAvLyBzbyB3ZSBhc3NpZ24gZGVmYXVsdFZhbHVlIHRvIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgLy8gYXNzaWdubWVudCBzdGVwIGFib3ZlLlxuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSAnJztcbiAgfVxuXG4gIGlmIChkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nKSB7XG4gICAgLy8gV2hlbiBub3Qgc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIHRoZSBjaGVja2VkIHByb3BlcnR5XG4gICAgLy8gbmV2ZXIgZ2V0cyBhc3NpZ25lZC4gSXQgbXVzdCBiZSBtYW51YWxseSBzZXQuIFdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBkbyB0aGlzIHdoZW4gaHlkcmF0aW5nIHNvIHRoYXQgZXhpc3RpbmcgdXNlciBpbnB1dCBpc24ndFxuICAgIC8vIG1vZGlmaWVkXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gT25seSBhc3NpZ24gdGhlIGNoZWNrZWQgYXR0cmlidXRlIGlmIGl0IGlzIGRlZmluZWQuIFRoaXMgc2F2ZXNcbiAgICAvLyBhIERPTSB3cml0ZSB3aGVuIGNvbnRyb2xsaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSBpc24ndCBuZWVkZWRcbiAgICAvLyAodGV4dCBpbnB1dHMsIHN1Ym1pdC9yZXNldClcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRDaGVja2VkJykpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBib3RoIHRoZSBjaGVja2VkIHByb3BlcnR5IGFuZFxuICAgIC8vIGF0dHJpYnV0ZSBhcmUgYXNzaWduZWQgYXQgdGhlIHNhbWUgdGltZSB1c2luZyBkZWZhdWx0Q2hlY2tlZC4gVGhpcyB1c2VzOlxuICAgIC8vXG4gICAgLy8gICAxLiBUaGUgY2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAvLyAgIDIuIFRoZSBkZWZhdWx0Q2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAvLyAgIDMuIE90aGVyd2lzZSwgZmFsc2VcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkO1xuICB9XG5cbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIGNvbnN0IG5vZGUgPSAoKGVsZW1lbnQ6IGFueSk6IElucHV0V2l0aFdyYXBwZXJTdGF0ZSk7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIGNvbnN0IG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICBsZXQgcXVlcnlSb290OiBFbGVtZW50ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9ICgocXVlcnlSb290LnBhcmVudE5vZGU6IGFueSk6IEVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgY29uc3QgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyxcbiAgICApO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb3RoZXJOb2RlID0gKChncm91cFtpXTogYW55KTogSFRNTElucHV0RWxlbWVudCk7XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgY29uc3Qgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUob3RoZXJOb2RlKTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgb3RoZXJQcm9wcyxcbiAgICAgICAgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnICtcbiAgICAgICAgICAnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nLFxuICAgICAgKTtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4vLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4vLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuLy9cbi8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4vLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKFxuICBub2RlOiBJbnB1dFdpdGhXcmFwcGVyU3RhdGUsXG4gIHR5cGU6ID9zdHJpbmcsXG4gIHZhbHVlOiAqLFxuKSB7XG4gIGlmIChcbiAgICAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gICAgdHlwZSAhPT0gJ251bWJlcicgfHxcbiAgICBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZVxuICApIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvUmVhY3RET01JbnB1dC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge1xuICBnZXRQcm9wZXJ0eUluZm8sXG4gIHNob3VsZElnbm9yZUF0dHJpYnV0ZSxcbiAgc2hvdWxkUmVtb3ZlQXR0cmlidXRlLFxuICBpc0F0dHJpYnV0ZU5hbWVTYWZlLFxuICBCT09MRUFOLFxuICBPVkVSTE9BREVEX0JPT0xFQU4sXG59IGZyb20gJy4uL3NoYXJlZC9ET01Qcm9wZXJ0eSc7XG5cbmltcG9ydCB0eXBlIHtQcm9wZXJ0eUluZm99IGZyb20gJy4uL3NoYXJlZC9ET01Qcm9wZXJ0eSc7XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShcbiAgbm9kZTogRWxlbWVudCxcbiAgbmFtZTogc3RyaW5nLFxuICBleHBlY3RlZDogbWl4ZWQsXG4gIHByb3BlcnR5SW5mbzogUHJvcGVydHlJbmZvLFxuKTogbWl4ZWQge1xuICBpZiAoX19ERVZfXykge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICBjb25zdCB7cHJvcGVydHlOYW1lfSA9IHByb3BlcnR5SW5mbztcbiAgICAgIHJldHVybiAobm9kZTogYW55KVtwcm9wZXJ0eU5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8udHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOKSB7XG4gICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyAoZXhwZWN0ZWQ6IGFueSkpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyAoZXhwZWN0ZWQ6IGFueSkpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKFxuICBub2RlOiBFbGVtZW50LFxuICBuYW1lOiBzdHJpbmcsXG4gIGV4cGVjdGVkOiBtaXhlZCxcbik6IG1peGVkIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgKyAoZXhwZWN0ZWQ6IGFueSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkoXG4gIG5vZGU6IEVsZW1lbnQsXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IG1peGVkLFxuICBpc0N1c3RvbUNvbXBvbmVudFRhZzogYm9vbGVhbixcbikge1xuICBjb25zdCBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cbiAgLy8gSWYgdGhlIHByb3AgaXNuJ3QgaW4gdGhlIHNwZWNpYWwgbGlzdCwgdHJlYXQgaXQgYXMgYSBzaW1wbGUgYXR0cmlidXRlLlxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgcHJvcGVydHlJbmZvID09PSBudWxsKSB7XG4gICAgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyAodmFsdWU6IGFueSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge211c3RVc2VQcm9wZXJ0eX0gPSBwcm9wZXJ0eUluZm87XG4gIGlmIChtdXN0VXNlUHJvcGVydHkpIHtcbiAgICBjb25zdCB7cHJvcGVydHlOYW1lfSA9IHByb3BlcnR5SW5mbztcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHt0eXBlfSA9IHByb3BlcnR5SW5mbztcbiAgICAgIChub2RlOiBhbnkpW3Byb3BlcnR5TmFtZV0gPSB0eXBlID09PSBCT09MRUFOID8gZmFsc2UgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgKG5vZGU6IGFueSlbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVGhlIHJlc3QgYXJlIHRyZWF0ZWQgYXMgYXR0cmlidXRlcyB3aXRoIHNwZWNpYWwgY2FzZXMuXG4gIGNvbnN0IHthdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVOYW1lc3BhY2V9ID0gcHJvcGVydHlJbmZvO1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7dHlwZX0gPSBwcm9wZXJ0eUluZm87XG4gICAgbGV0IGF0dHJpYnV0ZVZhbHVlO1xuICAgIGlmICh0eXBlID09PSBCT09MRUFOIHx8ICh0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpKSB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgKHZhbHVlOiBhbnkpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJpYnV0ZU5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBTeW50aGV0aWNNb3VzZUV2ZW50IGZyb20gJy4vU3ludGhldGljTW91c2VFdmVudCc7XG5cbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xuY29uc3QgU3ludGhldGljUG9pbnRlckV2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBwb2ludGVySWQ6IG51bGwsXG4gIHdpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIHByZXNzdXJlOiBudWxsLFxuICB0YW5nZW50aWFsUHJlc3N1cmU6IG51bGwsXG4gIHRpbHRYOiBudWxsLFxuICB0aWx0WTogbnVsbCxcbiAgdHdpc3Q6IG51bGwsXG4gIHBvaW50ZXJUeXBlOiBudWxsLFxuICBpc1ByaW1hcnk6IG51bGwsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU3ludGhldGljUG9pbnRlckV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljUG9pbnRlckV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc30gZnJvbSAnZXZlbnRzL0V2ZW50UGx1Z2luUmVnaXN0cnknO1xuaW1wb3J0IHtcbiAgVE9QX0JMVVIsXG4gIFRPUF9DQU5DRUwsXG4gIFRPUF9DTE9TRSxcbiAgVE9QX0ZPQ1VTLFxuICBUT1BfSU5WQUxJRCxcbiAgVE9QX1JFU0VULFxuICBUT1BfU0NST0xMLFxuICBUT1BfU1VCTUlULFxuICBnZXRSYXdFdmVudE5hbWUsXG4gIG1lZGlhRXZlbnRUeXBlcyxcbn0gZnJvbSAnLi9ET01Ub3BMZXZlbEV2ZW50VHlwZXMnO1xuaW1wb3J0IHtcbiAgc2V0RW5hYmxlZCxcbiAgaXNFbmFibGVkLFxuICB0cmFwQnViYmxlZEV2ZW50LFxuICB0cmFwQ2FwdHVyZWRFdmVudCxcbn0gZnJvbSAnLi9SZWFjdERPTUV2ZW50TGlzdGVuZXInO1xuaW1wb3J0IGlzRXZlbnRTdXBwb3J0ZWQgZnJvbSAnLi9pc0V2ZW50U3VwcG9ydGVkJztcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydFxuICogICAgcGx1Z2dhYmxlIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpblxuICogICAgdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG5jb25zdCBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbmxldCByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbmNvbnN0IHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0OiBhbnkpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIFdlIGxpc3RlbiBmb3IgYnViYmxlZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IG9iamVjdC5cbiAqXG4gKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gKiBtb3VudGluZyBgb25tb3VzZW1vdmVgIGV2ZW50cyBhdCBzb21lIG5vZGUgdGhhdCB3YXMgbm90IHRoZSBkb2N1bWVudFxuICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICogdG9wLWxldmVsIGxpc3RlbmVycyBmb3IgYG9ubW91c2Vtb3ZlYCB3b24ndCBiZSBjYWxsZWQuIEhvd2V2ZXIsIGlmIHlvdVxuICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgdG8gdGhlIGRvY3VtZW50IG9iamVjdCBvbmx5LCBhdCBsZWFzdCBmb3IgdGhlc2VcbiAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gKlxuICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICogdGhleSBidWJibGUgdG8gZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHBhcmFtIHtvYmplY3R9IG1vdW50QXQgQ29udGFpbmVyIHdoZXJlIHRvIG1vdW50IHRoZSBsaXN0ZW5lclxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG8oXG4gIHJlZ2lzdHJhdGlvbk5hbWU6IHN0cmluZyxcbiAgbW91bnRBdDogRG9jdW1lbnQgfCBFbGVtZW50LFxuKSB7XG4gIGNvbnN0IGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgc3dpdGNoIChkZXBlbmRlbmN5KSB7XG4gICAgICAgIGNhc2UgVE9QX1NDUk9MTDpcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudChUT1BfU0NST0xMLCBtb3VudEF0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUT1BfRk9DVVM6XG4gICAgICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoVE9QX0ZPQ1VTLCBtb3VudEF0KTtcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudChUT1BfQkxVUiwgbW91bnRBdCk7XG4gICAgICAgICAgLy8gV2Ugc2V0IHRoZSBmbGFnIGZvciBhIHNpbmdsZSBkZXBlbmRlbmN5IGxhdGVyIGluIHRoaXMgZnVuY3Rpb24sXG4gICAgICAgICAgLy8gYnV0IHRoaXMgZW5zdXJlcyB3ZSBtYXJrIGJvdGggYXMgYXR0YWNoZWQgcmF0aGVyIHRoYW4ganVzdCBvbmUuXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbVE9QX0JMVVJdID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZ1tUT1BfRk9DVVNdID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUT1BfQ0FOQ0VMOlxuICAgICAgICBjYXNlIFRPUF9DTE9TRTpcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZChnZXRSYXdFdmVudE5hbWUoZGVwZW5kZW5jeSkpKSB7XG4gICAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudChkZXBlbmRlbmN5LCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVE9QX0lOVkFMSUQ6XG4gICAgICAgIGNhc2UgVE9QX1NVQk1JVDpcbiAgICAgICAgY2FzZSBUT1BfUkVTRVQ6XG4gICAgICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZW0gb24gdGhlIHRhcmdldCBET00gZWxlbWVudHMuXG4gICAgICAgICAgLy8gU29tZSBvZiB0aGVtIGJ1YmJsZSBzbyB3ZSBkb24ndCB3YW50IHRoZW0gdG8gZmlyZSB0d2ljZS5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBsaXN0ZW4gb24gdGhlIHRvcCBsZXZlbCB0byBhbGwgbm9uLW1lZGlhIGV2ZW50cy5cbiAgICAgICAgICAvLyBNZWRpYSBldmVudHMgZG9uJ3QgYnViYmxlIHNvIGFkZGluZyB0aGUgbGlzdGVuZXIgd291bGRuJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgICAgY29uc3QgaXNNZWRpYUV2ZW50ID0gbWVkaWFFdmVudFR5cGVzLmluZGV4T2YoZGVwZW5kZW5jeSkgIT09IC0xO1xuICAgICAgICAgIGlmICghaXNNZWRpYUV2ZW50KSB7XG4gICAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMoXG4gIHJlZ2lzdHJhdGlvbk5hbWU6IHN0cmluZyxcbiAgbW91bnRBdDogRG9jdW1lbnQgfCBFbGVtZW50LFxuKSB7XG4gIGNvbnN0IGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7c2V0RW5hYmxlZCwgaXNFbmFibGVkLCB0cmFwQnViYmxlZEV2ZW50LCB0cmFwQ2FwdHVyZWRFdmVudH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU5hdGl2ZUV2ZW50fSBmcm9tICdldmVudHMvUGx1Z2luTW9kdWxlVHlwZSc7XG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0RPTVRvcExldmVsRXZlbnRUeXBlfSBmcm9tICdldmVudHMvVG9wTGV2ZWxFdmVudFR5cGVzJztcblxuaW1wb3J0IHtiYXRjaGVkVXBkYXRlcywgaW50ZXJhY3RpdmVVcGRhdGVzfSBmcm9tICdldmVudHMvUmVhY3RHZW5lcmljQmF0Y2hpbmcnO1xuaW1wb3J0IHtydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNofSBmcm9tICdldmVudHMvRXZlbnRQbHVnaW5IdWInO1xuaW1wb3J0IHtpc0ZpYmVyTW91bnRlZH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9yZWZsZWN0aW9uJztcbmltcG9ydCB7SG9zdFJvb3R9IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcblxuaW1wb3J0IHthZGRFdmVudEJ1YmJsZUxpc3RlbmVyLCBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcn0gZnJvbSAnLi9FdmVudExpc3RlbmVyJztcbmltcG9ydCBnZXRFdmVudFRhcmdldCBmcm9tICcuL2dldEV2ZW50VGFyZ2V0JztcbmltcG9ydCB7Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGV9IGZyb20gJy4uL2NsaWVudC9SZWFjdERPTUNvbXBvbmVudFRyZWUnO1xuaW1wb3J0IFNpbXBsZUV2ZW50UGx1Z2luIGZyb20gJy4vU2ltcGxlRXZlbnRQbHVnaW4nO1xuaW1wb3J0IHtnZXRSYXdFdmVudE5hbWV9IGZyb20gJy4vRE9NVG9wTGV2ZWxFdmVudFR5cGVzJztcblxuY29uc3Qge2lzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZX0gPSBTaW1wbGVFdmVudFBsdWdpbjtcblxuY29uc3QgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG5jb25zdCBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbCA9IFtdO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRSb290Q29udGFpbmVyTm9kZShpbnN0KSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHdoaWxlIChpbnN0LnJldHVybikge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjtcbiAgfVxuICBpZiAoaW5zdC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHdlJ3JlIGluIGEgZGV0YWNoZWQgdHJlZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5zdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoXG4gIHRvcExldmVsVHlwZSxcbiAgbmF0aXZlRXZlbnQsXG4gIHRhcmdldEluc3QsXG4pOiB7XG4gIHRvcExldmVsVHlwZTogP0RPTVRvcExldmVsRXZlbnRUeXBlLFxuICBuYXRpdmVFdmVudDogP0FueU5hdGl2ZUV2ZW50LFxuICB0YXJnZXRJbnN0OiBGaWJlciB8IG51bGwsXG4gIGFuY2VzdG9yczogQXJyYXk8RmliZXI+LFxufSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW10sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbChib29rS2VlcGluZykge1xuICBsZXQgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIGxldCBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IGZpbmRSb290Q29udGFpbmVyTm9kZShhbmNlc3Rvcik7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocm9vdCk7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaChcbiAgICAgIGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSxcbiAgICAgIHRhcmdldEluc3QsXG4gICAgICBib29rS2VlcGluZy5uYXRpdmVFdmVudCxcbiAgICAgIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSxcbiAgICApO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbmV4cG9ydCBsZXQgX2VuYWJsZWQgPSB0cnVlO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkOiA/Ym9vbGVhbikge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgcmV0dXJuIF9lbmFibGVkO1xufVxuXG4vKipcbiAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxFdmVudFR5cGVzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQoXG4gIHRvcExldmVsVHlwZTogRE9NVG9wTGV2ZWxFdmVudFR5cGUsXG4gIGVsZW1lbnQ6IERvY3VtZW50IHwgRWxlbWVudCxcbikge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaXNwYXRjaCA9IGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpXG4gICAgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnRcbiAgICA6IGRpc3BhdGNoRXZlbnQ7XG5cbiAgYWRkRXZlbnRCdWJibGVMaXN0ZW5lcihcbiAgICBlbGVtZW50LFxuICAgIGdldFJhd0V2ZW50TmFtZSh0b3BMZXZlbFR5cGUpLFxuICAgIC8vIENoZWNrIGlmIGludGVyYWN0aXZlIGFuZCB3cmFwIGluIGludGVyYWN0aXZlVXBkYXRlc1xuICAgIGRpc3BhdGNoLmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSxcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxFdmVudFR5cGVzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KFxuICB0b3BMZXZlbFR5cGU6IERPTVRvcExldmVsRXZlbnRUeXBlLFxuICBlbGVtZW50OiBEb2N1bWVudCB8IEVsZW1lbnQsXG4pIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGlzcGF0Y2ggPSBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUodG9wTGV2ZWxUeXBlKVxuICAgID8gZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50XG4gICAgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKFxuICAgIGVsZW1lbnQsXG4gICAgZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSksXG4gICAgLy8gQ2hlY2sgaWYgaW50ZXJhY3RpdmUgYW5kIHdyYXAgaW4gaW50ZXJhY3RpdmVVcGRhdGVzXG4gICAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpLFxuICApO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpbnRlcmFjdGl2ZVVwZGF0ZXMoZGlzcGF0Y2hFdmVudCwgdG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KFxuICB0b3BMZXZlbFR5cGU6IERPTVRvcExldmVsRXZlbnRUeXBlLFxuICBuYXRpdmVFdmVudDogQW55TmF0aXZlRXZlbnQsXG4pIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICBsZXQgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKFxuICAgIHRhcmdldEluc3QgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgdGFyZ2V0SW5zdC50YWcgPT09ICdudW1iZXInICYmXG4gICAgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpXG4gICkge1xuICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKFxuICAgIHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0LFxuICApO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvUmVhY3RET01FdmVudExpc3RlbmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgVG9wTGV2ZWxUeXBlLFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZSxcbn0gZnJvbSAnZXZlbnRzL1RvcExldmVsRXZlbnRUeXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIERpc3BhdGNoQ29uZmlnLFxuICBSZWFjdFN5bnRoZXRpY0V2ZW50LFxufSBmcm9tICdldmVudHMvUmVhY3RTeW50aGV0aWNFdmVudFR5cGUnO1xuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyJztcbmltcG9ydCB0eXBlIHtFdmVudFR5cGVzLCBQbHVnaW5Nb2R1bGV9IGZyb20gJ2V2ZW50cy9QbHVnaW5Nb2R1bGVUeXBlJztcblxuaW1wb3J0IHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzfSBmcm9tICdldmVudHMvRXZlbnRQcm9wYWdhdG9ycyc7XG5pbXBvcnQgU3ludGhldGljRXZlbnQgZnJvbSAnZXZlbnRzL1N5bnRoZXRpY0V2ZW50JztcblxuaW1wb3J0ICogYXMgRE9NVG9wTGV2ZWxFdmVudFR5cGVzIGZyb20gJy4vRE9NVG9wTGV2ZWxFdmVudFR5cGVzJztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuaW1wb3J0IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IGZyb20gJy4vU3ludGhldGljQW5pbWF0aW9uRXZlbnQnO1xuaW1wb3J0IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IGZyb20gJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnO1xuaW1wb3J0IFN5bnRoZXRpY0ZvY3VzRXZlbnQgZnJvbSAnLi9TeW50aGV0aWNGb2N1c0V2ZW50JztcbmltcG9ydCBTeW50aGV0aWNLZXlib2FyZEV2ZW50IGZyb20gJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCc7XG5pbXBvcnQgU3ludGhldGljTW91c2VFdmVudCBmcm9tICcuL1N5bnRoZXRpY01vdXNlRXZlbnQnO1xuaW1wb3J0IFN5bnRoZXRpY1BvaW50ZXJFdmVudCBmcm9tICcuL1N5bnRoZXRpY1BvaW50ZXJFdmVudCc7XG5pbXBvcnQgU3ludGhldGljRHJhZ0V2ZW50IGZyb20gJy4vU3ludGhldGljRHJhZ0V2ZW50JztcbmltcG9ydCBTeW50aGV0aWNUb3VjaEV2ZW50IGZyb20gJy4vU3ludGhldGljVG91Y2hFdmVudCc7XG5pbXBvcnQgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IGZyb20gJy4vU3ludGhldGljVHJhbnNpdGlvbkV2ZW50JztcbmltcG9ydCBTeW50aGV0aWNVSUV2ZW50IGZyb20gJy4vU3ludGhldGljVUlFdmVudCc7XG5pbXBvcnQgU3ludGhldGljV2hlZWxFdmVudCBmcm9tICcuL1N5bnRoZXRpY1doZWVsRXZlbnQnO1xuaW1wb3J0IGdldEV2ZW50Q2hhckNvZGUgZnJvbSAnLi9nZXRFdmVudENoYXJDb2RlJztcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQUJPUlRdLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSBuZXcgTWFwKFtcbiAqICAgW1RPUF9BQk9SVCwgeyBzYW1lQ29uZmlnIH1dLFxuICogXSk7XG4gKi9cbnR5cGUgRXZlbnRUdXBsZSA9IFtET01Ub3BMZXZlbEV2ZW50VHlwZSwgc3RyaW5nXTtcbmNvbnN0IGludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXM6IEFycmF5PEV2ZW50VHVwbGU+ID0gW1xuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9CTFVSLCAnYmx1ciddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9DQU5DRUwsICdjYW5jZWwnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfQ0xJQ0ssICdjbGljayddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9DTE9TRSwgJ2Nsb3NlJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NPTlRFWFRfTUVOVSwgJ2NvbnRleHRNZW51J10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NPUFksICdjb3B5J10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NVVCwgJ2N1dCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9BVVhfQ0xJQ0ssICdhdXhDbGljayddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9ET1VCTEVfQ0xJQ0ssICdkb3VibGVDbGljayddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9EUkFHX0VORCwgJ2RyYWdFbmQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRFJBR19TVEFSVCwgJ2RyYWdTdGFydCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9EUk9QLCAnZHJvcCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9GT0NVUywgJ2ZvY3VzJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0lOUFVULCAnaW5wdXQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfSU5WQUxJRCwgJ2ludmFsaWQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfS0VZX0RPV04sICdrZXlEb3duJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0tFWV9QUkVTUywgJ2tleVByZXNzJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0tFWV9VUCwgJ2tleVVwJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX01PVVNFX0RPV04sICdtb3VzZURvd24nXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfTU9VU0VfVVAsICdtb3VzZVVwJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1BBU1RFLCAncGFzdGUnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUEFVU0UsICdwYXVzZSddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QTEFZLCAncGxheSddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QT0lOVEVSX0NBTkNFTCwgJ3BvaW50ZXJDYW5jZWwnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUE9JTlRFUl9ET1dOLCAncG9pbnRlckRvd24nXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUE9JTlRFUl9VUCwgJ3BvaW50ZXJVcCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9SQVRFX0NIQU5HRSwgJ3JhdGVDaGFuZ2UnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUkVTRVQsICdyZXNldCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9TRUVLRUQsICdzZWVrZWQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU1VCTUlULCAnc3VibWl0J10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1RPVUNIX0NBTkNFTCwgJ3RvdWNoQ2FuY2VsJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1RPVUNIX0VORCwgJ3RvdWNoRW5kJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1RPVUNIX1NUQVJULCAndG91Y2hTdGFydCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9WT0xVTUVfQ0hBTkdFLCAndm9sdW1lQ2hhbmdlJ10sXG5dO1xuY29uc3Qgbm9uSW50ZXJhY3RpdmVFdmVudFR5cGVOYW1lczogQXJyYXk8RXZlbnRUdXBsZT4gPSBbXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0FCT1JULCAnYWJvcnQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfQU5JTUFUSU9OX0VORCwgJ2FuaW1hdGlvbkVuZCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9BTklNQVRJT05fSVRFUkFUSU9OLCAnYW5pbWF0aW9uSXRlcmF0aW9uJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0FOSU1BVElPTl9TVEFSVCwgJ2FuaW1hdGlvblN0YXJ0J10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NBTl9QTEFZLCAnY2FuUGxheSddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9DQU5fUExBWV9USFJPVUdILCAnY2FuUGxheVRocm91Z2gnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRFJBRywgJ2RyYWcnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRFJBR19FTlRFUiwgJ2RyYWdFbnRlciddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9EUkFHX0VYSVQsICdkcmFnRXhpdCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9EUkFHX0xFQVZFLCAnZHJhZ0xlYXZlJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0RSQUdfT1ZFUiwgJ2RyYWdPdmVyJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0RVUkFUSU9OX0NIQU5HRSwgJ2R1cmF0aW9uQ2hhbmdlJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0VNUFRJRUQsICdlbXB0aWVkJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0VOQ1JZUFRFRCwgJ2VuY3J5cHRlZCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9FTkRFRCwgJ2VuZGVkJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0VSUk9SLCAnZXJyb3InXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfR09UX1BPSU5URVJfQ0FQVFVSRSwgJ2dvdFBvaW50ZXJDYXB0dXJlJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0xPQUQsICdsb2FkJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0xPQURFRF9EQVRBLCAnbG9hZGVkRGF0YSddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9MT0FERURfTUVUQURBVEEsICdsb2FkZWRNZXRhZGF0YSddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9MT0FEX1NUQVJULCAnbG9hZFN0YXJ0J10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0xPU1RfUE9JTlRFUl9DQVBUVVJFLCAnbG9zdFBvaW50ZXJDYXB0dXJlJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX01PVVNFX01PVkUsICdtb3VzZU1vdmUnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfTU9VU0VfT1VULCAnbW91c2VPdXQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfTU9VU0VfT1ZFUiwgJ21vdXNlT3ZlciddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QTEFZSU5HLCAncGxheWluZyddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QT0lOVEVSX01PVkUsICdwb2ludGVyTW92ZSddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QT0lOVEVSX09VVCwgJ3BvaW50ZXJPdXQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUE9JTlRFUl9PVkVSLCAncG9pbnRlck92ZXInXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUFJPR1JFU1MsICdwcm9ncmVzcyddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9TQ1JPTEwsICdzY3JvbGwnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU0VFS0lORywgJ3NlZWtpbmcnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU1RBTExFRCwgJ3N0YWxsZWQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU1VTUEVORCwgJ3N1c3BlbmQnXSxcbiAgW0RPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfVElNRV9VUERBVEUsICd0aW1lVXBkYXRlJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1RPR0dMRSwgJ3RvZ2dsZSddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9UT1VDSF9NT1ZFLCAndG91Y2hNb3ZlJ10sXG4gIFtET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1RSQU5TSVRJT05fRU5ELCAndHJhbnNpdGlvbkVuZCddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9XQUlUSU5HLCAnd2FpdGluZyddLFxuICBbRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9XSEVFTCwgJ3doZWVsJ10sXG5dO1xuXG5jb25zdCBldmVudFR5cGVzOiBFdmVudFR5cGVzID0ge307XG5jb25zdCB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWc6IHtcbiAgW2tleTogVG9wTGV2ZWxUeXBlXTogRGlzcGF0Y2hDb25maWcsXG59ID0ge307XG5cbmZ1bmN0aW9uIGFkZEV2ZW50VHlwZU5hbWVUb0NvbmZpZyhcbiAgW3RvcEV2ZW50LCBldmVudF06IEV2ZW50VHVwbGUsXG4gIGlzSW50ZXJhY3RpdmU6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3QgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgY29uc3Qgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIGNvbnN0IHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJyxcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XSxcbiAgICBpc0ludGVyYWN0aXZlLFxuICB9O1xuICBldmVudFR5cGVzW2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufVxuXG5pbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzLmZvckVhY2goZXZlbnRUdXBsZSA9PiB7XG4gIGFkZEV2ZW50VHlwZU5hbWVUb0NvbmZpZyhldmVudFR1cGxlLCB0cnVlKTtcbn0pO1xubm9uSW50ZXJhY3RpdmVFdmVudFR5cGVOYW1lcy5mb3JFYWNoKGV2ZW50VHVwbGUgPT4ge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgZmFsc2UpO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG5jb25zdCBrbm93bkhUTUxUb3BMZXZlbFR5cGVzOiBBcnJheTxET01Ub3BMZXZlbEV2ZW50VHlwZT4gPSBbXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfQUJPUlQsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfQ0FOQ0VMLFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NBTl9QTEFZLFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NBTl9QTEFZX1RIUk9VR0gsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfQ0xPU0UsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRFVSQVRJT05fQ0hBTkdFLFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0VNUFRJRUQsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRU5DUllQVEVELFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0VOREVELFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0VSUk9SLFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0lOUFVULFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0lOVkFMSUQsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfTE9BRCxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9MT0FERURfREFUQSxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9MT0FERURfTUVUQURBVEEsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfTE9BRF9TVEFSVCxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QQVVTRSxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QTEFZLFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1BMQVlJTkcsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUFJPR1JFU1MsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUkFURV9DSEFOR0UsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUkVTRVQsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU0VFS0VELFxuICBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1NFRUtJTkcsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU1RBTExFRCxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9TVUJNSVQsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU1VTUEVORCxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9USU1FX1VQREFURSxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9UT0dHTEUsXG4gIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfVk9MVU1FX0NIQU5HRSxcbiAgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9XQUlUSU5HLFxuXTtcblxuY29uc3QgU2ltcGxlRXZlbnRQbHVnaW46IFBsdWdpbk1vZHVsZTxNb3VzZUV2ZW50PiAmIHtcbiAgaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlOiAodG9wTGV2ZWxUeXBlOiBUb3BMZXZlbFR5cGUpID0+IGJvb2xlYW4sXG59ID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZSh0b3BMZXZlbFR5cGU6IFRvcExldmVsVHlwZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIHJldHVybiBjb25maWcgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuaXNJbnRlcmFjdGl2ZSA9PT0gdHJ1ZTtcbiAgfSxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICB0b3BMZXZlbFR5cGU6IFRvcExldmVsVHlwZSxcbiAgICB0YXJnZXRJbnN0OiBudWxsIHwgRmliZXIsXG4gICAgbmF0aXZlRXZlbnQ6IE1vdXNlRXZlbnQsXG4gICAgbmF0aXZlRXZlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0LFxuICApOiBudWxsIHwgUmVhY3RTeW50aGV0aWNFdmVudCB7XG4gICAgY29uc3QgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9LRVlfUFJFU1M6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfS0VZX0RPV046XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfS0VZX1VQOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfQkxVUjpcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9GT0NVUzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NMSUNLOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9BVVhfQ0xJQ0s6XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRE9VQkxFX0NMSUNLOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX01PVVNFX0RPV046XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfTU9VU0VfTU9WRTpcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9NT1VTRV9VUDpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9NT1VTRV9PVVQ6XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfTU9VU0VfT1ZFUjpcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9DT05URVhUX01FTlU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9EUkFHOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0RSQUdfRU5EOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0RSQUdfRU5URVI6XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRFJBR19FWElUOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0RSQUdfTEVBVkU6XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRFJBR19PVkVSOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0RSQUdfU1RBUlQ6XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfRFJPUDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfVE9VQ0hfQ0FOQ0VMOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1RPVUNIX0VORDpcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9UT1VDSF9NT1ZFOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1RPVUNIX1NUQVJUOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfQU5JTUFUSU9OX0VORDpcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9BTklNQVRJT05fSVRFUkFUSU9OOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0FOSU1BVElPTl9TVEFSVDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9UUkFOU0lUSU9OX0VORDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfU0NST0xMOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfV0hFRUw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9DT1BZOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0NVVDpcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QQVNURTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9HT1RfUE9JTlRFUl9DQVBUVVJFOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX0xPU1RfUE9JTlRFUl9DQVBUVVJFOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1BPSU5URVJfQ0FOQ0VMOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1BPSU5URVJfRE9XTjpcbiAgICAgIGNhc2UgRE9NVG9wTGV2ZWxFdmVudFR5cGVzLlRPUF9QT0lOVEVSX01PVkU6XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUE9JTlRFUl9PVVQ6XG4gICAgICBjYXNlIERPTVRvcExldmVsRXZlbnRUeXBlcy5UT1BfUE9JTlRFUl9PVkVSOlxuICAgICAgY2FzZSBET01Ub3BMZXZlbEV2ZW50VHlwZXMuVE9QX1BPSU5URVJfVVA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgK1xuICAgICAgICAgICAgICAgICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChcbiAgICAgIGRpc3BhdGNoQ29uZmlnLFxuICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXQsXG4gICAgKTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTaW1wbGVFdmVudFBsdWdpbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jOiA/RG9jdW1lbnQpOiA/RWxlbWVudCB7XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxuY29uc3QgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7RmliZXJSb290fSBmcm9tICcuL1JlYWN0RmliZXJSb290JztcbmltcG9ydCB0eXBlIHtFeHBpcmF0aW9uVGltZX0gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuXG5pbXBvcnQge05vV29ya30gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuXG4vLyBUT0RPOiBPZmZzY3JlZW4gdXBkYXRlcyBzaG91bGQgbmV2ZXIgc3VzcGVuZC4gSG93ZXZlciwgYSBwcm9taXNlIHRoYXRcbi8vIHN1c3BlbmRlZCBpbnNpZGUgYW4gb2Zmc2NyZWVuIHN1YnRyZWUgc2hvdWxkIGJlIGFibGUgdG8gcGluZyBhdCB0aGUgcHJpb3JpdHlcbi8vIG9mIHRoZSBvdXRlciByZW5kZXIuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwoXG4gIHJvb3Q6IEZpYmVyUm9vdCxcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogdm9pZCB7XG4gIC8vIElmIHRoZXJlJ3MgYSBnYXAgYmV0d2VlbiBjb21wbGV0aW5nIGEgZmFpbGVkIHJvb3QgYW5kIHJldHJ5aW5nIGl0LFxuICAvLyBhZGRpdGlvbmFsIHVwZGF0ZXMgbWF5IGJlIHNjaGVkdWxlZC4gQ2xlYXIgYGRpZEVycm9yYCwgaW4gY2FzZSB0aGUgdXBkYXRlXG4gIC8vIGlzIHN1ZmZpY2llbnQgdG8gZml4IHRoZSBlcnJvci5cbiAgcm9vdC5kaWRFcnJvciA9IGZhbHNlO1xuXG4gIC8vIFVwZGF0ZSB0aGUgbGF0ZXN0IGFuZCBlYXJsaWVzdCBwZW5kaW5nIHRpbWVzXG4gIGNvbnN0IGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAvLyBObyBvdGhlciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9IGVsc2Uge1xuICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lIDwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGVhcmxpZXN0IHBlbmRpbmcgdXBkYXRlLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhdGVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZTtcbiAgICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhdGVzdCBwZW5kaW5nIHVwZGF0ZVxuICAgICAgICByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihleHBpcmF0aW9uVGltZSwgcm9vdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ29tbWl0dGVkUHJpb3JpdHlMZXZlbHMoXG4gIHJvb3Q6IEZpYmVyUm9vdCxcbiAgZWFybGllc3RSZW1haW5pbmdUaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IHZvaWQge1xuICByb290LmRpZEVycm9yID0gZmFsc2U7XG5cbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gRmFzdCBwYXRoLiBUaGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLiBDbGVhciBldmVyeXRoaW5nLlxuICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFBpbmdlZFRpbWUgPSBOb1dvcms7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA8IHJvb3QubGF0ZXN0UGluZ2VkVGltZSkge1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IE5vV29yaztcbiAgfVxuXG4gIC8vIExldCdzIHNlZSBpZiB0aGUgcHJldmlvdXMgbGF0ZXN0IGtub3duIHBlbmRpbmcgbGV2ZWwgd2FzIGp1c3QgZmx1c2hlZC5cbiAgY29uc3QgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yaykge1xuICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA+IGVhcmxpZXN0UmVtYWluaW5nVGltZSkge1xuICAgICAgLy8gV2UndmUgZmx1c2hlZCBhbGwgdGhlIGtub3duIHBlbmRpbmcgbGV2ZWxzLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID4gZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGZsdXNoZWQgdGhlIGVhcmxpZXN0IGtub3duIHBlbmRpbmcgbGV2ZWwuIFNldCB0aGlzIHRvIHRoZVxuICAgICAgICAvLyBsYXRlc3QgcGVuZGluZyB0aW1lLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBsZXQncyBoYW5kbGUgdGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBpbiB0aGUgd2hvbGUgdHJlZS4gV2UgbmVlZCB0b1xuICAvLyBkZWNpZGUgd2hldGhlciB0byB0cmVhdCBpdCBhcyBhIHBlbmRpbmcgbGV2ZWwgb3IgYXMgc3VzcGVuZGVkLiBDaGVja1xuICAvLyBpdCBmYWxscyB3aXRoaW4gdGhlIHJhbmdlIG9mIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG5cbiAgY29uc3QgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPT09IE5vV29yaykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gc3VzcGVuZGVkIHdvcmsuIFRyZWF0IHRoZSBlYXJsaWVzdCByZW1haW5pbmcgbGV2ZWwgYXMgYVxuICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA8IGxhdGVzdFN1c3BlbmRlZFRpbWUpIHtcbiAgICAvLyBUaGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGlzIGxhdGVyIHRoYW4gYWxsIHRoZSBzdXNwZW5kZWQgd29yay4gVGhhdFxuICAgIC8vIG1lYW5zIHdlJ3ZlIGZsdXNoZWQgYWxsIHRoZSBzdXNwZW5kZWQgd29yay5cbiAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFN1c3BlbmRlZFRpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuXG4gICAgLy8gVGhlcmUncyBubyBzdXNwZW5kZWQgd29yay4gVHJlYXQgdGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBhcyBhXG4gICAgLy8gcGVuZGluZyBsZXZlbC5cbiAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oTm9Xb3JrLCByb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lID4gZWFybGllc3RTdXNwZW5kZWRUaW1lKSB7XG4gICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyB0aW1lIGlzIGVhcmxpZXIgdGhhbiBhbGwgdGhlIHN1c3BlbmRlZCB3b3JrLlxuICAgIC8vIFRyZWF0IGl0IGFzIGEgcGVuZGluZyB1cGRhdGUuXG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyB0aW1lIGZhbGxzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Yga25vd24gc3VzcGVuZGVkXG4gIC8vIGxldmVscy4gV2Ugc2hvdWxkIHRyZWF0IHRoaXMgYXMgc3VzcGVuZGVkIHdvcmsuXG4gIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihOb1dvcmssIHJvb3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTG93ZXJQcmlvcml0eVdvcmsoXG4gIHJvb3Q6IEZpYmVyUm9vdCxcbiAgZXJyb3JlZEV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gIGNvbnN0IGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIGNvbnN0IGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG4gIHJldHVybiAoXG4gICAgKGxhdGVzdFBlbmRpbmdUaW1lICE9PSBOb1dvcmsgJiZcbiAgICAgIGxhdGVzdFBlbmRpbmdUaW1lIDwgZXJyb3JlZEV4cGlyYXRpb25UaW1lKSB8fFxuICAgIChsYXRlc3RTdXNwZW5kZWRUaW1lICE9PSBOb1dvcmsgJiZcbiAgICAgIGxhdGVzdFN1c3BlbmRlZFRpbWUgPCBlcnJvcmVkRXhwaXJhdGlvblRpbWUpIHx8XG4gICAgKGxhdGVzdFBpbmdlZFRpbWUgIT09IE5vV29yayAmJiBsYXRlc3RQaW5nZWRUaW1lIDwgZXJyb3JlZEV4cGlyYXRpb25UaW1lKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmlvcml0eUxldmVsU3VzcGVuZGVkKFxuICByb290OiBGaWJlclJvb3QsXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgY29uc3QgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgcmV0dXJuIChcbiAgICBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgIT09IE5vV29yayAmJlxuICAgIGV4cGlyYXRpb25UaW1lIDw9IGVhcmxpZXN0U3VzcGVuZGVkVGltZSAmJlxuICAgIGV4cGlyYXRpb25UaW1lID49IGxhdGVzdFN1c3BlbmRlZFRpbWVcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtTdXNwZW5kZWRQcmlvcml0eUxldmVsKFxuICByb290OiBGaWJlclJvb3QsXG4gIHN1c3BlbmRlZFRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogdm9pZCB7XG4gIHJvb3QuZGlkRXJyb3IgPSBmYWxzZTtcbiAgY2xlYXJQaW5nKHJvb3QsIHN1c3BlbmRlZFRpbWUpO1xuXG4gIC8vIEZpcnN0LCBjaGVjayB0aGUga25vd24gcGVuZGluZyBsZXZlbHMgYW5kIHVwZGF0ZSB0aGVtIGlmIG5lZWRlZC5cbiAgY29uc3QgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgY29uc3QgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA9PT0gc3VzcGVuZGVkVGltZSkge1xuICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA9PT0gc3VzcGVuZGVkVGltZSkge1xuICAgICAgLy8gQm90aCBrbm93biBwZW5kaW5nIGxldmVscyB3ZXJlIHN1c3BlbmRlZC4gQ2xlYXIgdGhlbS5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBOb1dvcms7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBlYXJsaWVzdCBwZW5kaW5nIGxldmVsIHdhcyBzdXNwZW5kZWQuIENsZWFyIGJ5IHNldHRpbmcgaXQgdG8gdGhlXG4gICAgICAvLyBsYXRlc3QgcGVuZGluZyBsZXZlbC5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IGxhdGVzdFBlbmRpbmdUaW1lO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsYXRlc3RQZW5kaW5nVGltZSA9PT0gc3VzcGVuZGVkVGltZSkge1xuICAgIC8vIFRoZSBsYXRlc3QgcGVuZGluZyBsZXZlbCB3YXMgc3VzcGVuZGVkLiBDbGVhciBieSBzZXR0aW5nIGl0IHRvIHRoZVxuICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgIHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBlYXJsaWVzdFBlbmRpbmdUaW1lO1xuICB9XG5cbiAgLy8gRmluYWxseSwgdXBkYXRlIHRoZSBrbm93biBzdXNwZW5kZWQgbGV2ZWxzLlxuICBjb25zdCBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgY29uc3QgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gTm8gb3RoZXIgc3VzcGVuZGVkIGxldmVscy5cbiAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZSA9IHN1c3BlbmRlZFRpbWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA8IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGVhcmxpZXN0IHN1c3BlbmRlZCBsZXZlbC5cbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICB9IGVsc2UgaWYgKGxhdGVzdFN1c3BlbmRlZFRpbWUgPiBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBsYXRlc3Qgc3VzcGVuZGVkIGxldmVsXG4gICAgICByb290LmxhdGVzdFN1c3BlbmRlZFRpbWUgPSBzdXNwZW5kZWRUaW1lO1xuICAgIH1cbiAgfVxuXG4gIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihzdXNwZW5kZWRUaW1lLCByb290KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtQaW5nZWRQcmlvcml0eUxldmVsKFxuICByb290OiBGaWJlclJvb3QsXG4gIHBpbmdlZFRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogdm9pZCB7XG4gIHJvb3QuZGlkRXJyb3IgPSBmYWxzZTtcblxuICAvLyBUT0RPOiBXaGVuIHdlIGFkZCBiYWNrIHJlc3VtaW5nLCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgcHJvZ3Jlc3NlZCB3b3JrXG4gIC8vIGlzIHRocm93biBvdXQgYW5kIG5vdCByZXVzZWQgZHVyaW5nIHRoZSByZXN0YXJ0ZWQgcmVuZGVyLiBPbmUgd2F5IHRvXG4gIC8vIGludmFsaWRhdGUgdGhlIHByb2dyZXNzZWQgd29yayBpcyB0byByZXN0YXJ0IGF0IGV4cGlyYXRpb25UaW1lICsgMS5cbiAgY29uc3QgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcbiAgaWYgKGxhdGVzdFBpbmdlZFRpbWUgPT09IE5vV29yayB8fCBsYXRlc3RQaW5nZWRUaW1lID4gcGluZ2VkVGltZSkge1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IHBpbmdlZFRpbWU7XG4gIH1cbiAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKHBpbmdlZFRpbWUsIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjbGVhclBpbmcocm9vdCwgY29tcGxldGVkVGltZSkge1xuICBjb25zdCBsYXRlc3RQaW5nZWRUaW1lID0gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuICBpZiAobGF0ZXN0UGluZ2VkVGltZSA+PSBjb21wbGV0ZWRUaW1lKSB7XG4gICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwoXG4gIHJvb3Q6IEZpYmVyUm9vdCxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogRXhwaXJhdGlvblRpbWUge1xuICBsZXQgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuXG4gIGNvbnN0IGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIGNvbnN0IGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA+IGVhcmxpZXN0RXhwaXJhdGlvblRpbWUpIHtcbiAgICBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gZWFybGllc3RQZW5kaW5nVGltZTtcbiAgfVxuICBpZiAoZWFybGllc3RTdXNwZW5kZWRUaW1lID4gZWFybGllc3RFeHBpcmF0aW9uVGltZSkge1xuICAgIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBlYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIH1cbiAgcmV0dXJuIGVhcmxpZXN0RXhwaXJhdGlvblRpbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWRFeHBpcmVBdEV4cGlyYXRpb25UaW1lKFxuICByb290OiBGaWJlclJvb3QsXG4gIGN1cnJlbnRUaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IHZvaWQge1xuICBjb25zdCBleHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gIGlmIChleHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGN1cnJlbnRUaW1lIDw9IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlIHJvb3QgaGFzIGV4cGlyZWQuIEZsdXNoIGFsbCB3b3JrIHVwIHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgcm9vdC5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGN1cnJlbnRUaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihjb21wbGV0ZWRFeHBpcmF0aW9uVGltZSwgcm9vdCkge1xuICBjb25zdCBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgY29uc3QgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgY29uc3QgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgY29uc3QgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcblxuICAvLyBXb3JrIG9uIHRoZSBlYXJsaWVzdCBwZW5kaW5nIHRpbWUuIEZhaWxpbmcgdGhhdCwgd29yayBvbiB0aGUgbGF0ZXN0XG4gIC8vIHBpbmdlZCB0aW1lLlxuICBsZXQgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPVxuICAgIGVhcmxpZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yayA/IGVhcmxpZXN0UGVuZGluZ1RpbWUgOiBsYXRlc3RQaW5nZWRUaW1lO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vIHBlbmRpbmcgb3IgcGluZ2VkIHdvcmssIGNoZWNrIGlmIHRoZXJlJ3Mgc3VzcGVuZGVkIHdvcmtcbiAgLy8gdGhhdCdzIGxvd2VyIHByaW9yaXR5IHRoYW4gd2hhdCB3ZSBqdXN0IGNvbXBsZXRlZC5cbiAgaWYgKFxuICAgIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID09PSBOb1dvcmsgJiZcbiAgICAoY29tcGxldGVkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZSA8IGNvbXBsZXRlZEV4cGlyYXRpb25UaW1lKVxuICApIHtcbiAgICAvLyBUaGUgbG93ZXN0IHByaW9yaXR5IHN1c3BlbmRlZCB3b3JrIGlzIHRoZSB3b3JrIG1vc3QgbGlrZWx5IHRvIGJlXG4gICAgLy8gY29tbWl0dGVkIG5leHQuIExldCdzIHN0YXJ0IHJlbmRlcmluZyBpdCBhZ2Fpbiwgc28gdGhhdCBpZiBpdCB0aW1lcyBvdXQsXG4gICAgLy8gaXQncyByZWFkeSB0byBjb21taXQuXG4gICAgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBsYXRlc3RTdXNwZW5kZWRUaW1lO1xuICB9XG5cbiAgbGV0IGV4cGlyYXRpb25UaW1lID0gbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT247XG4gIGlmIChleHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gRXhwaXJlIHVzaW5nIHRoZSBlYXJsaWVzdCBrbm93biBleHBpcmF0aW9uIHRpbWUuXG4gICAgZXhwaXJhdGlvblRpbWUgPSBlYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIH1cblxuICByb290Lm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID0gbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT247XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJQZW5kaW5nUHJpb3JpdHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0V4cGlyYXRpb25UaW1lfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1VwZGF0ZSwgU25hcHNob3R9IGZyb20gJ3NoYXJlZC9SZWFjdFNpZGVFZmZlY3RUYWdzJztcbmltcG9ydCB7XG4gIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyxcbiAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSxcbiAgd2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMsXG59IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5pbXBvcnQgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgZnJvbSAnLi9SZWFjdFN0cmljdE1vZGVXYXJuaW5ncyc7XG5pbXBvcnQge2lzTW91bnRlZH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9yZWZsZWN0aW9uJztcbmltcG9ydCB7Z2V0IGFzIGdldEluc3RhbmNlLCBzZXQgYXMgc2V0SW5zdGFuY2V9IGZyb20gJ3NoYXJlZC9SZWFjdEluc3RhbmNlTWFwJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnc2hhcmVkL3NoYWxsb3dFcXVhbCc7XG5pbXBvcnQgZ2V0Q29tcG9uZW50TmFtZSBmcm9tICdzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZSc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmdXaXRob3V0U3RhY2sgZnJvbSAnc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2snO1xuaW1wb3J0IHtSRUFDVF9DT05URVhUX1RZUEV9IGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuXG5pbXBvcnQge3N0YXJ0UGhhc2VUaW1lciwgc3RvcFBoYXNlVGltZXJ9IGZyb20gJy4vUmVhY3REZWJ1Z0ZpYmVyUGVyZic7XG5pbXBvcnQge3Jlc29sdmVEZWZhdWx0UHJvcHN9IGZyb20gJy4vUmVhY3RGaWJlckxhenlDb21wb25lbnQnO1xuaW1wb3J0IHtTdHJpY3RNb2RlfSBmcm9tICcuL1JlYWN0VHlwZU9mTW9kZSc7XG5cbmltcG9ydCB7XG4gIGVucXVldWVVcGRhdGUsXG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSxcbiAgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZyxcbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcsXG4gIGNyZWF0ZVVwZGF0ZSxcbiAgUmVwbGFjZVN0YXRlLFxuICBGb3JjZVVwZGF0ZSxcbn0gZnJvbSAnLi9SZWFjdFVwZGF0ZVF1ZXVlJztcbmltcG9ydCB7Tm9Xb3JrfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQge1xuICBjYWNoZUNvbnRleHQsXG4gIGdldE1hc2tlZENvbnRleHQsXG4gIGdldFVubWFza2VkQ29udGV4dCxcbiAgaGFzQ29udGV4dENoYW5nZWQsXG4gIGVtcHR5Q29udGV4dE9iamVjdCxcbn0gZnJvbSAnLi9SZWFjdEZpYmVyQ29udGV4dCc7XG5pbXBvcnQge3JlYWRDb250ZXh0fSBmcm9tICcuL1JlYWN0RmliZXJOZXdDb250ZXh0JztcbmltcG9ydCB7XG4gIHJlcXVlc3RDdXJyZW50VGltZSxcbiAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgc2NoZWR1bGVXb3JrLFxuICBmbHVzaFBhc3NpdmVFZmZlY3RzLFxufSBmcm9tICcuL1JlYWN0RmliZXJTY2hlZHVsZXInO1xuXG5jb25zdCBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG5leHBvcnQgY29uc3QgZW1wdHlSZWZzT2JqZWN0ID0gbmV3IFJlYWN0LkNvbXBvbmVudCgpLnJlZnM7XG5cbmxldCBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7XG5sZXQgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xubGV0IGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbmxldCBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xubGV0IGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbmxldCB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU7XG5sZXQgd2Fybk9uSW52YWxpZENhbGxiYWNrO1xubGV0IGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xubGV0IGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xubGV0IGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxuaWYgKF9fREVWX18pIHtcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcblxuICBjb25zdCBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2s6IG1peGVkLCBjYWxsZXJOYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGAke2NhbGxlck5hbWV9XyR7KGNhbGxiYWNrOiBhbnkpfWA7XG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgK1xuICAgICAgICAgICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxcbiAgICAgICAgY2FsbGVyTmFtZSxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbih0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArXG4gICAgICAgICAgICAnWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsXG4gICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSAnICtcbiAgICAgICAgICAnbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0ICcgK1xuICAgICAgICAgICdhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnICtcbiAgICAgICAgICBcInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc24ndCBzdXBwb3J0ZWQuIFRyeSBcIiArXG4gICAgICAgICAgJ3RvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoICcgK1xuICAgICAgICAgICd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicsXG4gICAgICApO1xuICAgIH0sXG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIGN0b3I6IGFueSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiAocHJvcHM6IGFueSwgc3RhdGU6IGFueSkgPT4gYW55LFxuICBuZXh0UHJvcHM6IGFueSxcbikge1xuICBjb25zdCBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKFxuICAgICAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8XG4gICAgICAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSlcbiAgICApIHtcbiAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfVxuICAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuICBjb25zdCBtZW1vaXplZFN0YXRlID1cbiAgICBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWRcbiAgICAgID8gcHJldlN0YXRlXG4gICAgICA6IE9iamVjdC5hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG5cbiAgLy8gT25jZSB0aGUgdXBkYXRlIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlXG4gIC8vIGJhc2Ugc3RhdGUuXG4gIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgdXBkYXRlUXVldWUuYmFzZVN0YXRlID0gbWVtb2l6ZWRTdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZCxcbiAgZW5xdWV1ZVNldFN0YXRlKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmliZXIgPSBnZXRJbnN0YW5jZShpbnN0KTtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgIGNvbnN0IGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgY29uc3QgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGZpYmVyID0gZ2V0SW5zdGFuY2UoaW5zdCk7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICBjb25zdCBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKTtcblxuICAgIGNvbnN0IHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICB9XG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmliZXIgPSBnZXRJbnN0YW5jZShpbnN0KTtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgIGNvbnN0IGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgY29uc3QgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gIHdvcmtJblByb2dyZXNzLFxuICBjdG9yLFxuICBvbGRQcm9wcyxcbiAgbmV3UHJvcHMsXG4gIG9sZFN0YXRlLFxuICBuZXdTdGF0ZSxcbiAgbmV4dENvbnRleHQsXG4pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBuZXdTdGF0ZSxcbiAgICAgIG5leHRDb250ZXh0LFxuICAgICk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICBzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgK1xuICAgICAgICAgICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJyxcbiAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3M6IEZpYmVyLCBjdG9yOiBhbnksIG5ld1Byb3BzOiBhbnkpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgY29uc3QgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID1cbiAgICAgICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHxcbiAgICAgIGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fFxuICAgICAgaW5zdGFuY2Uuc3RhdGU7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsXG4gICAgICAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgK1xuICAgICAgICAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICtcbiAgICAgICAgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsXG4gICAgICBuYW1lLFxuICAgICk7XG4gICAgY29uc3Qgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9XG4gICAgICAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8XG4gICAgICBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgIG5vR2V0RGVmYXVsdFByb3BzT25FUzYsXG4gICAgICAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgK1xuICAgICAgICAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICtcbiAgICAgICAgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJyxcbiAgICAgIG5hbWUsXG4gICAgKTtcbiAgICBjb25zdCBub0luc3RhbmNlUHJvcFR5cGVzID0gIWluc3RhbmNlLnByb3BUeXBlcztcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgbm9JbnN0YW5jZVByb3BUeXBlcyxcbiAgICAgICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICtcbiAgICAgICAgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLFxuICAgICAgbmFtZSxcbiAgICApO1xuICAgIGNvbnN0IG5vSW5zdGFuY2VDb250ZXh0VHlwZSA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgbm9JbnN0YW5jZUNvbnRleHRUeXBlLFxuICAgICAgJ2NvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArXG4gICAgICAgICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC4nLFxuICAgICAgbmFtZSxcbiAgICApO1xuICAgIGNvbnN0IG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBub0luc3RhbmNlQ29udGV4dFR5cGVzLFxuICAgICAgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgK1xuICAgICAgICAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsXG4gICAgICBuYW1lLFxuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICBjdG9yLmNvbnRleHRUeXBlICYmXG4gICAgICBjdG9yLmNvbnRleHRUeXBlcyAmJlxuICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKVxuICAgICkge1xuICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgK1xuICAgICAgICAgICdUaGUgbGVnYWN5IGNvbnRleHRUeXBlcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICAgICAgbmFtZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPVxuICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgbm9Db21wb25lbnRTaG91bGRVcGRhdGUsXG4gICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcbiAgICAgICAgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgK1xuICAgICAgICAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgK1xuICAgICAgICAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJyxcbiAgICAgIG5hbWUsXG4gICAgKTtcbiAgICBpZiAoXG4gICAgICBjdG9yLnByb3RvdHlwZSAmJlxuICAgICAgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiZcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgK1xuICAgICAgICAgICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgK1xuICAgICAgICAgICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLFxuICAgICAgICBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50JyxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG5vQ29tcG9uZW50RGlkVW5tb3VudCA9XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgbm9Db21wb25lbnREaWRVbm1vdW50LFxuICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgK1xuICAgICAgICAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JyxcbiAgICAgIG5hbWUsXG4gICAgKTtcbiAgICBjb25zdCBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyxcbiAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgK1xuICAgICAgICAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgK1xuICAgICAgICAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArXG4gICAgICAgICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLFxuICAgICAgbmFtZSxcbiAgICApO1xuICAgIGNvbnN0IG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLFxuICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgIG5hbWUsXG4gICAgKTtcbiAgICBjb25zdCBub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPVxuICAgICAgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsXG4gICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcbiAgICAgICAgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsXG4gICAgICBuYW1lLFxuICAgICk7XG4gICAgY29uc3QgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMsXG4gICAgICAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArXG4gICAgICAgIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICBuYW1lLFxuICAgICAgbmFtZSxcbiAgICApO1xuICAgIGNvbnN0IG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBub0luc3RhbmNlRGVmYXVsdFByb3BzLFxuICAgICAgJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICtcbiAgICAgICAgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsXG4gICAgICBuYW1lLFxuICAgICAgbmFtZSxcbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKVxuICAgICkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArXG4gICAgICAgICAgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsXG4gICAgICAgIGdldENvbXBvbmVudE5hbWUoY3RvciksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPVxuICAgICAgdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICAgICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArXG4gICAgICAgICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLFxuICAgICAgbmFtZSxcbiAgICApO1xuICAgIGNvbnN0IG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPVxuICAgICAgdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJztcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCxcbiAgICAgICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArXG4gICAgICAgICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLFxuICAgICAgbmFtZSxcbiAgICApO1xuICAgIGNvbnN0IG5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPVxuICAgICAgdHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgIG5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUsXG4gICAgICAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArXG4gICAgICAgICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLFxuICAgICAgbmFtZSxcbiAgICApO1xuICAgIGNvbnN0IHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLFxuICAgICAgICBuYW1lLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JyxcbiAgICAgICAgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArXG4gICAgICAgICAgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLFxuICAgICAgICBuYW1lLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzOiBGaWJlciwgaW5zdGFuY2U6IGFueSk6IHZvaWQge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICBzZXRJbnN0YW5jZShpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoX19ERVZfXykge1xuICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIGN0b3I6IGFueSxcbiAgcHJvcHM6IGFueSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogYW55IHtcbiAgbGV0IGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID0gZmFsc2U7XG4gIGxldCB1bm1hc2tlZENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIGxldCBjb250ZXh0ID0gbnVsbDtcbiAgY29uc3QgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNvbnRleHRUeXBlLiQkdHlwZW9mICE9PSBSRUFDVF9DT05URVhUX1RZUEUgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcilcbiAgICAgICkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgK1xuICAgICAgICAgICAgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiAnICtcbiAgICAgICAgICAgICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JyxcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dCgoY29udGV4dFR5cGU6IGFueSkpO1xuICB9IGVsc2Uge1xuICAgIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgY29uc3QgY29udGV4dFR5cGVzID0gY3Rvci5jb250ZXh0VHlwZXM7XG4gICAgaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPVxuICAgICAgY29udGV4dFR5cGVzICE9PSBudWxsICYmIGNvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnRleHQgPSBpc0xlZ2FjeUNvbnRleHRDb25zdW1lclxuICAgICAgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpXG4gICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIC8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoXG4gICAgICBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHxcbiAgICAgIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKVxuICAgICkge1xuICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICBjb25zdCBzdGF0ZSA9ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGluc3RhbmNlLnN0YXRlXG4gICAgICA6IG51bGwpO1xuICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArXG4gICAgICAgICAgICAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArXG4gICAgICAgICAgICAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgK1xuICAgICAgICAgICAgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGxldCBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgbGV0IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgbGV0IGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlXG4gICAgICApIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlXG4gICAgICApIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWVcbiAgICAgICkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fFxuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgY29uc3QgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSdcbiAgICAgICAgICAgIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgK1xuICAgICAgICAgICAgICAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgK1xuICAgICAgICAgICAgICAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArXG4gICAgICAgICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBgXFxuICAke2ZvdW5kV2lsbE1vdW50TmFtZX1gIDogJycsXG4gICAgICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsXG4gICAgICAgICAgICAgID8gYFxcbiAgJHtmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lfWBcbiAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBgXFxuICAke2ZvdW5kV2lsbFVwZGF0ZU5hbWV9YCA6ICcnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gIGlmIChpc0xlZ2FjeUNvbnRleHRDb25zdW1lcikge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gIGNvbnN0IG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArXG4gICAgICAgICAgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgK1xuICAgICAgICAgICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCcsXG4gICAgICApO1xuICAgIH1cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgaW5zdGFuY2UsXG4gIG5ld1Byb3BzLFxuICBuZXh0Q29udGV4dCxcbikge1xuICBjb25zdCBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9XG4gICAgICAgIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArXG4gICAgICAgICAgICBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICtcbiAgICAgICAgICAgICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG4vLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2UoXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgY3RvcjogYW55LFxuICBuZXdQcm9wczogYW55LFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pOiB2b2lkIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIGNvbnN0IGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLnJlZnMgPSBlbXB0eVJlZnNPYmplY3Q7XG5cbiAgY29uc3QgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJyVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlICcgK1xuICAgICAgICAgICAgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArXG4gICAgICAgICAgICAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgKTtcblxuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmREZXByZWNhdGlvbldhcm5pbmdzKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxldCB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgY29uc3QgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN0b3IsXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICApO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICBpZiAoXG4gICAgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmXG4gICAgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKVxuICApIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG4gICAgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2UoXG4gIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgY3RvcjogYW55LFxuICBuZXdQcm9wczogYW55LFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuXG4gIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICBjb25zdCBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIGxldCBuZXh0Q29udGV4dDtcbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgdHJ1ZSxcbiAgICApO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICBjb25zdCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgY29uc3QgaGFzTmV3TGlmZWN5Y2xlcyA9XG4gICAgdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gIGlmIChcbiAgICAhaGFzTmV3TGlmZWN5Y2xlcyAmJlxuICAgICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKVxuICApIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgbmV4dENvbnRleHQsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG5cbiAgY29uc3Qgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBsZXQgbmV3U3RhdGUgPSAoaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZSk7XG4gIGxldCB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG4gIGlmIChcbiAgICBvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiZcbiAgICBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiZcbiAgICAhaGFzQ29udGV4dENoYW5nZWQoKSAmJlxuICAgICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKClcbiAgKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgbmV3UHJvcHMsXG4gICAgKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBjb25zdCBzaG91bGRVcGRhdGUgPVxuICAgIGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fFxuICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBuZXh0Q29udGV4dCxcbiAgICApO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmIChcbiAgICAgICFoYXNOZXdMaWZlY3ljbGVzICYmXG4gICAgICAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBzdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG5cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoXG4gIGN1cnJlbnQ6IEZpYmVyLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIGN0b3I6IGFueSxcbiAgbmV3UHJvcHM6IGFueSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPVxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlXG4gICAgICA/IG9sZFByb3BzXG4gICAgICA6IHJlc29sdmVEZWZhdWx0UHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgb2xkUHJvcHMpO1xuXG4gIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICBjb25zdCBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIGxldCBuZXh0Q29udGV4dDtcbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXh0VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBuZXh0Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgY29uc3QgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIGNvbnN0IGhhc05ld0xpZmVjeWNsZXMgPVxuICAgIHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICBpZiAoXG4gICAgIWhhc05ld0xpZmVjeWNsZXMgJiZcbiAgICAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJylcbiAgKSB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgIG5leHRDb250ZXh0LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuXG4gIGNvbnN0IG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgbGV0IG5ld1N0YXRlID0gKGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGUpO1xuICBsZXQgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICB1cGRhdGVRdWV1ZSxcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmIChcbiAgICBvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiZcbiAgICBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiZcbiAgICAhaGFzQ29udGV4dENoYW5nZWQoKSAmJlxuICAgICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKClcbiAgKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKFxuICAgICAgICBvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICAgIG5ld1Byb3BzLFxuICAgICk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgY29uc3Qgc2hvdWxkVXBkYXRlID1cbiAgICBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHxcbiAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIG9sZFByb3BzLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBvbGRTdGF0ZSxcbiAgICAgIG5ld1N0YXRlLFxuICAgICAgbmV4dENvbnRleHQsXG4gICAgKTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoXG4gICAgICAhaGFzTmV3TGlmZWN5Y2xlcyAmJlxuICAgICAgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChcbiAgICAgICAgb2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICApIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKFxuICAgICAgICBvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5leHBvcnQge1xuICBhZG9wdENsYXNzSW5zdGFuY2UsXG4gIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gIG1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICB1cGRhdGVDbGFzc0luc3RhbmNlLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJDbGFzc0NvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7UmVhY3RDb250ZXh0fSBmcm9tICdzaGFyZWQvUmVhY3RUeXBlcyc7XG5pbXBvcnQgdHlwZSB7U2lkZUVmZmVjdFRhZ30gZnJvbSAnc2hhcmVkL1JlYWN0U2lkZUVmZmVjdFRhZ3MnO1xuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0V4cGlyYXRpb25UaW1lfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQgdHlwZSB7SG9va0VmZmVjdFRhZ30gZnJvbSAnLi9SZWFjdEhvb2tFZmZlY3RUYWdzJztcblxuaW1wb3J0IFJlYWN0U2hhcmVkSW50ZXJuYWxzIGZyb20gJ3NoYXJlZC9SZWFjdFNoYXJlZEludGVybmFscyc7XG5cbmltcG9ydCB7Tm9Xb3JrfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQge3JlYWRDb250ZXh0fSBmcm9tICcuL1JlYWN0RmliZXJOZXdDb250ZXh0JztcbmltcG9ydCB7XG4gIFVwZGF0ZSBhcyBVcGRhdGVFZmZlY3QsXG4gIFBhc3NpdmUgYXMgUGFzc2l2ZUVmZmVjdCxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0U2lkZUVmZmVjdFRhZ3MnO1xuaW1wb3J0IHtcbiAgTm9FZmZlY3QgYXMgTm9Ib29rRWZmZWN0LFxuICBVbm1vdW50TXV0YXRpb24sXG4gIE1vdW50TGF5b3V0LFxuICBVbm1vdW50UGFzc2l2ZSxcbiAgTW91bnRQYXNzaXZlLFxufSBmcm9tICcuL1JlYWN0SG9va0VmZmVjdFRhZ3MnO1xuaW1wb3J0IHtcbiAgc2NoZWR1bGVXb3JrLFxuICB3YXJuSWZOb3RDdXJyZW50bHlCYXRjaGluZ0luRGV2LFxuICBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICBmbHVzaFBhc3NpdmVFZmZlY3RzLFxuICByZXF1ZXN0Q3VycmVudFRpbWUsXG59IGZyb20gJy4vUmVhY3RGaWJlclNjaGVkdWxlcic7XG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5pbXBvcnQgZ2V0Q29tcG9uZW50TmFtZSBmcm9tICdzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZSc7XG5pbXBvcnQgaXMgZnJvbSAnc2hhcmVkL29iamVjdElzJztcbmltcG9ydCB7bWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGV9IGZyb20gJy4vUmVhY3RGaWJlckJlZ2luV29yayc7XG5cbmNvbnN0IHtSZWFjdEN1cnJlbnREaXNwYXRjaGVyfSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuXG5leHBvcnQgdHlwZSBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDxUPihcbiAgICBjb250ZXh0OiBSZWFjdENvbnRleHQ8VD4sXG4gICAgb2JzZXJ2ZWRCaXRzOiB2b2lkIHwgbnVtYmVyIHwgYm9vbGVhbixcbiAgKTogVCxcbiAgdXNlU3RhdGU8Uz4oaW5pdGlhbFN0YXRlOiAoKCkgPT4gUykgfCBTKTogW1MsIERpc3BhdGNoPEJhc2ljU3RhdGVBY3Rpb248Uz4+XSxcbiAgdXNlUmVkdWNlcjxTLCBJLCBBPihcbiAgICByZWR1Y2VyOiAoUywgQSkgPT4gUyxcbiAgICBpbml0aWFsQXJnOiBJLFxuICAgIGluaXQ/OiAoSSkgPT4gUyxcbiAgKTogW1MsIERpc3BhdGNoPEE+XSxcbiAgdXNlQ29udGV4dDxUPihcbiAgICBjb250ZXh0OiBSZWFjdENvbnRleHQ8VD4sXG4gICAgb2JzZXJ2ZWRCaXRzOiB2b2lkIHwgbnVtYmVyIHwgYm9vbGVhbixcbiAgKTogVCxcbiAgdXNlUmVmPFQ+KGluaXRpYWxWYWx1ZTogVCk6IHtjdXJyZW50OiBUfSxcbiAgdXNlRWZmZWN0KFxuICAgIGNyZWF0ZTogKCkgPT4gKCgpID0+IHZvaWQpIHwgdm9pZCxcbiAgICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbiAgKTogdm9pZCxcbiAgdXNlTGF5b3V0RWZmZWN0KFxuICAgIGNyZWF0ZTogKCkgPT4gKCgpID0+IHZvaWQpIHwgdm9pZCxcbiAgICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbiAgKTogdm9pZCxcbiAgdXNlQ2FsbGJhY2s8VD4oY2FsbGJhY2s6IFQsIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsKTogVCxcbiAgdXNlTWVtbzxUPihuZXh0Q3JlYXRlOiAoKSA9PiBULCBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCk6IFQsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU8VD4oXG4gICAgcmVmOiB7Y3VycmVudDogVCB8IG51bGx9IHwgKChpbnN0OiBUIHwgbnVsbCkgPT4gbWl4ZWQpIHwgbnVsbCB8IHZvaWQsXG4gICAgY3JlYXRlOiAoKSA9PiBULFxuICAgIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuICApOiB2b2lkLFxuICB1c2VEZWJ1Z1ZhbHVlPFQ+KHZhbHVlOiBULCBmb3JtYXR0ZXJGbjogPyh2YWx1ZTogVCkgPT4gbWl4ZWQpOiB2b2lkLFxufTtcblxudHlwZSBVcGRhdGU8UywgQT4gPSB7XG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAgYWN0aW9uOiBBLFxuICBlYWdlclJlZHVjZXI6ICgoUywgQSkgPT4gUykgfCBudWxsLFxuICBlYWdlclN0YXRlOiBTIHwgbnVsbCxcbiAgbmV4dDogVXBkYXRlPFMsIEE+IHwgbnVsbCxcbn07XG5cbnR5cGUgVXBkYXRlUXVldWU8UywgQT4gPSB7XG4gIGxhc3Q6IFVwZGF0ZTxTLCBBPiB8IG51bGwsXG4gIGRpc3BhdGNoOiAoQSA9PiBtaXhlZCkgfCBudWxsLFxuICBlYWdlclJlZHVjZXI6ICgoUywgQSkgPT4gUykgfCBudWxsLFxuICBlYWdlclN0YXRlOiBTIHwgbnVsbCxcbn07XG5cbnR5cGUgSG9va1R5cGUgPVxuICB8ICd1c2VTdGF0ZSdcbiAgfCAndXNlUmVkdWNlcidcbiAgfCAndXNlQ29udGV4dCdcbiAgfCAndXNlUmVmJ1xuICB8ICd1c2VFZmZlY3QnXG4gIHwgJ3VzZUxheW91dEVmZmVjdCdcbiAgfCAndXNlQ2FsbGJhY2snXG4gIHwgJ3VzZU1lbW8nXG4gIHwgJ3VzZUltcGVyYXRpdmVIYW5kbGUnXG4gIHwgJ3VzZURlYnVnVmFsdWUnO1xuXG5sZXQgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O1xuaWYgKF9fREVWX18pIHtcbiAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xufVxuXG5leHBvcnQgdHlwZSBIb29rID0ge1xuICBtZW1vaXplZFN0YXRlOiBhbnksXG5cbiAgYmFzZVN0YXRlOiBhbnksXG4gIGJhc2VVcGRhdGU6IFVwZGF0ZTxhbnksIGFueT4gfCBudWxsLFxuICBxdWV1ZTogVXBkYXRlUXVldWU8YW55LCBhbnk+IHwgbnVsbCxcblxuICBuZXh0OiBIb29rIHwgbnVsbCxcbn07XG5cbnR5cGUgSG9va0RldiA9IEhvb2sgJiB7XG4gIF9kZWJ1Z1R5cGU6IEhvb2tUeXBlLFxufTtcblxudHlwZSBFZmZlY3QgPSB7XG4gIHRhZzogSG9va0VmZmVjdFRhZyxcbiAgY3JlYXRlOiAoKSA9PiAoKCkgPT4gdm9pZCkgfCB2b2lkLFxuICBkZXN0cm95OiAoKCkgPT4gdm9pZCkgfCB2b2lkLFxuICBkZXBzOiBBcnJheTxtaXhlZD4gfCBudWxsLFxuICBuZXh0OiBFZmZlY3QsXG59O1xuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlID0ge1xuICBsYXN0RWZmZWN0OiBFZmZlY3QgfCBudWxsLFxufTtcblxudHlwZSBCYXNpY1N0YXRlQWN0aW9uPFM+ID0gKFMgPT4gUykgfCBTO1xuXG50eXBlIERpc3BhdGNoPEE+ID0gQSA9PiB2b2lkO1xuXG4vLyBUaGVzZSBhcmUgc2V0IHJpZ2h0IGJlZm9yZSBjYWxsaW5nIHRoZSBjb21wb25lbnQuXG5sZXQgcmVuZGVyRXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIEkndmUgbmFtZWQgaXQgZGlmZmVyZW50bHkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbmxldCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcjogRmliZXIgfCBudWxsID0gbnVsbDtcblxuLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbmxldCBmaXJzdEN1cnJlbnRIb29rOiBIb29rIHwgbnVsbCA9IG51bGw7XG5sZXQgY3VycmVudEhvb2s6IEhvb2sgfCBudWxsID0gbnVsbDtcbmxldCBuZXh0Q3VycmVudEhvb2s6IEhvb2sgfCBudWxsID0gbnVsbDtcbmxldCBmaXJzdFdvcmtJblByb2dyZXNzSG9vazogSG9vayB8IG51bGwgPSBudWxsO1xubGV0IHdvcmtJblByb2dyZXNzSG9vazogSG9vayB8IG51bGwgPSBudWxsO1xubGV0IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s6IEhvb2sgfCBudWxsID0gbnVsbDtcblxubGV0IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbmxldCBjb21wb25lbnRVcGRhdGVRdWV1ZTogRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSB8IG51bGwgPSBudWxsO1xubGV0IHNpZGVFZmZlY3RUYWc6IFNpZGVFZmZlY3RUYWcgPSAwO1xuXG4vLyBVcGRhdGVzIHNjaGVkdWxlZCBkdXJpbmcgcmVuZGVyIHdpbGwgdHJpZ2dlciBhbiBpbW1lZGlhdGUgcmUtcmVuZGVyIGF0IHRoZVxuLy8gZW5kIG9mIHRoZSBjdXJyZW50IHBhc3MuIFdlIGNhbid0IHN0b3JlIHRoZXNlIHVwZGF0ZXMgb24gdGhlIG5vcm1hbCBxdWV1ZSxcbi8vIGJlY2F1c2UgaWYgdGhlIHdvcmsgaXMgYWJvcnRlZCwgdGhleSBzaG91bGQgYmUgZGlzY2FyZGVkLiBCZWNhdXNlIHRoaXMgaXNcbi8vIGEgcmVsYXRpdmVseSByYXJlIGNhc2UsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBhZGQgYW4gYWRkaXRpb25hbCBmaWVsZCB0b1xuLy8gZWl0aGVyIHRoZSBob29rIG9yIHF1ZXVlIG9iamVjdCB0eXBlcy4gU28gd2Ugc3RvcmUgdGhlbSBpbiBhIGxhemlseSBjcmVhdGVcbi8vIG1hcCBvZiBxdWV1ZSAtPiByZW5kZXItcGhhc2UgdXBkYXRlcywgd2hpY2ggYXJlIGRpc2NhcmRlZCBvbmNlIHRoZSBjb21wb25lbnRcbi8vIGNvbXBsZXRlcyB3aXRob3V0IHJlLXJlbmRlcmluZy5cblxuLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5sZXQgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuLy8gTGF6aWx5IGNyZWF0ZWQgbWFwIG9mIHJlbmRlci1waGFzZSB1cGRhdGVzXG5sZXQgcmVuZGVyUGhhc2VVcGRhdGVzOiBNYXA8XG4gIFVwZGF0ZVF1ZXVlPGFueSwgYW55PixcbiAgVXBkYXRlPGFueSwgYW55Pixcbj4gfCBudWxsID0gbnVsbDtcbi8vIENvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbmxldCBudW1iZXJPZlJlUmVuZGVyczogbnVtYmVyID0gMDtcbmNvbnN0IFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xuXG4vLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcbmxldCBjdXJyZW50SG9va05hbWVJbkRldjogP0hvb2tUeXBlID0gbnVsbDtcblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyOiBhbnkpOiBGaWJlcikudHlwZSxcbiAgICApO1xuICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgY29uc3Qgc2Vjb25kQ29sdW1uU3RhcnQgPSAyMjtcblxuICAgICAgbGV0IHRhYmxlID0gJyc7XG4gICAgICBsZXQgcHJldkhvb2s6IEhvb2tEZXYgfCBudWxsID0gKGZpcnN0Q3VycmVudEhvb2s6IGFueSk7XG4gICAgICBsZXQgbmV4dEhvb2s6IEhvb2tEZXYgfCBudWxsID0gKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rOiBhbnkpO1xuICAgICAgbGV0IG4gPSAxO1xuICAgICAgd2hpbGUgKHByZXZIb29rICE9PSBudWxsICYmIG5leHRIb29rICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9sZEhvb2tOYW1lID0gcHJldkhvb2suX2RlYnVnVHlwZTtcbiAgICAgICAgY29uc3QgbmV3SG9va05hbWUgPSBuZXh0SG9vay5fZGVidWdUeXBlO1xuXG4gICAgICAgIGxldCByb3cgPSBgJHtufS4gJHtvbGRIb29rTmFtZX1gO1xuXG4gICAgICAgIC8vIEV4dHJhIHNwYWNlIHNvIHNlY29uZCBjb2x1bW4gbGluZXMgdXBcbiAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgcm93ICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuXG4gICAgICAgIHRhYmxlICs9IHJvdztcbiAgICAgICAgcHJldkhvb2sgPSAocHJldkhvb2submV4dDogYW55KTtcbiAgICAgICAgbmV4dEhvb2sgPSAobmV4dEhvb2submV4dDogYW55KTtcbiAgICAgICAgbisrO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1JlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiAnICtcbiAgICAgICAgICAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArXG4gICAgICAgICAgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9mYi5tZS9ydWxlcy1vZi1ob29rc1xcblxcbicgK1xuICAgICAgICAgICcgICBQcmV2aW91cyByZW5kZXIgICAgTmV4dCByZW5kZXJcXG4nICtcbiAgICAgICAgICAnICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgK1xuICAgICAgICAgICclcycgK1xuICAgICAgICAgICcgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuJyxcbiAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgdGFibGUsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICAnSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gJyArXG4gICAgICAnKGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YWxpZC1ob29rLWNhbGwpJyxcbiAgKTtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKFxuICBuZXh0RGVwczogQXJyYXk8bWl4ZWQ+LFxuICBwcmV2RGVwczogQXJyYXk8bWl4ZWQ+IHwgbnVsbCxcbikge1xuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArXG4gICAgICAgICAgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArXG4gICAgICAgICAgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsXG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICtcbiAgICAgICAgICAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICtcbiAgICAgICAgICAnUHJldmlvdXM6ICVzXFxuJyArXG4gICAgICAgICAgJ0luY29taW5nOiAlcycsXG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICBgWyR7bmV4dERlcHMuam9pbignLCAnKX1dYCxcbiAgICAgICAgYFske3ByZXZEZXBzLmpvaW4oJywgJyl9XWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIENvbXBvbmVudDogYW55LFxuICBwcm9wczogYW55LFxuICByZWZPckNvbnRleHQ6IGFueSxcbiAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IGFueSB7XG4gIHJlbmRlckV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBmaXJzdEN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rID1cbiAgICBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBjdXJyZW50SG9vayA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAgLy8gcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIC8vIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gc2lkZUVmZmVjdFRhZyA9IDA7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPVxuICAgICAgbmV4dEN1cnJlbnRIb29rID09PSBudWxsXG4gICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWXG4gICAgICAgIDogSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPVxuICAgICAgbmV4dEN1cnJlbnRIb29rID09PSBudWxsXG4gICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudFxuICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlO1xuICB9XG5cbiAgbGV0IGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTtcblxuICAgICAgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcbiAgICAgIGZpcnN0Q3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcblxuICAgICAgY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gX19ERVZfX1xuICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZTtcblxuICAgICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gICAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSk7XG5cbiAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAgIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICB9XG5cbiAgLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY3kuXG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBjb25zdCByZW5kZXJlZFdvcms6IEZpYmVyID0gKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyOiBhbnkpO1xuXG4gIHJlbmRlcmVkV29yay5tZW1vaXplZFN0YXRlID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gIHJlbmRlcmVkV29yay5leHBpcmF0aW9uVGltZSA9IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICByZW5kZXJlZFdvcmsudXBkYXRlUXVldWUgPSAoY29tcG9uZW50VXBkYXRlUXVldWU6IGFueSk7XG4gIHJlbmRlcmVkV29yay5lZmZlY3RUYWcgfD0gc2lkZUVmZmVjdFRhZztcblxuICBjb25zdCBkaWRSZW5kZXJUb29GZXdIb29rcyA9XG4gICAgY3VycmVudEhvb2sgIT09IG51bGwgJiYgY3VycmVudEhvb2submV4dCAhPT0gbnVsbDtcblxuICByZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuXG4gIGZpcnN0Q3VycmVudEhvb2sgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgc2lkZUVmZmVjdFRhZyA9IDA7XG5cbiAgLy8gVGhlc2Ugd2VyZSByZXNldCBhYm92ZVxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcblxuICBpbnZhcmlhbnQoXG4gICAgIWRpZFJlbmRlclRvb0Zld0hvb2tzLFxuICAgICdSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCAnICtcbiAgICAgICdlYXJseSByZXR1cm4gc3RhdGVtZW50LicsXG4gICk7XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFpbG91dEhvb2tzKFxuICBjdXJyZW50OiBGaWJlcixcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gfihQYXNzaXZlRWZmZWN0IHwgVXBkYXRlRWZmZWN0KTtcbiAgaWYgKGN1cnJlbnQuZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICBjdXJyZW50LmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEhvb2tzKCk6IHZvaWQge1xuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIC8vIFRoaXMgaXMgdXNlZCB0byByZXNldCB0aGUgc3RhdGUgb2YgdGhpcyBtb2R1bGUgd2hlbiBhIGNvbXBvbmVudCB0aHJvd3MuXG4gIC8vIEl0J3MgYWxzbyBjYWxsZWQgaW5zaWRlIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCBpZiB3ZSBkZXRlcm1pbmUgdGhlXG4gIC8vIGNvbXBvbmVudCBpcyBhIG1vZHVsZS1zdHlsZSBjb21wb25lbnQuXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG5cbiAgZmlyc3RDdXJyZW50SG9vayA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgbmV4dEN1cnJlbnRIb29rID0gbnVsbDtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBudWxsO1xuICBzaWRlRWZmZWN0VGFnID0gMDtcblxuICBpZiAoX19ERVZfXykge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xufVxuXG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpOiBIb29rIHtcbiAgY29uc3QgaG9vazogSG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuXG4gICAgYmFzZVN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIGJhc2VVcGRhdGU6IG51bGwsXG5cbiAgICBuZXh0OiBudWxsLFxuICB9O1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgKGhvb2s6IGFueSkuX2RlYnVnVHlwZSA9IChjdXJyZW50SG9va05hbWVJbkRldjogYW55KTtcbiAgfVxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTogSG9vayB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBib3RoIGZvciB1cGRhdGVzIGFuZCBmb3IgcmUtcmVuZGVycyB0cmlnZ2VyZWQgYnkgYVxuICAvLyByZW5kZXIgcGhhc2UgdXBkYXRlLiBJdCBhc3N1bWVzIHRoZXJlIGlzIGVpdGhlciBhIGN1cnJlbnQgaG9vayB3ZSBjYW5cbiAgLy8gY2xvbmUsIG9yIGEgd29yay1pbi1wcm9ncmVzcyBob29rIGZyb20gYSBwcmV2aW91cyByZW5kZXIgcGFzcyB0aGF0IHdlIGNhblxuICAvLyB1c2UgYXMgYSBiYXNlLiBXaGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGJhc2UgbGlzdCwgd2UgbXVzdCBzd2l0Y2ggdG9cbiAgLy8gdGhlIGRpc3BhdGNoZXIgdXNlZCBmb3IgbW91bnRzLlxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuXG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2sgIT09IG51bGwgPyBjdXJyZW50SG9vay5uZXh0IDogbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBDbG9uZSBmcm9tIHRoZSBjdXJyZW50IGhvb2suXG4gICAgaW52YXJpYW50KFxuICAgICAgbmV4dEN1cnJlbnRIb29rICE9PSBudWxsLFxuICAgICAgJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nLFxuICAgICk7XG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG5cbiAgICBjb25zdCBuZXdIb29rOiBIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcblxuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBiYXNlVXBkYXRlOiBjdXJyZW50SG9vay5iYXNlVXBkYXRlLFxuXG4gICAgICBuZXh0OiBudWxsLFxuICAgIH07XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0LlxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXdIb29rO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV3SG9vaztcbiAgICB9XG4gICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcblxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAobmV3SG9vazogYW55KS5fZGVidWdUeXBlID0gKGN1cnJlbnRIb29rTmFtZUluRGV2OiBhbnkpO1xuICAgICAgaWYgKGN1cnJlbnRIb29rTmFtZUluRGV2ICE9PSAoKGN1cnJlbnRIb29rOiBhbnkpOiBIb29rRGV2KS5fZGVidWdUeXBlKSB7XG4gICAgICAgIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTogRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSB7XG4gIHJldHVybiB7XG4gICAgbGFzdEVmZmVjdDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXI8Uz4oc3RhdGU6IFMsIGFjdGlvbjogQmFzaWNTdGF0ZUFjdGlvbjxTPik6IFMge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29udGV4dDxUPihcbiAgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+LFxuICBvYnNlcnZlZEJpdHM6IHZvaWQgfCBudW1iZXIgfCBib29sZWFuLFxuKTogVCB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgfVxuICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dDxUPihcbiAgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+LFxuICBvYnNlcnZlZEJpdHM6IHZvaWQgfCBudW1iZXIgfCBib29sZWFuLFxuKTogVCB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIH1cbiAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcjxTLCBJLCBBPihcbiAgcmVkdWNlcjogKFMsIEEpID0+IFMsXG4gIGluaXRpYWxBcmc6IEksXG4gIGluaXQ/OiBJID0+IFMsXG4pOiBbUywgRGlzcGF0Y2g8QT5dIHtcbiAgY29uc3QgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGxldCBpbml0aWFsU3RhdGU7XG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxTdGF0ZSA9ICgoaW5pdGlhbEFyZzogYW55KTogUyk7XG4gIH1cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHF1ZXVlID0gKGhvb2sucXVldWUgPSB7XG4gICAgbGFzdDogbnVsbCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBlYWdlclJlZHVjZXI6IHJlZHVjZXIsXG4gICAgZWFnZXJTdGF0ZTogKGluaXRpYWxTdGF0ZTogYW55KSxcbiAgfSk7XG4gIGNvbnN0IGRpc3BhdGNoOiBEaXNwYXRjaDxBPiA9IChxdWV1ZS5kaXNwYXRjaCA9IChkaXNwYXRjaEFjdGlvbi5iaW5kKFxuICAgIG51bGwsXG4gICAgLy8gRmxvdyBkb2Vzbid0IGtub3cgdGhpcyBpcyBub24tbnVsbCwgYnV0IHdlIGRvLlxuICAgICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXI6IGFueSk6IEZpYmVyKSxcbiAgICBxdWV1ZSxcbiAgKTogYW55KSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXI8UywgSSwgQT4oXG4gIHJlZHVjZXI6IChTLCBBKSA9PiBTLFxuICBpbml0aWFsQXJnOiBJLFxuICBpbml0PzogSSA9PiBTLFxuKTogW1MsIERpc3BhdGNoPEE+XSB7XG4gIGNvbnN0IGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgY29uc3QgcXVldWUgPSBob29rLnF1ZXVlO1xuICBpbnZhcmlhbnQoXG4gICAgcXVldWUgIT09IG51bGwsXG4gICAgJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICApO1xuXG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbiAgICBjb25zdCBkaXNwYXRjaDogRGlzcGF0Y2g8QT4gPSAocXVldWUuZGlzcGF0Y2g6IGFueSk7XG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXJlIHN0b3JlZCBpbiBhIG1hcCBvZiBxdWV1ZSAtPiBsaW5rZWQgbGlzdFxuICAgICAgY29uc3QgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuICAgICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICBsZXQgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICBjb25zdCBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTtcblxuICAgICAgICAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICBpZiAoIWlzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuXG4gICAgICAgIC8vIERvbid0IHBlcnNpc3QgdGhlIHN0YXRlIGFjY3VtbGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbiAgICAgICAgLy8gdGhlIGJhc2Ugc3RhdGUgdW5sZXNzIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgICAgLy8gVE9ETzogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgZGVzaXJlZCBzZW1hbnRpY3MsIGJ1dCBpdCdzIHdoYXQgd2VcbiAgICAgICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cbiAgICAgICAgaWYgKGhvb2suYmFzZVVwZGF0ZSA9PT0gcXVldWUubGFzdCkge1xuICAgICAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH1cblxuICAvLyBUaGUgbGFzdCB1cGRhdGUgaW4gdGhlIGVudGlyZSBxdWV1ZVxuICBjb25zdCBsYXN0ID0gcXVldWUubGFzdDtcbiAgLy8gVGhlIGxhc3QgdXBkYXRlIHRoYXQgaXMgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cbiAgY29uc3QgYmFzZVVwZGF0ZSA9IGhvb2suYmFzZVVwZGF0ZTtcbiAgY29uc3QgYmFzZVN0YXRlID0gaG9vay5iYXNlU3RhdGU7XG5cbiAgLy8gRmluZCB0aGUgZmlyc3QgdW5wcm9jZXNzZWQgdXBkYXRlLlxuICBsZXQgZmlyc3Q7XG4gIGlmIChiYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIC8vIEZvciB0aGUgZmlyc3QgdXBkYXRlLCB0aGUgcXVldWUgaXMgYSBjaXJjdWxhciBsaW5rZWQgbGlzdCB3aGVyZVxuICAgICAgLy8gYHF1ZXVlLmxhc3QubmV4dCA9IHF1ZXVlLmZpcnN0YC4gT25jZSB0aGUgZmlyc3QgdXBkYXRlIGNvbW1pdHMsIGFuZFxuICAgICAgLy8gdGhlIGBiYXNlVXBkYXRlYCBpcyBubyBsb25nZXIgZW1wdHksIHdlIGNhbiB1bnJhdmVsIHRoZSBsaXN0LlxuICAgICAgbGFzdC5uZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgZmlyc3QgPSBiYXNlVXBkYXRlLm5leHQ7XG4gIH0gZWxzZSB7XG4gICAgZmlyc3QgPSBsYXN0ICE9PSBudWxsID8gbGFzdC5uZXh0IDogbnVsbDtcbiAgfVxuICBpZiAoZmlyc3QgIT09IG51bGwpIHtcbiAgICBsZXQgbmV3U3RhdGUgPSBiYXNlU3RhdGU7XG4gICAgbGV0IG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG5ld0Jhc2VVcGRhdGUgPSBudWxsO1xuICAgIGxldCBwcmV2VXBkYXRlID0gYmFzZVVwZGF0ZTtcbiAgICBsZXQgdXBkYXRlID0gZmlyc3Q7XG4gICAgbGV0IGRpZFNraXAgPSBmYWxzZTtcbiAgICBkbyB7XG4gICAgICBjb25zdCB1cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgICAgbmV3QmFzZVVwZGF0ZSA9IHByZXZVcGRhdGU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuICAgICAgICBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG4gICAgICAgIGlmICh1cGRhdGUuZWFnZXJSZWR1Y2VyID09PSByZWR1Y2VyKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB1cGRhdGUgd2FzIHByb2Nlc3NlZCBlYWdlcmx5LCBhbmQgaXRzIHJlZHVjZXIgbWF0Y2hlcyB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHJlZHVjZXIsIHdlIGNhbiB1c2UgdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUuXG4gICAgICAgICAgbmV3U3RhdGUgPSAoKHVwZGF0ZS5lYWdlclN0YXRlOiBhbnkpOiBTKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldlVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCAmJiB1cGRhdGUgIT09IGZpcnN0KTtcblxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgbmV3QmFzZVVwZGF0ZSA9IHByZXZVcGRhdGU7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgaWYgKCFpcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBob29rLmJhc2VVcGRhdGUgPSBuZXdCYXNlVXBkYXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuXG4gICAgcXVldWUuZWFnZXJSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICBxdWV1ZS5lYWdlclN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICBjb25zdCBkaXNwYXRjaDogRGlzcGF0Y2g8QT4gPSAocXVldWUuZGlzcGF0Y2g6IGFueSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGU8Uz4oXG4gIGluaXRpYWxTdGF0ZTogKCgpID0+IFMpIHwgUyxcbik6IFtTLCBEaXNwYXRjaDxCYXNpY1N0YXRlQWN0aW9uPFM+Pl0ge1xuICBjb25zdCBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGUoKTtcbiAgfVxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgY29uc3QgcXVldWUgPSAoaG9vay5xdWV1ZSA9IHtcbiAgICBsYXN0OiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGVhZ2VyUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgZWFnZXJTdGF0ZTogKGluaXRpYWxTdGF0ZTogYW55KSxcbiAgfSk7XG4gIGNvbnN0IGRpc3BhdGNoOiBEaXNwYXRjaDxcbiAgICBCYXNpY1N0YXRlQWN0aW9uPFM+LFxuICA+ID0gKHF1ZXVlLmRpc3BhdGNoID0gKGRpc3BhdGNoQWN0aW9uLmJpbmQoXG4gICAgbnVsbCxcbiAgICAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGlzIGlzIG5vbi1udWxsLCBidXQgd2UgZG8uXG4gICAgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlcjogYW55KTogRmliZXIpLFxuICAgIHF1ZXVlLFxuICApOiBhbnkpKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGU8Uz4oXG4gIGluaXRpYWxTdGF0ZTogKCgpID0+IFMpIHwgUyxcbik6IFtTLCBEaXNwYXRjaDxCYXNpY1N0YXRlQWN0aW9uPFM+Pl0ge1xuICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgKGluaXRpYWxTdGF0ZTogYW55KSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGRlc3Ryb3ksIGRlcHMpIHtcbiAgY29uc3QgZWZmZWN0OiBFZmZlY3QgPSB7XG4gICAgdGFnLFxuICAgIGNyZWF0ZSxcbiAgICBkZXN0cm95LFxuICAgIGRlcHMsXG4gICAgLy8gQ2lyY3VsYXJcbiAgICBuZXh0OiAobnVsbDogYW55KSxcbiAgfTtcbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RFZmZlY3QgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgbGFzdEVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgICAgZWZmZWN0Lm5leHQgPSBmaXJzdEVmZmVjdDtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVmPFQ+KGluaXRpYWxWYWx1ZTogVCk6IHtjdXJyZW50OiBUfSB7XG4gIGNvbnN0IGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBjb25zdCByZWYgPSB7Y3VycmVudDogaW5pdGlhbFZhbHVlfTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBPYmplY3Quc2VhbChyZWYpO1xuICB9XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgcmV0dXJuIHJlZjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmPFQ+KGluaXRpYWxWYWx1ZTogVCk6IHtjdXJyZW50OiBUfSB7XG4gIGNvbnN0IGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRWZmZWN0VGFnLCBob29rRWZmZWN0VGFnLCBjcmVhdGUsIGRlcHMpOiB2b2lkIHtcbiAgY29uc3QgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGNvbnN0IG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHNpZGVFZmZlY3RUYWcgfD0gZmliZXJFZmZlY3RUYWc7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0VmZmVjdFRhZywgY3JlYXRlLCB1bmRlZmluZWQsIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckVmZmVjdFRhZywgaG9va0VmZmVjdFRhZywgY3JlYXRlLCBkZXBzKTogdm9pZCB7XG4gIGNvbnN0IGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgY29uc3QgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgbGV0IGRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGN1cnJlbnRIb29rICE9PSBudWxsKSB7XG4gICAgY29uc3QgcHJldkVmZmVjdCA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgZGVzdHJveSA9IHByZXZFZmZlY3QuZGVzdHJveTtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHB1c2hFZmZlY3QoTm9Ib29rRWZmZWN0LCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNpZGVFZmZlY3RUYWcgfD0gZmliZXJFZmZlY3RUYWc7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0VmZmVjdFRhZywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KFxuICBjcmVhdGU6ICgpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWQsXG4gIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuKTogdm9pZCB7XG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoXG4gICAgVXBkYXRlRWZmZWN0IHwgUGFzc2l2ZUVmZmVjdCxcbiAgICBVbm1vdW50UGFzc2l2ZSB8IE1vdW50UGFzc2l2ZSxcbiAgICBjcmVhdGUsXG4gICAgZGVwcyxcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KFxuICBjcmVhdGU6ICgpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWQsXG4gIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuKTogdm9pZCB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFxuICAgIFVwZGF0ZUVmZmVjdCB8IFBhc3NpdmVFZmZlY3QsXG4gICAgVW5tb3VudFBhc3NpdmUgfCBNb3VudFBhc3NpdmUsXG4gICAgY3JlYXRlLFxuICAgIGRlcHMsXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KFxuICBjcmVhdGU6ICgpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWQsXG4gIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuKTogdm9pZCB7XG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoXG4gICAgVXBkYXRlRWZmZWN0LFxuICAgIFVubW91bnRNdXRhdGlvbiB8IE1vdW50TGF5b3V0LFxuICAgIGNyZWF0ZSxcbiAgICBkZXBzLFxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoXG4gIGNyZWF0ZTogKCkgPT4gKCgpID0+IHZvaWQpIHwgdm9pZCxcbiAgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwsXG4pOiB2b2lkIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoXG4gICAgVXBkYXRlRWZmZWN0LFxuICAgIFVubW91bnRNdXRhdGlvbiB8IE1vdW50TGF5b3V0LFxuICAgIGNyZWF0ZSxcbiAgICBkZXBzLFxuICApO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0PFQ+KFxuICBjcmVhdGU6ICgpID0+IFQsXG4gIHJlZjoge2N1cnJlbnQ6IFQgfCBudWxsfSB8ICgoaW5zdDogVCB8IG51bGwpID0+IG1peGVkKSB8IG51bGwgfCB2b2lkLFxuKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgY29uc3QgaW5zdCA9IGNyZWF0ZSgpO1xuICAgIHJlZkNhbGxiYWNrKGluc3QpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHJlZk9iamVjdCA9IHJlZjtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JyksXG4gICAgICAgICdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgJyArXG4gICAgICAgICAgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsXG4gICAgICAgICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgaW5zdCA9IGNyZWF0ZSgpO1xuICAgIHJlZk9iamVjdC5jdXJyZW50ID0gaW5zdDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlPFQ+KFxuICByZWY6IHtjdXJyZW50OiBUIHwgbnVsbH0gfCAoKGluc3Q6IFQgfCBudWxsKSA9PiBtaXhlZCkgfCBudWxsIHwgdm9pZCxcbiAgY3JlYXRlOiAoKSA9PiBULFxuICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbik6IHZvaWQge1xuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5pbmcoXG4gICAgICB0eXBlb2YgY3JlYXRlID09PSAnZnVuY3Rpb24nLFxuICAgICAgJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxcbiAgICAgIGNyZWF0ZSAhPT0gbnVsbCA/IHR5cGVvZiBjcmVhdGUgOiAnbnVsbCcsXG4gICAgKTtcbiAgfVxuXG4gIC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG4gIGNvbnN0IGVmZmVjdERlcHMgPVxuICAgIGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFxuICAgIFVwZGF0ZUVmZmVjdCxcbiAgICBVbm1vdW50TXV0YXRpb24gfCBNb3VudExheW91dCxcbiAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgIGVmZmVjdERlcHMsXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGU8VD4oXG4gIHJlZjoge2N1cnJlbnQ6IFQgfCBudWxsfSB8ICgoaW5zdDogVCB8IG51bGwpID0+IG1peGVkKSB8IG51bGwgfCB2b2lkLFxuICBjcmVhdGU6ICgpID0+IFQsXG4gIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuKTogdm9pZCB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHR5cGVvZiBjcmVhdGUgPT09ICdmdW5jdGlvbicsXG4gICAgICAnRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLFxuICAgICAgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyxcbiAgICApO1xuICB9XG5cbiAgLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cbiAgY29uc3QgZWZmZWN0RGVwcyA9XG4gICAgZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuXG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFxuICAgIFVwZGF0ZUVmZmVjdCxcbiAgICBVbm1vdW50TXV0YXRpb24gfCBNb3VudExheW91dCxcbiAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgIGVmZmVjdERlcHMsXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZTxUPih2YWx1ZTogVCwgZm9ybWF0dGVyRm46ID8odmFsdWU6IFQpID0+IG1peGVkKTogdm9pZCB7XG4gIC8vIFRoaXMgaG9vayBpcyBub3JtYWxseSBhIG5vLW9wLlxuICAvLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cbiAgLy8gc28gdGhhdCBlLmcuIERldlRvb2xzIGNhbiBkaXNwbGF5IGN1c3RvbSBob29rIHZhbHVlcy5cbn1cblxuY29uc3QgdXBkYXRlRGVidWdWYWx1ZSA9IG1vdW50RGVidWdWYWx1ZTtcblxuZnVuY3Rpb24gbW91bnRDYWxsYmFjazxUPihjYWxsYmFjazogVCwgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwpOiBUIHtcbiAgY29uc3QgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGNvbnN0IG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrPFQ+KGNhbGxiYWNrOiBULCBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCk6IFQge1xuICBjb25zdCBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGNvbnN0IG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGNvbnN0IHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcHJldkRlcHM6IEFycmF5PG1peGVkPiB8IG51bGwgPSBwcmV2U3RhdGVbMV07XG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gbW91bnRNZW1vPFQ+KFxuICBuZXh0Q3JlYXRlOiAoKSA9PiBULFxuICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbik6IFQge1xuICBjb25zdCBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgY29uc3QgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgY29uc3QgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW88VD4oXG4gIG5leHRDcmVhdGU6ICgpID0+IFQsXG4gIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuKTogVCB7XG4gIGNvbnN0IGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgY29uc3QgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgY29uc3QgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gQXNzdW1lIHRoZXNlIGFyZSBkZWZpbmVkLiBJZiB0aGV5J3JlIG5vdCwgYXJlSG9va0lucHV0c0VxdWFsIHdpbGwgd2Fybi5cbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZXZEZXBzOiBBcnJheTxtaXhlZD4gfCBudWxsID0gcHJldlN0YXRlWzFdO1xuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG4vLyBpbiBhIHRlc3QtbGlrZSBlbnZpcm9ubWVudCwgd2Ugd2FudCB0byB3YXJuIGlmIGRpc3BhdGNoQWN0aW9uKClcbi8vIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgYmF0Y2hlZFVwZGF0ZXMvVGVzdFV0aWxzLmFjdCguLi4pIGNhbGwuXG5sZXQgc2hvdWxkV2FybkZvclVuYmF0Y2hlZFNldFN0YXRlID0gZmFsc2U7XG5cbmlmIChfX0RFVl9fKSB7XG4gIC8vIGplc3QgaXNuJ3QgYSAnZ2xvYmFsJywgaXQncyBqdXN0IGV4cG9zZWQgdG8gdGVzdHMgdmlhIGEgd3JhcHBlZCBmdW5jdGlvblxuICAvLyBmdXJ0aGVyLCB0aGlzIGlzbid0IGEgdGVzdCBmaWxlLCBzbyBmbG93IGRvZXNuJ3QgcmVjb2duaXplIHRoZSBzeW1ib2wuIFNvLi4uXG4gIC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIGJlY2F1c2UgcmVxdWlyZW1lbnRzIGRvbid0IGdpdmUgYSBkYW1uIGFib3V0IHlvdXIgdHlwZSBzaWdzLlxuICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBqZXN0KSB7XG4gICAgc2hvdWxkV2FybkZvclVuYmF0Y2hlZFNldFN0YXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbjxTLCBBPihcbiAgZmliZXI6IEZpYmVyLFxuICBxdWV1ZTogVXBkYXRlUXVldWU8UywgQT4sXG4gIGFjdGlvbjogQSxcbikge1xuICBpbnZhcmlhbnQoXG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQsXG4gICAgJ1RvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCAnICtcbiAgICAgICdhbiBpbmZpbml0ZSBsb29wLicsXG4gICk7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA8PSAzLFxuICAgICAgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArXG4gICAgICAgICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICtcbiAgICAgICAgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmIChcbiAgICBmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIgfHxcbiAgICAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIpXG4gICkge1xuICAgIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuICAgIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgICAvLyBhbmQgYXBwbHkgdGhlIHN0YXNoZWQgdXBkYXRlcyBvbiB0b3Agb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICBjb25zdCB1cGRhdGU6IFVwZGF0ZTxTLCBBPiA9IHtcbiAgICAgIGV4cGlyYXRpb25UaW1lOiByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIGVhZ2VyUmVkdWNlcjogbnVsbCxcbiAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICBuZXh0OiBudWxsLFxuICAgIH07XG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG4gICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIGxldCBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgY29uc3QgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG5cbiAgICBjb25zdCB1cGRhdGU6IFVwZGF0ZTxTLCBBPiA9IHtcbiAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgYWN0aW9uLFxuICAgICAgZWFnZXJSZWR1Y2VyOiBudWxsLFxuICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgfTtcblxuICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgY29uc3QgbGFzdCA9IHF1ZXVlLmxhc3Q7XG4gICAgaWYgKGxhc3QgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXJzdCA9IGxhc3QubmV4dDtcbiAgICAgIGlmIChmaXJzdCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBTdGlsbCBjaXJjdWxhci5cbiAgICAgICAgdXBkYXRlLm5leHQgPSBmaXJzdDtcbiAgICAgIH1cbiAgICAgIGxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gICAgcXVldWUubGFzdCA9IHVwZGF0ZTtcblxuICAgIGlmIChcbiAgICAgIGZpYmVyLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgJiZcbiAgICAgIChhbHRlcm5hdGUgPT09IG51bGwgfHwgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmspXG4gICAgKSB7XG4gICAgICAvLyBUaGUgcXVldWUgaXMgY3VycmVudGx5IGVtcHR5LCB3aGljaCBtZWFucyB3ZSBjYW4gZWFnZXJseSBjb21wdXRlIHRoZVxuICAgICAgLy8gbmV4dCBzdGF0ZSBiZWZvcmUgZW50ZXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gSWYgdGhlIG5ldyBzdGF0ZSBpcyB0aGVcbiAgICAgIC8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgc3RhdGUsIHdlIG1heSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVudGlyZWx5LlxuICAgICAgY29uc3QgZWFnZXJSZWR1Y2VyID0gcXVldWUuZWFnZXJSZWR1Y2VyO1xuICAgICAgaWYgKGVhZ2VyUmVkdWNlciAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gICAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGU6IFMgPSAocXVldWUuZWFnZXJTdGF0ZTogYW55KTtcbiAgICAgICAgICBjb25zdCBlYWdlclN0YXRlID0gZWFnZXJSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAvLyBTdGFzaCB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZSwgYW5kIHRoZSByZWR1Y2VyIHVzZWQgdG8gY29tcHV0ZVxuICAgICAgICAgIC8vIGl0LCBvbiB0aGUgdXBkYXRlIG9iamVjdC4gSWYgdGhlIHJlZHVjZXIgaGFzbid0IGNoYW5nZWQgYnkgdGhlXG4gICAgICAgICAgLy8gdGltZSB3ZSBlbnRlciB0aGUgcmVuZGVyIHBoYXNlLCB0aGVuIHRoZSBlYWdlciBzdGF0ZSBjYW4gYmUgdXNlZFxuICAgICAgICAgIC8vIHdpdGhvdXQgY2FsbGluZyB0aGUgcmVkdWNlciBhZ2Fpbi5cbiAgICAgICAgICB1cGRhdGUuZWFnZXJSZWR1Y2VyID0gZWFnZXJSZWR1Y2VyO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoaXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAoc2hvdWxkV2FybkZvclVuYmF0Y2hlZFNldFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUJhdGNoaW5nSW5EZXYoZmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ29udGV4dE9ubHlEaXNwYXRjaGVyOiBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dCxcblxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbn07XG5cbmNvbnN0IEhvb2tzRGlzcGF0Y2hlck9uTW91bnQ6IERpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0LFxuXG4gIHVzZUNhbGxiYWNrOiBtb3VudENhbGxiYWNrLFxuICB1c2VDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlRWZmZWN0OiBtb3VudEVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbW91bnRJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VMYXlvdXRFZmZlY3Q6IG1vdW50TGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vOiBtb3VudE1lbW8sXG4gIHVzZVJlZHVjZXI6IG1vdW50UmVkdWNlcixcbiAgdXNlUmVmOiBtb3VudFJlZixcbiAgdXNlU3RhdGU6IG1vdW50U3RhdGUsXG4gIHVzZURlYnVnVmFsdWU6IG1vdW50RGVidWdWYWx1ZSxcbn07XG5cbmNvbnN0IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlOiBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dCxcblxuICB1c2VDYWxsYmFjazogdXBkYXRlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VFZmZlY3Q6IHVwZGF0ZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTGF5b3V0RWZmZWN0OiB1cGRhdGVMYXlvdXRFZmZlY3QsXG4gIHVzZU1lbW86IHVwZGF0ZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVwZGF0ZVJlZHVjZXIsXG4gIHVzZVJlZjogdXBkYXRlUmVmLFxuICB1c2VTdGF0ZTogdXBkYXRlU3RhdGUsXG4gIHVzZURlYnVnVmFsdWU6IHVwZGF0ZURlYnVnVmFsdWUsXG59O1xuXG5sZXQgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWOiBEaXNwYXRjaGVyIHwgbnVsbCA9IG51bGw7XG5sZXQgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjogRGlzcGF0Y2hlciB8IG51bGwgPSBudWxsO1xubGV0IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY6IERpc3BhdGNoZXIgfCBudWxsID0gbnVsbDtcbmxldCBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjogRGlzcGF0Y2hlciB8IG51bGwgPSBudWxsO1xuXG5pZiAoX19ERVZfXykge1xuICBjb25zdCB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MgPSAoKSA9PiB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgK1xuICAgICAgICAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArXG4gICAgICAgICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArXG4gICAgICAgICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicsXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB3YXJuSW52YWxpZEhvb2tBY2Nlc3MgPSAoKSA9PiB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArXG4gICAgICAgICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgK1xuICAgICAgICAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICtcbiAgICAgICAgJ2h0dHBzOi8vZmIubWUvcnVsZXMtb2YtaG9va3MnLFxuICAgICk7XG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0PFQ+KFxuICAgICAgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+LFxuICAgICAgb2JzZXJ2ZWRCaXRzOiB2b2lkIHwgbnVtYmVyIHwgYm9vbGVhbixcbiAgICApOiBUIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG5cbiAgICB1c2VDYWxsYmFjazxUPihjYWxsYmFjazogVCwgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwpOiBUIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ8VD4oXG4gICAgICBjb250ZXh0OiBSZWFjdENvbnRleHQ8VD4sXG4gICAgICBvYnNlcnZlZEJpdHM6IHZvaWQgfCBudW1iZXIgfCBib29sZWFuLFxuICAgICk6IFQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICByZXR1cm4gbW91bnRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3QoXG4gICAgICBjcmVhdGU6ICgpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWQsXG4gICAgICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbiAgICApOiB2b2lkIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU8VD4oXG4gICAgICByZWY6IHtjdXJyZW50OiBUIHwgbnVsbH0gfCAoKGluc3Q6IFQgfCBudWxsKSA9PiBtaXhlZCkgfCBudWxsIHwgdm9pZCxcbiAgICAgIGNyZWF0ZTogKCkgPT4gVCxcbiAgICAgIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuICAgICk6IHZvaWQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdChcbiAgICAgIGNyZWF0ZTogKCkgPT4gKCgpID0+IHZvaWQpIHwgdm9pZCxcbiAgICAgIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuICAgICk6IHZvaWQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzxUPihjcmVhdGU6ICgpID0+IFQsIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsKTogVCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIGNvbnN0IHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjxTLCBJLCBBPihcbiAgICAgIHJlZHVjZXI6IChTLCBBKSA9PiBTLFxuICAgICAgaW5pdGlhbEFyZzogSSxcbiAgICAgIGluaXQ/OiBJID0+IFMsXG4gICAgKTogW1MsIERpc3BhdGNoPEE+XSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIGNvbnN0IHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjxUPihpbml0aWFsVmFsdWU6IFQpOiB7Y3VycmVudDogVH0ge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU8Uz4oXG4gICAgICBpbml0aWFsU3RhdGU6ICgoKSA9PiBTKSB8IFMsXG4gICAgKTogW1MsIERpc3BhdGNoPEJhc2ljU3RhdGVBY3Rpb248Uz4+XSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICBjb25zdCBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlPFQ+KHZhbHVlOiBULCBmb3JtYXR0ZXJGbjogPyh2YWx1ZTogVCkgPT4gbWl4ZWQpOiB2b2lkIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICAgIH0sXG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDxUPihcbiAgICAgIGNvbnRleHQ6IFJlYWN0Q29udGV4dDxUPixcbiAgICAgIG9ic2VydmVkQml0czogdm9pZCB8IG51bWJlciB8IGJvb2xlYW4sXG4gICAgKTogVCB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuXG4gICAgdXNlQ2FsbGJhY2s8VD4oY2FsbGJhY2s6IFQsIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsKTogVCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDxUPihcbiAgICAgIGNvbnRleHQ6IFJlYWN0Q29udGV4dDxUPixcbiAgICAgIG9ic2VydmVkQml0czogdm9pZCB8IG51bWJlciB8IGJvb2xlYW4sXG4gICAgKTogVCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3QoXG4gICAgICBjcmVhdGU6ICgpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWQsXG4gICAgICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbiAgICApOiB2b2lkIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlPFQ+KFxuICAgICAgcmVmOiB7Y3VycmVudDogVCB8IG51bGx9IHwgKChpbnN0OiBUIHwgbnVsbCkgPT4gbWl4ZWQpIHwgbnVsbCB8IHZvaWQsXG4gICAgICBjcmVhdGU6ICgpID0+IFQsXG4gICAgICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbiAgICApOiB2b2lkIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0KFxuICAgICAgY3JlYXRlOiAoKSA9PiAoKCkgPT4gdm9pZCkgfCB2b2lkLFxuICAgICAgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwsXG4gICAgKTogdm9pZCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzxUPihjcmVhdGU6ICgpID0+IFQsIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsKTogVCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIGNvbnN0IHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyPFMsIEksIEE+KFxuICAgICAgcmVkdWNlcjogKFMsIEEpID0+IFMsXG4gICAgICBpbml0aWFsQXJnOiBJLFxuICAgICAgaW5pdD86IEkgPT4gUyxcbiAgICApOiBbUywgRGlzcGF0Y2g8QT5dIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgY29uc3QgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY8VD4oaW5pdGlhbFZhbHVlOiBUKToge2N1cnJlbnQ6IFR9IHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTxTPihcbiAgICAgIGluaXRpYWxTdGF0ZTogKCgpID0+IFMpIHwgUyxcbiAgICApOiBbUywgRGlzcGF0Y2g8QmFzaWNTdGF0ZUFjdGlvbjxTPj5dIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIGNvbnN0IHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTxUPih2YWx1ZTogVCwgZm9ybWF0dGVyRm46ID8odmFsdWU6IFQpID0+IG1peGVkKTogdm9pZCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gICAgfSxcbiAgfTtcblxuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0PFQ+KFxuICAgICAgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+LFxuICAgICAgb2JzZXJ2ZWRCaXRzOiB2b2lkIHwgbnVtYmVyIHwgYm9vbGVhbixcbiAgICApOiBUIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcblxuICAgIHVzZUNhbGxiYWNrPFQ+KGNhbGxiYWNrOiBULCBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCk6IFQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0PFQ+KFxuICAgICAgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+LFxuICAgICAgb2JzZXJ2ZWRCaXRzOiB2b2lkIHwgbnVtYmVyIHwgYm9vbGVhbixcbiAgICApOiBUIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gbW91bnRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3QoXG4gICAgICBjcmVhdGU6ICgpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWQsXG4gICAgICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbiAgICApOiB2b2lkIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTxUPihcbiAgICAgIHJlZjoge2N1cnJlbnQ6IFQgfCBudWxsfSB8ICgoaW5zdDogVCB8IG51bGwpID0+IG1peGVkKSB8IG51bGwgfCB2b2lkLFxuICAgICAgY3JlYXRlOiAoKSA9PiBULFxuICAgICAgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwsXG4gICAgKTogdm9pZCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3QoXG4gICAgICBjcmVhdGU6ICgpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWQsXG4gICAgICBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbiAgICApOiB2b2lkIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzxUPihjcmVhdGU6ICgpID0+IFQsIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsKTogVCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgY29uc3QgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyPFMsIEksIEE+KFxuICAgICAgcmVkdWNlcjogKFMsIEEpID0+IFMsXG4gICAgICBpbml0aWFsQXJnOiBJLFxuICAgICAgaW5pdD86IEkgPT4gUyxcbiAgICApOiBbUywgRGlzcGF0Y2g8QT5dIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBjb25zdCBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY8VD4oaW5pdGlhbFZhbHVlOiBUKToge2N1cnJlbnQ6IFR9IHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU8Uz4oXG4gICAgICBpbml0aWFsU3RhdGU6ICgoKSA9PiBTKSB8IFMsXG4gICAgKTogW1MsIERpc3BhdGNoPEJhc2ljU3RhdGVBY3Rpb248Uz4+XSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIGNvbnN0IHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU8VD4odmFsdWU6IFQsIGZvcm1hdHRlckZuOiA/KHZhbHVlOiBUKSA9PiBtaXhlZCk6IHZvaWQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICB9LFxuICB9O1xuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgIHJlYWRDb250ZXh0PFQ+KFxuICAgICAgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+LFxuICAgICAgb2JzZXJ2ZWRCaXRzOiB2b2lkIHwgbnVtYmVyIHwgYm9vbGVhbixcbiAgICApOiBUIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcblxuICAgIHVzZUNhbGxiYWNrPFQ+KGNhbGxiYWNrOiBULCBkZXBzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCk6IFQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDxUPihcbiAgICAgIGNvbnRleHQ6IFJlYWN0Q29udGV4dDxUPixcbiAgICAgIG9ic2VydmVkQml0czogdm9pZCB8IG51bWJlciB8IGJvb2xlYW4sXG4gICAgKTogVCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdChcbiAgICAgIGNyZWF0ZTogKCkgPT4gKCgpID0+IHZvaWQpIHwgdm9pZCxcbiAgICAgIGRlcHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuICAgICk6IHZvaWQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTxUPihcbiAgICAgIHJlZjoge2N1cnJlbnQ6IFQgfCBudWxsfSB8ICgoaW5zdDogVCB8IG51bGwpID0+IG1peGVkKSB8IG51bGwgfCB2b2lkLFxuICAgICAgY3JlYXRlOiAoKSA9PiBULFxuICAgICAgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwsXG4gICAgKTogdm9pZCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0KFxuICAgICAgY3JlYXRlOiAoKSA9PiAoKCkgPT4gdm9pZCkgfCB2b2lkLFxuICAgICAgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwsXG4gICAgKTogdm9pZCB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vPFQ+KGNyZWF0ZTogKCkgPT4gVCwgZGVwczogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwpOiBUIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBjb25zdCBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjxTLCBJLCBBPihcbiAgICAgIHJlZHVjZXI6IChTLCBBKSA9PiBTLFxuICAgICAgaW5pdGlhbEFyZzogSSxcbiAgICAgIGluaXQ/OiBJID0+IFMsXG4gICAgKTogW1MsIERpc3BhdGNoPEE+XSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgY29uc3QgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY8VD4oaW5pdGlhbFZhbHVlOiBUKToge2N1cnJlbnQ6IFR9IHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlPFM+KFxuICAgICAgaW5pdGlhbFN0YXRlOiAoKCkgPT4gUykgfCBTLFxuICAgICk6IFtTLCBEaXNwYXRjaDxCYXNpY1N0YXRlQWN0aW9uPFM+Pl0ge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBjb25zdCBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU8VD4odmFsdWU6IFQsIGZvcm1hdHRlckZuOiA/KHZhbHVlOiBUKSA9PiBtaXhlZCk6IHZvaWQge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gICAgfSxcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJIb29rcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgdHlwZSBIb29rRWZmZWN0VGFnID0gbnVtYmVyO1xuXG5leHBvcnQgY29uc3QgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAqLyAwYjAwMDAwMDAwO1xuZXhwb3J0IGNvbnN0IFVubW91bnRTbmFwc2hvdCA9IC8qICAgICAgKi8gMGIwMDAwMDAxMDtcbmV4cG9ydCBjb25zdCBVbm1vdW50TXV0YXRpb24gPSAvKiAgICAgICovIDBiMDAwMDAxMDA7XG5leHBvcnQgY29uc3QgTW91bnRNdXRhdGlvbiA9IC8qICAgICAgICAqLyAwYjAwMDAxMDAwO1xuZXhwb3J0IGNvbnN0IFVubW91bnRMYXlvdXQgPSAvKiAgICAgICAgKi8gMGIwMDAxMDAwMDtcbmV4cG9ydCBjb25zdCBNb3VudExheW91dCA9IC8qICAgICAgICAgICovIDBiMDAxMDAwMDA7XG5leHBvcnQgY29uc3QgTW91bnRQYXNzaXZlID0gLyogICAgICAgICAqLyAwYjAxMDAwMDAwO1xuZXhwb3J0IGNvbnN0IFVubW91bnRQYXNzaXZlID0gLyogICAgICAgKi8gMGIxMDAwMDAwMDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0SG9va0VmZmVjdFRhZ3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge1xuICBJbnN0YW5jZSxcbiAgVGV4dEluc3RhbmNlLFxuICBIeWRyYXRhYmxlSW5zdGFuY2UsXG4gIFN1c3BlbnNlSW5zdGFuY2UsXG4gIENvbnRhaW5lcixcbiAgSG9zdENvbnRleHQsXG59IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb25maWcnO1xuXG5pbXBvcnQge1xuICBIb3N0Q29tcG9uZW50LFxuICBIb3N0VGV4dCxcbiAgSG9zdFJvb3QsXG4gIFN1c3BlbnNlQ29tcG9uZW50LFxuICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCB7RGVsZXRpb24sIFBsYWNlbWVudH0gZnJvbSAnc2hhcmVkL1JlYWN0U2lkZUVmZmVjdFRhZ3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcblxuaW1wb3J0IHtjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcbmltcG9ydCB7XG4gIHNob3VsZFNldFRleHRDb250ZW50LFxuICBzdXBwb3J0c0h5ZHJhdGlvbixcbiAgY2FuSHlkcmF0ZUluc3RhbmNlLFxuICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlLFxuICBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSxcbiAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgaHlkcmF0ZUluc3RhbmNlLFxuICBoeWRyYXRlVGV4dEluc3RhbmNlLFxuICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlLFxuICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UsXG4gIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyU3VzcGVuc2VJbnN0YW5jZSxcbiAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UsXG4gIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZSxcbn0gZnJvbSAnLi9SZWFjdEZpYmVySG9zdENvbmZpZyc7XG5pbXBvcnQge2VuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXJ9IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5cbi8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuLy8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cbmxldCBoeWRyYXRpb25QYXJlbnRGaWJlcjogbnVsbCB8IEZpYmVyID0gbnVsbDtcbmxldCBuZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBudWxsIHwgSHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbmxldCBpc0h5ZHJhdGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyOiBGaWJlcik6IGJvb2xlYW4ge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKFxuICBmaWJlcjogRmliZXIsXG4pOiBib29sZWFuIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN1c3BlbnNlSW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoc3VzcGVuc2VJbnN0YW5jZSk7XG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoXG4gIHJldHVybkZpYmVyOiBGaWJlcixcbiAgaW5zdGFuY2U6IEh5ZHJhdGFibGVJbnN0YW5jZSxcbikge1xuICBpZiAoX19ERVZfXykge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UoXG4gICAgICAgICAgcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UoXG4gICAgICAgICAgcmV0dXJuRmliZXIudHlwZSxcbiAgICAgICAgICByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLFxuICAgICAgICAgIHJldHVybkZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gIGNoaWxkVG9EZWxldGUuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gIGNoaWxkVG9EZWxldGUucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgLy8gVGhpcyBtaWdodCBzZWVtIGxpa2UgaXQgYmVsb25ncyBvbiBwcm9ncmVzc2VkRmlyc3REZWxldGlvbi4gSG93ZXZlcixcbiAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAvLyBhZ2FpbiBhbmQgdGhlIG5vZGVzIGFyZSBzdGlsbCBpbiB0aGUgaG9zdCB0cmVlIHNvIHRoZXNlIHdpbGwgYmVcbiAgLy8gcmVjcmVhdGVkLlxuICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyOiBGaWJlciwgZmliZXI6IEZpYmVyKSB7XG4gIGZpYmVyLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAgICAgY29uc3QgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJTdXNwZW5zZUluc3RhbmNlKHBhcmVudENvbnRhaW5lcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgY29uc3QgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICAgICAgcGFyZW50UHJvcHMsXG4gICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgICAgICBwYXJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShcbiAgICAgICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICAgICAgcGFyZW50UHJvcHMsXG4gICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIGNvbnN0IHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgY29uc3QgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSAoaW5zdGFuY2U6IEluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6IHtcbiAgICAgIGNvbnN0IHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICBjb25zdCB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9ICh0ZXh0SW5zdGFuY2U6IFRleHRJbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OiB7XG4gICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICBjb25zdCBzdXNwZW5zZUluc3RhbmNlID0gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBEb3duZ3JhZGUgdGhlIHRhZyB0byBhIGRlaHlkcmF0ZWQgY29tcG9uZW50IHVudGlsIHdlJ3ZlIGh5ZHJhdGVkIGl0LlxuICAgICAgICAgIGZpYmVyLnRhZyA9IERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSAoc3VzcGVuc2VJbnN0YW5jZTogU3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoKGh5ZHJhdGlvblBhcmVudEZpYmVyOiBhbnkpLCBmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmaXJzdEF0dGVtcHRlZEluc3RhbmNlID0gbmV4dEluc3RhbmNlO1xuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoKGh5ZHJhdGlvblBhcmVudEZpYmVyOiBhbnkpLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgLy8gd2UnbGwgaGF2ZSB0byBzY2hlZHVsZSBhIGRlbGV0aW9uLiBUbyBkbyB0aGF0LCB0aGlzIG5vZGUgbmVlZHMgYSBkdW1teVxuICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoXG4gICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXI6IGFueSksXG4gICAgICBmaXJzdEF0dGVtcHRlZEluc3RhbmNlLFxuICAgICk7XG4gIH1cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKChuZXh0SW5zdGFuY2U6IGFueSkpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKFxuICBmaWJlcjogRmliZXIsXG4gIHJvb3RDb250YWluZXJJbnN0YW5jZTogQ29udGFpbmVyLFxuICBob3N0Q29udGV4dDogSG9zdENvbnRleHQsXG4pOiBib29sZWFuIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgK1xuICAgICAgICAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBpbnN0YW5jZTogSW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoXG4gICAgaW5zdGFuY2UsXG4gICAgZmliZXIudHlwZSxcbiAgICBmaWJlci5tZW1vaXplZFByb3BzLFxuICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICBob3N0Q29udGV4dCxcbiAgICBmaWJlcixcbiAgKTtcbiAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gKHVwZGF0ZVBheWxvYWQ6IGFueSk7XG4gIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyOiBGaWJlcik6IGJvb2xlYW4ge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgK1xuICAgICAgICAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICk7XG4gIH1cblxuICBjb25zdCB0ZXh0SW5zdGFuY2U6IFRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgY29uc3QgdGV4dENvbnRlbnQ6IHN0cmluZyA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gIGNvbnN0IHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICBpZiAoX19ERVZfXykge1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgICBjb25zdCByZXR1cm5GaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDoge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICBwYXJlbnRDb250YWluZXIsXG4gICAgICAgICAgICAgIHRleHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgIHBhcmVudFR5cGUsXG4gICAgICAgICAgICAgIHBhcmVudFByb3BzLFxuICAgICAgICAgICAgICBwYXJlbnRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgdGV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0V4cGVjdGVkIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgK1xuICAgICAgICAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICk7XG4gIH1cbiAgbGV0IHN1c3BlbnNlSW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIGludmFyaWFudChcbiAgICBzdXNwZW5zZUluc3RhbmNlLFxuICAgICdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgK1xuICAgICAgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgKTtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UoXG4gICAgc3VzcGVuc2VJbnN0YW5jZSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgbGV0IHBhcmVudCA9IGZpYmVyLnJldHVybjtcbiAgd2hpbGUgKFxuICAgIHBhcmVudCAhPT0gbnVsbCAmJlxuICAgIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiZcbiAgICBwYXJlbnQudGFnICE9PSBIb3N0Um9vdCAmJlxuICAgIHBhcmVudC50YWcgIT09IERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudFxuICApIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcjogRmliZXIpOiBib29sZWFuIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgIC8vIHRyZWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAvLyBzaWRlIG9mIHRoZW0uXG4gIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG4gIGlmIChcbiAgICBmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHxcbiAgICAodHlwZSAhPT0gJ2hlYWQnICYmXG4gICAgICB0eXBlICE9PSAnYm9keScgJiZcbiAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSlcbiAgKSB7XG4gICAgbGV0IG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlclxuICAgID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSlcbiAgICA6IG51bGw7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCk6IHZvaWQge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuZXhwb3J0IHtcbiAgZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICByZXNldEh5ZHJhdGlvblN0YXRlLFxuICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gIHBvcEh5ZHJhdGlvblN0YXRlLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcblxuaW1wb3J0IHtnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2R9IGZyb20gJy4vUmVhY3RDdXJyZW50RmliZXInO1xuXG5leHBvcnQgdHlwZSBDYXB0dXJlZFZhbHVlPFQ+ID0ge1xuICB2YWx1ZTogVCxcbiAgc291cmNlOiBGaWJlciB8IG51bGwsXG4gIHN0YWNrOiBzdHJpbmcgfCBudWxsLFxufTtcblxuZXhwb3J0IHR5cGUgQ2FwdHVyZWRFcnJvciA9IHtcbiAgY29tcG9uZW50TmFtZTogP3N0cmluZyxcbiAgY29tcG9uZW50U3RhY2s6IHN0cmluZyxcbiAgZXJyb3I6IG1peGVkLFxuICBlcnJvckJvdW5kYXJ5OiA/T2JqZWN0LFxuICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGJvb2xlYW4sXG4gIGVycm9yQm91bmRhcnlOYW1lOiBzdHJpbmcgfCBudWxsLFxuICB3aWxsUmV0cnk6IGJvb2xlYW4sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZTxUPihcbiAgdmFsdWU6IFQsXG4gIHNvdXJjZTogRmliZXIsXG4pOiBDYXB0dXJlZFZhbHVlPFQ+IHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpLFxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RDYXB0dXJlZFZhbHVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgSW5zdGFuY2UsXG4gIFRleHRJbnN0YW5jZSxcbiAgU3VzcGVuc2VJbnN0YW5jZSxcbiAgQ29udGFpbmVyLFxuICBDaGlsZFNldCxcbiAgVXBkYXRlUGF5bG9hZCxcbn0gZnJvbSAnLi9SZWFjdEZpYmVySG9zdENvbmZpZyc7XG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJy4vUmVhY3RGaWJlcic7XG5pbXBvcnQgdHlwZSB7RmliZXJSb290fSBmcm9tICcuL1JlYWN0RmliZXJSb290JztcbmltcG9ydCB0eXBlIHtFeHBpcmF0aW9uVGltZX0gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuaW1wb3J0IHR5cGUge0NhcHR1cmVkVmFsdWUsIENhcHR1cmVkRXJyb3J9IGZyb20gJy4vUmVhY3RDYXB0dXJlZFZhbHVlJztcbmltcG9ydCB0eXBlIHtTdXNwZW5zZVN0YXRlfSBmcm9tICcuL1JlYWN0RmliZXJTdXNwZW5zZUNvbXBvbmVudCc7XG5pbXBvcnQgdHlwZSB7RnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZX0gZnJvbSAnLi9SZWFjdEZpYmVySG9va3MnO1xuaW1wb3J0IHR5cGUge1RoZW5hYmxlfSBmcm9tICcuL1JlYWN0RmliZXJTY2hlZHVsZXInO1xuXG5pbXBvcnQge3Vuc3RhYmxlX3dyYXAgYXMgU2NoZWR1bGVfdHJhY2luZ193cmFwfSBmcm9tICdzY2hlZHVsZXIvdHJhY2luZyc7XG5pbXBvcnQge1xuICBlbmFibGVTY2hlZHVsZXJUcmFjaW5nLFxuICBlbmFibGVQcm9maWxlclRpbWVyLFxuICBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyLFxufSBmcm9tICdzaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MnO1xuaW1wb3J0IHtcbiAgRnVuY3Rpb25Db21wb25lbnQsXG4gIEZvcndhcmRSZWYsXG4gIENsYXNzQ29tcG9uZW50LFxuICBIb3N0Um9vdCxcbiAgSG9zdENvbXBvbmVudCxcbiAgSG9zdFRleHQsXG4gIEhvc3RQb3J0YWwsXG4gIFByb2ZpbGVyLFxuICBTdXNwZW5zZUNvbXBvbmVudCxcbiAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50LFxuICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQsXG4gIE1lbW9Db21wb25lbnQsXG4gIFNpbXBsZU1lbW9Db21wb25lbnQsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjayxcbiAgaGFzQ2F1Z2h0RXJyb3IsXG4gIGNsZWFyQ2F1Z2h0RXJyb3IsXG59IGZyb20gJ3NoYXJlZC9SZWFjdEVycm9yVXRpbHMnO1xuaW1wb3J0IHtcbiAgQ29udGVudFJlc2V0LFxuICBQbGFjZW1lbnQsXG4gIFNuYXBzaG90LFxuICBVcGRhdGUsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFNpZGVFZmZlY3RUYWdzJztcbmltcG9ydCBnZXRDb21wb25lbnROYW1lIGZyb20gJ3NoYXJlZC9nZXRDb21wb25lbnROYW1lJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbmltcG9ydCB7Tm9Xb3JrfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQge29uQ29tbWl0VW5tb3VudH0gZnJvbSAnLi9SZWFjdEZpYmVyRGV2VG9vbHNIb29rJztcbmltcG9ydCB7c3RhcnRQaGFzZVRpbWVyLCBzdG9wUGhhc2VUaW1lcn0gZnJvbSAnLi9SZWFjdERlYnVnRmliZXJQZXJmJztcbmltcG9ydCB7Z2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kfSBmcm9tICcuL1JlYWN0Q3VycmVudEZpYmVyJztcbmltcG9ydCB7bG9nQ2FwdHVyZWRFcnJvcn0gZnJvbSAnLi9SZWFjdEZpYmVyRXJyb3JMb2dnZXInO1xuaW1wb3J0IHtyZXNvbHZlRGVmYXVsdFByb3BzfSBmcm9tICcuL1JlYWN0RmliZXJMYXp5Q29tcG9uZW50JztcbmltcG9ydCB7Z2V0Q29tbWl0VGltZX0gZnJvbSAnLi9SZWFjdFByb2ZpbGVyVGltZXInO1xuaW1wb3J0IHtjb21taXRVcGRhdGVRdWV1ZX0gZnJvbSAnLi9SZWFjdFVwZGF0ZVF1ZXVlJztcbmltcG9ydCB7XG4gIGdldFB1YmxpY0luc3RhbmNlLFxuICBzdXBwb3J0c011dGF0aW9uLFxuICBzdXBwb3J0c1BlcnNpc3RlbmNlLFxuICBjb21taXRNb3VudCxcbiAgY29tbWl0VXBkYXRlLFxuICByZXNldFRleHRDb250ZW50LFxuICBjb21taXRUZXh0VXBkYXRlLFxuICBhcHBlbmRDaGlsZCxcbiAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgaW5zZXJ0QmVmb3JlLFxuICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQsXG4gIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcixcbiAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5LFxuICBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyLFxuICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICBoaWRlSW5zdGFuY2UsXG4gIGhpZGVUZXh0SW5zdGFuY2UsXG4gIHVuaGlkZUluc3RhbmNlLFxuICB1bmhpZGVUZXh0SW5zdGFuY2UsXG59IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb25maWcnO1xuaW1wb3J0IHtcbiAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IsXG4gIHJlcXVlc3RDdXJyZW50VGltZSxcbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5LFxufSBmcm9tICcuL1JlYWN0RmliZXJTY2hlZHVsZXInO1xuaW1wb3J0IHtcbiAgTm9FZmZlY3QgYXMgTm9Ib29rRWZmZWN0LFxuICBVbm1vdW50U25hcHNob3QsXG4gIFVubW91bnRNdXRhdGlvbixcbiAgTW91bnRNdXRhdGlvbixcbiAgVW5tb3VudExheW91dCxcbiAgTW91bnRMYXlvdXQsXG4gIFVubW91bnRQYXNzaXZlLFxuICBNb3VudFBhc3NpdmUsXG59IGZyb20gJy4vUmVhY3RIb29rRWZmZWN0VGFncyc7XG5pbXBvcnQge2RpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHN9IGZyb20gJy4vUmVhY3RGaWJlckJlZ2luV29yayc7XG5cbmxldCBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTogU2V0PG1peGVkPiB8IG51bGwgPSBudWxsO1xuaWYgKF9fREVWX18pIHtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59XG5cbmNvbnN0IFBvc3NpYmx5V2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nID8gV2Vha1NldCA6IFNldDtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0Vycm9yKGJvdW5kYXJ5OiBGaWJlciwgZXJyb3JJbmZvOiBDYXB0dXJlZFZhbHVlPG1peGVkPikge1xuICBjb25zdCBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICBsZXQgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gIGlmIChzdGFjayA9PT0gbnVsbCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICBzdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpO1xuICB9XG5cbiAgY29uc3QgY2FwdHVyZWRFcnJvcjogQ2FwdHVyZWRFcnJvciA9IHtcbiAgICBjb21wb25lbnROYW1lOiBzb3VyY2UgIT09IG51bGwgPyBnZXRDb21wb25lbnROYW1lKHNvdXJjZS50eXBlKSA6IG51bGwsXG4gICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJyxcbiAgICBlcnJvcjogZXJyb3JJbmZvLnZhbHVlLFxuICAgIGVycm9yQm91bmRhcnk6IG51bGwsXG4gICAgZXJyb3JCb3VuZGFyeU5hbWU6IG51bGwsXG4gICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBmYWxzZSxcbiAgICB3aWxsUmV0cnk6IGZhbHNlLFxuICB9O1xuXG4gIGlmIChib3VuZGFyeSAhPT0gbnVsbCAmJiBib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5ID0gYm91bmRhcnkuc3RhdGVOb2RlO1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lKGJvdW5kYXJ5LnR5cGUpO1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICBjYXB0dXJlZEVycm9yLndpbGxSZXRyeSA9IHRydWU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbihjdXJyZW50LCBpbnN0YW5jZSkge1xuICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gIGluc3RhbmNlLnByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbn07XG5cbi8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2soXG4gICAgICBudWxsLFxuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLFxuICAgICAgbnVsbCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBpbnN0YW5jZSxcbiAgICApO1xuICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICBjb25zdCB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyKGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICB9IGNhdGNoICh1bm1vdW50RXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50OiBGaWJlcikge1xuICBjb25zdCByZWYgPSBjdXJyZW50LnJlZjtcbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBjb25zdCByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVmKG51bGwpO1xuICAgICAgICB9IGNhdGNoIChyZWZFcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgZGVzdHJveSwgbnVsbCk7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgZXJyb3IpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICBmaW5pc2hlZFdvcms6IEZpYmVyLFxuKTogdm9pZCB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDoge1xuICAgICAgY29tbWl0SG9va0VmZmVjdExpc3QoVW5tb3VudFNuYXBzaG90LCBOb0hvb2tFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgU25hcHNob3QpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZScpO1xuICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICAgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICtcbiAgICAgICAgICAgICAgICAgICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAgICAgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArXG4gICAgICAgICAgICAgICAgICAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICAgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICtcbiAgICAgICAgICAgICAgICAgICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAgICAgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArXG4gICAgICAgICAgICAgICAgICAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZVxuICAgICAgICAgICAgICA/IHByZXZQcm9wc1xuICAgICAgICAgICAgICA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksXG4gICAgICAgICAgICBwcmV2U3RhdGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgY29uc3QgZGlkV2FyblNldCA9ICgoZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU6IGFueSk6IFNldDxcbiAgICAgICAgICAgICAgbWl4ZWQsXG4gICAgICAgICAgICA+KTtcbiAgICAgICAgICAgIGlmIChzbmFwc2hvdCA9PT0gdW5kZWZpbmVkICYmICFkaWRXYXJuU2V0LmhhcyhmaW5pc2hlZFdvcmsudHlwZSkpIHtcbiAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuICAgICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICtcbiAgICAgICAgICAgICAgICAgICdtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJyxcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDoge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgK1xuICAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3QoXG4gIHVubW91bnRUYWc6IG51bWJlcixcbiAgbW91bnRUYWc6IG51bWJlcixcbiAgZmluaXNoZWRXb3JrOiBGaWJlcixcbikge1xuICBjb25zdCB1cGRhdGVRdWV1ZTogRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSB8IG51bGwgPSAoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlOiBhbnkpO1xuICBsZXQgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgbGV0IGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIHVubW91bnRUYWcpICE9PSBOb0hvb2tFZmZlY3QpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICBjb25zdCBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG4gICAgICAgIGVmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiBtb3VudFRhZykgIT09IE5vSG9va0VmZmVjdCkge1xuICAgICAgICAvLyBNb3VudFxuICAgICAgICBjb25zdCBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgY29uc3QgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBhZGRlbmR1bTtcbiAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID1cbiAgICAgICAgICAgICAgICAnIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuICcgK1xuICAgICAgICAgICAgICAgICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9XG4gICAgICAgICAgICAgICAgJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlIHVzZUVmZmVjdChhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gJyArXG4gICAgICAgICAgICAgICAgJ0luc3RlYWQsIHlvdSBtYXkgd3JpdGUgYW4gYXN5bmMgZnVuY3Rpb24gc2VwYXJhdGVseSAnICtcbiAgICAgICAgICAgICAgICAnYW5kIHRoZW4gY2FsbCBpdCBmcm9tIGluc2lkZSB0aGUgZWZmZWN0OlxcblxcbicgK1xuICAgICAgICAgICAgICAgICdhc3luYyBmdW5jdGlvbiBmZXRjaENvbW1lbnQoY29tbWVudElkKSB7XFxuJyArXG4gICAgICAgICAgICAgICAgJyAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArXG4gICAgICAgICAgICAgICAgJ31cXG5cXG4nICtcbiAgICAgICAgICAgICAgICAndXNlRWZmZWN0KCgpID0+IHtcXG4nICtcbiAgICAgICAgICAgICAgICAnICBmZXRjaENvbW1lbnQoY29tbWVudElkKTtcXG4nICtcbiAgICAgICAgICAgICAgICAnfSwgW2NvbW1lbnRJZF0pO1xcblxcbicgK1xuICAgICAgICAgICAgICAgICdJbiB0aGUgZnV0dXJlLCBSZWFjdCB3aWxsIHByb3ZpZGUgYSBtb3JlIGlkaW9tYXRpYyBzb2x1dGlvbiBmb3IgZGF0YSBmZXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICBcInRoYXQgZG9lc24ndCBpbnZvbHZlIHdyaXRpbmcgZWZmZWN0cyBtYW51YWxseS5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQ6ICcgKyBkZXN0cm95O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdBbiBFZmZlY3QgZnVuY3Rpb24gbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgJyArXG4gICAgICAgICAgICAgICAgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJXMnLFxuICAgICAgICAgICAgICBhZGRlbmR1bSxcbiAgICAgICAgICAgICAgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVIb29rRWZmZWN0cyhmaW5pc2hlZFdvcms6IEZpYmVyKTogdm9pZCB7XG4gIGNvbW1pdEhvb2tFZmZlY3RMaXN0KFVubW91bnRQYXNzaXZlLCBOb0hvb2tFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gIGNvbW1pdEhvb2tFZmZlY3RMaXN0KE5vSG9va0VmZmVjdCwgTW91bnRQYXNzaXZlLCBmaW5pc2hlZFdvcmspO1xufVxuXG5mdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKFxuICBmaW5pc2hlZFJvb3Q6IEZpYmVyUm9vdCxcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICBmaW5pc2hlZFdvcms6IEZpYmVyLFxuICBjb21taXR0ZWRFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pOiB2b2lkIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OiB7XG4gICAgICBjb21taXRIb29rRWZmZWN0TGlzdChVbm1vdW50TGF5b3V0LCBNb3VudExheW91dCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG4gICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJlxuICAgICAgICAgICAgICAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wc1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgICAnY29tcG9uZW50RGlkTW91bnQuICcgK1xuICAgICAgICAgICAgICAgICAgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICAgICAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICtcbiAgICAgICAgICAgICAgICAgICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgICAnY29tcG9uZW50RGlkTW91bnQuICcgK1xuICAgICAgICAgICAgICAgICAgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICAgICAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICtcbiAgICAgICAgICAgICAgICAgICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcmV2UHJvcHMgPVxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZVxuICAgICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICAgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArXG4gICAgICAgICAgICAgICAgICAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgICAgICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgK1xuICAgICAgICAgICAgICAgICAgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAgICdjb21wb25lbnREaWRVcGRhdGUuICcgK1xuICAgICAgICAgICAgICAgICAgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICAgICAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICtcbiAgICAgICAgICAgICAgICAgICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShcbiAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgIHByZXZTdGF0ZSxcbiAgICAgICAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgK1xuICAgICAgICAgICAgICAgICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAgICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgK1xuICAgICAgICAgICAgICAgICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICtcbiAgICAgICAgICAgICAgICAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgICAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICBjb25zdCB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgIGNvbnN0IHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGNvbW1pdE1vdW50KGluc3RhbmNlLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OiB7XG4gICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6IHtcbiAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgUHJvZmlsZXI6IHtcbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgIGNvbnN0IG9uUmVuZGVyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMub25SZW5kZXI7XG5cbiAgICAgICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAgICAgICBvblJlbmRlcihcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLFxuICAgICAgICAgICAgY3VycmVudCA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSxcbiAgICAgICAgICAgIGdldENvbW1pdFRpbWUoKSxcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uUmVuZGVyKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsXG4gICAgICAgICAgICBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLFxuICAgICAgICAgICAgZ2V0Q29tbWl0VGltZSgpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgK1xuICAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbikge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgbGV0IG5vZGU6IEZpYmVyID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaGlkZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaGlkZVRleHRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKGluc3RhbmNlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiZcbiAgICAgICAgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgLy8gRm91bmQgYSBuZXN0ZWQgU3VzcGVuc2UgY29tcG9uZW50IHRoYXQgdGltZWQgb3V0LiBTa2lwIG92ZXIgdGhlXG4gICAgICAgIC8vIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQsIHdoaWNoIHNob3VsZCByZW1haW4gaGlkZGVuLlxuICAgICAgICBjb25zdCBmYWxsYmFja0NoaWxkRnJhZ21lbnQ6IEZpYmVyID0gKG5vZGUuY2hpbGQ6IGFueSkuc2libGluZztcbiAgICAgICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcms6IEZpYmVyKSB7XG4gIGNvbnN0IHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgbGV0IGluc3RhbmNlVG9Vc2U7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuICcgK1xuICAgICAgICAgICAgICAnVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJXMnLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSksXG4gICAgICAgICAgICBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQ6IEZpYmVyKSB7XG4gIGNvbnN0IGN1cnJlbnRSZWYgPSBjdXJyZW50LnJlZjtcbiAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbi8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG5mdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQ6IEZpYmVyKTogdm9pZCB7XG4gIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcblxuICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDoge1xuICAgICAgY29uc3QgdXBkYXRlUXVldWU6IEZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUgfCBudWxsID0gKGN1cnJlbnQudXBkYXRlUXVldWU6IGFueSk7XG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG4gICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgbGV0IGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc3Ryb3kgPSBlZmZlY3QuZGVzdHJveTtcbiAgICAgICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6IHtcbiAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgLy8gV2UgYXJlIGFsc28gbm90IHVzaW5nIHRoaXMgcGFyZW50IGJlY2F1c2VcbiAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290OiBGaWJlcik6IHZvaWQge1xuICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAvLyB3ZSBkbyBhbiBpbm5lciBsb29wIHdoaWxlIHdlJ3JlIHN0aWxsIGluc2lkZSB0aGUgaG9zdCBub2RlLlxuICBsZXQgbm9kZTogRmliZXIgPSByb290O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgLy8gU2tpcCBwb3J0YWxzIGJlY2F1c2UgY29tbWl0VW5tb3VudCgpIGN1cnJlbnRseSB2aXNpdHMgdGhlbSByZWN1cnNpdmVseS5cbiAgICBpZiAoXG4gICAgICBub2RlLmNoaWxkICE9PSBudWxsICYmXG4gICAgICAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgICAoIXN1cHBvcnRzTXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpXG4gICAgKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50OiBGaWJlcikge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICBjdXJyZW50LnJldHVybiA9IG51bGw7XG4gIGN1cnJlbnQuY2hpbGQgPSBudWxsO1xuICBjdXJyZW50Lm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICBjdXJyZW50LnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgY29uc3QgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUucmV0dXJuID0gbnVsbDtcbiAgICBhbHRlcm5hdGUuY2hpbGQgPSBudWxsO1xuICAgIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICBhbHRlcm5hdGUudXBkYXRlUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQ6IEZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBvcnRhbDoge2NvbnRhaW5lckluZm86IENvbnRhaW5lciwgcGVuZGluZ0NoaWxkcmVuOiBDaGlsZFNldH0gPVxuICAgIGN1cnJlbnQuc3RhdGVOb2RlO1xuICBjb25zdCB7Y29udGFpbmVySW5mb30gPSBwb3J0YWw7XG4gIGNvbnN0IGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrOiBGaWJlcikge1xuICBpZiAoIXN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OiB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OiB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOiB7XG4gICAgICBjb25zdCBwb3J0YWxPclJvb3Q6IHtcbiAgICAgICAgY29udGFpbmVySW5mbzogQ29udGFpbmVyLFxuICAgICAgICBwZW5kaW5nQ2hpbGRyZW46IENoaWxkU2V0LFxuICAgICAgfSA9XG4gICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBjb25zdCB7Y29udGFpbmVySW5mbywgcGVuZGluZ0NoaWxkcmVufSA9IHBvcnRhbE9yUm9vdDtcbiAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBwZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJyArXG4gICAgICAgICAgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXI6IEZpYmVyKTogRmliZXIge1xuICBsZXQgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArXG4gICAgICAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcjogRmliZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHxcbiAgICBmaWJlci50YWcgPT09IEhvc3RSb290IHx8XG4gICAgZmliZXIudGFnID09PSBIb3N0UG9ydGFsXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyOiBGaWJlcik6ID9JbnN0YW5jZSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbiAgbGV0IG5vZGU6IEZpYmVyID0gZmliZXI7XG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIHdoaWxlIChcbiAgICAgIG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmXG4gICAgICBub2RlLnRhZyAhPT0gSG9zdFRleHQgJiZcbiAgICAgIG5vZGUudGFnICE9PSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnRcbiAgICApIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG4gICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yazogRmliZXIpOiB2b2lkIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVjdXJzaXZlbHkgaW5zZXJ0IGFsbCBob3N0IG5vZGVzIGludG8gdGhlIHBhcmVudC5cbiAgY29uc3QgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcblxuICAvLyBOb3RlOiB0aGVzZSB0d28gdmFyaWFibGVzICptdXN0KiBhbHdheXMgYmUgdXBkYXRlZCB0b2dldGhlci5cbiAgbGV0IHBhcmVudDtcbiAgbGV0IGlzQ29udGFpbmVyO1xuXG4gIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArXG4gICAgICAgICAgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgfVxuICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgIHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmPSB+Q29udGVudFJlc2V0O1xuICB9XG5cbiAgY29uc3QgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIGxldCBub2RlOiBGaWJlciA9IGZpbmlzaGVkV29yaztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTogdm9pZCB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIGxldCBub2RlOiBGaWJlciA9IGN1cnJlbnQ7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgbGV0IGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG5cbiAgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG4gIGxldCBjdXJyZW50UGFyZW50O1xuICBsZXQgY3VycmVudFBhcmVudElzQ29udGFpbmVyO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgbGV0IHBhcmVudCA9IG5vZGUucmV0dXJuO1xuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHBhcmVudCAhPT0gbnVsbCxcbiAgICAgICAgICAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJyArXG4gICAgICAgICAgICAnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgICk7XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMobm9kZSk7XG4gICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG4gICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihcbiAgICAgICAgICAoKGN1cnJlbnRQYXJlbnQ6IGFueSk6IENvbnRhaW5lciksXG4gICAgICAgICAgKG5vZGUuc3RhdGVOb2RlOiBJbnN0YW5jZSB8IFRleHRJbnN0YW5jZSksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVDaGlsZChcbiAgICAgICAgICAoKGN1cnJlbnRQYXJlbnQ6IGFueSk6IEluc3RhbmNlKSxcbiAgICAgICAgICAobm9kZS5zdGF0ZU5vZGU6IEluc3RhbmNlIHwgVGV4dEluc3RhbmNlKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgJiZcbiAgICAgIG5vZGUudGFnID09PSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnRcbiAgICApIHtcbiAgICAgIC8vIERlbGV0ZSB0aGUgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBhbmQgYWxsIG9mIGl0cyBjb250ZW50LlxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKFxuICAgICAgICAgICgoY3VycmVudFBhcmVudDogYW55KTogQ29udGFpbmVyKSxcbiAgICAgICAgICAobm9kZS5zdGF0ZU5vZGU6IFN1c3BlbnNlSW5zdGFuY2UpLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICgoY3VycmVudFBhcmVudDogYW55KTogSW5zdGFuY2UpLFxuICAgICAgICAgIChub2RlLnN0YXRlTm9kZTogU3VzcGVuc2VJbnN0YW5jZSksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbihjdXJyZW50OiBGaWJlcik6IHZvaWQge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50KTtcbiAgfVxuICBkZXRhY2hGaWJlcihjdXJyZW50KTtcbn1cblxuZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50OiBGaWJlciB8IG51bGwsIGZpbmlzaGVkV29yazogRmliZXIpOiB2b2lkIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OiB7XG4gICAgICAgIC8vIE5vdGU6IFdlIGN1cnJlbnRseSBuZXZlciB1c2UgTW91bnRNdXRhdGlvbiwgYnV0IHVzZUxheW91dCB1c2VzXG4gICAgICAgIC8vIFVubW91bnRNdXRhdGlvbi5cbiAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3QoVW5tb3VudE11dGF0aW9uLCBNb3VudE11dGF0aW9uLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDoge1xuICAgICAgLy8gTm90ZTogV2UgY3VycmVudGx5IG5ldmVyIHVzZSBNb3VudE11dGF0aW9uLCBidXQgdXNlTGF5b3V0IHVzZXNcbiAgICAgIC8vIFVubW91bnRNdXRhdGlvbi5cbiAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0KFVubW91bnRNdXRhdGlvbiwgTW91bnRNdXRhdGlvbiwgZmluaXNoZWRXb3JrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDoge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgY29uc3QgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQ6IG51bGwgfCBVcGRhdGVQYXlsb2FkID0gKGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTogYW55KTtcbiAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRVcGRhdGUoXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6IHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAhPT0gbnVsbCxcbiAgICAgICAgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcgK1xuICAgICAgICAgICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICApO1xuICAgICAgY29uc3QgdGV4dEluc3RhbmNlOiBUZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgY29uc3QgbmV3VGV4dDogc3RyaW5nID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgIGNvbnN0IG9sZFRleHQ6IHN0cmluZyA9XG4gICAgICAgIGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgUHJvZmlsZXI6IHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDoge1xuICAgICAgbGV0IG5ld1N0YXRlOiBTdXNwZW5zZVN0YXRlIHwgbnVsbCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBsZXQgbmV3RGlkVGltZW91dDtcbiAgICAgIGxldCBwcmltYXJ5Q2hpbGRQYXJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICBpZiAobmV3U3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgbmV3RGlkVGltZW91dCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RGlkVGltZW91dCA9IHRydWU7XG4gICAgICAgIHByaW1hcnlDaGlsZFBhcmVudCA9IGZpbmlzaGVkV29yay5jaGlsZDtcbiAgICAgICAgaWYgKG5ld1N0YXRlLnRpbWVkT3V0QXQgPT09IE5vV29yaykge1xuICAgICAgICAgIC8vIElmIHRoZSBjaGlsZHJlbiBoYWQgbm90IGFscmVhZHkgdGltZWQgb3V0LCByZWNvcmQgdGhlIHRpbWUuXG4gICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlIGVsYXBzZWQgdGltZSBkdXJpbmcgc3Vic2VxdWVudFxuICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgbmV3U3RhdGUudGltZWRPdXRBdCA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmltYXJ5Q2hpbGRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4ocHJpbWFyeUNoaWxkUGFyZW50LCBuZXdEaWRUaW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBqdXN0IHRpbWVkIG91dCwgdGhlbiBpdCB3aWxsIGhhdmUgYSBzZXQgb2YgdGhlbmFibGVzLlxuICAgICAgLy8gRm9yIGVhY2ggdGhlbmFibGUsIGF0dGFjaCBhIGxpc3RlbmVyIHNvIHRoYXQgd2hlbiBpdCByZXNvbHZlcywgUmVhY3RcbiAgICAgIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgICAgIGNvbnN0IHRoZW5hYmxlczogU2V0PFRoZW5hYmxlPiB8IG51bGwgPSAoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlOiBhbnkpO1xuICAgICAgaWYgKHRoZW5hYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICBsZXQgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChyZXRyeUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhlbmFibGVzLmZvckVhY2godGhlbmFibGUgPT4ge1xuICAgICAgICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIGJvdW5kYXJ5IGZpYmVyIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICAgICAgICBsZXQgcmV0cnkgPSByZXRyeVRpbWVkT3V0Qm91bmRhcnkuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHRoZW5hYmxlKTtcbiAgICAgICAgICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgICAgICAgICAgcmV0cnkgPSBTY2hlZHVsZV90cmFjaW5nX3dyYXAocmV0cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHRoZW5hYmxlKSkge1xuICAgICAgICAgICAgcmV0cnlDYWNoZS5hZGQodGhlbmFibGUpO1xuICAgICAgICAgICAgdGhlbmFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgK1xuICAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50OiBGaWJlcikge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG59XG5cbmV4cG9ydCB7XG4gIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyxcbiAgY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgY29tbWl0UGxhY2VtZW50LFxuICBjb21taXREZWxldGlvbixcbiAgY29tbWl0V29yayxcbiAgY29tbWl0TGlmZUN5Y2xlcyxcbiAgY29tbWl0QXR0YWNoUmVmLFxuICBjb21taXREZXRhY2hSZWYsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckNvbW1pdFdvcmsuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgTUFUSF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG5jb25zdCBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuZXhwb3J0IGNvbnN0IE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0UsXG59O1xuXG4vLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShcbiAgcGFyZW50TmFtZXNwYWNlOiBzdHJpbmcgfCBudWxsLFxuICB0eXBlOiBzdHJpbmcsXG4pOiBzdHJpbmcge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxuICAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cbiAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0RPTU5hbWVzcGFjZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIHdoaXRlbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG5jb25zdCBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcblxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbicsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwb3NzaWJsZVN0YW5kYXJkTmFtZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9wb3NzaWJsZVN0YW5kYXJkTmFtZXMuanMiLCJpbXBvcnQgUmVhY3QsIHt1c2VTdGF0ZSwgdXNlckVmZmVjdH0gZnJvbSAnQHBhY2thZ2VzL3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdAcGFja2FnZXMvcmVhY3QtZG9tJztcblxuZnVuY3Rpb24gSG9va3MoKSB7XG4gIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoMClcblxuICByZXR1cm4gKDxkaXY+XG4gICAgICA8cD55b3UgaGF2ZSBjbGlja2VkIHtjb3VudH0gdGltZXM8L3A+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldENvdW50KGNvdW50ICsgMSl9PlxuICAgICAgICBDbGljayBtZVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+KVxufVxuXG5SZWFjdERPTS5yZW5kZXIoPEhvb2tzIC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi90ZXN0LWVudi9hcHAuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBSZWFjdFZlcnNpb24gZnJvbSAnc2hhcmVkL1JlYWN0VmVyc2lvbic7XG5pbXBvcnQge1xuICBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSxcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSxcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSxcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSxcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5cbmltcG9ydCB7Q29tcG9uZW50LCBQdXJlQ29tcG9uZW50fSBmcm9tICcuL1JlYWN0QmFzZUNsYXNzZXMnO1xuaW1wb3J0IHtjcmVhdGVSZWZ9IGZyb20gJy4vUmVhY3RDcmVhdGVSZWYnO1xuaW1wb3J0IHtmb3JFYWNoLCBtYXAsIGNvdW50LCB0b0FycmF5LCBvbmx5fSBmcm9tICcuL1JlYWN0Q2hpbGRyZW4nO1xuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRmFjdG9yeSxcbiAgY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudCxcbn0gZnJvbSAnLi9SZWFjdEVsZW1lbnQnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0fSBmcm9tICcuL1JlYWN0Q29udGV4dCc7XG5pbXBvcnQge2xhenl9IGZyb20gJy4vUmVhY3RMYXp5JztcbmltcG9ydCBmb3J3YXJkUmVmIGZyb20gJy4vZm9yd2FyZFJlZic7XG5pbXBvcnQgbWVtbyBmcm9tICcuL21lbW8nO1xuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlRGVidWdWYWx1ZSxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlLFxufSBmcm9tICcuL1JlYWN0SG9va3MnO1xuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24sXG4gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxufSBmcm9tICcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcic7XG5pbXBvcnQgUmVhY3RTaGFyZWRJbnRlcm5hbHMgZnJvbSAnLi9SZWFjdFNoYXJlZEludGVybmFscyc7XG5pbXBvcnQge2VuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJc30gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcblxuY29uc3QgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwLFxuICAgIGZvckVhY2gsXG4gICAgY291bnQsXG4gICAgdG9BcnJheSxcbiAgICBvbmx5LFxuICB9LFxuXG4gIGNyZWF0ZVJlZixcbiAgQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWYsXG4gIGxhenksXG4gIG1lbW8sXG5cbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlRGVidWdWYWx1ZSxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlLFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBTdHJpY3RNb2RlOiBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICBTdXNwZW5zZTogUkVBQ1RfU1VTUEVOU0VfVFlQRSxcblxuICBjcmVhdGVFbGVtZW50OiBfX0RFVl9fID8gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBfX0RFVl9fID8gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gOiBjbG9uZUVsZW1lbnQsXG4gIGNyZWF0ZUZhY3Rvcnk6IF9fREVWX18gPyBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gOiBjcmVhdGVGYWN0b3J5LFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIHVuc3RhYmxlX0NvbmN1cnJlbnRNb2RlOiBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSxcbiAgdW5zdGFibGVfUHJvZmlsZXI6IFJFQUNUX1BST0ZJTEVSX1RZUEUsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IFJlYWN0U2hhcmVkSW50ZXJuYWxzLFxufTtcblxuLy8gTm90ZTogc29tZSBBUElzIGFyZSBhZGRlZCB3aXRoIGZlYXR1cmUgZmxhZ3MuXG4vLyBNYWtlIHN1cmUgdGhhdCBzdGFibGUgYnVpbGRzIGZvciBvcGVuIHNvdXJjZVxuLy8gZG9uJ3QgbW9kaWZ5IHRoZSBSZWFjdCBvYmplY3QgdG8gYXZvaWQgZGVvcHRzLlxuLy8gQWxzbyBsZXQncyBub3QgZXhwb3NlIHRoZWlyIG5hbWVzIGluIHN0YWJsZSBidWlsZHMuXG5cbmlmIChlbmFibGVTdGFibGVDb25jdXJyZW50TW9kZUFQSXMpIHtcbiAgUmVhY3QuQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbiAgUmVhY3QuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBSZWFjdC51bnN0YWJsZV9Db25jdXJyZW50TW9kZSA9IHVuZGVmaW5lZDtcbiAgUmVhY3QudW5zdGFibGVfUHJvZmlsZXIgPSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuaW1wb3J0IGxvd1ByaW9yaXR5V2FybmluZyBmcm9tICdzaGFyZWQvbG93UHJpb3JpdHlXYXJuaW5nJztcblxuaW1wb3J0IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIGZyb20gJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnO1xuXG5jb25zdCBlbXB0eU9iamVjdCA9IHt9O1xuaWYgKF9fREVWX18pIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaW52YXJpYW50KFxuICAgIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8XG4gICAgICB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICBwYXJ0aWFsU3RhdGUgPT0gbnVsbCxcbiAgICAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICtcbiAgICAgICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJyxcbiAgKTtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKF9fREVWX18pIHtcbiAgY29uc3QgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbXG4gICAgICAnaXNNb3VudGVkJyxcbiAgICAgICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICtcbiAgICAgICAgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLicsXG4gICAgXSxcbiAgICByZXBsYWNlU3RhdGU6IFtcbiAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nLFxuICAgIF0sXG4gIH07XG4gIGNvbnN0IGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsXG4gICAgICAgICAgaW5mb1swXSxcbiAgICAgICAgICBpbmZvWzFdLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcbiAgZm9yIChjb25zdCBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmNvbnN0IHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSAoUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuT2JqZWN0LmFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5leHBvcnQge0NvbXBvbmVudCwgUHVyZUNvbXBvbmVudH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RCYXNlQ2xhc3Nlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHdhcm5pbmdXaXRob3V0U3RhY2sgZnJvbSAnc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2snO1xuXG5jb25zdCBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPVxuICAgICAgKGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSkgfHxcbiAgICAgICdSZWFjdENsYXNzJztcbiAgICBjb25zdCB3YXJuaW5nS2V5ID0gYCR7Y29tcG9uZW50TmFtZX0uJHtjYWxsZXJOYW1lfWA7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICBcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICtcbiAgICAgICAgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgK1xuICAgICAgICAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgK1xuICAgICAgICAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsXG4gICAgICBjYWxsZXJOYW1lLFxuICAgICAgY29tcG9uZW50TmFtZSxcbiAgICApO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuY29uc3QgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbihcbiAgICBwdWJsaWNJbnN0YW5jZSxcbiAgICBjb21wbGV0ZVN0YXRlLFxuICAgIGNhbGxiYWNrLFxuICAgIGNhbGxlck5hbWUsXG4gICkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24oXG4gICAgcHVibGljSW5zdGFuY2UsXG4gICAgcGFydGlhbFN0YXRlLFxuICAgIGNhbGxiYWNrLFxuICAgIGNhbGxlck5hbWUsXG4gICkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1JlZk9iamVjdH0gZnJvbSAnc2hhcmVkL1JlYWN0VHlwZXMnO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpOiBSZWZPYmplY3Qge1xuICBjb25zdCByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgfTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RDcmVhdGVSZWYuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5pbXBvcnQge1xuICBnZXRJdGVyYXRvckZuLFxuICBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gIFJFQUNUX1BPUlRBTF9UWVBFLFxufSBmcm9tICdzaGFyZWQvUmVhY3RTeW1ib2xzJztcbmltcG9ydCB7aXNWYWxpZEVsZW1lbnQsIGNsb25lQW5kUmVwbGFjZUtleX0gZnJvbSAnLi9SZWFjdEVsZW1lbnQnO1xuaW1wb3J0IFJlYWN0RGVidWdDdXJyZW50RnJhbWUgZnJvbSAnLi9SZWFjdERlYnVnQ3VycmVudEZyYW1lJztcblxuY29uc3QgU0VQQVJBVE9SID0gJy4nO1xuY29uc3QgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgY29uc3QgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICBjb25zdCBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MicsXG4gIH07XG4gIGNvbnN0IGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxubGV0IGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuY29uc3QgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuY29uc3QgUE9PTF9TSVpFID0gMTA7XG5jb25zdCB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoXG4gIG1hcFJlc3VsdCxcbiAga2V5UHJlZml4LFxuICBtYXBGdW5jdGlvbixcbiAgbWFwQ29udGV4dCxcbikge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICBjb25zdCB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMCxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICBjaGlsZHJlbixcbiAgbmFtZVNvRmFyLFxuICBjYWxsYmFjayxcbiAgdHJhdmVyc2VDb250ZXh0LFxuKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGxldCBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayhcbiAgICAgIHRyYXZlcnNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0ZhcixcbiAgICApO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgbGV0IGNoaWxkO1xuICBsZXQgbmV4dE5hbWU7XG4gIGxldCBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICBjb25zdCBuZXh0TmFtZVByZWZpeCA9XG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0TmFtZSxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIHRyYXZlcnNlQ29udGV4dCxcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzLFxuICAgICAgICAgICAgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgK1xuICAgICAgICAgICAgICAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArXG4gICAgICAgICAgICAgICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIGxldCBzdGVwO1xuICAgICAgbGV0IGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIG5leHROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIHRyYXZlcnNlQ29udGV4dCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGFkZGVuZHVtID1cbiAgICAgICAgICAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArXG4gICAgICAgICAgJ2luc3RlYWQuJyArXG4gICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLFxuICAgICAgICBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgICAgICAgICA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfSdcbiAgICAgICAgICA6IGNoaWxkcmVuU3RyaW5nLFxuICAgICAgICBhZGRlbmR1bSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKFxuICAgIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmXG4gICAgY29tcG9uZW50ICE9PSBudWxsICYmXG4gICAgY29tcG9uZW50LmtleSAhPSBudWxsXG4gICkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICBjb25zdCB7ZnVuYywgY29udGV4dH0gPSBib29rS2VlcGluZztcbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBjb25zdCB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoXG4gICAgbnVsbCxcbiAgICBudWxsLFxuICAgIGZvckVhY2hGdW5jLFxuICAgIGZvckVhY2hDb250ZXh0LFxuICApO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIGNvbnN0IHtyZXN1bHQsIGtleVByZWZpeCwgZnVuYywgY29udGV4dH0gPSBib29rS2VlcGluZztcblxuICBsZXQgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBjID0+IGMpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgbWFwcGVkQ2hpbGQsXG4gICAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBrZXlQcmVmaXggK1xuICAgICAgICAgIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSlcbiAgICAgICAgICAgID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLydcbiAgICAgICAgICAgIDogJycpICtcbiAgICAgICAgICBjaGlsZEtleSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIGxldCBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICBjb25zdCB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoXG4gICAgYXJyYXksXG4gICAgZXNjYXBlZFByZWZpeCxcbiAgICBmdW5jLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgKCkgPT4gbnVsbCwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGNoaWxkID0+IGNoaWxkKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGludmFyaWFudChcbiAgICBpc1ZhbGlkRWxlbWVudChjaGlsZHJlbiksXG4gICAgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicsXG4gICk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZXhwb3J0IHtcbiAgZm9yRWFjaENoaWxkcmVuIGFzIGZvckVhY2gsXG4gIG1hcENoaWxkcmVuIGFzIG1hcCxcbiAgY291bnRDaGlsZHJlbiBhcyBjb3VudCxcbiAgb25seUNoaWxkIGFzIG9ubHksXG4gIHRvQXJyYXksXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0Q2hpbGRyZW4uanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cblxuaW1wb3J0IHtlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmd9IGZyb20gJy4vU2NoZWR1bGVyRmVhdHVyZUZsYWdzJztcblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbi8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcbnZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7XG5cbi8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxudmFyIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7XG4vLyBFdmVudHVhbGx5IHRpbWVzIG91dFxudmFyIFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFkgPSAyNTA7XG52YXIgTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQgPSA1MDAwO1xudmFyIExPV19QUklPUklUWV9USU1FT1VUID0gMTAwMDA7XG4vLyBOZXZlciB0aW1lcyBvdXRcbnZhciBJRExFX1BSSU9SSVRZID0gbWF4U2lnbmVkMzFCaXRJbnQ7XG5cbi8vIENhbGxiYWNrcyBhcmUgc3RvcmVkIGFzIGEgY2lyY3VsYXIsIGRvdWJseSBsaW5rZWQgbGlzdC5cbnZhciBmaXJzdENhbGxiYWNrTm9kZSA9IG51bGw7XG5cbnZhciBjdXJyZW50RGlkVGltZW91dCA9IGZhbHNlO1xuLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxudmFyIGlzU2NoZWR1bGVyUGF1c2VkID0gZmFsc2U7XG5cbnZhciBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xudmFyIGN1cnJlbnRFdmVudFN0YXJ0VGltZSA9IC0xO1xudmFyIGN1cnJlbnRFeHBpcmF0aW9uVGltZSA9IC0xO1xuXG4vLyBUaGlzIGlzIHNldCB3aGVuIGEgY2FsbGJhY2sgaXMgYmVpbmcgZXhlY3V0ZWQsIHRvIHByZXZlbnQgcmUtZW50cmFuY3kuXG52YXIgaXNFeGVjdXRpbmdDYWxsYmFjayA9IGZhbHNlO1xuXG52YXIgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxudmFyIGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93ID1cbiAgdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCgpIHtcbiAgaWYgKGlzRXhlY3V0aW5nQ2FsbGJhY2spIHtcbiAgICAvLyBEb24ndCBzY2hlZHVsZSB3b3JrIHlldDsgd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuICAgIHJldHVybjtcbiAgfVxuICAvLyBTY2hlZHVsZSB0aGUgaG9zdCBjYWxsYmFjayB1c2luZyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiBpbiB0aGUgbGlzdC5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gZmlyc3RDYWxsYmFja05vZGUuZXhwaXJhdGlvblRpbWU7XG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FuY2VsIHRoZSBleGlzdGluZyBob3N0IGNhbGxiYWNrLlxuICAgIGNhbmNlbEhvc3RDYWxsYmFjaygpO1xuICB9XG4gIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrLCBleHBpcmF0aW9uVGltZSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoRmlyc3RDYWxsYmFjaygpIHtcbiAgdmFyIGZsdXNoZWROb2RlID0gZmlyc3RDYWxsYmFja05vZGU7XG5cbiAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGxpc3QgYmVmb3JlIGNhbGxpbmcgdGhlIGNhbGxiYWNrLiBUaGF0IHdheSB0aGVcbiAgLy8gbGlzdCBpcyBpbiBhIGNvbnNpc3RlbnQgc3RhdGUgZXZlbiBpZiB0aGUgY2FsbGJhY2sgdGhyb3dzLlxuICB2YXIgbmV4dCA9IGZpcnN0Q2FsbGJhY2tOb2RlLm5leHQ7XG4gIGlmIChmaXJzdENhbGxiYWNrTm9kZSA9PT0gbmV4dCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGxhc3QgY2FsbGJhY2sgaW4gdGhlIGxpc3QuXG4gICAgZmlyc3RDYWxsYmFja05vZGUgPSBudWxsO1xuICAgIG5leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYXN0Q2FsbGJhY2tOb2RlID0gZmlyc3RDYWxsYmFja05vZGUucHJldmlvdXM7XG4gICAgZmlyc3RDYWxsYmFja05vZGUgPSBsYXN0Q2FsbGJhY2tOb2RlLm5leHQgPSBuZXh0O1xuICAgIG5leHQucHJldmlvdXMgPSBsYXN0Q2FsbGJhY2tOb2RlO1xuICB9XG5cbiAgZmx1c2hlZE5vZGUubmV4dCA9IGZsdXNoZWROb2RlLnByZXZpb3VzID0gbnVsbDtcblxuICAvLyBOb3cgaXQncyBzYWZlIHRvIGNhbGwgdGhlIGNhbGxiYWNrLlxuICB2YXIgY2FsbGJhY2sgPSBmbHVzaGVkTm9kZS5jYWxsYmFjaztcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gZmx1c2hlZE5vZGUuZXhwaXJhdGlvblRpbWU7XG4gIHZhciBwcmlvcml0eUxldmVsID0gZmx1c2hlZE5vZGUucHJpb3JpdHlMZXZlbDtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uVGltZSA9IGN1cnJlbnRFeHBpcmF0aW9uVGltZTtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICBjdXJyZW50RXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICB0cnkge1xuICAgIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50RXhwaXJhdGlvblRpbWUgPSBwcmV2aW91c0V4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgLy8gQSBjYWxsYmFjayBtYXkgcmV0dXJuIGEgY29udGludWF0aW9uLiBUaGUgY29udGludWF0aW9uIHNob3VsZCBiZSBzY2hlZHVsZWRcbiAgLy8gd2l0aCB0aGUgc2FtZSBwcmlvcml0eSBhbmQgZXhwaXJhdGlvbiBhcyB0aGUganVzdC1maW5pc2hlZCBjYWxsYmFjay5cbiAgaWYgKHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBjb250aW51YXRpb25Ob2RlOiBDYWxsYmFja05vZGUgPSB7XG4gICAgICBjYWxsYmFjazogY29udGludWF0aW9uQ2FsbGJhY2ssXG4gICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAgcHJldmlvdXM6IG51bGwsXG4gICAgfTtcblxuICAgIC8vIEluc2VydCB0aGUgbmV3IGNhbGxiYWNrIGludG8gdGhlIGxpc3QsIHNvcnRlZCBieSBpdHMgZXhwaXJhdGlvbi4gVGhpcyBpc1xuICAgIC8vIGFsbW9zdCB0aGUgc2FtZSBhcyB0aGUgY29kZSBpbiBgc2NoZWR1bGVDYWxsYmFja2AsIGV4Y2VwdCB0aGUgY2FsbGJhY2tcbiAgICAvLyBpcyBpbnNlcnRlZCBpbnRvIHRoZSBsaXN0ICpiZWZvcmUqIGNhbGxiYWNrcyBvZiBlcXVhbCBleHBpcmF0aW9uIGluc3RlYWRcbiAgICAvLyBvZiBhZnRlci5cbiAgICBpZiAoZmlyc3RDYWxsYmFja05vZGUgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGNhbGxiYWNrIGluIHRoZSBsaXN0LlxuICAgICAgZmlyc3RDYWxsYmFja05vZGUgPSBjb250aW51YXRpb25Ob2RlLm5leHQgPSBjb250aW51YXRpb25Ob2RlLnByZXZpb3VzID0gY29udGludWF0aW9uTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRBZnRlckNvbnRpbnVhdGlvbiA9IG51bGw7XG4gICAgICB2YXIgbm9kZSA9IGZpcnN0Q2FsbGJhY2tOb2RlO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA+PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgZXhwaXJlcyBhdCBvciBhZnRlciB0aGUgY29udGludWF0aW9uLiBXZSB3aWxsIGluc2VydFxuICAgICAgICAgIC8vIHRoZSBjb250aW51YXRpb24gKmJlZm9yZSogdGhpcyBjYWxsYmFjay5cbiAgICAgICAgICBuZXh0QWZ0ZXJDb250aW51YXRpb24gPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICB9IHdoaWxlIChub2RlICE9PSBmaXJzdENhbGxiYWNrTm9kZSk7XG5cbiAgICAgIGlmIChuZXh0QWZ0ZXJDb250aW51YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgLy8gTm8gZXF1YWwgb3IgbG93ZXIgcHJpb3JpdHkgY2FsbGJhY2sgd2FzIGZvdW5kLCB3aGljaCBtZWFucyB0aGUgbmV3XG4gICAgICAgIC8vIGNhbGxiYWNrIGlzIHRoZSBsb3dlc3QgcHJpb3JpdHkgY2FsbGJhY2sgaW4gdGhlIGxpc3QuXG4gICAgICAgIG5leHRBZnRlckNvbnRpbnVhdGlvbiA9IGZpcnN0Q2FsbGJhY2tOb2RlO1xuICAgICAgfSBlbHNlIGlmIChuZXh0QWZ0ZXJDb250aW51YXRpb24gPT09IGZpcnN0Q2FsbGJhY2tOb2RlKSB7XG4gICAgICAgIC8vIFRoZSBuZXcgY2FsbGJhY2sgaXMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgY2FsbGJhY2sgaW4gdGhlIGxpc3QuXG4gICAgICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gY29udGludWF0aW9uTm9kZTtcbiAgICAgICAgZW5zdXJlSG9zdENhbGxiYWNrSXNTY2hlZHVsZWQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZpb3VzID0gbmV4dEFmdGVyQ29udGludWF0aW9uLnByZXZpb3VzO1xuICAgICAgcHJldmlvdXMubmV4dCA9IG5leHRBZnRlckNvbnRpbnVhdGlvbi5wcmV2aW91cyA9IGNvbnRpbnVhdGlvbk5vZGU7XG4gICAgICBjb250aW51YXRpb25Ob2RlLm5leHQgPSBuZXh0QWZ0ZXJDb250aW51YXRpb247XG4gICAgICBjb250aW51YXRpb25Ob2RlLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoSW1tZWRpYXRlV29yaygpIHtcbiAgaWYgKFxuICAgIC8vIENvbmZpcm0gd2UndmUgZXhpdGVkIHRoZSBvdXRlciBtb3N0IGV2ZW50IGhhbmRsZXJcbiAgICBjdXJyZW50RXZlbnRTdGFydFRpbWUgPT09IC0xICYmXG4gICAgZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwgJiZcbiAgICBmaXJzdENhbGxiYWNrTm9kZS5wcmlvcml0eUxldmVsID09PSBJbW1lZGlhdGVQcmlvcml0eVxuICApIHtcbiAgICBpc0V4ZWN1dGluZ0NhbGxiYWNrID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgZG8ge1xuICAgICAgICBmbHVzaEZpcnN0Q2FsbGJhY2soKTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICAvLyBLZWVwIGZsdXNoaW5nIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlIGltbWVkaWF0ZSBjYWxsYmFja3NcbiAgICAgICAgZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwgJiZcbiAgICAgICAgZmlyc3RDYWxsYmFja05vZGUucHJpb3JpdHlMZXZlbCA9PT0gSW1tZWRpYXRlUHJpb3JpdHlcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRXhlY3V0aW5nQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGlmIChmaXJzdENhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSdzIHN0aWxsIHdvcmsgcmVtYWluaW5nLiBSZXF1ZXN0IGFub3RoZXIgY2FsbGJhY2suXG4gICAgICAgIGVuc3VyZUhvc3RDYWxsYmFja0lzU2NoZWR1bGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoZGlkVGltZW91dCkge1xuICAvLyBFeGl0IHJpZ2h0IGF3YXkgaWYgd2UncmUgY3VycmVudGx5IHBhdXNlZFxuXG4gIGlmIChlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgJiYgaXNTY2hlZHVsZXJQYXVzZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpc0V4ZWN1dGluZ0NhbGxiYWNrID0gdHJ1ZTtcbiAgY29uc3QgcHJldmlvdXNEaWRUaW1lb3V0ID0gY3VycmVudERpZFRpbWVvdXQ7XG4gIGN1cnJlbnREaWRUaW1lb3V0ID0gZGlkVGltZW91dDtcbiAgdHJ5IHtcbiAgICBpZiAoZGlkVGltZW91dCkge1xuICAgICAgLy8gRmx1c2ggYWxsIHRoZSBleHBpcmVkIGNhbGxiYWNrcyB3aXRob3V0IHlpZWxkaW5nLlxuICAgICAgd2hpbGUgKFxuICAgICAgICBmaXJzdENhbGxiYWNrTm9kZSAhPT0gbnVsbCAmJlxuICAgICAgICAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyAmJiBpc1NjaGVkdWxlclBhdXNlZClcbiAgICAgICkge1xuICAgICAgICAvLyBUT0RPIFdyYXAgaW4gZmVhdHVyZSBmbGFnXG4gICAgICAgIC8vIFJlYWQgdGhlIGN1cnJlbnQgdGltZS4gRmx1c2ggYWxsIHRoZSBjYWxsYmFja3MgdGhhdCBleHBpcmUgYXQgb3JcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoYXQgdGltZS4gVGhlbiByZWFkIHRoZSBjdXJyZW50IHRpbWUgYWdhaW4gYW5kIHJlcGVhdC5cbiAgICAgICAgLy8gVGhpcyBvcHRpbWl6ZXMgZm9yIGFzIGZldyBwZXJmb3JtYW5jZS5ub3cgY2FsbHMgYXMgcG9zc2libGUuXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgICAgIGlmIChmaXJzdENhbGxiYWNrTm9kZS5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGZsdXNoRmlyc3RDYWxsYmFjaygpO1xuICAgICAgICAgIH0gd2hpbGUgKFxuICAgICAgICAgICAgZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGZpcnN0Q2FsbGJhY2tOb2RlLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgICAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyAmJiBpc1NjaGVkdWxlclBhdXNlZClcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIGZsdXNoaW5nIGNhbGxiYWNrcyB1bnRpbCB3ZSBydW4gb3V0IG9mIHRpbWUgaW4gdGhlIGZyYW1lLlxuICAgICAgaWYgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nICYmIGlzU2NoZWR1bGVyUGF1c2VkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hGaXJzdENhbGxiYWNrKCk7XG4gICAgICAgIH0gd2hpbGUgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsICYmICFzaG91bGRZaWVsZFRvSG9zdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaXNFeGVjdXRpbmdDYWxsYmFjayA9IGZhbHNlO1xuICAgIGN1cnJlbnREaWRUaW1lb3V0ID0gcHJldmlvdXNEaWRUaW1lb3V0O1xuICAgIGlmIChmaXJzdENhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB3b3JrIHJlbWFpbmluZy4gUmVxdWVzdCBhbm90aGVyIGNhbGxiYWNrLlxuICAgICAgZW5zdXJlSG9zdENhbGxiYWNrSXNTY2hlZHVsZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQmVmb3JlIGV4aXRpbmcsIGZsdXNoIGFsbCB0aGUgaW1tZWRpYXRlIHdvcmsgdGhhdCB3YXMgc2NoZWR1bGVkLlxuICAgIGZsdXNoSW1tZWRpYXRlV29yaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHZhciBwcmV2aW91c0V2ZW50U3RhcnRUaW1lID0gY3VycmVudEV2ZW50U3RhcnRUaW1lO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRFdmVudFN0YXJ0VGltZSA9IGdldEN1cnJlbnRUaW1lKCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudEV2ZW50U3RhcnRUaW1lID0gcHJldmlvdXNFdmVudFN0YXJ0VGltZTtcblxuICAgIC8vIEJlZm9yZSBleGl0aW5nLCBmbHVzaCBhbGwgdGhlIGltbWVkaWF0ZSB3b3JrIHRoYXQgd2FzIHNjaGVkdWxlZC5cbiAgICBmbHVzaEltbWVkaWF0ZVdvcmsoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuICBsZXQgcHJpb3JpdHlMZXZlbDtcbiAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgLy8gU2hpZnQgZG93biB0byBub3JtYWwgcHJpb3JpdHlcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHZhciBwcmV2aW91c0V2ZW50U3RhcnRUaW1lID0gY3VycmVudEV2ZW50U3RhcnRUaW1lO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRFdmVudFN0YXJ0VGltZSA9IGdldEN1cnJlbnRUaW1lKCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudEV2ZW50U3RhcnRUaW1lID0gcHJldmlvdXNFdmVudFN0YXJ0VGltZTtcblxuICAgIC8vIEJlZm9yZSBleGl0aW5nLCBmbHVzaCBhbGwgdGhlIGltbWVkaWF0ZSB3b3JrIHRoYXQgd2FzIHNjaGVkdWxlZC5cbiAgICBmbHVzaEltbWVkaWF0ZVdvcmsoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIHZhciBwcmV2aW91c0V2ZW50U3RhcnRUaW1lID0gY3VycmVudEV2ZW50U3RhcnRUaW1lO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50RXZlbnRTdGFydFRpbWUgPSBnZXRDdXJyZW50VGltZSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRFdmVudFN0YXJ0VGltZSA9IHByZXZpb3VzRXZlbnRTdGFydFRpbWU7XG4gICAgICBmbHVzaEltbWVkaWF0ZVdvcmsoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHJlY2F0ZWRfb3B0aW9ucykge1xuICB2YXIgc3RhcnRUaW1lID1cbiAgICBjdXJyZW50RXZlbnRTdGFydFRpbWUgIT09IC0xID8gY3VycmVudEV2ZW50U3RhcnRUaW1lIDogZ2V0Q3VycmVudFRpbWUoKTtcblxuICB2YXIgZXhwaXJhdGlvblRpbWU7XG4gIGlmIChcbiAgICB0eXBlb2YgZGVwcmVjYXRlZF9vcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgIGRlcHJlY2F0ZWRfb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiBkZXByZWNhdGVkX29wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcidcbiAgKSB7XG4gICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGJyYW5jaCBvbmNlIHdlIGxpZnQgZXhwaXJhdGlvbiB0aW1lcyBvdXQgb2YgUmVhY3QuXG4gICAgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyBkZXByZWNhdGVkX29wdGlvbnMudGltZW91dDtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgVVNFUl9CTE9DS0lOR19QUklPUklUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyBJRExFX1BSSU9SSVRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgTE9XX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld05vZGUgPSB7XG4gICAgY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogY3VycmVudFByaW9yaXR5TGV2ZWwsXG4gICAgZXhwaXJhdGlvblRpbWUsXG4gICAgbmV4dDogbnVsbCxcbiAgICBwcmV2aW91czogbnVsbCxcbiAgfTtcblxuICAvLyBJbnNlcnQgdGhlIG5ldyBjYWxsYmFjayBpbnRvIHRoZSBsaXN0LCBvcmRlcmVkIGZpcnN0IGJ5IGV4cGlyYXRpb24sIHRoZW5cbiAgLy8gYnkgaW5zZXJ0aW9uLiBTbyB0aGUgbmV3IGNhbGxiYWNrIGlzIGluc2VydGVkIGFueSBvdGhlciBjYWxsYmFjayB3aXRoXG4gIC8vIGVxdWFsIGV4cGlyYXRpb24uXG4gIGlmIChmaXJzdENhbGxiYWNrTm9kZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGNhbGxiYWNrIGluIHRoZSBsaXN0LlxuICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbmV3Tm9kZS5uZXh0ID0gbmV3Tm9kZS5wcmV2aW91cyA9IG5ld05vZGU7XG4gICAgZW5zdXJlSG9zdENhbGxiYWNrSXNTY2hlZHVsZWQoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaXJzdENhbGxiYWNrTm9kZTtcbiAgICBkbyB7XG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFRoZSBuZXcgY2FsbGJhY2sgZXhwaXJlcyBiZWZvcmUgdGhpcyBvbmUuXG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gZmlyc3RDYWxsYmFja05vZGUpO1xuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIE5vIGNhbGxiYWNrIHdpdGggYSBsYXRlciBleHBpcmF0aW9uIHdhcyBmb3VuZCwgd2hpY2ggbWVhbnMgdGhlIG5ld1xuICAgICAgLy8gY2FsbGJhY2sgaGFzIHRoZSBsYXRlc3QgZXhwaXJhdGlvbiBpbiB0aGUgbGlzdC5cbiAgICAgIG5leHQgPSBmaXJzdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IGZpcnN0Q2FsbGJhY2tOb2RlKSB7XG4gICAgICAvLyBUaGUgbmV3IGNhbGxiYWNrIGhhcyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiBpbiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICBmaXJzdENhbGxiYWNrTm9kZSA9IG5ld05vZGU7XG4gICAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCgpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IG5leHQucHJldmlvdXM7XG4gICAgcHJldmlvdXMubmV4dCA9IG5leHQucHJldmlvdXMgPSBuZXdOb2RlO1xuICAgIG5ld05vZGUubmV4dCA9IG5leHQ7XG4gICAgbmV3Tm9kZS5wcmV2aW91cyA9IHByZXZpb3VzO1xuICB9XG5cbiAgcmV0dXJuIG5ld05vZGU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uKCkge1xuICBpc1NjaGVkdWxlclBhdXNlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuICBpc1NjaGVkdWxlclBhdXNlZCA9IGZhbHNlO1xuICBpZiAoZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gZmlyc3RDYWxsYmFja05vZGU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSkge1xuICB2YXIgbmV4dCA9IGNhbGxiYWNrTm9kZS5uZXh0O1xuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIEFscmVhZHkgY2FuY2VsbGVkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSBjYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHNjaGVkdWxlZCBjYWxsYmFjay4gQ2xlYXIgdGhlIGxpc3QuXG4gICAgZmlyc3RDYWxsYmFja05vZGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBpdHMgcG9zaXRpb24gaW4gdGhlIGxpc3QuXG4gICAgaWYgKGNhbGxiYWNrTm9kZSA9PT0gZmlyc3RDYWxsYmFja05vZGUpIHtcbiAgICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbmV4dDtcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzID0gY2FsbGJhY2tOb2RlLnByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgfVxuXG4gIGNhbGxiYWNrTm9kZS5uZXh0ID0gY2FsbGJhY2tOb2RlLnByZXZpb3VzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc2hvdWxkWWllbGQoKSB7XG4gIHJldHVybiAoXG4gICAgIWN1cnJlbnREaWRUaW1lb3V0ICYmXG4gICAgKChmaXJzdENhbGxiYWNrTm9kZSAhPT0gbnVsbCAmJlxuICAgICAgZmlyc3RDYWxsYmFja05vZGUuZXhwaXJhdGlvblRpbWUgPCBjdXJyZW50RXhwaXJhdGlvblRpbWUpIHx8XG4gICAgICBzaG91bGRZaWVsZFRvSG9zdCgpKVxuICApO1xufVxuXG4vLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgZXNzZW50aWFsbHkgYSBwb2x5ZmlsbCBmb3IgcmVxdWVzdElkbGVDYWxsYmFjay4gSXRcbi8vIHdvcmtzIGJ5IHNjaGVkdWxpbmcgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydFxuLy8gb2YgdGhlIGZyYW1lLCB0aGVuIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC5cbi8vIFdpdGhpbiB0aGUgcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lXG4vLyByYXRlLiBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbi8vIFdlIGNhcHR1cmUgYSBsb2NhbCByZWZlcmVuY2UgdG8gYW55IGdsb2JhbCwgaW4gY2FzZSBpdCBnZXRzIHBvbHlmaWxsZWQgYWZ0ZXJcbi8vIHRoaXMgbW9kdWxlIGlzIGluaXRpYWxseSBldmFsdWF0ZWQuIFdlIHdhbnQgdG8gYmUgdXNpbmcgYVxuLy8gY29uc2lzdGVudCBpbXBsZW1lbnRhdGlvbi5cbnZhciBsb2NhbERhdGUgPSBEYXRlO1xuXG4vLyBUaGlzIGluaXRpYWxpemF0aW9uIGNvZGUgbWF5IHJ1biBldmVuIG9uIHNlcnZlciBlbnZpcm9ubWVudHMgaWYgYSBjb21wb25lbnRcbi8vIGp1c3QgaW1wb3J0cyBSZWFjdERPTSAoZS5nLiBmb3IgZmluZERPTU5vZGUpLiBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3Rcbi8vIGhhdmUgc2V0VGltZW91dCBvciBjbGVhclRpbWVvdXQuIEhvd2V2ZXIsIHdlIGFsd2F5cyBleHBlY3QgdGhlbSB0byBiZSBkZWZpbmVkXG4vLyBvbiB0aGUgY2xpZW50LiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzA4OFxudmFyIGxvY2FsU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9XG4gIHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWQ7XG5cbi8vIFdlIGRvbid0IGV4cGVjdCBlaXRoZXIgb2YgdGhlc2UgdG8gbmVjZXNzYXJpbHkgYmUgZGVmaW5lZCwgYnV0IHdlIHdpbGwgZXJyb3Jcbi8vIGxhdGVyIGlmIHRoZXkgYXJlIG1pc3Npbmcgb24gdGhlIGNsaWVudC5cbnZhciBsb2NhbFJlcXVlc3RBbmltYXRpb25GcmFtZSA9XG4gIHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbidcbiAgICA/IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIDogdW5kZWZpbmVkO1xudmFyIGxvY2FsQ2FuY2VsQW5pbWF0aW9uRnJhbWUgPVxuICB0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicgPyBjYW5jZWxBbmltYXRpb25GcmFtZSA6IHVuZGVmaW5lZDtcblxudmFyIGdldEN1cnJlbnRUaW1lO1xuXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZG9lcyBub3QgcnVuIHdoZW4gdGhlIHRhYiBpcyBpbiB0aGUgYmFja2dyb3VuZC4gSWZcbi8vIHdlJ3JlIGJhY2tncm91bmRlZCB3ZSBwcmVmZXIgZm9yIHRoYXQgd29yayB0byBoYXBwZW4gc28gdGhhdCB0aGUgcGFnZVxuLy8gY29udGludWVzIHRvIGxvYWQgaW4gdGhlIGJhY2tncm91bmQuIFNvIHdlIGFsc28gc2NoZWR1bGUgYSAnc2V0VGltZW91dCcgYXNcbi8vIGEgZmFsbGJhY2suXG4vLyBUT0RPOiBOZWVkIGEgYmV0dGVyIGhldXJpc3RpYyBmb3IgYmFja2dyb3VuZGVkIHdvcmsuXG52YXIgQU5JTUFUSU9OX0ZSQU1FX1RJTUVPVVQgPSAxMDA7XG52YXIgckFGSUQ7XG52YXIgckFGVGltZW91dElEO1xudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZVdpdGhUaW1lb3V0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgLy8gc2NoZWR1bGUgckFGIGFuZCBhbHNvIGEgc2V0VGltZW91dFxuICByQUZJRCA9IGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIC8vIGNhbmNlbCB0aGUgc2V0VGltZW91dFxuICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHJBRlRpbWVvdXRJRCk7XG4gICAgY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgfSk7XG4gIHJBRlRpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAvLyBjYW5jZWwgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIGxvY2FsQ2FuY2VsQW5pbWF0aW9uRnJhbWUockFGSUQpO1xuICAgIGNhbGxiYWNrKGdldEN1cnJlbnRUaW1lKCkpO1xuICB9LCBBTklNQVRJT05fRlJBTUVfVElNRU9VVCk7XG59O1xuXG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gIGdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpO1xuICB9O1xufVxuXG52YXIgcmVxdWVzdEhvc3RDYWxsYmFjaztcbnZhciBjYW5jZWxIb3N0Q2FsbGJhY2s7XG52YXIgc2hvdWxkWWllbGRUb0hvc3Q7XG5cbnZhciBnbG9iYWxWYWx1ZSA9IG51bGw7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsVmFsdWUgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbFZhbHVlID0gZ2xvYmFsO1xufVxuXG5pZiAoZ2xvYmFsVmFsdWUgJiYgZ2xvYmFsVmFsdWUuX3NjaGVkTW9jaykge1xuICAvLyBEeW5hbWljIGluamVjdGlvbiwgb25seSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgdmFyIGdsb2JhbEltcGwgPSBnbG9iYWxWYWx1ZS5fc2NoZWRNb2NrO1xuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZ2xvYmFsSW1wbFswXTtcbiAgY2FuY2VsSG9zdENhbGxiYWNrID0gZ2xvYmFsSW1wbFsxXTtcbiAgc2hvdWxkWWllbGRUb0hvc3QgPSBnbG9iYWxJbXBsWzJdO1xuICBnZXRDdXJyZW50VGltZSA9IGdsb2JhbEltcGxbM107XG59IGVsc2UgaWYgKFxuICAvLyBJZiBTY2hlZHVsZXIgcnVucyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGl0IGZhbGxzIGJhY2sgdG8gYSBuYWl2ZVxuICAvLyBpbXBsZW1lbnRhdGlvbiB1c2luZyBzZXRUaW1lb3V0LlxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fFxuICAvLyBDaGVjayBpZiBNZXNzYWdlQ2hhbm5lbCBpcyBzdXBwb3J0ZWQsIHRvby5cbiAgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAnZnVuY3Rpb24nXG4pIHtcbiAgLy8gSWYgdGhpcyBhY2NpZGVudGFsbHkgZ2V0cyBpbXBvcnRlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LCBlLmcuIEphdmFTY3JpcHRDb3JlLFxuICAvLyBmYWxsYmFjayB0byBhIG5haXZlIGltcGxlbWVudGF0aW9uLlxuICB2YXIgX2NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIF9mbHVzaENhbGxiYWNrID0gZnVuY3Rpb24oZGlkVGltZW91dCkge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIF9jYWxsYmFjayhkaWRUaW1lb3V0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9jYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24oY2IsIG1zKSB7XG4gICAgaWYgKF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHJlLWVudHJhbmN5LlxuICAgICAgc2V0VGltZW91dChyZXF1ZXN0SG9zdENhbGxiYWNrLCAwLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9jYWxsYmFjayA9IGNiO1xuICAgICAgc2V0VGltZW91dChfZmx1c2hDYWxsYmFjaywgMCwgZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgY2FuY2VsSG9zdENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgX2NhbGxiYWNrID0gbnVsbDtcbiAgfTtcbiAgc2hvdWxkWWllbGRUb0hvc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59IGVsc2Uge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIGZiLm1lIGxpbmtcbiAgICBpZiAodHlwZW9mIGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBcIiArXG4gICAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArXG4gICAgICAgICAgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxvY2FsQ2FuY2VsQW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gXCIgK1xuICAgICAgICAgICdNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgK1xuICAgICAgICAgICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzTWVzc2FnZUV2ZW50U2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB0aW1lb3V0VGltZSA9IC0xO1xuXG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGlzRmx1c2hpbmdIb3N0Q2FsbGJhY2sgPSBmYWxzZTtcblxuICB2YXIgZnJhbWVEZWFkbGluZSA9IDA7XG4gIC8vIFdlIHN0YXJ0IG91dCBhc3N1bWluZyB0aGF0IHdlIHJ1biBhdCAzMGZwcyBidXQgdGhlbiB0aGUgaGV1cmlzdGljIHRyYWNraW5nXG4gIC8vIHdpbGwgYWRqdXN0IHRoaXMgdmFsdWUgdG8gYSBmYXN0ZXIgZnBzIGlmIHdlIGdldCBtb3JlIGZyZXF1ZW50IGFuaW1hdGlvblxuICAvLyBmcmFtZXMuXG4gIHZhciBwcmV2aW91c0ZyYW1lVGltZSA9IDMzO1xuICB2YXIgYWN0aXZlRnJhbWVUaW1lID0gMzM7XG5cbiAgc2hvdWxkWWllbGRUb0hvc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnJhbWVEZWFkbGluZSA8PSBnZXRDdXJyZW50VGltZSgpO1xuICB9O1xuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpc01lc3NhZ2VFdmVudFNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHByZXZTY2hlZHVsZWRDYWxsYmFjayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjaztcbiAgICB2YXIgcHJldlRpbWVvdXRUaW1lID0gdGltZW91dFRpbWU7XG4gICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICB0aW1lb3V0VGltZSA9IC0xO1xuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgIHZhciBkaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgaWYgKGZyYW1lRGVhZGxpbmUgLSBjdXJyZW50VGltZSA8PSAwKSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdCBpbiB0aGlzIGlkbGUgcGVyaW9kLiBDaGVjayBpZiB0aGUgY2FsbGJhY2sgaGFzXG4gICAgICAvLyBhIHRpbWVvdXQgYW5kIHdoZXRoZXIgaXQncyBiZWVuIGV4Y2VlZGVkLlxuICAgICAgaWYgKHByZXZUaW1lb3V0VGltZSAhPT0gLTEgJiYgcHJldlRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBkaWRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIHRpbWVvdXQuXG4gICAgICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFub3RoZXIgYW5pbWF0aW9uIGNhbGxiYWNrIHNvIHdlIHJldHJ5IGxhdGVyLlxuICAgICAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZVdpdGhUaW1lb3V0KGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IHByZXZTY2hlZHVsZWRDYWxsYmFjaztcbiAgICAgICAgdGltZW91dFRpbWUgPSBwcmV2VGltZW91dFRpbWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldlNjaGVkdWxlZENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBpc0ZsdXNoaW5nSG9zdENhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByZXZTY2hlZHVsZWRDYWxsYmFjayhkaWRUaW1lb3V0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzRmx1c2hpbmdIb3N0Q2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbihyYWZUaW1lKSB7XG4gICAgaWYgKHNjaGVkdWxlZEhvc3RDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gRWFnZXJseSBzY2hlZHVsZSB0aGUgbmV4dCBhbmltYXRpb24gY2FsbGJhY2sgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgICAgIC8vIGZyYW1lLiBJZiB0aGUgc2NoZWR1bGVyIHF1ZXVlIGlzIG5vdCBlbXB0eSBhdCB0aGUgZW5kIG9mIHRoZSBmcmFtZSwgaXRcbiAgICAgIC8vIHdpbGwgY29udGludWUgZmx1c2hpbmcgaW5zaWRlIHRoYXQgY2FsbGJhY2suIElmIHRoZSBxdWV1ZSAqaXMqIGVtcHR5LFxuICAgICAgLy8gdGhlbiBpdCB3aWxsIGV4aXQgaW1tZWRpYXRlbHkuIFBvc3RpbmcgdGhlIGNhbGxiYWNrIGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgIC8vIGZyYW1lIGVuc3VyZXMgaXQncyBmaXJlZCB3aXRoaW4gdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGZyYW1lLiBJZiB3ZVxuICAgICAgLy8gd2FpdGVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIGZyYW1lIHRvIHBvc3QgdGhlIGNhbGxiYWNrLCB3ZSByaXNrIHRoZVxuICAgICAgLy8gYnJvd3NlciBza2lwcGluZyBhIGZyYW1lIGFuZCBub3QgZmlyaW5nIHRoZSBjYWxsYmFjayB1bnRpbCB0aGUgZnJhbWVcbiAgICAgIC8vIGFmdGVyIHRoYXQuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVXaXRoVGltZW91dChhbmltYXRpb25UaWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gcGVuZGluZyB3b3JrLiBFeGl0LlxuICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0RnJhbWVUaW1lID0gcmFmVGltZSAtIGZyYW1lRGVhZGxpbmUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKFxuICAgICAgbmV4dEZyYW1lVGltZSA8IGFjdGl2ZUZyYW1lVGltZSAmJlxuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWVcbiAgICApIHtcbiAgICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgOCkge1xuICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAvLyBJZiB0aGUgY2FsY3VsYXRlZCBmcmFtZSB0aW1lIGdldHMgbG93ZXIgdGhhbiA4LCBpdCBpcyBwcm9iYWJseSBhIGJ1Zy5cbiAgICAgICAgbmV4dEZyYW1lVGltZSA9IDg7XG4gICAgICB9XG4gICAgICAvLyBJZiBvbmUgZnJhbWUgZ29lcyBsb25nLCB0aGVuIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2hvcnQgdG8gY2F0Y2ggdXAuXG4gICAgICAvLyBJZiB0d28gZnJhbWVzIGFyZSBzaG9ydCBpbiBhIHJvdywgdGhlbiB0aGF0J3MgYW4gaW5kaWNhdGlvbiB0aGF0IHdlXG4gICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseSBvcHRpbWl6aW5nLlxuICAgICAgLy8gV2UgYWRqdXN0IG91ciBoZXVyaXN0aWMgZHluYW1pY2FsbHkgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiB3ZSdyZVxuICAgICAgLy8gcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlIgZGlzcGxheS5cbiAgICAgIC8vIFRha2UgdGhlIG1heCBvZiB0aGUgdHdvIGluIGNhc2Ugb25lIG9mIHRoZW0gd2FzIGFuIGFub21hbHkgZHVlIHRvXG4gICAgICAvLyBtaXNzZWQgZnJhbWUgZGVhZGxpbmVzLlxuICAgICAgYWN0aXZlRnJhbWVUaW1lID1cbiAgICAgICAgbmV4dEZyYW1lVGltZSA8IHByZXZpb3VzRnJhbWVUaW1lID8gcHJldmlvdXNGcmFtZVRpbWUgOiBuZXh0RnJhbWVUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWU7XG4gICAgfVxuICAgIGZyYW1lRGVhZGxpbmUgPSByYWZUaW1lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmICghaXNNZXNzYWdlRXZlbnRTY2hlZHVsZWQpIHtcbiAgICAgIGlzTWVzc2FnZUV2ZW50U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHBvcnQucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhYnNvbHV0ZVRpbWVvdXQpIHtcbiAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aW1lb3V0VGltZSA9IGFic29sdXRlVGltZW91dDtcbiAgICBpZiAoaXNGbHVzaGluZ0hvc3RDYWxsYmFjayB8fCBhYnNvbHV0ZVRpbWVvdXQgPCAwKSB7XG4gICAgICAvLyBEb24ndCB3YWl0IGZvciB0aGUgbmV4dCBmcmFtZS4gQ29udGludWUgd29ya2luZyBBU0FQLCBpbiBhIG5ldyBldmVudC5cbiAgICAgIHBvcnQucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAvLyBJZiByQUYgZGlkbid0IGFscmVhZHkgc2NoZWR1bGUgb25lLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgZnJhbWUuXG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIHJBRiBkb2Vzbid0IG1hdGVyaWFsaXplIGJlY2F1c2UgdGhlIGJyb3dzZXIgdGhyb3R0bGVzLCB3ZVxuICAgICAgLy8gbWlnaHQgd2FudCB0byBzdGlsbCBoYXZlIHNldFRpbWVvdXQgdHJpZ2dlciBySUMgYXMgYSBiYWNrdXAgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGtlZXAgcGVyZm9ybWluZyB3b3JrLlxuICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVXaXRoVGltZW91dChhbmltYXRpb25UaWNrKTtcbiAgICB9XG4gIH07XG5cbiAgY2FuY2VsSG9zdENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICBpc01lc3NhZ2VFdmVudFNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59XG5cbmV4cG9ydCB7XG4gIEltbWVkaWF0ZVByaW9yaXR5IGFzIHVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICBVc2VyQmxvY2tpbmdQcmlvcml0eSBhcyB1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgTm9ybWFsUHJpb3JpdHkgYXMgdW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gIElkbGVQcmlvcml0eSBhcyB1bnN0YWJsZV9JZGxlUHJpb3JpdHksXG4gIExvd1ByaW9yaXR5IGFzIHVuc3RhYmxlX0xvd1ByaW9yaXR5LFxuICB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksXG4gIHVuc3RhYmxlX25leHQsXG4gIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrLFxuICB1bnN0YWJsZV93cmFwQ2FsbGJhY2ssXG4gIHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLFxuICB1bnN0YWJsZV9zaG91bGRZaWVsZCxcbiAgdW5zdGFibGVfY29udGludWVFeGVjdXRpb24sXG4gIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uLFxuICB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSxcbiAgZ2V0Q3VycmVudFRpbWUgYXMgdW5zdGFibGVfbm93LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NjaGVkdWxlci9zcmMvU2NoZWR1bGVyLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmV4cG9ydCBjb25zdCBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NjaGVkdWxlci9zcmMvU2NoZWR1bGVyRmVhdHVyZUZsYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtJbnRlcmFjdGlvbiwgU3Vic2NyaWJlcn0gZnJvbSAnLi9UcmFjaW5nJztcblxuaW1wb3J0IHtlbmFibGVTY2hlZHVsZXJUcmFjaW5nfSBmcm9tICdzaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MnO1xuaW1wb3J0IHtfX3N1YnNjcmliZXJSZWZ9IGZyb20gJy4vVHJhY2luZyc7XG5cbmxldCBzdWJzY3JpYmVyczogU2V0PFN1YnNjcmliZXI+ID0gKG51bGw6IGFueSk7XG5pZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc3RhYmxlX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyKTogdm9pZCB7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHtcbiAgICAgIF9fc3Vic2NyaWJlclJlZi5jdXJyZW50ID0ge1xuICAgICAgICBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZCxcbiAgICAgICAgb25JbnRlcmFjdGlvblRyYWNlZCxcbiAgICAgICAgb25Xb3JrQ2FuY2VsZWQsXG4gICAgICAgIG9uV29ya1NjaGVkdWxlZCxcbiAgICAgICAgb25Xb3JrU3RhcnRlZCxcbiAgICAgICAgb25Xb3JrU3RvcHBlZCxcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0YWJsZV91bnN1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyKTogdm9pZCB7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgc3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgIF9fc3Vic2NyaWJlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbjogSW50ZXJhY3Rpb24pOiB2b2lkIHtcbiAgbGV0IGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uOiBJbnRlcmFjdGlvbik6IHZvaWQge1xuICBsZXQgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICBsZXQgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1NjaGVkdWxlZChcbiAgaW50ZXJhY3Rpb25zOiBTZXQ8SW50ZXJhY3Rpb24+LFxuICB0aHJlYWRJRDogbnVtYmVyLFxuKTogdm9pZCB7XG4gIGxldCBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIGxldCBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnM6IFNldDxJbnRlcmFjdGlvbj4sIHRocmVhZElEOiBudW1iZXIpOiB2b2lkIHtcbiAgbGV0IGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnM6IFNldDxJbnRlcmFjdGlvbj4sIHRocmVhZElEOiBudW1iZXIpOiB2b2lkIHtcbiAgbGV0IGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrQ2FuY2VsZWQoXG4gIGludGVyYWN0aW9uczogU2V0PEludGVyYWN0aW9uPixcbiAgdGhyZWFkSUQ6IG51bWJlcixcbik6IHZvaWQge1xuICBsZXQgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICBsZXQgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrQ2FuY2VsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NjaGVkdWxlci9zcmMvVHJhY2luZ1N1YnNjcmlwdGlvbnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtSRUFDVF9QUk9WSURFUl9UWVBFLCBSRUFDVF9DT05URVhUX1RZUEV9IGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuXG5pbXBvcnQgdHlwZSB7UmVhY3RDb250ZXh0fSBmcm9tICdzaGFyZWQvUmVhY3RUeXBlcyc7XG5cbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3NoYXJlZC93YXJuaW5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VD4oXG4gIGRlZmF1bHRWYWx1ZTogVCxcbiAgY2FsY3VsYXRlQ2hhbmdlZEJpdHM6ID8oYTogVCwgYjogVCkgPT4gbnVtYmVyLFxuKTogUmVhY3RDb250ZXh0PFQ+IHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAnY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgK1xuICAgICAgICAgICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLFxuICAgICAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29udGV4dDogUmVhY3RDb250ZXh0PFQ+ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiAobnVsbDogYW55KSxcbiAgICBDb25zdW1lcjogKG51bGw6IGFueSksXG4gIH07XG5cbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgfTtcblxuICBsZXQgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgbGV0IGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgY29uc3QgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIH07XG4gICAgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICtcbiAgICAgICAgICAgICAgICAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgK1xuICAgICAgICAgICAgICAgICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBjb250ZXh0O1xuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RDb250ZXh0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7TGF6eUNvbXBvbmVudCwgVGhlbmFibGV9IGZyb20gJ3NoYXJlZC9SZWFjdExhenlDb21wb25lbnQnO1xuXG5pbXBvcnQge1JFQUNUX0xBWllfVFlQRX0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5PFQsIFI+KGN0b3I6ICgpID0+IFRoZW5hYmxlPFQsIFI+KTogTGF6eUNvbXBvbmVudDxUPiB7XG4gIGxldCBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9jdG9yOiBjdG9yLFxuICAgIC8vIFJlYWN0IHVzZXMgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogbnVsbCxcbiAgfTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICBsZXQgZGVmYXVsdFByb3BzO1xuICAgIGxldCBwcm9wVHlwZXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArXG4gICAgICAgICAgICAgICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nLFxuICAgICAgICAgICk7XG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzO1xuICAgICAgICAgIC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICtcbiAgICAgICAgICAgICAgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7XG4gICAgICAgICAgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RMYXp5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge1JFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIFJFQUNUX01FTU9fVFlQRX0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5cbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9yd2FyZFJlZjxQcm9wcywgRWxlbWVudFR5cGU6IFJlYWN0JEVsZW1lbnRUeXBlPihcbiAgcmVuZGVyOiAocHJvcHM6IFByb3BzLCByZWY6IFJlYWN0JFJlZjxFbGVtZW50VHlwZT4pID0+IFJlYWN0JE5vZGUsXG4pIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICtcbiAgICAgICAgICAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJyxcbiAgICAgICAgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcixcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIC8vIERvIG5vdCB3YXJuIGZvciAwIGFyZ3VtZW50cyBiZWNhdXNlIGl0IGNvdWxkIGJlIGR1ZSB0byB1c2FnZSBvZiB0aGUgJ2FyZ3VtZW50cycgb2JqZWN0XG4gICAgICAgIHJlbmRlci5sZW5ndGggPT09IDAgfHwgcmVuZGVyLmxlbmd0aCA9PT0gMixcbiAgICAgICAgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLFxuICAgICAgICByZW5kZXIubGVuZ3RoID09PSAxXG4gICAgICAgICAgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPydcbiAgICAgICAgICA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICByZW5kZXIuZGVmYXVsdFByb3BzID09IG51bGwgJiYgcmVuZGVyLnByb3BUeXBlcyA9PSBudWxsLFxuICAgICAgICAnZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgK1xuICAgICAgICAgICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyLFxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3Qvc3JjL2ZvcndhcmRSZWYuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7UkVBQ1RfTUVNT19UWVBFfSBmcm9tICdzaGFyZWQvUmVhY3RTeW1ib2xzJztcblxuaW1wb3J0IGlzVmFsaWRFbGVtZW50VHlwZSBmcm9tICdzaGFyZWQvaXNWYWxpZEVsZW1lbnRUeXBlJztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVtbzxQcm9wcz4oXG4gIHR5cGU6IFJlYWN0JEVsZW1lbnRUeXBlLFxuICBjb21wYXJlPzogKG9sZFByb3BzOiBQcm9wcywgbmV3UHJvcHM6IFByb3BzKSA9PiBib29sZWFuLFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkOiAlcycsXG4gICAgICAgIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlLFxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3Qvc3JjL21lbW8uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1JlYWN0Q29udGV4dH0gZnJvbSAnc2hhcmVkL1JlYWN0VHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3NoYXJlZC93YXJuaW5nJztcblxuaW1wb3J0IFJlYWN0Q3VycmVudERpc3BhdGNoZXIgZnJvbSAnLi9SZWFjdEN1cnJlbnREaXNwYXRjaGVyJztcblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIGNvbnN0IGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gIGludmFyaWFudChcbiAgICBkaXNwYXRjaGVyICE9PSBudWxsLFxuICAgICdIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiAnICtcbiAgICAgICcoaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhbGlkLWhvb2stY2FsbCknLFxuICApO1xuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQ8VD4oXG4gIENvbnRleHQ6IFJlYWN0Q29udGV4dDxUPixcbiAgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzOiBudW1iZXIgfCBib29sZWFuIHwgdm9pZCxcbikge1xuICBjb25zdCBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSB1bmRlZmluZWQsXG4gICAgICAndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgK1xuICAgICAgICAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgK1xuICAgICAgICAnWW91IHBhc3NlZDogJXMuJXMnLFxuICAgICAgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLFxuICAgICAgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pXG4gICAgICAgID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgK1xuICAgICAgICAgICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArXG4gICAgICAgICAgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9mYi5tZS9ydWxlcy1vZi1ob29rcydcbiAgICAgICAgOiAnJyxcbiAgICApO1xuXG4gICAgLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuICAgIGlmICgoQ29udGV4dDogYW55KS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZWFsQ29udGV4dCA9IChDb250ZXh0OiBhbnkpLl9jb250ZXh0O1xuICAgICAgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArXG4gICAgICAgICAgICAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/JyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgK1xuICAgICAgICAgICAgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxTPihpbml0aWFsU3RhdGU6ICgoKSA9PiBTKSB8IFMpIHtcbiAgY29uc3QgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyPFMsIEksIEE+KFxuICByZWR1Y2VyOiAoUywgQSkgPT4gUyxcbiAgaW5pdGlhbEFyZzogSSxcbiAgaW5pdD86IEkgPT4gUyxcbikge1xuICBjb25zdCBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZjxUPihpbml0aWFsVmFsdWU6IFQpOiB7Y3VycmVudDogVH0ge1xuICBjb25zdCBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFZmZlY3QoXG4gIGNyZWF0ZTogKCkgPT4gKCgpID0+IHZvaWQpIHwgdm9pZCxcbiAgaW5wdXRzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbikge1xuICBjb25zdCBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgaW5wdXRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChcbiAgY3JlYXRlOiAoKSA9PiAoKCkgPT4gdm9pZCkgfCB2b2lkLFxuICBpbnB1dHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuKSB7XG4gIGNvbnN0IGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsbGJhY2soXG4gIGNhbGxiYWNrOiAoKSA9PiBtaXhlZCxcbiAgaW5wdXRzOiBBcnJheTxtaXhlZD4gfCB2b2lkIHwgbnVsbCxcbikge1xuICBjb25zdCBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGlucHV0cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vKFxuICBjcmVhdGU6ICgpID0+IG1peGVkLFxuICBpbnB1dHM6IEFycmF5PG1peGVkPiB8IHZvaWQgfCBudWxsLFxuKSB7XG4gIGNvbnN0IGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgaW5wdXRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGU8VD4oXG4gIHJlZjoge2N1cnJlbnQ6IFQgfCBudWxsfSB8ICgoaW5zdDogVCB8IG51bGwpID0+IG1peGVkKSB8IG51bGwgfCB2b2lkLFxuICBjcmVhdGU6ICgpID0+IFQsXG4gIGlucHV0czogQXJyYXk8bWl4ZWQ+IHwgdm9pZCB8IG51bGwsXG4pOiB2b2lkIHtcbiAgY29uc3QgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGlucHV0cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlOiBhbnksIGZvcm1hdHRlckZuOiA/KHZhbHVlOiBhbnkpID0+IGFueSkge1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3Qvc3JjL1JlYWN0SG9va3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbmltcG9ydCBsb3dQcmlvcml0eVdhcm5pbmcgZnJvbSAnc2hhcmVkL2xvd1ByaW9yaXR5V2FybmluZyc7XG5pbXBvcnQgaXNWYWxpZEVsZW1lbnRUeXBlIGZyb20gJ3NoYXJlZC9pc1ZhbGlkRWxlbWVudFR5cGUnO1xuaW1wb3J0IGdldENvbXBvbmVudE5hbWUgZnJvbSAnc2hhcmVkL2dldENvbXBvbmVudE5hbWUnO1xuaW1wb3J0IHtcbiAgZ2V0SXRlcmF0b3JGbixcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgUkVBQ1RfTUVNT19UWVBFLFxuICBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBSRUFDVF9FTEVNRU5UX1RZUEUsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuaW1wb3J0IGNoZWNrUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnc2hhcmVkL3dhcm5pbmcnO1xuaW1wb3J0IHdhcm5pbmdXaXRob3V0U3RhY2sgZnJvbSAnc2hhcmVkL3dhcm5pbmdXaXRob3V0U3RhY2snO1xuXG5pbXBvcnQgUmVhY3RDdXJyZW50T3duZXIgZnJvbSAnLi9SZWFjdEN1cnJlbnRPd25lcic7XG5pbXBvcnQge2lzVmFsaWRFbGVtZW50LCBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnR9IGZyb20gJy4vUmVhY3RFbGVtZW50JztcbmltcG9ydCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLCB7XG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50LFxufSBmcm9tICcuL1JlYWN0RGVidWdDdXJyZW50RnJhbWUnO1xuXG5sZXQgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbmlmIChfX0RFVl9fKSB7XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChcbiAgICBlbGVtZW50UHJvcHMgIT09IG51bGwgJiZcbiAgICBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJlxuICAgIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGNvbnN0IHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICBjb25zdCBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgY29uc3QgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuY29uc3Qgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICBsZXQgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIGNvbnN0IHBhcmVudE5hbWUgPVxuICAgICAgdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcGFyZW50VHlwZVxuICAgICAgICA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gYFxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCR7cGFyZW50TmFtZX0+LmA7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIGNvbnN0IGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIGxldCBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChcbiAgICBlbGVtZW50ICYmXG4gICAgZWxlbWVudC5fb3duZXIgJiZcbiAgICBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudFxuICApIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gYCBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAke2dldENvbXBvbmVudE5hbWUoXG4gICAgICBlbGVtZW50Ll9vd25lci50eXBlLFxuICAgICl9LmA7XG4gIH1cblxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgK1xuICAgICAgICAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sXG4gICAgICBjaGlsZE93bmVyLFxuICAgICk7XG4gIH1cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgbGV0IHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgY29uc3QgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgbGV0IHByb3BUeXBlcztcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gIH0gZWxzZSBpZiAoXG4gICAgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgIC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKVxuICApIHtcbiAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb3BUeXBlcykge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgcHJvcFR5cGVzLFxuICAgICAgZWxlbWVudC5wcm9wcyxcbiAgICAgICdwcm9wJyxcbiAgICAgIG5hbWUsXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0sXG4gICAgKTtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JyxcbiAgICAgIG5hbWUgfHwgJ1Vua25vd24nLFxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICB0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCxcbiAgICAgICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICtcbiAgICAgICAgICAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLFxuICAgICAgICBrZXksXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuICB9XG5cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTtcblxuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIGxldCBpbmZvID0gJyc7XG4gICAgaWYgKFxuICAgICAgdHlwZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGUgIT09IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKVxuICAgICkge1xuICAgICAgaW5mbyArPVxuICAgICAgICAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgK1xuICAgICAgICBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgbGV0IHR5cGVTdHJpbmc7XG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBgPCR7Z2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJ30gLz5gO1xuICAgICAgaW5mbyA9XG4gICAgICAgICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgK1xuICAgICAgICAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICtcbiAgICAgICAgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJyxcbiAgICAgIHR5cGVTdHJpbmcsXG4gICAgICBpbmZvLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICBjb25zdCB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcbiAgaWYgKF9fREVWX18pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArXG4gICAgICAgICAgICAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nLFxuICAgICAgICApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICBjb25zdCBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAobGV0IGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgUmVhY3RET00gPSByZXF1aXJlKCcuL3NyYy9jbGllbnQvUmVhY3RET00nKTtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NLmRlZmF1bHQgfHwgUmVhY3RET007XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1JlYWN0Tm9kZUxpc3R9IGZyb20gJ3NoYXJlZC9SZWFjdFR5cGVzJztcbi8vIFRPRE86IFRoaXMgdHlwZSBpcyBzaGFyZWQgYmV0d2VlbiB0aGUgcmVjb25jaWxlciBhbmQgUmVhY3RET00sIGJ1dCB3aWxsXG4vLyBldmVudHVhbGx5IGJlIGxpZnRlZCBvdXQgdG8gdGhlIHJlbmRlcmVyLlxuaW1wb3J0IHR5cGUge1xuICBGaWJlclJvb3QsXG4gIEJhdGNoIGFzIEZpYmVyUm9vdEJhdGNoLFxufSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyUm9vdCc7XG5cbmltcG9ydCAnLi4vc2hhcmVkL2NoZWNrUmVhY3QnO1xuaW1wb3J0ICcuL1JlYWN0RE9NQ2xpZW50SW5qZWN0aW9uJztcblxuaW1wb3J0IHtcbiAgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbixcbiAgZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMsXG4gIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUsXG4gIGZsdXNoUm9vdCxcbiAgY3JlYXRlQ29udGFpbmVyLFxuICB1cGRhdGVDb250YWluZXIsXG4gIGJhdGNoZWRVcGRhdGVzLFxuICB1bmJhdGNoZWRVcGRhdGVzLFxuICBpbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzLFxuICBmbHVzaFN5bmMsXG4gIGZsdXNoQ29udHJvbGxlZCxcbiAgaW5qZWN0SW50b0RldlRvb2xzLFxuICBnZXRQdWJsaWNSb290SW5zdGFuY2UsXG4gIGZpbmRIb3N0SW5zdGFuY2UsXG4gIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyxcbn0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9pbmxpbmUuZG9tJztcbmltcG9ydCB7Y3JlYXRlUG9ydGFsIGFzIGNyZWF0ZVBvcnRhbEltcGx9IGZyb20gJ3NoYXJlZC9SZWFjdFBvcnRhbCc7XG5pbXBvcnQge2NhblVzZURPTX0gZnJvbSAnc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50JztcbmltcG9ydCB7c2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbn0gZnJvbSAnZXZlbnRzL1JlYWN0R2VuZXJpY0JhdGNoaW5nJztcbmltcG9ydCB7XG4gIHNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbixcbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSxcbiAgcmVzdG9yZVN0YXRlSWZOZWVkZWQsXG59IGZyb20gJ2V2ZW50cy9SZWFjdENvbnRyb2xsZWRDb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgaW5qZWN0aW9uIGFzIEV2ZW50UGx1Z2luSHViSW5qZWN0aW9uLFxuICBydW5FdmVudHNJbkJhdGNoLFxufSBmcm9tICdldmVudHMvRXZlbnRQbHVnaW5IdWInO1xuaW1wb3J0IHtldmVudE5hbWVEaXNwYXRjaENvbmZpZ3N9IGZyb20gJ2V2ZW50cy9FdmVudFBsdWdpblJlZ2lzdHJ5JztcbmltcG9ydCB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxufSBmcm9tICdldmVudHMvRXZlbnRQcm9wYWdhdG9ycyc7XG5pbXBvcnQge2hhcyBhcyBoYXNJbnN0YW5jZX0gZnJvbSAnc2hhcmVkL1JlYWN0SW5zdGFuY2VNYXAnO1xuaW1wb3J0IFJlYWN0VmVyc2lvbiBmcm9tICdzaGFyZWQvUmVhY3RWZXJzaW9uJztcbmltcG9ydCBSZWFjdFNoYXJlZEludGVybmFscyBmcm9tICdzaGFyZWQvUmVhY3RTaGFyZWRJbnRlcm5hbHMnO1xuaW1wb3J0IGdldENvbXBvbmVudE5hbWUgZnJvbSAnc2hhcmVkL2dldENvbXBvbmVudE5hbWUnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCBsb3dQcmlvcml0eVdhcm5pbmcgZnJvbSAnc2hhcmVkL2xvd1ByaW9yaXR5V2FybmluZyc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5pbXBvcnQge2VuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJc30gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcblxuaW1wb3J0IHtcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSxcbiAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG59IGZyb20gJy4vUmVhY3RET01Db21wb25lbnRUcmVlJztcbmltcG9ydCB7cmVzdG9yZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSAnLi9SZWFjdERPTUNvbXBvbmVudCc7XG5pbXBvcnQge2Rpc3BhdGNoRXZlbnR9IGZyb20gJy4uL2V2ZW50cy9SZWFjdERPTUV2ZW50TGlzdGVuZXInO1xuaW1wb3J0IHtcbiAgRUxFTUVOVF9OT0RFLFxuICBDT01NRU5UX05PREUsXG4gIERPQ1VNRU5UX05PREUsXG4gIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUsXG59IGZyb20gJy4uL3NoYXJlZC9IVE1MTm9kZVR5cGUnO1xuaW1wb3J0IHtST09UX0FUVFJJQlVURV9OQU1FfSBmcm9tICcuLi9zaGFyZWQvRE9NUHJvcGVydHknO1xuXG5jb25zdCBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXG5sZXQgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncztcbmxldCB3YXJuT25JbnZhbGlkQ2FsbGJhY2s7XG5sZXQgZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwgPSBmYWxzZTtcblxuaWYgKF9fREVWX18pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHxcbiAgICAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIE1hcCBoYXMgbm8gcHJvdG90eXBlXG4gICAgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8XG4gICAgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBTZXQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFNldCBoYXMgbm8gcHJvdG90eXBlXG4gICAgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8XG4gICAgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBmYWxzZSxcbiAgICAgICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgK1xuICAgICAgICAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzJyxcbiAgICApO1xuICB9XG5cbiAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IChjb250YWluZXI6IERPTUNvbnRhaW5lcikgPT4ge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgY29uc3QgaG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoXG4gICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLl9pbnRlcm5hbFJvb3QuY3VycmVudCxcbiAgICAgICk7XG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICAgaG9zdEluc3RhbmNlLnBhcmVudE5vZGUgPT09IGNvbnRhaW5lcixcbiAgICAgICAgICAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICtcbiAgICAgICAgICAgICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArXG4gICAgICAgICAgICAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICtcbiAgICAgICAgICAgICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCA9ICEhY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gICAgY29uc3Qgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgY29uc3QgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAhaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCxcbiAgICAgICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICtcbiAgICAgICAgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICtcbiAgICAgICAgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArXG4gICAgICAgICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicsXG4gICAgKTtcblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fFxuICAgICAgICAhKChjb250YWluZXI6IGFueSk6IEVsZW1lbnQpLnRhZ05hbWUgfHxcbiAgICAgICAgKChjb250YWluZXI6IGFueSk6IEVsZW1lbnQpLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLFxuICAgICAgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICtcbiAgICAgICAgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArXG4gICAgICAgICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArXG4gICAgICAgICdmb3IgeW91ciBhcHAuJyxcbiAgICApO1xuICB9O1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrOiBtaXhlZCwgY2FsbGVyTmFtZTogc3RyaW5nKSB7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArXG4gICAgICAgICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxcbiAgICAgIGNhbGxlck5hbWUsXG4gICAgICBjYWxsYmFjayxcbiAgICApO1xuICB9O1xufVxuXG5zZXRSZXN0b3JlSW1wbGVtZW50YXRpb24ocmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSk7XG5cbmV4cG9ydCB0eXBlIERPTUNvbnRhaW5lciA9XG4gIHwgKEVsZW1lbnQgJiB7XG4gICAgICBfcmVhY3RSb290Q29udGFpbmVyOiA/Um9vdCxcbiAgICAgIF9yZWFjdEhhc0JlZW5QYXNzZWRUb0NyZWF0ZVJvb3RERVY6ID9ib29sZWFuLFxuICAgIH0pXG4gIHwgKERvY3VtZW50ICYge1xuICAgICAgX3JlYWN0Um9vdENvbnRhaW5lcjogP1Jvb3QsXG4gICAgICBfcmVhY3RIYXNCZWVuUGFzc2VkVG9DcmVhdGVSb290REVWOiA/Ym9vbGVhbixcbiAgICB9KTtcblxudHlwZSBCYXRjaCA9IEZpYmVyUm9vdEJhdGNoICYge1xuICByZW5kZXIoY2hpbGRyZW46IFJlYWN0Tm9kZUxpc3QpOiBXb3JrLFxuICB0aGVuKG9uQ29tcGxldGU6ICgpID0+IG1peGVkKTogdm9pZCxcbiAgY29tbWl0KCk6IHZvaWQsXG5cbiAgLy8gVGhlIFJlYWN0Um9vdCBjb25zdHJ1Y3RvciBpcyBob2lzdGVkIGJ1dCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgYXJlIG5vdC4gSWZcbiAgLy8gd2UgbW92ZSBSZWFjdFJvb3QgdG8gYmUgYWJvdmUgUmVhY3RCYXRjaCwgdGhlIGludmVyc2UgZXJyb3Igb2NjdXJzLlxuICAvLyAkRmxvd0ZpeE1lIEhvaXN0aW5nIGlzc3VlLlxuICBfcm9vdDogUm9vdCxcbiAgX2hhc0NoaWxkcmVuOiBib29sZWFuLFxuICBfY2hpbGRyZW46IFJlYWN0Tm9kZUxpc3QsXG5cbiAgX2NhbGxiYWNrczogQXJyYXk8KCkgPT4gbWl4ZWQ+IHwgbnVsbCxcbiAgX2RpZENvbXBsZXRlOiBib29sZWFuLFxufTtcblxudHlwZSBSb290ID0ge1xuICByZW5kZXIoY2hpbGRyZW46IFJlYWN0Tm9kZUxpc3QsIGNhbGxiYWNrOiA/KCkgPT4gbWl4ZWQpOiBXb3JrLFxuICB1bm1vdW50KGNhbGxiYWNrOiA/KCkgPT4gbWl4ZWQpOiBXb3JrLFxuICBsZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoXG4gICAgcGFyZW50Q29tcG9uZW50OiA/UmVhY3QkQ29tcG9uZW50PGFueSwgYW55PixcbiAgICBjaGlsZHJlbjogUmVhY3ROb2RlTGlzdCxcbiAgICBjYWxsYmFjazogPygpID0+IG1peGVkLFxuICApOiBXb3JrLFxuICBjcmVhdGVCYXRjaCgpOiBCYXRjaCxcblxuICBfaW50ZXJuYWxSb290OiBGaWJlclJvb3QsXG59O1xuXG5mdW5jdGlvbiBSZWFjdEJhdGNoKHJvb3Q6IFJlYWN0Um9vdCkge1xuICBjb25zdCBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24oKTtcbiAgdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21wbGV0ZSA9IGZhbHNlO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICB0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX2RlZmVyID0gdHJ1ZTtcbn1cblJlYWN0QmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGNoaWxkcmVuOiBSZWFjdE5vZGVMaXN0KSB7XG4gIGludmFyaWFudChcbiAgICB0aGlzLl9kZWZlcixcbiAgICAnYmF0Y2gucmVuZGVyOiBDYW5ub3QgcmVuZGVyIGEgYmF0Y2ggdGhhdCBhbHJlYWR5IGNvbW1pdHRlZC4nLFxuICApO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gIGNvbnN0IGludGVybmFsUm9vdCA9IHRoaXMuX3Jvb3QuX2ludGVybmFsUm9vdDtcbiAgY29uc3QgZXhwaXJhdGlvblRpbWUgPSB0aGlzLl9leHBpcmF0aW9uVGltZTtcbiAgY29uc3Qgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShcbiAgICBjaGlsZHJlbixcbiAgICBpbnRlcm5hbFJvb3QsXG4gICAgbnVsbCxcbiAgICBleHBpcmF0aW9uVGltZSxcbiAgICB3b3JrLl9vbkNvbW1pdCxcbiAgKTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uQ29tcGxldGU6ICgpID0+IG1peGVkKSB7XG4gIGlmICh0aGlzLl9kaWRDb21wbGV0ZSkge1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICB9XG4gIGNhbGxiYWNrcy5wdXNoKG9uQ29tcGxldGUpO1xufTtcblJlYWN0QmF0Y2gucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBpbnRlcm5hbFJvb3QgPSB0aGlzLl9yb290Ll9pbnRlcm5hbFJvb3Q7XG4gIGxldCBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2g7XG4gIGludmFyaWFudChcbiAgICB0aGlzLl9kZWZlciAmJiBmaXJzdEJhdGNoICE9PSBudWxsLFxuICAgICdiYXRjaC5jb21taXQ6IENhbm5vdCBjb21taXQgYSBiYXRjaCBtdWx0aXBsZSB0aW1lcy4nLFxuICApO1xuXG4gIGlmICghdGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAvLyBUaGlzIGJhdGNoIGlzIGVtcHR5LiBSZXR1cm4uXG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fZGVmZXIgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZXhwaXJhdGlvblRpbWUgPSB0aGlzLl9leHBpcmF0aW9uVGltZTtcblxuICAvLyBFbnN1cmUgdGhpcyBpcyB0aGUgZmlyc3QgYmF0Y2ggaW4gdGhlIGxpc3QuXG4gIGlmIChmaXJzdEJhdGNoICE9PSB0aGlzKSB7XG4gICAgLy8gVGhpcyBiYXRjaCBpcyBub3QgdGhlIGVhcmxpZXN0IGJhdGNoLiBXZSBuZWVkIHRvIG1vdmUgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIFVwZGF0ZSBpdHMgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHRoZSBleHBpcmF0aW9uIHRpbWUgb2YgdGhlIGVhcmxpZXN0XG4gICAgLy8gYmF0Y2gsIHNvIHRoYXQgd2UgY2FuIGZsdXNoIGl0IHdpdGhvdXQgZmx1c2hpbmcgdGhlIG90aGVyIGJhdGNoZXMuXG4gICAgaWYgKHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lID0gZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWU7XG4gICAgICAvLyBSZW5kZXJpbmcgdGhpcyBiYXRjaCBhZ2FpbiBlbnN1cmVzIGl0cyBjaGlsZHJlbiB3aWxsIGJlIHRoZSBmaW5hbCBzdGF0ZVxuICAgICAgLy8gd2hlbiB3ZSBmbHVzaCAodXBkYXRlcyBhcmUgcHJvY2Vzc2VkIGluIGluc2VydGlvbiBvcmRlcjogbGFzdFxuICAgICAgLy8gdXBkYXRlIHdpbnMpLlxuICAgICAgLy8gVE9ETzogVGhpcyBmb3JjZXMgYSByZXN0YXJ0LiBTaG91bGQgd2UgcHJpbnQgYSB3YXJuaW5nP1xuICAgICAgdGhpcy5yZW5kZXIodGhpcy5fY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgbGlzdC5cbiAgICBsZXQgcHJldmlvdXMgPSBudWxsO1xuICAgIGxldCBiYXRjaCA9IGZpcnN0QmF0Y2g7XG4gICAgd2hpbGUgKGJhdGNoICE9PSB0aGlzKSB7XG4gICAgICBwcmV2aW91cyA9IGJhdGNoO1xuICAgICAgYmF0Y2ggPSBiYXRjaC5fbmV4dDtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgcHJldmlvdXMgIT09IG51bGwsXG4gICAgICAnYmF0Y2guY29tbWl0OiBDYW5ub3QgY29tbWl0IGEgYmF0Y2ggbXVsdGlwbGUgdGltZXMuJyxcbiAgICApO1xuICAgIHByZXZpb3VzLl9uZXh0ID0gYmF0Y2guX25leHQ7XG5cbiAgICAvLyBBZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIHRoaXMuX25leHQgPSBmaXJzdEJhdGNoO1xuICAgIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IHRoaXM7XG4gIH1cblxuICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCB0aGUgd29yayB1cCB0byB0aGlzIGJhdGNoJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICBmbHVzaFJvb3QoaW50ZXJuYWxSb290LCBleHBpcmF0aW9uVGltZSk7XG5cbiAgLy8gUG9wIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICBjb25zdCBuZXh0ID0gdGhpcy5fbmV4dDtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IG5leHQ7XG5cbiAgLy8gQXBwZW5kIHRoZSBuZXh0IGVhcmxpZXN0IGJhdGNoJ3MgY2hpbGRyZW4gdG8gdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgaWYgKGZpcnN0QmF0Y2ggIT09IG51bGwgJiYgZmlyc3RCYXRjaC5faGFzQ2hpbGRyZW4pIHtcbiAgICBmaXJzdEJhdGNoLnJlbmRlcihmaXJzdEJhdGNoLl9jaGlsZHJlbik7XG4gIH1cbn07XG5SZWFjdEJhdGNoLnByb3RvdHlwZS5fb25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZGlkQ29tcGxldGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tcGxldGUgPSB0cnVlO1xuICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxudHlwZSBXb3JrID0ge1xuICB0aGVuKG9uQ29tbWl0OiAoKSA9PiBtaXhlZCk6IHZvaWQsXG4gIF9vbkNvbW1pdDogKCkgPT4gdm9pZCxcbiAgX2NhbGxiYWNrczogQXJyYXk8KCkgPT4gbWl4ZWQ+IHwgbnVsbCxcbiAgX2RpZENvbW1pdDogYm9vbGVhbixcbn07XG5cbmZ1bmN0aW9uIFJlYWN0V29yaygpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fZGlkQ29tbWl0ID0gZmFsc2U7XG4gIC8vIFRPRE86IEF2b2lkIG5lZWQgdG8gYmluZCBieSByZXBsYWNpbmcgY2FsbGJhY2tzIGluIHRoZSB1cGRhdGUgcXVldWUgd2l0aFxuICAvLyBsaXN0IG9mIFdvcmsgb2JqZWN0cy5cbiAgdGhpcy5fb25Db21taXQgPSB0aGlzLl9vbkNvbW1pdC5iaW5kKHRoaXMpO1xufVxuUmVhY3RXb3JrLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25Db21taXQ6ICgpID0+IG1peGVkKTogdm9pZCB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICBvbkNvbW1pdCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgY2FsbGJhY2tzLnB1c2gob25Db21taXQpO1xufTtcblJlYWN0V29yay5wcm90b3R5cGUuX29uQ29tbWl0ID0gZnVuY3Rpb24oKTogdm9pZCB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tbWl0ID0gdHJ1ZTtcbiAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRPRE86IEVycm9yIGhhbmRsaW5nLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgIGludmFyaWFudChcbiAgICAgIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCAnICtcbiAgICAgICAgJ3JlY2VpdmVkOiAlcycsXG4gICAgICBjYWxsYmFjayxcbiAgICApO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChcbiAgY29udGFpbmVyOiBET01Db250YWluZXIsXG4gIGlzQ29uY3VycmVudDogYm9vbGVhbixcbiAgaHlkcmF0ZTogYm9vbGVhbixcbikge1xuICBjb25zdCByb290ID0gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgaXNDb25jdXJyZW50LCBoeWRyYXRlKTtcbiAgdGhpcy5faW50ZXJuYWxSb290ID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oXG4gIGNoaWxkcmVuOiBSZWFjdE5vZGVMaXN0LFxuICBjYWxsYmFjazogPygpID0+IG1peGVkLFxuKTogV29yayB7XG4gIGNvbnN0IHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gIGNvbnN0IHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZW5kZXInKTtcbiAgfVxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB3b3JrLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgbnVsbCwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbihjYWxsYmFjazogPygpID0+IG1peGVkKTogV29yayB7XG4gIGNvbnN0IHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gIGNvbnN0IHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZW5kZXInKTtcbiAgfVxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB3b3JrLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIHVwZGF0ZUNvbnRhaW5lcihudWxsLCByb290LCBudWxsLCB3b3JrLl9vbkNvbW1pdCk7XG4gIHJldHVybiB3b3JrO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUubGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gZnVuY3Rpb24oXG4gIHBhcmVudENvbXBvbmVudDogP1JlYWN0JENvbXBvbmVudDxhbnksIGFueT4sXG4gIGNoaWxkcmVuOiBSZWFjdE5vZGVMaXN0LFxuICBjYWxsYmFjazogPygpID0+IG1peGVkLFxuKTogV29yayB7XG4gIGNvbnN0IHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gIGNvbnN0IHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZW5kZXInKTtcbiAgfVxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB3b3JrLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCB3b3JrLl9vbkNvbW1pdCk7XG4gIHJldHVybiB3b3JrO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUuY3JlYXRlQmF0Y2ggPSBmdW5jdGlvbigpOiBCYXRjaCB7XG4gIGNvbnN0IGJhdGNoID0gbmV3IFJlYWN0QmF0Y2godGhpcyk7XG4gIGNvbnN0IGV4cGlyYXRpb25UaW1lID0gYmF0Y2guX2V4cGlyYXRpb25UaW1lO1xuXG4gIGNvbnN0IGludGVybmFsUm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgY29uc3QgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCA9PT0gbnVsbCkge1xuICAgIGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gYmF0Y2g7XG4gICAgYmF0Y2guX25leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIEluc2VydCBzb3J0ZWQgYnkgZXhwaXJhdGlvbiB0aW1lIHRoZW4gaW5zZXJ0aW9uIG9yZGVyXG4gICAgbGV0IGluc2VydEFmdGVyID0gbnVsbDtcbiAgICBsZXQgaW5zZXJ0QmVmb3JlID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoXG4gICAgICBpbnNlcnRCZWZvcmUgIT09IG51bGwgJiZcbiAgICAgIGluc2VydEJlZm9yZS5fZXhwaXJhdGlvblRpbWUgPj0gZXhwaXJhdGlvblRpbWVcbiAgICApIHtcbiAgICAgIGluc2VydEFmdGVyID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlLl9uZXh0O1xuICAgIH1cbiAgICBiYXRjaC5fbmV4dCA9IGluc2VydEJlZm9yZTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgIGluc2VydEFmdGVyLl9uZXh0ID0gYmF0Y2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhdGNoO1xufTtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKFxuICAgIG5vZGUgJiZcbiAgICAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8XG4gICAgICBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8XG4gICAgICBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8XG4gICAgICAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmXG4gICAgICAgIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyOiBhbnkpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICBjb25zdCByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEoXG4gICAgcm9vdEVsZW1lbnQgJiZcbiAgICByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmXG4gICAgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpXG4gICk7XG59XG5cbnNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oXG4gIGJhdGNoZWRVcGRhdGVzLFxuICBpbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzLFxuKTtcblxubGV0IHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IGZhbHNlO1xuXG5mdW5jdGlvbiBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihcbiAgY29udGFpbmVyOiBET01Db250YWluZXIsXG4gIGZvcmNlSHlkcmF0ZTogYm9vbGVhbixcbik6IFJvb3Qge1xuICBjb25zdCBzaG91bGRIeWRyYXRlID1cbiAgICBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgbGV0IHJvb3RTaWJsaW5nO1xuICAgIHdoaWxlICgocm9vdFNpYmxpbmcgPSBjb250YWluZXIubGFzdENoaWxkKSkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF3YXJuZWQgJiZcbiAgICAgICAgICByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmXG4gICAgICAgICAgKHJvb3RTaWJsaW5nOiBhbnkpLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgK1xuICAgICAgICAgICAgICAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgK1xuICAgICAgICAgICAgICAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuICBpZiAoX19ERVZfXykge1xuICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArXG4gICAgICAgICAgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxNy4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICtcbiAgICAgICAgICAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gTGVnYWN5IHJvb3RzIGFyZSBub3QgYXN5bmMgYnkgZGVmYXVsdC5cbiAgY29uc3QgaXNDb25jdXJyZW50ID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaXNDb25jdXJyZW50LCBzaG91bGRIeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIoXG4gIHBhcmVudENvbXBvbmVudDogP1JlYWN0JENvbXBvbmVudDxhbnksIGFueT4sXG4gIGNoaWxkcmVuOiBSZWFjdE5vZGVMaXN0LFxuICBjb250YWluZXI6IERPTUNvbnRhaW5lcixcbiAgZm9yY2VIeWRyYXRlOiBib29sZWFuLFxuICBjYWxsYmFjazogP0Z1bmN0aW9uLFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyhjb250YWluZXIpO1xuICB9XG5cbiAgLy8gVE9ETzogV2l0aG91dCBgYW55YCB0eXBlLCBGbG93IHNheXMgXCJQcm9wZXJ0eSBjYW5ub3QgYmUgYWNjZXNzZWQgb24gYW55XG4gIC8vIG1lbWJlciBvZiBpbnRlcnNlY3Rpb24gdHlwZS5cIiBXaHl5eXl5eS5cbiAgbGV0IHJvb3Q6IFJvb3QgPSAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI6IGFueSk7XG4gIGlmICghcm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGZvcmNlSHlkcmF0ZSxcbiAgICApO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICB1bmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgICByb290LmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LnJlbmRlcihjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBVcGRhdGVcbiAgICBpZiAocGFyZW50Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgIHJvb3QubGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QucmVuZGVyKGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdC5faW50ZXJuYWxSb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKFxuICBjaGlsZHJlbjogUmVhY3ROb2RlTGlzdCxcbiAgY29udGFpbmVyOiBET01Db250YWluZXIsXG4gIGtleTogP3N0cmluZyA9IG51bGwsXG4pIHtcbiAgaW52YXJpYW50KFxuICAgIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSxcbiAgICAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nLFxuICApO1xuICAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICByZXR1cm4gY3JlYXRlUG9ydGFsSW1wbChjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xufVxuXG5jb25zdCBSZWFjdERPTTogT2JqZWN0ID0ge1xuICBjcmVhdGVQb3J0YWwsXG5cbiAgZmluZERPTU5vZGUoXG4gICAgY29tcG9uZW50T3JFbGVtZW50OiBFbGVtZW50IHwgP1JlYWN0JENvbXBvbmVudDxhbnksIGFueT4sXG4gICk6IG51bGwgfCBFbGVtZW50IHwgVGV4dCB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGxldCBvd25lciA9IChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50OiBhbnkpO1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3YXJuZWRBYm91dFJlZnNJblJlbmRlciA9XG4gICAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICB3YXJuZWRBYm91dFJlZnNJblJlbmRlcixcbiAgICAgICAgICAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgK1xuICAgICAgICAgICAgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArXG4gICAgICAgICAgICAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArXG4gICAgICAgICAgICAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArXG4gICAgICAgICAgICAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJyxcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcsXG4gICAgICAgICk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKGNvbXBvbmVudE9yRWxlbWVudDogYW55KS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gKGNvbXBvbmVudE9yRWxlbWVudDogYW55KTtcbiAgICB9XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHJldHVybiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50T3JFbGVtZW50LCAnZmluZERPTU5vZGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgfSxcblxuICBoeWRyYXRlKGVsZW1lbnQ6IFJlYWN0JE5vZGUsIGNvbnRhaW5lcjogRE9NQ29udGFpbmVyLCBjYWxsYmFjazogP0Z1bmN0aW9uKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpLFxuICAgICAgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyxcbiAgICApO1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAhY29udGFpbmVyLl9yZWFjdEhhc0JlZW5QYXNzZWRUb0NyZWF0ZVJvb3RERVYsXG4gICAgICAgICdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00uaHlkcmF0ZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArXG4gICAgICAgICAgJ3Bhc3NlZCB0byBSZWFjdERPTS4lcygpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgK1xuICAgICAgICAgICdEaWQgeW91IG1lYW4gdG8gY2FsbCBjcmVhdGVSb290KGNvbnRhaW5lciwge2h5ZHJhdGU6IHRydWV9KS5yZW5kZXIoZWxlbWVudCk/JyxcbiAgICAgICAgZW5hYmxlU3RhYmxlQ29uY3VycmVudE1vZGVBUElzID8gJ2NyZWF0ZVJvb3QnIDogJ3Vuc3RhYmxlX2NyZWF0ZVJvb3QnLFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuICAgIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihcbiAgICAgIG51bGwsXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgdHJ1ZSxcbiAgICAgIGNhbGxiYWNrLFxuICAgICk7XG4gIH0sXG5cbiAgcmVuZGVyKFxuICAgIGVsZW1lbnQ6IFJlYWN0JEVsZW1lbnQ8YW55PixcbiAgICBjb250YWluZXI6IERPTUNvbnRhaW5lcixcbiAgICBjYWxsYmFjazogP0Z1bmN0aW9uLFxuICApIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nLFxuICAgICk7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICFjb250YWluZXIuX3JlYWN0SGFzQmVlblBhc3NlZFRvQ3JlYXRlUm9vdERFVixcbiAgICAgICAgJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgK1xuICAgICAgICAgICdwYXNzZWQgdG8gUmVhY3RET00uJXMoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC5yZW5kZXIoZWxlbWVudCk/JyxcbiAgICAgICAgZW5hYmxlU3RhYmxlQ29uY3VycmVudE1vZGVBUElzID8gJ2NyZWF0ZVJvb3QnIDogJ3Vuc3RhYmxlX2NyZWF0ZVJvb3QnLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKFxuICAgICAgbnVsbCxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBmYWxzZSxcbiAgICAgIGNhbGxiYWNrLFxuICAgICk7XG4gIH0sXG5cbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoXG4gICAgcGFyZW50Q29tcG9uZW50OiBSZWFjdCRDb21wb25lbnQ8YW55LCBhbnk+LFxuICAgIGVsZW1lbnQ6IFJlYWN0JEVsZW1lbnQ8YW55PixcbiAgICBjb250YWluZXJOb2RlOiBET01Db250YWluZXIsXG4gICAgY2FsbGJhY2s6ID9GdW5jdGlvbixcbiAgKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXJOb2RlKSxcbiAgICAgICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicsXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXNJbnN0YW5jZShwYXJlbnRDb21wb25lbnQpLFxuICAgICAgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JyxcbiAgICApO1xuICAgIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXJOb2RlLFxuICAgICAgZmFsc2UsXG4gICAgICBjYWxsYmFjayxcbiAgICApO1xuICB9LFxuXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyOiBET01Db250YWluZXIpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicsXG4gICAgKTtcblxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAhY29udGFpbmVyLl9yZWFjdEhhc0JlZW5QYXNzZWRUb0NyZWF0ZVJvb3RERVYsXG4gICAgICAgICdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArXG4gICAgICAgICAgJ3Bhc3NlZCB0byBSZWFjdERPTS4lcygpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycsXG4gICAgICAgIGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcyA/ICdjcmVhdGVSb290JyA6ICd1bnN0YWJsZV9jcmVhdGVSb290JyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBjb25zdCByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgICAgIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCxcbiAgICAgICAgICBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArXG4gICAgICAgICAgICAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCAoKSA9PiB7XG4gICAgICAgICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAgIC8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGNvbnN0IHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICBjb25zdCBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKHJvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgICBjb25zdCBpc0NvbnRhaW5lclJlYWN0Um9vdCA9XG4gICAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiZcbiAgICAgICAgICBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lci5wYXJlbnROb2RlKSAmJlxuICAgICAgICAgICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgICFoYXNOb25Sb290UmVhY3RDaGlsZCxcbiAgICAgICAgICBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArXG4gICAgICAgICAgICAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsXG4gICAgICAgICAgaXNDb250YWluZXJSZWFjdFJvb3RcbiAgICAgICAgICAgID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArXG4gICAgICAgICAgICAgICdvZiBpdHMgY29udGFpbmVyLidcbiAgICAgICAgICAgIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArXG4gICAgICAgICAgICAgICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvLyBUZW1wb3JhcnkgYWxpYXMgc2luY2Ugd2UgYWxyZWFkeSBzaGlwcGVkIFJlYWN0IDE2IFJDIHdpdGggaXQuXG4gIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy5cbiAgdW5zdGFibGVfY3JlYXRlUG9ydGFsKC4uLmFyZ3MpIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgK1xuICAgICAgICAgICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArXG4gICAgICAgICAgJ1JlYWN0RE9NLmNyZWF0ZVBvcnRhbCgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEksICcgK1xuICAgICAgICAgICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLi4uYXJncyk7XG4gIH0sXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gIHVuc3RhYmxlX2ludGVyYWN0aXZlVXBkYXRlczogaW50ZXJhY3RpdmVVcGRhdGVzLFxuXG4gIGZsdXNoU3luYzogZmx1c2hTeW5jLFxuXG4gIHVuc3RhYmxlX2NyZWF0ZVJvb3Q6IGNyZWF0ZVJvb3QsXG4gIHVuc3RhYmxlX2ZsdXNoQ29udHJvbGxlZDogZmx1c2hDb250cm9sbGVkLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgLy8gS2VlcCBpbiBzeW5jIHdpdGggUmVhY3RET01VbnN0YWJsZU5hdGl2ZURlcGVuZGVuY2llcy5qc1xuICAgIC8vIGFuZCBSZWFjdFRlc3RVdGlscy5qcy4gVGhpcyBpcyBhbiBhcnJheSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvbi5cbiAgICBFdmVudHM6IFtcbiAgICAgIGdldEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlLFxuICAgICAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSxcbiAgICAgIEV2ZW50UGx1Z2luSHViSW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSxcbiAgICAgIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcbiAgICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gICAgICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgICAgIGVucXVldWVTdGF0ZVJlc3RvcmUsXG4gICAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCxcbiAgICAgIGRpc3BhdGNoRXZlbnQsXG4gICAgICBydW5FdmVudHNJbkJhdGNoLFxuICAgIF0sXG4gIH0sXG59O1xuXG50eXBlIFJvb3RPcHRpb25zID0ge1xuICBoeWRyYXRlPzogYm9vbGVhbixcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyOiBET01Db250YWluZXIsIG9wdGlvbnM/OiBSb290T3B0aW9ucyk6IFJlYWN0Um9vdCB7XG4gIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJc1xuICAgID8gJ2NyZWF0ZVJvb3QnXG4gICAgOiAndW5zdGFibGVfY3JlYXRlUm9vdCc7XG4gIGludmFyaWFudChcbiAgICBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgJyVzKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyxcbiAgICBmdW5jdGlvbk5hbWUsXG4gICk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcixcbiAgICAgICdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00uJXMoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgK1xuICAgICAgICAncGFzc2VkIHRvIFJlYWN0RE9NLnJlbmRlcigpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuJyxcbiAgICAgIGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcyA/ICdjcmVhdGVSb290JyA6ICd1bnN0YWJsZV9jcmVhdGVSb290JyxcbiAgICApO1xuICAgIGNvbnRhaW5lci5fcmVhY3RIYXNCZWVuUGFzc2VkVG9DcmVhdGVSb290REVWID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCB0cnVlLCBoeWRyYXRlKTtcbn1cblxuaWYgKGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcykge1xuICBSZWFjdERPTS5jcmVhdGVSb290ID0gY3JlYXRlUm9vdDtcbiAgUmVhY3RET00udW5zdGFibGVfY3JlYXRlUm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogX19ERVZfXyA/IDEgOiAwLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nLFxufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIGlmICghZm91bmREZXZUb29scyAmJiBjYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAoXG4gICAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSkgfHxcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTFcbiAgICApIHtcbiAgICAgIGNvbnN0IHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgK1xuICAgICAgICAgICAgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICtcbiAgICAgICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArXG4gICAgICAgICAgICAocHJvdG9jb2wgPT09ICdmaWxlOidcbiAgICAgICAgICAgICAgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgK1xuICAgICAgICAgICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcSdcbiAgICAgICAgICAgICAgOiAnJyksXG4gICAgICAgICAgJ2ZvbnQtd2VpZ2h0OmJvbGQnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdERPTTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuXG5pbnZhcmlhbnQoXG4gIFJlYWN0LFxuICAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCAnICtcbiAgICAndGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uJyxcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9jaGVja1JlYWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge2luamVjdGlvbiBhcyBFdmVudFBsdWdpbkh1YkluamVjdGlvbn0gZnJvbSAnZXZlbnRzL0V2ZW50UGx1Z2luSHViJztcbmltcG9ydCB7c2V0Q29tcG9uZW50VHJlZX0gZnJvbSAnZXZlbnRzL0V2ZW50UGx1Z2luVXRpbHMnO1xuXG5pbXBvcnQge1xuICBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlLFxuICBnZXRJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXROb2RlRnJvbUluc3RhbmNlLFxufSBmcm9tICcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZSc7XG5pbXBvcnQgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiBmcm9tICcuLi9ldmVudHMvQmVmb3JlSW5wdXRFdmVudFBsdWdpbic7XG5pbXBvcnQgQ2hhbmdlRXZlbnRQbHVnaW4gZnJvbSAnLi4vZXZlbnRzL0NoYW5nZUV2ZW50UGx1Z2luJztcbmltcG9ydCBET01FdmVudFBsdWdpbk9yZGVyIGZyb20gJy4uL2V2ZW50cy9ET01FdmVudFBsdWdpbk9yZGVyJztcbmltcG9ydCBFbnRlckxlYXZlRXZlbnRQbHVnaW4gZnJvbSAnLi4vZXZlbnRzL0VudGVyTGVhdmVFdmVudFBsdWdpbic7XG5pbXBvcnQgU2VsZWN0RXZlbnRQbHVnaW4gZnJvbSAnLi4vZXZlbnRzL1NlbGVjdEV2ZW50UGx1Z2luJztcbmltcG9ydCBTaW1wbGVFdmVudFBsdWdpbiBmcm9tICcuLi9ldmVudHMvU2ltcGxlRXZlbnRQbHVnaW4nO1xuXG4vKipcbiAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICovXG5FdmVudFBsdWdpbkh1YkluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERPTUV2ZW50UGx1Z2luT3JkZXIpO1xuc2V0Q29tcG9uZW50VHJlZShcbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbik7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuRXZlbnRQbHVnaW5IdWJJbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW4sXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NQ2xpZW50SW5qZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5cbmxldCBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gZnVuY3Rpb248QSwgQiwgQywgRCwgRSwgRiwgQ29udGV4dD4oXG4gIG5hbWU6IHN0cmluZyB8IG51bGwsXG4gIGZ1bmM6IChhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCBlOiBFLCBmOiBGKSA9PiBtaXhlZCxcbiAgY29udGV4dDogQ29udGV4dCxcbiAgYTogQSxcbiAgYjogQixcbiAgYzogQyxcbiAgZDogRCxcbiAgZTogRSxcbiAgZjogRixcbikge1xuICBjb25zdCBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufTtcblxuaWYgKF9fREVWX18pIHtcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW5pbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgY29uc3QgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgY29uc3QgaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2ID0gZnVuY3Rpb248QSwgQiwgQywgRCwgRSwgRiwgQ29udGV4dD4oXG4gICAgICBuYW1lOiBzdHJpbmcgfCBudWxsLFxuICAgICAgZnVuYzogKGE6IEEsIGI6IEIsIGM6IEMsIGQ6IEQsIGU6IEUsIGY6IEYpID0+IG1peGVkLFxuICAgICAgY29udGV4dDogQ29udGV4dCxcbiAgICAgIGE6IEEsXG4gICAgICBiOiBCLFxuICAgICAgYzogQyxcbiAgICAgIGQ6IEQsXG4gICAgICBlOiBFLFxuICAgICAgZjogRixcbiAgICApIHtcbiAgICAgIC8vIElmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3Qgd2Uga25vdyBmb3Igc3VyZSB3ZSB3aWxsIGNyYXNoIGluIHRoaXMgbWV0aG9kXG4gICAgICAvLyB3aGVuIHdlIGNhbGwgZG9jdW1lbnQuY3JlYXRlRXZlbnQoKS4gSG93ZXZlciB0aGlzIGNhbiBjYXVzZSBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9yczogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHAvaXNzdWVzLzM0ODJcbiAgICAgIC8vIFNvIHdlIHByZWVtcHRpdmVseSB0aHJvdyB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UgaW5zdGVhZC5cbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCAnICtcbiAgICAgICAgICAnZGVmaW5lZCBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gaW4gYSB0ZXN0IGVudmlyb25tZW50IGlmIGEgY29tcG9uZW50ICcgK1xuICAgICAgICAgICdzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgJyArXG4gICAgICAgICAgJ2ZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCAnICtcbiAgICAgICAgICAndGhlIGVuZCBvZiB5b3VyIHRlc3QgKGFuZCBlbnN1cmUgdGhhdCBhbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMgZ2V0ICcgK1xuICAgICAgICAgICdjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmICcgK1xuICAgICAgICAgICd0byBiZSBhc3luY2hyb25vdXMuJyxcbiAgICAgICk7XG4gICAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuICAgICAgbGV0IGRpZEVycm9yID0gdHJ1ZTtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG4gICAgICBsZXQgd2luZG93RXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4gICAgICAvLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxuICAgICAgY29uc3Qgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgd2luZG93LFxuICAgICAgICAnZXZlbnQnLFxuICAgICAgKTtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cbiAgICAgIGNvbnN0IGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgbGV0IGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICBsZXQgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0Vycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHtcbiAgICAgICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG4gICAgICBjb25zdCBldnRUeXBlID0gYHJlYWN0LSR7bmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJ31gO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdldmVudCcsIHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgK1xuICAgICAgICAgICAgICBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgK1xuICAgICAgICAgICAgICAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgK1xuICAgICAgICAgICAgICAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICtcbiAgICAgICAgICAgICAgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgK1xuICAgICAgICAgICAgICAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICtcbiAgICAgICAgICAgICAgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArXG4gICAgICAgICAgICAgICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgK1xuICAgICAgICAgICAgICAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgK1xuICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgfTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9pbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7VG9wTGV2ZWxUeXBlfSBmcm9tICdldmVudHMvVG9wTGV2ZWxFdmVudFR5cGVzJztcblxuaW1wb3J0IHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzfSBmcm9tICdldmVudHMvRXZlbnRQcm9wYWdhdG9ycyc7XG5pbXBvcnQge2NhblVzZURPTX0gZnJvbSAnc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50JztcblxuaW1wb3J0IHtcbiAgVE9QX0JMVVIsXG4gIFRPUF9DT01QT1NJVElPTl9TVEFSVCxcbiAgVE9QX0NPTVBPU0lUSU9OX0VORCxcbiAgVE9QX0NPTVBPU0lUSU9OX1VQREFURSxcbiAgVE9QX0tFWV9ET1dOLFxuICBUT1BfS0VZX1BSRVNTLFxuICBUT1BfS0VZX1VQLFxuICBUT1BfTU9VU0VfRE9XTixcbiAgVE9QX1RFWFRfSU5QVVQsXG4gIFRPUF9QQVNURSxcbn0gZnJvbSAnLi9ET01Ub3BMZXZlbEV2ZW50VHlwZXMnO1xuaW1wb3J0IHtcbiAgZ2V0RGF0YSBhcyBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVHZXREYXRhLFxuICBpbml0aWFsaXplIGFzIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZUluaXRpYWxpemUsXG4gIHJlc2V0IGFzIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZVJlc2V0LFxufSBmcm9tICcuL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSc7XG5pbXBvcnQgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCBmcm9tICcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnO1xuaW1wb3J0IFN5bnRoZXRpY0lucHV0RXZlbnQgZnJvbSAnLi9TeW50aGV0aWNJbnB1dEV2ZW50JztcblxuY29uc3QgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxuY29uc3QgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxuY29uc3QgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IGNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG5sZXQgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxuY29uc3QgY2FuVXNlVGV4dElucHV0RXZlbnQgPVxuICBjYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG5jb25zdCB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9XG4gIGNhblVzZURPTSAmJlxuICAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHxcbiAgICAoZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKSk7XG5cbmNvbnN0IFNQQUNFQkFSX0NPREUgPSAzMjtcbmNvbnN0IFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG5jb25zdCBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJyxcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgVE9QX0NPTVBPU0lUSU9OX0VORCxcbiAgICAgIFRPUF9LRVlfUFJFU1MsXG4gICAgICBUT1BfVEVYVF9JTlBVVCxcbiAgICAgIFRPUF9QQVNURSxcbiAgICBdLFxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJyxcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgVE9QX0JMVVIsXG4gICAgICBUT1BfQ09NUE9TSVRJT05fRU5ELFxuICAgICAgVE9QX0tFWV9ET1dOLFxuICAgICAgVE9QX0tFWV9QUkVTUyxcbiAgICAgIFRPUF9LRVlfVVAsXG4gICAgICBUT1BfTU9VU0VfRE9XTixcbiAgICBdLFxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJyxcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgVE9QX0JMVVIsXG4gICAgICBUT1BfQ09NUE9TSVRJT05fU1RBUlQsXG4gICAgICBUT1BfS0VZX0RPV04sXG4gICAgICBUT1BfS0VZX1BSRVNTLFxuICAgICAgVE9QX0tFWV9VUCxcbiAgICAgIFRPUF9NT1VTRV9ET1dOLFxuICAgIF0sXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnLFxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICBUT1BfQkxVUixcbiAgICAgIFRPUF9DT01QT1NJVElPTl9VUERBVEUsXG4gICAgICBUT1BfS0VZX0RPV04sXG4gICAgICBUT1BfS0VZX1BSRVNTLFxuICAgICAgVE9QX0tFWV9VUCxcbiAgICAgIFRPUF9NT1VTRV9ET1dOLFxuICAgIF0sXG4gIH0sXG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG5sZXQgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKFxuICAgIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAgIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAgICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpXG4gICk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9TVEFSVDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSBUT1BfQ09NUE9TSVRJT05fRU5EOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSBUT1BfQ09NUE9TSVRJT05fVVBEQVRFOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gVE9QX0tFWV9ET1dOICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSBUT1BfS0VZX1VQOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgVE9QX0tFWV9ET1dOOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgY2FzZSBUT1BfTU9VU0VfRE9XTjpcbiAgICBjYXNlIFRPUF9CTFVSOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICBjb25zdCBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9zaXRpb24gZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBLb3JlYW4gSU1FLlxuICogT3VyIGZhbGxiYWNrIG1vZGUgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggSUUncyBLb3JlYW4gSU1FLFxuICogc28ganVzdCB1c2UgbmF0aXZlIGNvbXBvc2l0aW9uIGV2ZW50cyB3aGVuIEtvcmVhbiBJTUUgaXMgdXNlZC5cbiAqIEFsdGhvdWdoIENvbXBvc2l0aW9uRXZlbnQubG9jYWxlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsXG4gKiBpdCBpcyBhdmFpbGFibGUgaW4gSUUsIHdoZXJlIG91ciBmYWxsYmFjayBtb2RlIGlzIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVFdmVudC5sb2NhbGUgPT09ICdrbyc7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cbmxldCBpc0NvbXBvc2luZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQoXG4gIHRvcExldmVsVHlwZSxcbiAgdGFyZ2V0SW5zdCxcbiAgbmF0aXZlRXZlbnQsXG4gIG5hdGl2ZUV2ZW50VGFyZ2V0LFxuKSB7XG4gIGxldCBldmVudFR5cGU7XG4gIGxldCBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJiAhaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVJbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZUdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKFxuICAgIGV2ZW50VHlwZSxcbiAgICB0YXJnZXRJbnN0LFxuICAgIG5hdGl2ZUV2ZW50LFxuICAgIG5hdGl2ZUV2ZW50VGFyZ2V0LFxuICApO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlfSB0b3BMZXZlbFR5cGUgTnVtYmVyIGZyb20gYFRvcExldmVsVHlwZWAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZTogVG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICBjb25zdCB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSBUT1BfVEVYVF9JTlBVVDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgY29uc3QgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGlnbm9yZSBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wTGV2ZWxUeXBlIE51bWJlciBmcm9tIGBUb3BMZXZlbEV2ZW50VHlwZXNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlOiBUb3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKFxuICAgICAgdG9wTGV2ZWxUeXBlID09PSBUT1BfQ09NUE9TSVRJT05fRU5EIHx8XG4gICAgICAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiZcbiAgICAgICAgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKVxuICAgICkge1xuICAgICAgY29uc3QgY2hhcnMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVHZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVSZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX1BBU1RFOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBUT1BfS0VZX1BSRVNTOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9FTkQ6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQoXG4gIHRvcExldmVsVHlwZSxcbiAgdGFyZ2V0SW5zdCxcbiAgbmF0aXZlRXZlbnQsXG4gIG5hdGl2ZUV2ZW50VGFyZ2V0LFxuKSB7XG4gIGxldCBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKFxuICAgIGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgKTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xuY29uc3QgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgKSB7XG4gICAgY29uc3QgY29tcG9zaXRpb24gPSBleHRyYWN0Q29tcG9zaXRpb25FdmVudChcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRhcmdldEluc3QsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0LFxuICAgICk7XG5cbiAgICBjb25zdCBiZWZvcmVJbnB1dCA9IGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXQsXG4gICAgKTtcblxuICAgIGlmIChjb21wb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJlZm9yZUlucHV0O1xuICAgIH1cblxuICAgIGlmIChiZWZvcmVJbnB1dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbXBvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBbY29tcG9zaXRpb24sIGJlZm9yZUlucHV0XTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge0hvc3RDb21wb25lbnR9IGZyb20gJy4vUmVhY3RXb3JrVGFncyc7XG5cbmZ1bmN0aW9uIGdldFBhcmVudChpbnN0KSB7XG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47XG4gICAgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgbGV0IGRlcHRoQSA9IDA7XG4gIGZvciAobGV0IHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICBsZXQgZGVwdGhCID0gMDtcbiAgZm9yIChsZXQgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgbGV0IGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB3aGlsZSAoaW5zdEIpIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICBsZXQgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7ICkge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIGNvbnN0IGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICBjb25zdCBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIGNvbnN0IHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghdG8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodG8gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGFsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHBhdGhUby5sZW5ndGg7IGktLSA+IDA7ICkge1xuICAgIGZuKHBhdGhUb1tpXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9zaGFyZWQvUmVhY3RUcmVlVHJhdmVyc2FsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCB0eXBlIFJOVG9wTGV2ZWxFdmVudFR5cGUgPVxuICB8ICd0b3BNb3VzZURvd24nXG4gIHwgJ3RvcE1vdXNlTW92ZSdcbiAgfCAndG9wTW91c2VVcCdcbiAgfCAndG9wU2Nyb2xsJ1xuICB8ICd0b3BTZWxlY3Rpb25DaGFuZ2UnXG4gIHwgJ3RvcFRvdWNoQ2FuY2VsJ1xuICB8ICd0b3BUb3VjaEVuZCdcbiAgfCAndG9wVG91Y2hNb3ZlJ1xuICB8ICd0b3BUb3VjaFN0YXJ0JztcblxuZXhwb3J0IG9wYXF1ZSB0eXBlIERPTVRvcExldmVsRXZlbnRUeXBlID0gc3RyaW5nO1xuXG4vLyBEbyBub3QgdXNlcyB0aGUgYmVsb3cgdHdvIG1ldGhvZHMgZGlyZWN0bHkhXG4vLyBJbnN0ZWFkIHVzZSBjb25zdGFudHMgZXhwb3J0ZWQgZnJvbSBET01Ub3BMZXZlbEV2ZW50VHlwZXMgaW4gUmVhY3RET00uXG4vLyAoSXQgaXMgdGhlIG9ubHkgbW9kdWxlIHRoYXQgaXMgYWxsb3dlZCB0byBhY2Nlc3MgdGhlc2UgbWV0aG9kcy4pXG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoXG4gIHRvcExldmVsVHlwZTogc3RyaW5nLFxuKTogRE9NVG9wTGV2ZWxFdmVudFR5cGUge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKFxuICB0b3BMZXZlbFR5cGU6IERPTVRvcExldmVsRXZlbnRUeXBlLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZTtcbn1cblxuZXhwb3J0IHR5cGUgVG9wTGV2ZWxUeXBlID0gRE9NVG9wTGV2ZWxFdmVudFR5cGUgfCBSTlRvcExldmVsRXZlbnRUeXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvZXZlbnRzL1RvcExldmVsRXZlbnRUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHtjYW5Vc2VET019IGZyb20gJ3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudCc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIGNvbnN0IHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG5jb25zdCB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpLFxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbmNvbnN0IHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG5sZXQgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIGNvbnN0IHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yIChjb25zdCBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIFRoZXNlIHZhcmlhYmxlcyBzdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cblxubGV0IHJvb3QgPSBudWxsO1xubGV0IHN0YXJ0VGV4dCA9IG51bGw7XG5sZXQgZmFsbGJhY2tUZXh0ID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBzdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJvb3QgPSBudWxsO1xuICBzdGFydFRleHQgPSBudWxsO1xuICBmYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG4gIH1cblxuICBsZXQgc3RhcnQ7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSBzdGFydFRleHQ7XG4gIGNvbnN0IHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIGxldCBlbmQ7XG4gIGNvbnN0IGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICBjb25zdCBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gZmFsbGJhY2tUZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gcm9vdCkge1xuICAgIHJldHVybiByb290LnZhbHVlO1xuICB9XG4gIHJldHVybiByb290LnRleHRDb250ZW50O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgU3ludGhldGljRXZlbnQgZnJvbSAnZXZlbnRzL1N5bnRoZXRpY0V2ZW50JztcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbmNvbnN0IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICBkYXRhOiBudWxsLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgU3ludGhldGljRXZlbnQgZnJvbSAnZXZlbnRzL1N5bnRoZXRpY0V2ZW50JztcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbmNvbnN0IFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICBkYXRhOiBudWxsLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge3J1bkV2ZW50c0luQmF0Y2h9IGZyb20gJ2V2ZW50cy9FdmVudFBsdWdpbkh1Yic7XG5pbXBvcnQge2FjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXN9IGZyb20gJ2V2ZW50cy9FdmVudFByb3BhZ2F0b3JzJztcbmltcG9ydCB7ZW5xdWV1ZVN0YXRlUmVzdG9yZX0gZnJvbSAnZXZlbnRzL1JlYWN0Q29udHJvbGxlZENvbXBvbmVudCc7XG5pbXBvcnQge2JhdGNoZWRVcGRhdGVzfSBmcm9tICdldmVudHMvUmVhY3RHZW5lcmljQmF0Y2hpbmcnO1xuaW1wb3J0IFN5bnRoZXRpY0V2ZW50IGZyb20gJ2V2ZW50cy9TeW50aGV0aWNFdmVudCc7XG5pbXBvcnQgaXNUZXh0SW5wdXRFbGVtZW50IGZyb20gJ3NoYXJlZC9pc1RleHRJbnB1dEVsZW1lbnQnO1xuaW1wb3J0IHtjYW5Vc2VET019IGZyb20gJ3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudCc7XG5cbmltcG9ydCB7XG4gIFRPUF9CTFVSLFxuICBUT1BfQ0hBTkdFLFxuICBUT1BfQ0xJQ0ssXG4gIFRPUF9GT0NVUyxcbiAgVE9QX0lOUFVULFxuICBUT1BfS0VZX0RPV04sXG4gIFRPUF9LRVlfVVAsXG4gIFRPUF9TRUxFQ1RJT05fQ0hBTkdFLFxufSBmcm9tICcuL0RPTVRvcExldmVsRXZlbnRUeXBlcyc7XG5pbXBvcnQgZ2V0RXZlbnRUYXJnZXQgZnJvbSAnLi9nZXRFdmVudFRhcmdldCc7XG5pbXBvcnQgaXNFdmVudFN1cHBvcnRlZCBmcm9tICcuL2lzRXZlbnRTdXBwb3J0ZWQnO1xuaW1wb3J0IHtnZXROb2RlRnJvbUluc3RhbmNlfSBmcm9tICcuLi9jbGllbnQvUmVhY3RET01Db21wb25lbnRUcmVlJztcbmltcG9ydCB7dXBkYXRlVmFsdWVJZkNoYW5nZWR9IGZyb20gJy4uL2NsaWVudC9pbnB1dFZhbHVlVHJhY2tpbmcnO1xuaW1wb3J0IHtzZXREZWZhdWx0VmFsdWV9IGZyb20gJy4uL2NsaWVudC9SZWFjdERPTUlucHV0JztcbmltcG9ydCB7ZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZ30gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcblxuY29uc3QgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZScsXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIFRPUF9CTFVSLFxuICAgICAgVE9QX0NIQU5HRSxcbiAgICAgIFRPUF9DTElDSyxcbiAgICAgIFRPUF9GT0NVUyxcbiAgICAgIFRPUF9JTlBVVCxcbiAgICAgIFRPUF9LRVlfRE9XTixcbiAgICAgIFRPUF9LRVlfVVAsXG4gICAgICBUT1BfU0VMRUNUSU9OX0NIQU5HRSxcbiAgICBdLFxuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgY29uc3QgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgZXZlbnRUeXBlcy5jaGFuZ2UsXG4gICAgaW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXQsXG4gICk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG5sZXQgYWN0aXZlRWxlbWVudCA9IG51bGw7XG5sZXQgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAoXG4gICAgbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJylcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICBjb25zdCBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgICBhY3RpdmVFbGVtZW50SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCksXG4gICk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIGJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgcnVuRXZlbnRzSW5CYXRjaChldmVudCk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIGNvbnN0IHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9DSEFOR0UpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbmxldCBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChjYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPVxuICAgIGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiZcbiAgICAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfRk9DVVMpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQkxVUikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKFxuICAgIHRvcExldmVsVHlwZSA9PT0gVE9QX1NFTEVDVElPTl9DSEFOR0UgfHxcbiAgICB0b3BMZXZlbFR5cGUgPT09IFRPUF9LRVlfVVAgfHxcbiAgICB0b3BMZXZlbFR5cGUgPT09IFRPUF9LRVlfRE9XTlxuICApIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgY29uc3Qgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gKFxuICAgIG5vZGVOYW1lICYmXG4gICAgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJlxuICAgIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NMSUNLKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfSU5QVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfQ0hBTkdFKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKG5vZGUpIHtcbiAgbGV0IHN0YXRlID0gbm9kZS5fd3JhcHBlclN0YXRlO1xuXG4gIGlmICghc3RhdGUgfHwgIXN0YXRlLmNvbnRyb2xsZWQgfHwgbm9kZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZykge1xuICAgIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbmNvbnN0IENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIF9pc0lucHV0RXZlbnRTdXBwb3J0ZWQ6IGlzSW5wdXRFdmVudFN1cHBvcnRlZCxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgKSB7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgbGV0IGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICBjb25zdCBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KFxuICAgICAgICAgIGluc3QsXG4gICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXQsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9CTFVSKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbmNvbnN0IERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbXG4gICdSZXNwb25kZXJFdmVudFBsdWdpbicsXG4gICdTaW1wbGVFdmVudFBsdWdpbicsXG4gICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLFxuICAnQ2hhbmdlRXZlbnRQbHVnaW4nLFxuICAnU2VsZWN0RXZlbnRQbHVnaW4nLFxuICAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbicsXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBET01FdmVudFBsdWdpbk9yZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvRE9NRXZlbnRQbHVnaW5PcmRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHthY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXN9IGZyb20gJ2V2ZW50cy9FdmVudFByb3BhZ2F0b3JzJztcblxuaW1wb3J0IHtcbiAgVE9QX01PVVNFX09VVCxcbiAgVE9QX01PVVNFX09WRVIsXG4gIFRPUF9QT0lOVEVSX09VVCxcbiAgVE9QX1BPSU5URVJfT1ZFUixcbn0gZnJvbSAnLi9ET01Ub3BMZXZlbEV2ZW50VHlwZXMnO1xuaW1wb3J0IFN5bnRoZXRpY01vdXNlRXZlbnQgZnJvbSAnLi9TeW50aGV0aWNNb3VzZUV2ZW50JztcbmltcG9ydCBTeW50aGV0aWNQb2ludGVyRXZlbnQgZnJvbSAnLi9TeW50aGV0aWNQb2ludGVyRXZlbnQnO1xuaW1wb3J0IHtcbiAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2UsXG59IGZyb20gJy4uL2NsaWVudC9SZWFjdERPTUNvbXBvbmVudFRyZWUnO1xuXG5jb25zdCBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX01PVVNFX09VVCwgVE9QX01PVVNFX09WRVJdLFxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX01PVVNFX09VVCwgVE9QX01PVVNFX09WRVJdLFxuICB9LFxuICBwb2ludGVyRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Qb2ludGVyRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9QT0lOVEVSX09VVCwgVE9QX1BPSU5URVJfT1ZFUl0sXG4gIH0sXG4gIHBvaW50ZXJMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvblBvaW50ZXJMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX1BPSU5URVJfT1VULCBUT1BfUE9JTlRFUl9PVkVSXSxcbiAgfSxcbn07XG5cbmNvbnN0IEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRhcmdldEluc3QsXG4gICAgbmF0aXZlRXZlbnQsXG4gICAgbmF0aXZlRXZlbnRUYXJnZXQsXG4gICkge1xuICAgIGNvbnN0IGlzT3ZlckV2ZW50ID1cbiAgICAgIHRvcExldmVsVHlwZSA9PT0gVE9QX01PVVNFX09WRVIgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVkVSO1xuICAgIGNvbnN0IGlzT3V0RXZlbnQgPVxuICAgICAgdG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1VUIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1VUO1xuXG4gICAgaWYgKGlzT3ZlckV2ZW50ICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFpc091dEV2ZW50ICYmICFpc092ZXJFdmVudCkge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBvciBwb2ludGVyIGluIG9yIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgY29uc3QgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZyb207XG4gICAgbGV0IHRvO1xuICAgIGlmIChpc091dEV2ZW50KSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIGNvbnN0IHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGV2ZW50SW50ZXJmYWNlLCBsZWF2ZUV2ZW50VHlwZSwgZW50ZXJFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeDtcblxuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1ZFUikge1xuICAgICAgZXZlbnRJbnRlcmZhY2UgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgbGVhdmVFdmVudFR5cGUgPSBldmVudFR5cGVzLm1vdXNlTGVhdmU7XG4gICAgICBlbnRlckV2ZW50VHlwZSA9IGV2ZW50VHlwZXMubW91c2VFbnRlcjtcbiAgICAgIGV2ZW50VHlwZVByZWZpeCA9ICdtb3VzZSc7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1VUIHx8XG4gICAgICB0b3BMZXZlbFR5cGUgPT09IFRPUF9QT0lOVEVSX09WRVJcbiAgICApIHtcbiAgICAgIGV2ZW50SW50ZXJmYWNlID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgbGVhdmVFdmVudFR5cGUgPSBldmVudFR5cGVzLnBvaW50ZXJMZWF2ZTtcbiAgICAgIGVudGVyRXZlbnRUeXBlID0gZXZlbnRUeXBlcy5wb2ludGVyRW50ZXI7XG4gICAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gICAgfVxuXG4gICAgY29uc3QgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICAgIGNvbnN0IHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIGNvbnN0IGxlYXZlID0gZXZlbnRJbnRlcmZhY2UuZ2V0UG9vbGVkKFxuICAgICAgbGVhdmVFdmVudFR5cGUsXG4gICAgICBmcm9tLFxuICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgICApO1xuICAgIGxlYXZlLnR5cGUgPSBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICBjb25zdCBlbnRlciA9IGV2ZW50SW50ZXJmYWNlLmdldFBvb2xlZChcbiAgICAgIGVudGVyRXZlbnRUeXBlLFxuICAgICAgdG8sXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0LFxuICAgICk7XG4gICAgZW50ZXIudHlwZSA9IGV2ZW50VHlwZVByZWZpeCArICdlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcblxuICAgIHJldHVybiBbbGVhdmUsIGVudGVyXTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzfSBmcm9tICdldmVudHMvRXZlbnRQcm9wYWdhdG9ycyc7XG5pbXBvcnQge2NhblVzZURPTX0gZnJvbSAnc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50JztcbmltcG9ydCBTeW50aGV0aWNFdmVudCBmcm9tICdldmVudHMvU3ludGhldGljRXZlbnQnO1xuaW1wb3J0IGlzVGV4dElucHV0RWxlbWVudCBmcm9tICdzaGFyZWQvaXNUZXh0SW5wdXRFbGVtZW50JztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnc2hhcmVkL3NoYWxsb3dFcXVhbCc7XG5cbmltcG9ydCB7XG4gIFRPUF9CTFVSLFxuICBUT1BfQ09OVEVYVF9NRU5VLFxuICBUT1BfRFJBR19FTkQsXG4gIFRPUF9GT0NVUyxcbiAgVE9QX0tFWV9ET1dOLFxuICBUT1BfS0VZX1VQLFxuICBUT1BfTU9VU0VfRE9XTixcbiAgVE9QX01PVVNFX1VQLFxuICBUT1BfU0VMRUNUSU9OX0NIQU5HRSxcbn0gZnJvbSAnLi9ET01Ub3BMZXZlbEV2ZW50VHlwZXMnO1xuaW1wb3J0IHtpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzfSBmcm9tICcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcic7XG5pbXBvcnQgZ2V0QWN0aXZlRWxlbWVudCBmcm9tICcuLi9jbGllbnQvZ2V0QWN0aXZlRWxlbWVudCc7XG5pbXBvcnQge2dldE5vZGVGcm9tSW5zdGFuY2V9IGZyb20gJy4uL2NsaWVudC9SZWFjdERPTUNvbXBvbmVudFRyZWUnO1xuaW1wb3J0IHtoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXN9IGZyb20gJy4uL2NsaWVudC9SZWFjdElucHV0U2VsZWN0aW9uJztcbmltcG9ydCB7RE9DVU1FTlRfTk9ERX0gZnJvbSAnLi4vc2hhcmVkL0hUTUxOb2RlVHlwZSc7XG5cbmNvbnN0IHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9XG4gIGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbmNvbnN0IGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnLFxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICBUT1BfQkxVUixcbiAgICAgIFRPUF9DT05URVhUX01FTlUsXG4gICAgICBUT1BfRFJBR19FTkQsXG4gICAgICBUT1BfRk9DVVMsXG4gICAgICBUT1BfS0VZX0RPV04sXG4gICAgICBUT1BfS0VZX1VQLFxuICAgICAgVE9QX01PVVNFX0RPV04sXG4gICAgICBUT1BfTU9VU0VfVVAsXG4gICAgICBUT1BfU0VMRUNUSU9OX0NIQU5HRSxcbiAgICBdLFxuICB9LFxufTtcblxubGV0IGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xubGV0IGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbmxldCBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbmxldCBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmQsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3aW4gPVxuICAgICAgKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogR2V0IGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0RG9jdW1lbnQoZXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIGV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gZXZlbnRUYXJnZXRcbiAgICA/IGV2ZW50VGFyZ2V0LmRvY3VtZW50XG4gICAgOiBldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERVxuICAgICAgPyBldmVudFRhcmdldFxuICAgICAgOiBldmVudFRhcmdldC5vd25lckRvY3VtZW50O1xufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgY29uc3QgZG9jID0gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKFxuICAgIG1vdXNlRG93biB8fFxuICAgIGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fFxuICAgIGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoZG9jKVxuICApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIGNvbnN0IHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgZXZlbnRUeXBlcy5zZWxlY3QsXG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXQsXG4gICAgKTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG5jb25zdCBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgKSB7XG4gICAgY29uc3QgZG9jID0gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgLy8gVHJhY2sgd2hldGhlciBhbGwgbGlzdGVuZXJzIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4gICAgLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG4gICAgaWYgKCFkb2MgfHwgIWlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMoJ29uU2VsZWN0JywgZG9jKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSBUT1BfRk9DVVM6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHxcbiAgICAgICAgICB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnXG4gICAgICAgICkge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0NPTlRFWFRfTUVOVTpcbiAgICAgIGNhc2UgVE9QX01PVVNFX1VQOlxuICAgICAgY2FzZSBUT1BfRFJBR19FTkQ6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgVE9QX1NFTEVDVElPTl9DSEFOR0U6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0RXZlbnRQbHVnaW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJy4vUmVhY3RGaWJlcic7XG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5cbmltcG9ydCB7Z2V0IGFzIGdldEluc3RhbmNlfSBmcm9tICdzaGFyZWQvUmVhY3RJbnN0YW5jZU1hcCc7XG5pbXBvcnQgUmVhY3RTaGFyZWRJbnRlcm5hbHMgZnJvbSAnc2hhcmVkL1JlYWN0U2hhcmVkSW50ZXJuYWxzJztcbmltcG9ydCBnZXRDb21wb25lbnROYW1lIGZyb20gJ3NoYXJlZC9nZXRDb21wb25lbnROYW1lJztcbmltcG9ydCB7XG4gIENsYXNzQ29tcG9uZW50LFxuICBIb3N0Q29tcG9uZW50LFxuICBIb3N0Um9vdCxcbiAgSG9zdFBvcnRhbCxcbiAgSG9zdFRleHQsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCB7Tm9FZmZlY3QsIFBsYWNlbWVudH0gZnJvbSAnc2hhcmVkL1JlYWN0U2lkZUVmZmVjdFRhZ3MnO1xuXG5jb25zdCBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXG5jb25zdCBNT1VOVElORyA9IDE7XG5jb25zdCBNT1VOVEVEID0gMjtcbmNvbnN0IFVOTU9VTlRFRCA9IDM7XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcjogRmliZXIpOiBudW1iZXIge1xuICBsZXQgbm9kZSA9IGZpYmVyO1xuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgIHJldHVybiBNT1VOVElORztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIE1PVU5URUQ7XG4gIH1cbiAgLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuICByZXR1cm4gVU5NT1VOVEVEO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXI6IEZpYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudDogUmVhY3QkQ29tcG9uZW50PGFueSwgYW55Pik6IGJvb2xlYW4ge1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnN0IG93bmVyID0gKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ6IGFueSk7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IG93bmVyRmliZXI6IEZpYmVyID0gb3duZXI7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLFxuICAgICAgICAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICtcbiAgICAgICAgICAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICtcbiAgICAgICAgICAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArXG4gICAgICAgICAgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgK1xuICAgICAgICAgICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50JyxcbiAgICAgICk7XG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpYmVyOiA/RmliZXIgPSBnZXRJbnN0YW5jZShjb21wb25lbnQpO1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgaW52YXJpYW50KFxuICAgIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQsXG4gICAgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXI6IEZpYmVyKTogRmliZXIgfCBudWxsIHtcbiAgbGV0IGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgY29uc3Qgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgIGludmFyaWFudChcbiAgICAgIHN0YXRlICE9PSBVTk1PVU5URUQsXG4gICAgICAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicsXG4gICAgKTtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIGxldCBhID0gZmliZXI7XG4gIGxldCBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgbGV0IHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIGxldCBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICBsZXQgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICBsZXQgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQsXG4gICAgICAgICAgJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgK1xuICAgICAgICAgICAgJ2luIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGludmFyaWFudChcbiAgICAgIGEuYWx0ZXJuYXRlID09PSBiLFxuICAgICAgXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiICtcbiAgICAgICAgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICApO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgaW52YXJpYW50KFxuICAgIGEudGFnID09PSBIb3N0Um9vdCxcbiAgICAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicsXG4gICk7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQ6IEZpYmVyKTogRmliZXIgfCBudWxsIHtcbiAgY29uc3QgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgbGV0IG5vZGU6IEZpYmVyID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50OiBGaWJlcik6IEZpYmVyIHwgbnVsbCB7XG4gIGNvbnN0IGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIGxldCBub2RlOiBGaWJlciA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclRyZWVSZWZsZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKFxuICBlbGVtZW50OiBEb2N1bWVudCB8IEVsZW1lbnQsXG4gIGV2ZW50VHlwZTogc3RyaW5nLFxuICBsaXN0ZW5lcjogRnVuY3Rpb24sXG4pOiB2b2lkIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKFxuICBlbGVtZW50OiBEb2N1bWVudCB8IEVsZW1lbnQsXG4gIGV2ZW50VHlwZTogc3RyaW5nLFxuICBsaXN0ZW5lcjogRnVuY3Rpb24sXG4pOiB2b2lkIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHRydWUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvRXZlbnRMaXN0ZW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IFN5bnRoZXRpY0V2ZW50IGZyb20gJ2V2ZW50cy9TeW50aGV0aWNFdmVudCc7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xuY29uc3QgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbCxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgU3ludGhldGljRXZlbnQgZnJvbSAnZXZlbnRzL1N5bnRoZXRpY0V2ZW50JztcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG5jb25zdCBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudFxuICAgICAgPyBldmVudC5jbGlwYm9hcmREYXRhXG4gICAgICA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBTeW50aGV0aWNVSUV2ZW50IGZyb20gJy4vU3ludGhldGljVUlFdmVudCc7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuY29uc3QgU3ludGhldGljRm9jdXNFdmVudCA9IFN5bnRoZXRpY1VJRXZlbnQuZXh0ZW5kKHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbCxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9ldmVudHMvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IFN5bnRoZXRpY1VJRXZlbnQgZnJvbSAnLi9TeW50aGV0aWNVSUV2ZW50JztcbmltcG9ydCBnZXRFdmVudENoYXJDb2RlIGZyb20gJy4vZ2V0RXZlbnRDaGFyQ29kZSc7XG5pbXBvcnQgZ2V0RXZlbnRLZXkgZnJvbSAnLi9nZXRFdmVudEtleSc7XG5pbXBvcnQgZ2V0RXZlbnRNb2RpZmllclN0YXRlIGZyb20gJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJztcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5jb25zdCBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU3ludGhldGljS2V5Ym9hcmRFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IGdldEV2ZW50Q2hhckNvZGUgZnJvbSAnLi9nZXRFdmVudENoYXJDb2RlJztcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5jb25zdCBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJyxcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5jb25zdCB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJyxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudDogS2V5Ym9hcmRFdmVudCk6IHN0cmluZyB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIGNvbnN0IGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0RXZlbnRLZXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2V2ZW50cy9nZXRFdmVudEtleS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IFN5bnRoZXRpY01vdXNlRXZlbnQgZnJvbSAnLi9TeW50aGV0aWNNb3VzZUV2ZW50JztcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbmNvbnN0IFN5bnRoZXRpY0RyYWdFdmVudCA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZXh0ZW5kKHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IFN5bnRoZXRpY1VJRXZlbnQgZnJvbSAnLi9TeW50aGV0aWNVSUV2ZW50JztcbmltcG9ydCBnZXRFdmVudE1vZGlmaWVyU3RhdGUgZnJvbSAnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbmNvbnN0IFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU3ludGhldGljVG91Y2hFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBTeW50aGV0aWNFdmVudCBmcm9tICdldmVudHMvU3ludGhldGljRXZlbnQnO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG5jb25zdCBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IFN5bnRoZXRpY01vdXNlRXZlbnQgZnJvbSAnLi9TeW50aGV0aWNNb3VzZUV2ZW50JztcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5jb25zdCBTeW50aGV0aWNXaGVlbEV2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBkZWx0YVgoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnRcbiAgICAgID8gZXZlbnQuZGVsdGFYXG4gICAgICA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnRcbiAgICAgICAgPyAtZXZlbnQud2hlZWxEZWx0YVhcbiAgICAgICAgOiAwO1xuICB9LFxuICBkZWx0YVkoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnRcbiAgICAgID8gZXZlbnQuZGVsdGFZXG4gICAgICA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAgICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudFxuICAgICAgICA/IC1ldmVudC53aGVlbERlbHRhWVxuICAgICAgICA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAgICAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnRcbiAgICAgICAgICA/IC1ldmVudC53aGVlbERlbHRhXG4gICAgICAgICAgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGwsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU3ludGhldGljV2hlZWxFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvZXZlbnRzL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBnZXRBY3RpdmVFbGVtZW50IGZyb20gJy4vZ2V0QWN0aXZlRWxlbWVudCc7XG5cbmltcG9ydCB7Z2V0T2Zmc2V0cywgc2V0T2Zmc2V0c30gZnJvbSAnLi9SZWFjdERPTVNlbGVjdGlvbic7XG5pbXBvcnQge0VMRU1FTlRfTk9ERSwgVEVYVF9OT0RFfSBmcm9tICcuLi9zaGFyZWQvSFRNTE5vZGVUeXBlJztcblxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiAoXG4gICAgbm9kZSAmJlxuICAgIG5vZGUub3duZXJEb2N1bWVudCAmJlxuICAgIGNvbnRhaW5zTm9kZShub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50RGVlcCgpIHtcbiAgbGV0IHdpbiA9IHdpbmRvdztcbiAgbGV0IGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHdoaWxlIChlbGVtZW50IGluc3RhbmNlb2Ygd2luLkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyB0byB0aHJvdywgZS5nLiBpZiBpdCBoYXMgYSBjcm9zcy1vcmlnaW4gc3JjIGF0dHJpYnV0ZVxuICAgIHRyeSB7XG4gICAgICB3aW4gPSBlbGVtZW50LmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQod2luLmRvY3VtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuLyoqXG4gKiBAaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiB3ZSBnZXQgdGhlIGVsZW1lbnQgdHlwZXMgdGhhdCBzdXBwb3J0IHNlbGVjdGlvblxuICogZnJvbSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNkby1ub3QtYXBwbHksIGxvb2tpbmcgYXQgYHNlbGVjdGlvblN0YXJ0YFxuICogYW5kIGBzZWxlY3Rpb25FbmRgIHJvd3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICBjb25zdCBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAoXG4gICAgbm9kZU5hbWUgJiZcbiAgICAoKG5vZGVOYW1lID09PSAnaW5wdXQnICYmXG4gICAgICAoZWxlbS50eXBlID09PSAndGV4dCcgfHxcbiAgICAgICAgZWxlbS50eXBlID09PSAnc2VhcmNoJyB8fFxuICAgICAgICBlbGVtLnR5cGUgPT09ICd0ZWwnIHx8XG4gICAgICAgIGVsZW0udHlwZSA9PT0gJ3VybCcgfHxcbiAgICAgICAgZWxlbS50eXBlID09PSAncGFzc3dvcmQnKSkgfHxcbiAgICAgIG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8XG4gICAgICBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIGNvbnN0IGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSlcbiAgICAgID8gZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKVxuICAgICAgOiBudWxsLFxuICB9O1xufVxuXG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICBjb25zdCBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKCk7XG4gIGNvbnN0IHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICBjb25zdCBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChcbiAgICAgIHByaW9yU2VsZWN0aW9uUmFuZ2UgIT09IG51bGwgJiZcbiAgICAgIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKVxuICAgICkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgY29uc3QgYW5jZXN0b3JzID0gW107XG4gICAgbGV0IGFuY2VzdG9yID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICB3aGlsZSAoKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oaW5wdXQpIHtcbiAgbGV0IHNlbGVjdGlvbjtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmQsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwge3N0YXJ0OiAwLCBlbmQ6IDB9O1xufVxuXG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIGxldCB7c3RhcnQsIGVuZH0gPSBvZmZzZXRzO1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0IGZyb20gJy4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCc7XG5pbXBvcnQge1RFWFRfTk9ERX0gZnJvbSAnLi4vc2hhcmVkL0hUTUxOb2RlVHlwZSc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICBjb25zdCB7b3duZXJEb2N1bWVudH0gPSBvdXRlck5vZGU7XG4gIGNvbnN0IHdpbiA9IChvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbiAgY29uc3Qgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbiAmJiB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXR9ID0gc2VsZWN0aW9uO1xuXG4gIC8vIEluIEZpcmVmb3gsIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBjYW4gYmUgXCJhbm9ueW1vdXMgZGl2c1wiLCBlLmcuIHRoZVxuICAvLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4gIC8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbiAgLy8gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZSB3YXkgdG8gYXZvaWQgZXJyb3JpbmdcbiAgLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbiAgLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhcbiAgICBvdXRlck5vZGUsXG4gICAgYW5jaG9yTm9kZSxcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNOb2RlLFxuICAgIGZvY3VzT2Zmc2V0LFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKFxuICBvdXRlck5vZGUsXG4gIGFuY2hvck5vZGUsXG4gIGFuY2hvck9mZnNldCxcbiAgZm9jdXNOb2RlLFxuICBmb2N1c09mZnNldCxcbikge1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgbGV0IGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICBsZXQgbm9kZSA9IG91dGVyTm9kZTtcbiAgbGV0IHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG5vZGUgPT09IGFuY2hvck5vZGUgJiZcbiAgICAgICAgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpXG4gICAgICApIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIG5vZGUgPT09IGZvY3VzTm9kZSAmJlxuICAgICAgICAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKVxuICAgICAgKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kLFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBjb25zdCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIGNvbnN0IHdpbiA9IChkb2MgJiYgZG9jLmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG5cbiAgLy8gRWRnZSBmYWlscyB3aXRoIFwiT2JqZWN0IGV4cGVjdGVkXCIgaW4gc29tZSBzY2VuYXJpb3MuXG4gIC8vIChGb3IgaW5zdGFuY2U6IFRpbnlNQ0UgZWRpdG9yIHVzZWQgaW4gYSBsaXN0IGNvbXBvbmVudCB0aGF0IHN1cHBvcnRzIHBhc3RpbmcgdG8gYWRkIG1vcmUsXG4gIC8vIGZhaWxzIHdoZW4gcGFzdGluZyAxMDArIGl0ZW1zKVxuICBpZiAoIXdpbi5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gIGNvbnN0IGxlbmd0aCA9IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICBsZXQgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgbGV0IHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgY29uc3QgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoXG4gICAgICBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJlxuICAgICAgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiZcbiAgICAgIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJlxuICAgICAgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiZcbiAgICAgIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvUmVhY3RET01TZWxlY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtURVhUX05PREV9IGZyb20gJy4uL3NoYXJlZC9IVE1MTm9kZVR5cGUnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3Q6IEVsZW1lbnQsIG9mZnNldDogbnVtYmVyKTogP09iamVjdCB7XG4gIGxldCBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIGxldCBub2RlU3RhcnQgPSAwO1xuICBsZXQgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydCxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIGZpbGUgaW50ZW50aW9uYWxseSBkb2VzICpub3QqIGhhdmUgdGhlIEZsb3cgYW5ub3RhdGlvbi5cbi8vIERvbid0IGFkZCBpdC4gU2VlIGAuL2lubGluZS10eXBlZC5qc2AgZm9yIGFuIGV4cGxhbmF0aW9uLlxuXG5leHBvcnQgKiBmcm9tICcuL3NyYy9SZWFjdEZpYmVyUmVjb25jaWxlcic7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL2lubGluZS5kb20uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0ZpYmVyUm9vdH0gZnJvbSAnLi9SZWFjdEZpYmVyUm9vdCc7XG5pbXBvcnQgdHlwZSB7XG4gIEluc3RhbmNlLFxuICBUZXh0SW5zdGFuY2UsXG4gIENvbnRhaW5lcixcbiAgUHVibGljSW5zdGFuY2UsXG59IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb25maWcnO1xuaW1wb3J0IHR5cGUge1JlYWN0Tm9kZUxpc3R9IGZyb20gJ3NoYXJlZC9SZWFjdFR5cGVzJztcbmltcG9ydCB0eXBlIHtFeHBpcmF0aW9uVGltZX0gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuXG5pbXBvcnQge1xuICBmaW5kQ3VycmVudEhvc3RGaWJlcixcbiAgZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzLFxufSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3JlZmxlY3Rpb24nO1xuaW1wb3J0IHtnZXQgYXMgZ2V0SW5zdGFuY2V9IGZyb20gJ3NoYXJlZC9SZWFjdEluc3RhbmNlTWFwJztcbmltcG9ydCB7SG9zdENvbXBvbmVudCwgQ2xhc3NDb21wb25lbnR9IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCBnZXRDb21wb25lbnROYW1lIGZyb20gJ3NoYXJlZC9nZXRDb21wb25lbnROYW1lJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG5pbXBvcnQgUmVhY3RTaGFyZWRJbnRlcm5hbHMgZnJvbSAnc2hhcmVkL1JlYWN0U2hhcmVkSW50ZXJuYWxzJztcblxuaW1wb3J0IHtnZXRQdWJsaWNJbnN0YW5jZX0gZnJvbSAnLi9SZWFjdEZpYmVySG9zdENvbmZpZyc7XG5pbXBvcnQge1xuICBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCxcbiAgcHJvY2Vzc0NoaWxkQ29udGV4dCxcbiAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICBpc0NvbnRleHRQcm92aWRlciBhcyBpc0xlZ2FjeUNvbnRleHRQcm92aWRlcixcbn0gZnJvbSAnLi9SZWFjdEZpYmVyQ29udGV4dCc7XG5pbXBvcnQge2NyZWF0ZUZpYmVyUm9vdH0gZnJvbSAnLi9SZWFjdEZpYmVyUm9vdCc7XG5pbXBvcnQge2luamVjdEludGVybmFsc30gZnJvbSAnLi9SZWFjdEZpYmVyRGV2VG9vbHNIb29rJztcbmltcG9ydCB7XG4gIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24sXG4gIHJlcXVlc3RDdXJyZW50VGltZSxcbiAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgc2NoZWR1bGVXb3JrLFxuICByZXF1ZXN0V29yayxcbiAgZmx1c2hSb290LFxuICBiYXRjaGVkVXBkYXRlcyxcbiAgdW5iYXRjaGVkVXBkYXRlcyxcbiAgZmx1c2hTeW5jLFxuICBmbHVzaENvbnRyb2xsZWQsXG4gIGRlZmVycmVkVXBkYXRlcyxcbiAgc3luY1VwZGF0ZXMsXG4gIGludGVyYWN0aXZlVXBkYXRlcyxcbiAgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMsXG59IGZyb20gJy4vUmVhY3RGaWJlclNjaGVkdWxlcic7XG5pbXBvcnQge2NyZWF0ZVVwZGF0ZSwgZW5xdWV1ZVVwZGF0ZX0gZnJvbSAnLi9SZWFjdFVwZGF0ZVF1ZXVlJztcbmltcG9ydCBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uIGZyb20gJy4vUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbic7XG5pbXBvcnQge1xuICBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QsXG4gIHBoYXNlIGFzIFJlYWN0Q3VycmVudEZpYmVyUGhhc2UsXG4gIGN1cnJlbnQgYXMgUmVhY3RDdXJyZW50RmliZXJDdXJyZW50LFxufSBmcm9tICcuL1JlYWN0Q3VycmVudEZpYmVyJztcbmltcG9ydCB7U3RyaWN0TW9kZX0gZnJvbSAnLi9SZWFjdFR5cGVPZk1vZGUnO1xuaW1wb3J0IHtTeW5jfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5cbnR5cGUgT3BhcXVlUm9vdCA9IEZpYmVyUm9vdDtcblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxudHlwZSBCdW5kbGVUeXBlID0gMCB8IDE7XG5cbnR5cGUgRGV2VG9vbHNDb25maWcgPSB7fFxuICBidW5kbGVUeXBlOiBCdW5kbGVUeXBlLFxuICB2ZXJzaW9uOiBzdHJpbmcsXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6IHN0cmluZyxcbiAgLy8gTm90ZTogdGhpcyBhY3R1YWxseSAqZG9lcyogZGVwZW5kIG9uIEZpYmVyIGludGVybmFsIGZpZWxkcy5cbiAgLy8gVXNlZCBieSBcImluc3BlY3QgY2xpY2tlZCBET00gZWxlbWVudFwiIGluIFJlYWN0IERldlRvb2xzLlxuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZT86IChpbnN0YW5jZTogSW5zdGFuY2UgfCBUZXh0SW5zdGFuY2UpID0+IEZpYmVyLFxuICAvLyBVc2VkIGJ5IFJOIGluLWFwcCBpbnNwZWN0b3IuXG4gIC8vIFRoaXMgQVBJIGlzIHVuZm9ydHVuYXRlbHkgUk4tc3BlY2lmaWMuXG4gIC8vIFRPRE86IENoYW5nZSBpdCB0byBhY2NlcHQgRmliZXIgaW5zdGVhZCBhbmQgdHlwZSBpdCBwcm9wZXJseS5cbiAgZ2V0SW5zcGVjdG9yRGF0YUZvclZpZXdUYWc/OiAodGFnOiBudW1iZXIpID0+IE9iamVjdCxcbnx9O1xuXG5sZXQgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcztcbmxldCBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZTtcblxuaWYgKF9fREVWX18pIHtcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShcbiAgcGFyZW50Q29tcG9uZW50OiA/UmVhY3QkQ29tcG9uZW50PGFueSwgYW55Pixcbik6IE9iamVjdCB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIGNvbnN0IGZpYmVyID0gZ2V0SW5zdGFuY2UocGFyZW50Q29tcG9uZW50KTtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG4gICAgaWYgKGlzTGVnYWN5Q29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBDb21wb25lbnQsIHBhcmVudENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVJvb3RVcGRhdGUoXG4gIGN1cnJlbnQ6IEZpYmVyLFxuICBlbGVtZW50OiBSZWFjdE5vZGVMaXN0LFxuICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIGNhbGxiYWNrOiA/RnVuY3Rpb24sXG4pIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoXG4gICAgICBSZWFjdEN1cnJlbnRGaWJlclBoYXNlID09PSAncmVuZGVyJyAmJlxuICAgICAgUmVhY3RDdXJyZW50RmliZXJDdXJyZW50ICE9PSBudWxsICYmXG4gICAgICAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlc1xuICAgICkge1xuICAgICAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IHRydWU7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICtcbiAgICAgICAgICAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgK1xuICAgICAgICAgICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgK1xuICAgICAgICAgICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLFxuICAgICAgICBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudEZpYmVyQ3VycmVudC50eXBlKSB8fCAnVW5rbm93bicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gIC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuICB1cGRhdGUucGF5bG9hZCA9IHtlbGVtZW50fTtcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsXG4gICAgICAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICtcbiAgICAgICAgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLFxuICAgICAgY2FsbGJhY2ssXG4gICAgKTtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50LCB1cGRhdGUpO1xuICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuXG4gIHJldHVybiBleHBpcmF0aW9uVGltZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUoXG4gIGVsZW1lbnQ6IFJlYWN0Tm9kZUxpc3QsXG4gIGNvbnRhaW5lcjogT3BhcXVlUm9vdCxcbiAgcGFyZW50Q29tcG9uZW50OiA/UmVhY3QkQ29tcG9uZW50PGFueSwgYW55PixcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICBjYWxsYmFjazogP0Z1bmN0aW9uLFxuKSB7XG4gIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICBjb25zdCBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wpIHtcbiAgICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBzY2hlZHVsZVJvb3RVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQ6IE9iamVjdCk6IFB1YmxpY0luc3RhbmNlIHwgbnVsbCB7XG4gIGNvbnN0IGZpYmVyID0gZ2V0SW5zdGFuY2UoY29tcG9uZW50KTtcbiAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ0FyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6ICVzJyxcbiAgICAgICAgT2JqZWN0LmtleXMoY29tcG9uZW50KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoXG4gIGNvbXBvbmVudDogT2JqZWN0LFxuICBtZXRob2ROYW1lOiBzdHJpbmcsXG4pOiBQdWJsaWNJbnN0YW5jZSB8IG51bGwge1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnN0IGZpYmVyID0gZ2V0SW5zdGFuY2UoY29tcG9uZW50KTtcbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogJXMnLFxuICAgICAgICAgIE9iamVjdC5rZXlzKGNvbXBvbmVudCksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJyVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJyArXG4gICAgICAgICAgICAgICclcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIGlzIGluc2lkZSBTdHJpY3RNb2RlLiAnICtcbiAgICAgICAgICAgICAgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuJyArXG4gICAgICAgICAgICAgICdcXG4lcycgK1xuICAgICAgICAgICAgICAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgK1xuICAgICAgICAgICAgICAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1maW5kLW5vZGUnLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGhvc3RGaWJlciksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICtcbiAgICAgICAgICAgICAgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICtcbiAgICAgICAgICAgICAgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuJyArXG4gICAgICAgICAgICAgICdcXG4lcycgK1xuICAgICAgICAgICAgICAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgK1xuICAgICAgICAgICAgICAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1maW5kLW5vZGUnLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGhvc3RGaWJlciksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKFxuICBjb250YWluZXJJbmZvOiBDb250YWluZXIsXG4gIGlzQ29uY3VycmVudDogYm9vbGVhbixcbiAgaHlkcmF0ZTogYm9vbGVhbixcbik6IE9wYXF1ZVJvb3Qge1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGlzQ29uY3VycmVudCwgaHlkcmF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDb250YWluZXIoXG4gIGVsZW1lbnQ6IFJlYWN0Tm9kZUxpc3QsXG4gIGNvbnRhaW5lcjogT3BhcXVlUm9vdCxcbiAgcGFyZW50Q29tcG9uZW50OiA/UmVhY3QkQ29tcG9uZW50PGFueSwgYW55PixcbiAgY2FsbGJhY2s6ID9GdW5jdGlvbixcbik6IEV4cGlyYXRpb25UaW1lIHtcbiAgY29uc3QgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuICBjb25zdCBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICBjb25zdCBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGN1cnJlbnQpO1xuICByZXR1cm4gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShcbiAgICBlbGVtZW50LFxuICAgIGNvbnRhaW5lcixcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgZXhwaXJhdGlvblRpbWUsXG4gICAgY2FsbGJhY2ssXG4gICk7XG59XG5cbmV4cG9ydCB7XG4gIGZsdXNoUm9vdCxcbiAgcmVxdWVzdFdvcmssXG4gIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24sXG4gIGJhdGNoZWRVcGRhdGVzLFxuICB1bmJhdGNoZWRVcGRhdGVzLFxuICBkZWZlcnJlZFVwZGF0ZXMsXG4gIHN5bmNVcGRhdGVzLFxuICBpbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzLFxuICBmbHVzaENvbnRyb2xsZWQsXG4gIGZsdXNoU3luYyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoXG4gIGNvbnRhaW5lcjogT3BhcXVlUm9vdCxcbik6IFJlYWN0JENvbXBvbmVudDxhbnksIGFueT4gfCBQdWJsaWNJbnN0YW5jZSB8IG51bGwge1xuICBjb25zdCBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5leHBvcnQge2ZpbmRIb3N0SW5zdGFuY2V9O1xuXG5leHBvcnQge2ZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZ307XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhcbiAgZmliZXI6IEZpYmVyLFxuKTogUHVibGljSW5zdGFuY2UgfCBudWxsIHtcbiAgY29uc3QgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5sZXQgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG5cbmlmIChfX0RFVl9fKSB7XG4gIGNvbnN0IGNvcHlXaXRoU2V0SW1wbCA9IChcbiAgICBvYmo6IE9iamVjdCB8IEFycmF5PGFueT4sXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgICBpZHg6IG51bWJlcixcbiAgICB2YWx1ZTogYW55LFxuICApID0+IHtcbiAgICBpZiAoaWR4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHBhdGhbaWR4XTtcbiAgICBjb25zdCB1cGRhdGVkID0gQXJyYXkuaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiB7Li4ub2JqfTtcbiAgICAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpZHggKyAxLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgY29uc3QgY29weVdpdGhTZXQgPSAoXG4gICAgb2JqOiBPYmplY3QgfCBBcnJheTxhbnk+LFxuICAgIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICAgdmFsdWU6IGFueSxcbiAgKTogT2JqZWN0IHwgQXJyYXk8YW55PiA9PiB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cbiAgb3ZlcnJpZGVQcm9wcyA9IChmaWJlcjogRmliZXIsIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sIHZhbHVlOiBhbnkpID0+IHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuICAgIHNjaGVkdWxlV29yayhmaWJlciwgU3luYyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWc6IERldlRvb2xzQ29uZmlnKTogYm9vbGVhbiB7XG4gIGNvbnN0IHtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZX0gPSBkZXZUb29sc0NvbmZpZztcbiAgY29uc3Qge1JlYWN0Q3VycmVudERpc3BhdGNoZXJ9ID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5cbiAgcmV0dXJuIGluamVjdEludGVybmFscyh7XG4gICAgLi4uZGV2VG9vbHNDb25maWcsXG4gICAgb3ZlcnJpZGVQcm9wcyxcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcjogRmliZXIpOiBJbnN0YW5jZSB8IFRleHRJbnN0YW5jZSB8IG51bGwge1xuICAgICAgY29uc3QgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2U6IEluc3RhbmNlIHwgVGV4dEluc3RhbmNlKTogRmliZXIgfCBudWxsIHtcbiAgICAgIGlmICghZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclJlY29uY2lsZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0V4cGlyYXRpb25UaW1lfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQgdHlwZSB7VGltZW91dEhhbmRsZSwgTm9UaW1lb3V0fSBmcm9tICcuL1JlYWN0RmliZXJIb3N0Q29uZmlnJztcbmltcG9ydCB0eXBlIHtUaGVuYWJsZX0gZnJvbSAnLi9SZWFjdEZpYmVyU2NoZWR1bGVyJztcbmltcG9ydCB0eXBlIHtJbnRlcmFjdGlvbn0gZnJvbSAnc2NoZWR1bGVyL3NyYy9UcmFjaW5nJztcblxuaW1wb3J0IHtub1RpbWVvdXR9IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb25maWcnO1xuaW1wb3J0IHtjcmVhdGVIb3N0Um9vdEZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHtOb1dvcmt9IGZyb20gJy4vUmVhY3RGaWJlckV4cGlyYXRpb25UaW1lJztcbmltcG9ydCB7ZW5hYmxlU2NoZWR1bGVyVHJhY2luZ30gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcbmltcG9ydCB7dW5zdGFibGVfZ2V0VGhyZWFkSUR9IGZyb20gJ3NjaGVkdWxlci90cmFjaW5nJztcblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbGlmdGVkIGludG8gdGhlIHJlbmRlcmVyLlxuZXhwb3J0IHR5cGUgQmF0Y2ggPSB7XG4gIF9kZWZlcjogYm9vbGVhbixcbiAgX2V4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAgX29uQ29tcGxldGU6ICgpID0+IG1peGVkLFxuICBfbmV4dDogQmF0Y2ggfCBudWxsLFxufTtcblxuZXhwb3J0IHR5cGUgUGVuZGluZ0ludGVyYWN0aW9uTWFwID0gTWFwPEV4cGlyYXRpb25UaW1lLCBTZXQ8SW50ZXJhY3Rpb24+PjtcblxudHlwZSBCYXNlRmliZXJSb290UHJvcGVydGllcyA9IHt8XG4gIC8vIEFueSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZyb20gdGhlIGhvc3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcm9vdC5cbiAgY29udGFpbmVySW5mbzogYW55LFxuICAvLyBVc2VkIG9ubHkgYnkgcGVyc2lzdGVudCB1cGRhdGVzLlxuICBwZW5kaW5nQ2hpbGRyZW46IGFueSxcbiAgLy8gVGhlIGN1cnJlbnRseSBhY3RpdmUgcm9vdCBmaWJlci4gVGhpcyBpcyB0aGUgbXV0YWJsZSByb290IG9mIHRoZSB0cmVlLlxuICBjdXJyZW50OiBGaWJlcixcblxuICAvLyBUaGUgZm9sbG93aW5nIHByaW9yaXR5IGxldmVscyBhcmUgdXNlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDEpXG4gIC8vIHVuY29tbWl0dGVkIHdvcmssIDIpIHVuY29tbWl0dGVkIHdvcmsgdGhhdCBpcyBzdXNwZW5kZWQsIGFuZCAzKSB1bmNvbW1pdHRlZFxuICAvLyB3b3JrIHRoYXQgbWF5IGJlIHVuc3VzcGVuZGVkLiBXZSBjaG9vc2Ugbm90IHRvIHRyYWNrIGVhY2ggaW5kaXZpZHVhbFxuICAvLyBwZW5kaW5nIGxldmVsLCB0cmFkaW5nIGdyYW51bGFyaXR5IGZvciBwZXJmb3JtYW5jZS5cbiAgLy9cbiAgLy8gVGhlIGVhcmxpZXN0IGFuZCBsYXRlc3QgcHJpb3JpdHkgbGV2ZWxzIHRoYXQgYXJlIHN1c3BlbmRlZCBmcm9tIGNvbW1pdHRpbmcuXG4gIGVhcmxpZXN0U3VzcGVuZGVkVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIGxhdGVzdFN1c3BlbmRlZFRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICAvLyBUaGUgZWFybGllc3QgYW5kIGxhdGVzdCBwcmlvcml0eSBsZXZlbHMgdGhhdCBhcmUgbm90IGtub3duIHRvIGJlIHN1c3BlbmRlZC5cbiAgZWFybGllc3RQZW5kaW5nVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIGxhdGVzdFBlbmRpbmdUaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAgLy8gVGhlIGxhdGVzdCBwcmlvcml0eSBsZXZlbCB0aGF0IHdhcyBwaW5nZWQgYnkgYSByZXNvbHZlZCBwcm9taXNlIGFuZCBjYW5cbiAgLy8gYmUgcmV0cmllZC5cbiAgbGF0ZXN0UGluZ2VkVGltZTogRXhwaXJhdGlvblRpbWUsXG5cbiAgcGluZ0NhY2hlOlxuICAgIHwgV2Vha01hcDxUaGVuYWJsZSwgU2V0PEV4cGlyYXRpb25UaW1lPj5cbiAgICB8IE1hcDxUaGVuYWJsZSwgU2V0PEV4cGlyYXRpb25UaW1lPj5cbiAgICB8IG51bGwsXG5cbiAgLy8gSWYgYW4gZXJyb3IgaXMgdGhyb3duLCBhbmQgdGhlcmUgYXJlIG5vIG1vcmUgdXBkYXRlcyBpbiB0aGUgcXVldWUsIHdlIHRyeVxuICAvLyByZW5kZXJpbmcgZnJvbSB0aGUgcm9vdCBvbmUgbW9yZSB0aW1lLCBzeW5jaHJvbm91c2x5LCBiZWZvcmUgaGFuZGxpbmdcbiAgLy8gdGhlIGVycm9yLlxuICBkaWRFcnJvcjogYm9vbGVhbixcblxuICBwZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICAvLyBBIGZpbmlzaGVkIHdvcmstaW4tcHJvZ3Jlc3MgSG9zdFJvb3QgdGhhdCdzIHJlYWR5IHRvIGJlIGNvbW1pdHRlZC5cbiAgZmluaXNoZWRXb3JrOiBGaWJlciB8IG51bGwsXG4gIC8vIFRpbWVvdXQgaGFuZGxlIHJldHVybmVkIGJ5IHNldFRpbWVvdXQuIFVzZWQgdG8gY2FuY2VsIGEgcGVuZGluZyB0aW1lb3V0LCBpZlxuICAvLyBpdCdzIHN1cGVyc2VkZWQgYnkgYSBuZXcgb25lLlxuICB0aW1lb3V0SGFuZGxlOiBUaW1lb3V0SGFuZGxlIHwgTm9UaW1lb3V0LFxuICAvLyBUb3AgY29udGV4dCBvYmplY3QsIHVzZWQgYnkgcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiAgY29udGV4dDogT2JqZWN0IHwgbnVsbCxcbiAgcGVuZGluZ0NvbnRleHQ6IE9iamVjdCB8IG51bGwsXG4gIC8vIERldGVybWluZXMgaWYgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gaHlkcmF0ZSBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAraHlkcmF0ZTogYm9vbGVhbixcbiAgLy8gUmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSBvbiB0aGlzIHJvb3QuXG4gIC8vIFRPRE86IExpZnQgdGhpcyBpbnRvIHRoZSByZW5kZXJlclxuICBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjogRXhwaXJhdGlvblRpbWUsXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAgLy8gTGlzdCBvZiB0b3AtbGV2ZWwgYmF0Y2hlcy4gVGhpcyBsaXN0IGluZGljYXRlcyB3aGV0aGVyIGEgY29tbWl0IHNob3VsZCBiZVxuICAvLyBkZWZlcnJlZC4gQWxzbyBjb250YWlucyBjb21wbGV0aW9uIGNhbGxiYWNrcy5cbiAgLy8gVE9ETzogTGlmdCB0aGlzIGludG8gdGhlIHJlbmRlcmVyXG4gIGZpcnN0QmF0Y2g6IEJhdGNoIHwgbnVsbCxcbiAgLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbiAgbmV4dFNjaGVkdWxlZFJvb3Q6IEZpYmVyUm9vdCB8IG51bGwsXG58fTtcblxuLy8gVGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIGFyZSBvbmx5IHVzZWQgYnkgaW50ZXJhY3Rpb24gdHJhY2luZyBidWlsZHMuXG4vLyBUaGV5IGVuYWJsZSBpbnRlcmFjdGlvbnMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIGFzeW5jIHdvcmssXG4vLyBBbmQgZXhwb3NlIGludGVyYWN0aW9uIG1ldGFkYXRhIHRvIHRoZSBSZWFjdCBEZXZUb29scyBQcm9maWxlciBwbHVnaW4uXG4vLyBOb3RlIHRoYXQgdGhlc2UgYXR0cmlidXRlcyBhcmUgb25seSBkZWZpbmVkIHdoZW4gdGhlIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgZmxhZyBpcyBlbmFibGVkLlxudHlwZSBQcm9maWxpbmdPbmx5RmliZXJSb290UHJvcGVydGllcyA9IHt8XG4gIGludGVyYWN0aW9uVGhyZWFkSUQ6IG51bWJlcixcbiAgbWVtb2l6ZWRJbnRlcmFjdGlvbnM6IFNldDxJbnRlcmFjdGlvbj4sXG4gIHBlbmRpbmdJbnRlcmFjdGlvbk1hcDogUGVuZGluZ0ludGVyYWN0aW9uTWFwLFxufH07XG5cbi8vIEV4cG9ydGVkIEZpYmVyUm9vdCB0eXBlIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzLFxuLy8gVG8gYXZvaWQgcmVxdWlyaW5nIHBvdGVudGlhbGx5IGVycm9yLXByb25lIDphbnkgY2FzdHMgdGhyb3VnaG91dCB0aGUgcHJvamVjdC5cbi8vIFByb2ZpbGluZyBwcm9wZXJ0aWVzIGFyZSBvbmx5IHNhZmUgdG8gYWNjZXNzIGluIHByb2ZpbGluZyBidWlsZHMgKHdoZW4gZW5hYmxlU2NoZWR1bGVyVHJhY2luZyBpcyB0cnVlKS5cbi8vIFRoZSB0eXBlcyBhcmUgZGVmaW5lZCBzZXBhcmF0ZWx5IHdpdGhpbiB0aGlzIGZpbGUgdG8gZW5zdXJlIHRoZXkgc3RheSBpbiBzeW5jLlxuLy8gKFdlIGRvbid0IGhhdmUgdG8gdXNlIGFuIGlubGluZSA6YW55IGNhc3Qgd2hlbiBlbmFibGVTY2hlZHVsZXJUcmFjaW5nIGlzIGRpc2FibGVkLilcbmV4cG9ydCB0eXBlIEZpYmVyUm9vdCA9IHtcbiAgLi4uQmFzZUZpYmVyUm9vdFByb3BlcnRpZXMsXG4gIC4uLlByb2ZpbGluZ09ubHlGaWJlclJvb3RQcm9wZXJ0aWVzLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChcbiAgY29udGFpbmVySW5mbzogYW55LFxuICBpc0NvbmN1cnJlbnQ6IGJvb2xlYW4sXG4gIGh5ZHJhdGU6IGJvb2xlYW4sXG4pOiBGaWJlclJvb3Qge1xuICAvLyBDeWNsaWMgY29uc3RydWN0aW9uLiBUaGlzIGNoZWF0cyB0aGUgdHlwZSBzeXN0ZW0gcmlnaHQgbm93IGJlY2F1c2VcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cbiAgY29uc3QgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0NvbmN1cnJlbnQpO1xuXG4gIGxldCByb290O1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHJvb3QgPSAoe1xuICAgICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcblxuICAgICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGluZ2VkVGltZTogTm9Xb3JrLFxuXG4gICAgICBwaW5nQ2FjaGU6IG51bGwsXG5cbiAgICAgIGRpZEVycm9yOiBmYWxzZSxcblxuICAgICAgcGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBub1RpbWVvdXQsXG4gICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgICBoeWRyYXRlLFxuICAgICAgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT246IE5vV29yayxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaXJzdEJhdGNoOiBudWxsLFxuICAgICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGwsXG5cbiAgICAgIGludGVyYWN0aW9uVGhyZWFkSUQ6IHVuc3RhYmxlX2dldFRocmVhZElEKCksXG4gICAgICBtZW1vaXplZEludGVyYWN0aW9uczogbmV3IFNldCgpLFxuICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwOiBuZXcgTWFwKCksXG4gICAgfTogRmliZXJSb290KTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0gKHtcbiAgICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG5cbiAgICAgIHBpbmdDYWNoZTogbnVsbCxcblxuICAgICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGluZ2VkVGltZTogTm9Xb3JrLFxuXG4gICAgICBkaWRFcnJvcjogZmFsc2UsXG5cbiAgICAgIHBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgICAgdGltZW91dEhhbmRsZTogbm9UaW1lb3V0LFxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uOiBOb1dvcmssXG4gICAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmlyc3RCYXRjaDogbnVsbCxcbiAgICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsLFxuICAgIH06IEJhc2VGaWJlclJvb3RQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIC8vIFRoZSByZWFzb24gZm9yIHRoZSB3YXkgdGhlIEZsb3cgdHlwZXMgYXJlIHN0cnVjdHVyZWQgaW4gdGhpcyBmaWxlLFxuICAvLyBJcyB0byBhdm9pZCBuZWVkaW5nIDphbnkgY2FzdHMgZXZlcnl3aGVyZSBpbnRlcmFjdGlvbiB0cmFjaW5nIGZpZWxkcyBhcmUgdXNlZC5cbiAgLy8gVW5mb3J0dW5hdGVseSB0aGF0IHJlcXVpcmVzIGFuIDphbnkgY2FzdCBmb3Igbm9uLWludGVyYWN0aW9uIHRyYWNpbmcgY2FwYWJsZSBidWlsZHMuXG4gIC8vICRGbG93Rml4TWUgUmVtb3ZlIHRoaXMgOmFueSBjYXN0IGFuZCByZXBsYWNlIGl0IHdpdGggc29tZXRoaW5nIGJldHRlci5cbiAgcmV0dXJuICgocm9vdDogYW55KTogRmliZXJSb290KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJSb290LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtSZWFjdEVsZW1lbnR9IGZyb20gJ3NoYXJlZC9SZWFjdEVsZW1lbnRUeXBlJztcbmltcG9ydCB0eXBlIHtSZWFjdFBvcnRhbH0gZnJvbSAnc2hhcmVkL1JlYWN0VHlwZXMnO1xuaW1wb3J0IHR5cGUge0ZpYmVyfSBmcm9tICcuL1JlYWN0RmliZXInO1xuaW1wb3J0IHR5cGUge0V4cGlyYXRpb25UaW1lfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5cbmltcG9ydCBnZXRDb21wb25lbnROYW1lIGZyb20gJ3NoYXJlZC9nZXRDb21wb25lbnROYW1lJztcbmltcG9ydCB7UGxhY2VtZW50LCBEZWxldGlvbn0gZnJvbSAnc2hhcmVkL1JlYWN0U2lkZUVmZmVjdFRhZ3MnO1xuaW1wb3J0IHtcbiAgZ2V0SXRlcmF0b3JGbixcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBSRUFDVF9QT1JUQUxfVFlQRSxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5pbXBvcnQge1xuICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgQ2xhc3NDb21wb25lbnQsXG4gIEhvc3RUZXh0LFxuICBIb3N0UG9ydGFsLFxuICBGcmFnbWVudCxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0V29ya1RhZ3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3NoYXJlZC93YXJuaW5nJztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlV29ya0luUHJvZ3Jlc3MsXG4gIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQsXG4gIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50LFxuICBjcmVhdGVGaWJlckZyb21UZXh0LFxuICBjcmVhdGVGaWJlckZyb21Qb3J0YWwsXG59IGZyb20gJy4vUmVhY3RGaWJlcic7XG5pbXBvcnQge2VtcHR5UmVmc09iamVjdH0gZnJvbSAnLi9SZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldixcbiAgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kLFxufSBmcm9tICcuL1JlYWN0Q3VycmVudEZpYmVyJztcbmltcG9ydCB7U3RyaWN0TW9kZX0gZnJvbSAnLi9SZWFjdFR5cGVPZk1vZGUnO1xuXG5sZXQgZGlkV2FybkFib3V0TWFwcztcbmxldCBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzO1xubGV0IGRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZTtcbmxldCBvd25lckhhc0tleVVzZVdhcm5pbmc7XG5sZXQgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nO1xubGV0IHdhcm5Gb3JNaXNzaW5nS2V5ID0gKGNoaWxkOiBtaXhlZCkgPT4ge307XG5cbmlmIChfX0RFVl9fKSB7XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGUgPSB7fTtcblxuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB3YXJuRm9yTWlzc2luZ0tleSA9IChjaGlsZDogbWl4ZWQpID0+IHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIHR5cGVvZiBjaGlsZC5fc3RvcmUgPT09ICdvYmplY3QnLFxuICAgICAgJ1JlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gJyArXG4gICAgICAgICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgKTtcbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlICcgK1xuICAgICAgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICtcbiAgICAgICdtb3JlIGluZm9ybWF0aW9uLicgK1xuICAgICAgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpO1xuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICtcbiAgICAgICAgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICtcbiAgICAgICAgJ21vcmUgaW5mb3JtYXRpb24uJyxcbiAgICApO1xuICB9O1xufVxuXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKFxuICByZXR1cm5GaWJlcjogRmliZXIsXG4gIGN1cnJlbnQ6IEZpYmVyIHwgbnVsbCxcbiAgZWxlbWVudDogUmVhY3RFbGVtZW50LFxuKSB7XG4gIGxldCBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAoXG4gICAgbWl4ZWRSZWYgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgbWl4ZWRSZWYgIT09ICdvYmplY3QnXG4gICkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUocmV0dXJuRmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0Egc3RyaW5nIHJlZiwgXCIlc1wiLCBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICtcbiAgICAgICAgICAgICAgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgK1xuICAgICAgICAgICAgICAnV2UgcmVjb21tZW5kIHVzaW5nIGNyZWF0ZVJlZigpIGluc3RlYWQuJyArXG4gICAgICAgICAgICAgICdcXG4lcycgK1xuICAgICAgICAgICAgICAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgK1xuICAgICAgICAgICAgICAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJyxcbiAgICAgICAgICAgIG1peGVkUmVmLFxuICAgICAgICAgICAgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHJldHVybkZpYmVyKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIGNvbnN0IG93bmVyOiA/RmliZXIgPSAoZWxlbWVudC5fb3duZXI6IGFueSk7XG4gICAgICBsZXQgaW5zdDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBjb25zdCBvd25lckZpYmVyID0gKChvd25lcjogYW55KTogRmliZXIpO1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgb3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50LFxuICAgICAgICAgICdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuICcgK1xuICAgICAgICAgICAgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPycsXG4gICAgICAgICk7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgIGludmFyaWFudChcbiAgICAgICAgaW5zdCxcbiAgICAgICAgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhICcgK1xuICAgICAgICAgICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgIG1peGVkUmVmLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChcbiAgICAgICAgY3VycmVudCAhPT0gbnVsbCAmJlxuICAgICAgICBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVmID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgbGV0IHJlZnMgPSBpbnN0LnJlZnM7XG4gICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6eSBwb29sZWQgZnJvemVuIG9iamVjdCwgc28gd2UgbmVlZCB0byBpbml0aWFsaXplLlxuICAgICAgICAgIHJlZnMgPSBpbnN0LnJlZnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycsXG4gICAgICAgICdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC4nLFxuICAgICAgKTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZWxlbWVudC5fb3duZXIsXG4gICAgICAgICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YnICtcbiAgICAgICAgICAnIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICtcbiAgICAgICAgICAnMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4nICtcbiAgICAgICAgICBcIjIuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudCdzIHJlbmRlciBtZXRob2RcXG5cIiArXG4gICAgICAgICAgJzMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG4nICtcbiAgICAgICAgICAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgbWl4ZWRSZWYsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlcjogRmliZXIsIG5ld0NoaWxkOiBPYmplY3QpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICBsZXQgYWRkZW5kdW0gPSAnJztcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgYWRkZW5kdW0gPVxuICAgICAgICAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArXG4gICAgICAgICdpbnN0ZWFkLicgK1xuICAgICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJyxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9J1xuICAgICAgICA6IG5ld0NoaWxkLFxuICAgICAgYWRkZW5kdW0sXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIGNvbnN0IGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArXG4gICAgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICtcbiAgICAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyArXG4gICAgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKFxuICAgIGZhbHNlLFxuICAgICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArXG4gICAgICAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgK1xuICAgICAgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicsXG4gICk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlcjogRmliZXIsIGNoaWxkVG9EZWxldGU6IEZpYmVyKTogdm9pZCB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuICAgIGNvbnN0IGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgIHJldHVybkZpYmVyOiBGaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZDogRmliZXIgfCBudWxsLFxuICApOiBudWxsIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuICAgIGxldCBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgcmV0dXJuRmliZXI6IEZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkOiBGaWJlcixcbiAgKTogTWFwPHN0cmluZyB8IG51bWJlciwgRmliZXI+IHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIC8vIGluc3RlYWQuXG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZHJlbjogTWFwPHN0cmluZyB8IG51bWJlciwgRmliZXI+ID0gbmV3IE1hcCgpO1xuXG4gICAgbGV0IGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihcbiAgICBmaWJlcjogRmliZXIsXG4gICAgcGVuZGluZ1Byb3BzOiBtaXhlZCxcbiAgICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gICk6IEZpYmVyIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgY29uc3QgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG4gICAgbmV3RmliZXI6IEZpYmVyLFxuICAgIGxhc3RQbGFjZWRJbmRleDogbnVtYmVyLFxuICAgIG5ld0luZGV4OiBudW1iZXIsXG4gICk6IG51bWJlciB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcjogRmliZXIpOiBGaWJlciB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShcbiAgICByZXR1cm5GaWJlcjogRmliZXIsXG4gICAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICAgIHRleHRDb250ZW50OiBzdHJpbmcsXG4gICAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICApIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgY29uc3QgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgY29uc3QgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChcbiAgICByZXR1cm5GaWJlcjogRmliZXIsXG4gICAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICAgIGVsZW1lbnQ6IFJlYWN0RWxlbWVudCxcbiAgICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gICk6IEZpYmVyIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIGNvbnN0IGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKFxuICAgIHJldHVybkZpYmVyOiBGaWJlcixcbiAgICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gICAgcG9ydGFsOiBSZWFjdFBvcnRhbCxcbiAgICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gICk6IEZpYmVyIHtcbiAgICBpZiAoXG4gICAgICBjdXJyZW50ID09PSBudWxsIHx8XG4gICAgICBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fFxuICAgICAgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHxcbiAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICApIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgY29uc3QgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgY29uc3QgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KFxuICAgIHJldHVybkZpYmVyOiBGaWJlcixcbiAgICBjdXJyZW50OiBGaWJlciB8IG51bGwsXG4gICAgZnJhZ21lbnQ6IEl0ZXJhYmxlPCo+LFxuICAgIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAgICBrZXk6IG51bGwgfCBzdHJpbmcsXG4gICk6IEZpYmVyIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgY29uc3QgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIGtleSxcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgY29uc3QgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQoXG4gICAgcmV0dXJuRmliZXI6IEZpYmVyLFxuICAgIG5ld0NoaWxkOiBhbnksXG4gICAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICApOiBGaWJlciB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGNvbnN0IGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAnJyArIG5ld0NoaWxkLFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6IHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6IHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBjb25zdCBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICApO1xuICAgICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KFxuICAgIHJldHVybkZpYmVyOiBGaWJlcixcbiAgICBvbGRGaWJlcjogRmliZXIgfCBudWxsLFxuICAgIG5ld0NoaWxkOiBhbnksXG4gICAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICApOiBGaWJlciB8IG51bGwge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIGNvbnN0IGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgJycgKyBuZXdDaGlsZCxcbiAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOiB7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6IHtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKFxuICAgIGV4aXN0aW5nQ2hpbGRyZW46IE1hcDxzdHJpbmcgfCBudW1iZXIsIEZpYmVyPixcbiAgICByZXR1cm5GaWJlcjogRmliZXIsXG4gICAgbmV3SWR4OiBudW1iZXIsXG4gICAgbmV3Q2hpbGQ6IGFueSxcbiAgICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gICk6IEZpYmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICBjb25zdCBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBtYXRjaGVkRmliZXIsXG4gICAgICAgICcnICsgbmV3Q2hpbGQsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRToge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZWRGaWJlciA9XG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmdldChcbiAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5LFxuICAgICAgICAgICAgKSB8fCBudWxsO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBtYXRjaGVkRmliZXIsXG4gICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG1hdGNoZWRGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgICAgY29uc3QgbWF0Y2hlZEZpYmVyID1cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICBuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXksXG4gICAgICAgICAgICApIHx8IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbWF0Y2hlZEZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBtYXRjaGVkRmliZXIsXG4gICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoXG4gICAgY2hpbGQ6IG1peGVkLFxuICAgIGtub3duS2V5czogU2V0PHN0cmluZz4gfCBudWxsLFxuICApOiBTZXQ8c3RyaW5nPiB8IG51bGwge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgK1xuICAgICAgICAgICAgICAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICtcbiAgICAgICAgICAgICAgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgK1xuICAgICAgICAgICAgICAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICtcbiAgICAgICAgICAgICAgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgcmV0dXJuRmliZXI6IEZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkOiBGaWJlciB8IG51bGwsXG4gICAgbmV3Q2hpbGRyZW46IEFycmF5PCo+LFxuICAgIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAgKTogRmliZXIgfCBudWxsIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICBsZXQga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0aW5nRmlyc3RDaGlsZDogRmliZXIgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgcHJldmlvdXNOZXdGaWJlcjogRmliZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGxldCBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGxldCBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIGxldCBuZXdJZHggPSAwO1xuICAgIGxldCBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdGaWJlciA9IHVwZGF0ZVNsb3QoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIGNvbnN0IG5ld0ZpYmVyID0gY3JlYXRlQ2hpbGQoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFuZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBjb25zdCBuZXdGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBuZXdJZHgsXG4gICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICAgIGlmIChuZXdGaWJlcikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChuZXdGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShcbiAgICAgICAgICAgICAgbmV3RmliZXIua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3RmliZXIua2V5LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgcmV0dXJuRmliZXI6IEZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkOiBGaWJlciB8IG51bGwsXG4gICAgbmV3Q2hpbGRyZW5JdGVyYWJsZTogSXRlcmFibGU8Kj4sXG4gICAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICApOiBGaWJlciB8IG51bGwge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIGNvbnN0IGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgIGludmFyaWFudChcbiAgICAgIHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nLFxuICAgICAgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiAnICtcbiAgICAgICAgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICk7XG5cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xuICAgICAgICBuZXdDaGlsZHJlbkl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InXG4gICAgICApIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzLFxuICAgICAgICAgICdVc2luZyBHZW5lcmF0b3JzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICtcbiAgICAgICAgICAgICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArXG4gICAgICAgICAgICAnYFsuLi5zcHJlYWRdYCBvcGVyYXRvciBiZWZvcmUgcmVuZGVyaW5nLiBLZWVwIGluIG1pbmQgJyArXG4gICAgICAgICAgICAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicsXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmICgobmV3Q2hpbGRyZW5JdGVyYWJsZTogYW55KS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyxcbiAgICAgICAgICAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArXG4gICAgICAgICAgICAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArXG4gICAgICAgICAgICAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicsXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbiAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKG5ld0NoaWxkcmVuKSB7XG4gICAgICAgIGxldCBrbm93bktleXMgPSBudWxsO1xuICAgICAgICBsZXQgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgIGludmFyaWFudChuZXdDaGlsZHJlbiAhPSBudWxsLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpO1xuXG4gICAgbGV0IHJlc3VsdGluZ0ZpcnN0Q2hpbGQ6IEZpYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHByZXZpb3VzTmV3RmliZXI6IEZpYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBsZXQgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICBsZXQgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICBsZXQgbmV3SWR4ID0gMDtcbiAgICBsZXQgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIGxldCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgIGZvciAoXG4gICAgICA7XG4gICAgICBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lO1xuICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICApIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG9sZEZpYmVyLFxuICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgY29uc3QgbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGNvbnN0IG5ld0ZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICApO1xuICAgICAgaWYgKG5ld0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKG5ld0ZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKFxuICAgICAgICAgICAgICBuZXdGaWJlci5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdGaWJlci5rZXksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUoXG4gICAgcmV0dXJuRmliZXI6IEZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkOiBGaWJlciB8IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IHN0cmluZyxcbiAgICBleHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gICk6IEZpYmVyIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICBjb25zdCBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgIHRleHRDb250ZW50LFxuICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQoXG4gICAgcmV0dXJuRmliZXI6IEZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkOiBGaWJlciB8IG51bGwsXG4gICAgZWxlbWVudDogUmVhY3RFbGVtZW50LFxuICAgIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbiAgKTogRmliZXIge1xuICAgIGNvbnN0IGtleSA9IGVsZW1lbnQua2V5O1xuICAgIGxldCBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjaGlsZC50YWcgPT09IEZyYWdtZW50XG4gICAgICAgICAgICA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRVxuICAgICAgICAgICAgOiBjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudC50eXBlXG4gICAgICAgICkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHVzZUZpYmVyKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEVcbiAgICAgICAgICAgICAgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgIDogZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIGNvbnN0IGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIGVsZW1lbnQua2V5LFxuICAgICAgKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKFxuICAgIHJldHVybkZpYmVyOiBGaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZDogRmliZXIgfCBudWxsLFxuICAgIHBvcnRhbDogUmVhY3RQb3J0YWwsXG4gICAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICApOiBGaWJlciB7XG4gICAgY29uc3Qga2V5ID0gcG9ydGFsLmtleTtcbiAgICBsZXQgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmXG4gICAgICAgICAgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmXG4gICAgICAgICAgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdXNlRmliZXIoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSxcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgY29uc3QgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgIHBvcnRhbCxcbiAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICBleHBpcmF0aW9uVGltZSxcbiAgICApO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgIHJldHVybkZpYmVyOiBGaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZDogRmliZXIgfCBudWxsLFxuICAgIG5ld0NoaWxkOiBhbnksXG4gICAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuICApOiBGaWJlciB8IG51bGwge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgY29uc3QgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9XG4gICAgICB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmXG4gICAgICBuZXdDaGlsZCAhPT0gbnVsbCAmJlxuICAgICAgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJlxuICAgICAgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcbiAgICBjb25zdCBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQoXG4gICAgICAgICAgICByZWNvbmNpbGVTaW5nbGVFbGVtZW50KFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChcbiAgICAgICAgICAgIHJlY29uY2lsZVNpbmdsZVBvcnRhbChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQoXG4gICAgICAgIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICcnICsgbmV3Q2hpbGQsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0NoaWxkLFxuICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OiB7XG4gICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDoge1xuICAgICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhICcgK1xuICAgICAgICAgICAgICAncmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsICcgK1xuICAgICAgICAgICAgICAncmV0dXJuIG51bGwuJyxcbiAgICAgICAgICAgIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxuZXhwb3J0IGNvbnN0IHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xuZXhwb3J0IGNvbnN0IG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4pOiB2b2lkIHtcbiAgaW52YXJpYW50KFxuICAgIGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQsXG4gICAgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nLFxuICApO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgbGV0IG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoXG4gICAgY3VycmVudENoaWxkLFxuICAgIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsXG4gICAgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lLFxuICApO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuXG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhcbiAgICAgIGN1cnJlbnRDaGlsZCxcbiAgICAgIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsXG4gICAgICBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUsXG4gICAgKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0Q2hpbGRGaWJlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJy4vUmVhY3RGaWJlcic7XG5pbXBvcnQgdHlwZSB7RXhwaXJhdGlvblRpbWV9IGZyb20gJy4vUmVhY3RGaWJlckV4cGlyYXRpb25UaW1lJztcbmltcG9ydCB0eXBlIHtGaWJlclJvb3R9IGZyb20gJy4vUmVhY3RGaWJlclJvb3QnO1xuaW1wb3J0IHR5cGUge1xuICBJbnN0YW5jZSxcbiAgVHlwZSxcbiAgUHJvcHMsXG4gIENvbnRhaW5lcixcbiAgQ2hpbGRTZXQsXG59IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb25maWcnO1xuaW1wb3J0IHR5cGUge1N1c3BlbnNlU3RhdGV9IGZyb20gJy4vUmVhY3RGaWJlclN1c3BlbnNlQ29tcG9uZW50JztcblxuaW1wb3J0IHtcbiAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCxcbiAgRnVuY3Rpb25Db21wb25lbnQsXG4gIENsYXNzQ29tcG9uZW50LFxuICBIb3N0Um9vdCxcbiAgSG9zdENvbXBvbmVudCxcbiAgSG9zdFRleHQsXG4gIEhvc3RQb3J0YWwsXG4gIENvbnRleHRQcm92aWRlcixcbiAgQ29udGV4dENvbnN1bWVyLFxuICBGb3J3YXJkUmVmLFxuICBGcmFnbWVudCxcbiAgTW9kZSxcbiAgUHJvZmlsZXIsXG4gIFN1c3BlbnNlQ29tcG9uZW50LFxuICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG4gIE1lbW9Db21wb25lbnQsXG4gIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gIExhenlDb21wb25lbnQsXG4gIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0V29ya1RhZ3MnO1xuaW1wb3J0IHtcbiAgUGxhY2VtZW50LFxuICBSZWYsXG4gIFVwZGF0ZSxcbiAgTm9FZmZlY3QsXG4gIERpZENhcHR1cmUsXG4gIERlbGV0aW9uLFxufSBmcm9tICdzaGFyZWQvUmVhY3RTaWRlRWZmZWN0VGFncyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVJbnN0YW5jZSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlLFxuICBjcmVhdGVIaWRkZW5UZXh0SW5zdGFuY2UsXG4gIGFwcGVuZEluaXRpYWxDaGlsZCxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gIHByZXBhcmVVcGRhdGUsXG4gIHN1cHBvcnRzTXV0YXRpb24sXG4gIHN1cHBvcnRzUGVyc2lzdGVuY2UsXG4gIGNsb25lSW5zdGFuY2UsXG4gIGNsb25lSGlkZGVuSW5zdGFuY2UsXG4gIGNsb25lVW5oaWRkZW5JbnN0YW5jZSxcbiAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQsXG4gIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbixcbn0gZnJvbSAnLi9SZWFjdEZpYmVySG9zdENvbmZpZyc7XG5pbXBvcnQge1xuICBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgcG9wSG9zdENvbnRleHQsXG4gIGdldEhvc3RDb250ZXh0LFxuICBwb3BIb3N0Q29udGFpbmVyLFxufSBmcm9tICcuL1JlYWN0RmliZXJIb3N0Q29udGV4dCc7XG5pbXBvcnQge1xuICBpc0NvbnRleHRQcm92aWRlciBhcyBpc0xlZ2FjeUNvbnRleHRQcm92aWRlcixcbiAgcG9wQ29udGV4dCBhcyBwb3BMZWdhY3lDb250ZXh0LFxuICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QgYXMgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0LFxufSBmcm9tICcuL1JlYWN0RmliZXJDb250ZXh0JztcbmltcG9ydCB7cG9wUHJvdmlkZXJ9IGZyb20gJy4vUmVhY3RGaWJlck5ld0NvbnRleHQnO1xuaW1wb3J0IHtcbiAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gIHBvcEh5ZHJhdGlvblN0YXRlLFxufSBmcm9tICcuL1JlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0JztcbmltcG9ydCB7ZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcn0gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzczogRmliZXIpIHtcbiAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAvLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gbWFya1JlZih3b3JrSW5Qcm9ncmVzczogRmliZXIpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbn1cblxubGV0IGFwcGVuZEFsbENoaWxkcmVuO1xubGV0IHVwZGF0ZUhvc3RDb250YWluZXI7XG5sZXQgdXBkYXRlSG9zdENvbXBvbmVudDtcbmxldCB1cGRhdGVIb3N0VGV4dDtcbmlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gIC8vIE11dGF0aW9uIG1vZGVcblxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKFxuICAgIHBhcmVudDogSW5zdGFuY2UsXG4gICAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZTogYm9vbGVhbixcbiAgICBpc0hpZGRlbjogYm9vbGVhbixcbiAgKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIGxldCBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24od29ya0luUHJvZ3Jlc3M6IEZpYmVyKSB7XG4gICAgLy8gTm9vcFxuICB9O1xuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24oXG4gICAgY3VycmVudDogRmliZXIsXG4gICAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICAgIHR5cGU6IFR5cGUsXG4gICAgbmV3UHJvcHM6IFByb3BzLFxuICAgIHJvb3RDb250YWluZXJJbnN0YW5jZTogQ29udGFpbmVyLFxuICApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgY29uc3Qgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gSW4gbXV0YXRpb24gbW9kZSwgdGhpcyBpcyBzdWZmaWNpZW50IGZvciBhIGJhaWxvdXQgYmVjYXVzZVxuICAgICAgLy8gd2Ugd29uJ3QgdG91Y2ggdGhpcyBub2RlIGV2ZW4gaWYgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICBjb25zdCBpbnN0YW5jZTogSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgY29uc3QgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKFxuICAgICAgaW5zdGFuY2UsXG4gICAgICB0eXBlLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGN1cnJlbnRIb3N0Q29udGV4dCxcbiAgICApO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gKHVwZGF0ZVBheWxvYWQ6IGFueSk7XG4gICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbihcbiAgICBjdXJyZW50OiBGaWJlcixcbiAgICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gICAgb2xkVGV4dDogc3RyaW5nLFxuICAgIG5ld1RleHQ6IHN0cmluZyxcbiAgKSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG5cbiAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbihcbiAgICBwYXJlbnQ6IEluc3RhbmNlLFxuICAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGU6IGJvb2xlYW4sXG4gICAgaXNIaWRkZW46IGJvb2xlYW4sXG4gICkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICBsZXQgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICBicmFuY2hlczogaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlKSB7XG4gICAgICAgICAgY29uc3QgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgICBpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBjaGlsZCB3YXMgcHJldmlvdXNseSBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSWYgaXQgd2FzIG5vdFxuICAgICAgICAgICAgLy8gdXBkYXRlZCBkdXJpbmcgdGhpcyByZW5kZXIsIGl0IG1heSBuZWVkIHRvIGJlIHVuaGlkZGVuLiBDbG9uZVxuICAgICAgICAgICAgLy8gYWdhaW4gdG8gYmUgc3VyZS5cbiAgICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVVbmhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGNvbnN0IHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgY29uc3QgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gY3JlYXRlSGlkZGVuVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICByb290Q29udGFpbmVySW5zdGFuY2UsXG4gICAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3Qgb2xkU3RhdGU6IFN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgY29uc3QgbmV3U3RhdGU6IFN1c3BlbnNlU3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgY29uc3Qgb2xkSXNIaWRkZW4gPSBvbGRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICBjb25zdCBuZXdJc0hpZGRlbiA9IG5ld1N0YXRlICE9PSBudWxsO1xuICAgICAgICAgIGlmIChvbGRJc0hpZGRlbiAhPT0gbmV3SXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIFRoZSBwbGFjZWhvbGRlciBlaXRoZXIganVzdCB0aW1lZCBvdXQgb3Igc3dpdGNoZWQgYmFjayB0byB0aGUgbm9ybWFsXG4gICAgICAgICAgICAvLyBjaGlsZHJlbiBhZnRlciBoYXZpbmcgcHJldmlvdXNseSB0aW1lZCBvdXQuIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZlxuICAgICAgICAgICAgLy8gdGhlIGRpcmVjdCBob3N0IGNoaWxkcmVuLlxuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUNoaWxkUGFyZW50ID0gbmV3SXNIaWRkZW4gPyBub2RlLmNoaWxkIDogbm9kZTtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCBwcmltYXJ5Q2hpbGRQYXJlbnQsIHRydWUsIG5ld0lzSGlkZGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICAgIGJyZWFrIGJyYW5jaGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbnRpbnVlIHRyYXZlcnNpbmcgbGlrZSBub3JtYWxcbiAgICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBjb3JyZWN0IGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBsYWJlbGVkIGJyZWFrLlxuICAgICAgbm9kZSA9IChub2RlOiBGaWJlcik7XG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuICBjb25zdCBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24oXG4gICAgY29udGFpbmVyQ2hpbGRTZXQ6IENoaWxkU2V0LFxuICAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGU6IGJvb2xlYW4sXG4gICAgaXNIaWRkZW46IGJvb2xlYW4sXG4gICkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICBsZXQgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICBicmFuY2hlczogaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlKSB7XG4gICAgICAgICAgY29uc3QgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgICBpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBjaGlsZCB3YXMgcHJldmlvdXNseSBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSWYgaXQgd2FzIG5vdFxuICAgICAgICAgICAgLy8gdXBkYXRlZCBkdXJpbmcgdGhpcyByZW5kZXIsIGl0IG1heSBuZWVkIHRvIGJlIHVuaGlkZGVuLiBDbG9uZVxuICAgICAgICAgICAgLy8gYWdhaW4gdG8gYmUgc3VyZS5cbiAgICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVVbmhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSkge1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgY29uc3Qgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBjcmVhdGVIaWRkZW5UZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgICAgICAgICAgY3VycmVudEhvc3RDb250ZXh0LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gY3JlYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICByb290Q29udGFpbmVySW5zdGFuY2UsXG4gICAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG9sZFN0YXRlOiBTdXNwZW5zZVN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlOiBTdXNwZW5zZVN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGNvbnN0IG9sZElzSGlkZGVuID0gb2xkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgY29uc3QgbmV3SXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICBpZiAob2xkSXNIaWRkZW4gIT09IG5ld0lzSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBUaGUgcGxhY2Vob2xkZXIgZWl0aGVyIGp1c3QgdGltZWQgb3V0IG9yIHN3aXRjaGVkIGJhY2sgdG8gdGhlIG5vcm1hbFxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gYWZ0ZXIgaGF2aW5nIHByZXZpb3VzbHkgdGltZWQgb3V0LiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBkaXJlY3QgaG9zdCBjaGlsZHJlbi5cbiAgICAgICAgICAgIGNvbnN0IHByaW1hcnlDaGlsZFBhcmVudCA9IG5ld0lzSGlkZGVuID8gbm9kZS5jaGlsZCA6IG5vZGU7XG4gICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIoXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUNoaWxkUGFyZW50LFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgbmV3SXNIaWRkZW4sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICAgICAgICBicmVhayBicmFuY2hlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBDb250aW51ZSB0cmF2ZXJzaW5nIGxpa2Ugbm9ybWFsXG4gICAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgY29ycmVjdCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgbGFiZWxlZCBicmVhay5cbiAgICAgIG5vZGUgPSAobm9kZTogRmliZXIpO1xuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uKHdvcmtJblByb2dyZXNzOiBGaWJlcikge1xuICAgIGNvbnN0IHBvcnRhbE9yUm9vdDoge1xuICAgICAgY29udGFpbmVySW5mbzogQ29udGFpbmVyLFxuICAgICAgcGVuZGluZ0NoaWxkcmVuOiBDaGlsZFNldCxcbiAgICB9ID1cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBjb25zdCBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgbGV0IG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0O1xuICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQgPSBmdW5jdGlvbihcbiAgICBjdXJyZW50OiBGaWJlcixcbiAgICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gICAgdHlwZTogVHlwZSxcbiAgICBuZXdQcm9wczogUHJvcHMsXG4gICAgcm9vdENvbnRhaW5lckluc3RhbmNlOiBDb250YWluZXIsXG4gICkge1xuICAgIGNvbnN0IGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIGNvbnN0IG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIHRoZW4gbm9uZSBvZiBvdXIgY2hpbGRyZW4gaGFkIGFueSB1cGRhdGVzLlxuICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICBjb25zdCBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiBvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWN5Y2xhYmxlSW5zdGFuY2U6IEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGNvbnN0IGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgbGV0IHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKFxuICAgICAgICByZWN5Y2xhYmxlSW5zdGFuY2UsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICBjdXJyZW50SG9zdENvbnRleHQsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZXdJbnN0YW5jZSA9IGNsb25lSW5zdGFuY2UoXG4gICAgICBjdXJyZW50SW5zdGFuY2UsXG4gICAgICB1cGRhdGVQYXlsb2FkLFxuICAgICAgdHlwZSxcbiAgICAgIG9sZFByb3BzLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGNoaWxkcmVuVW5jaGFuZ2VkLFxuICAgICAgcmVjeWNsYWJsZUluc3RhbmNlLFxuICAgICk7XG4gICAgaWYgKFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oXG4gICAgICAgIG5ld0luc3RhbmNlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICBjdXJyZW50SG9zdENvbnRleHQsXG4gICAgICApXG4gICAgKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3RoZXIgZWZmZWN0cyBpbiB0aGlzIHRyZWUsIHdlIG5lZWQgdG8gZmxhZyB0aGlzIG5vZGUgYXMgaGF2aW5nIG9uZS5cbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIG5vdCBnb2luZyB0byB1c2UgaXQgZm9yIGFueXRoaW5nLlxuICAgICAgLy8gT3RoZXJ3aXNlIHBhcmVudHMgd29uJ3Qga25vdyB0aGF0IHRoZXJlIGFyZSBuZXcgY2hpbGRyZW4gdG8gcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbihcbiAgICBjdXJyZW50OiBGaWJlcixcbiAgICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gICAgb2xkVGV4dDogc3RyaW5nLFxuICAgIG5ld1RleHQ6IHN0cmluZyxcbiAgKSB7XG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIC8vIElmIHRoZSB0ZXh0IGNvbnRlbnQgZGlmZmVycywgd2UnbGwgY3JlYXRlIGEgbmV3IHRleHQgaW5zdGFuY2UgZm9yIGl0LlxuICAgICAgY29uc3Qgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgIG5ld1RleHQsXG4gICAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgICAgY3VycmVudEhvc3RDb250ZXh0LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICk7XG4gICAgICAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgLy8gVGhpcyBsZXRzIHRoZSBwYXJlbnRzIGtub3cgdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlaXIgY2hpbGRyZW4gaGFzIGNoYW5nZWQuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBObyBob3N0IG9wZXJhdGlvbnNcbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uKHdvcmtJblByb2dyZXNzOiBGaWJlcikge1xuICAgIC8vIE5vb3BcbiAgfTtcbiAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uKFxuICAgIGN1cnJlbnQ6IEZpYmVyLFxuICAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgICB0eXBlOiBUeXBlLFxuICAgIG5ld1Byb3BzOiBQcm9wcyxcbiAgICByb290Q29udGFpbmVySW5zdGFuY2U6IENvbnRhaW5lcixcbiAgKSB7XG4gICAgLy8gTm9vcFxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uKFxuICAgIGN1cnJlbnQ6IEZpYmVyLFxuICAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgICBvbGRUZXh0OiBzdHJpbmcsXG4gICAgbmV3VGV4dDogc3RyaW5nLFxuICApIHtcbiAgICAvLyBOb29wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhcbiAgY3VycmVudDogRmliZXIgfCBudWxsLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IEZpYmVyIHwgbnVsbCB7XG4gIGNvbnN0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OiB7XG4gICAgICBjb25zdCBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKGlzTGVnYWN5Q29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgcG9wTGVnYWN5Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDoge1xuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3BUb3BMZXZlbExlZ2FjeUNvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY29uc3QgZmliZXJSb290ID0gKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTogRmliZXJSb290KTtcbiAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY29uc3Qgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIGNvbnN0IHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwsXG4gICAgICAgICAgICAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArXG4gICAgICAgICAgICAgICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3ZSB3YW50IHRvIGFkZCB0aGVuIHRvcC0+ZG93biBvclxuICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgIGxldCB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHQsXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAvLyBjb21taXQtcGhhc2Ugd2UgbWFyayB0aGlzIGFzIHN1Y2guXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICByb290Q29udGFpbmVySW5zdGFuY2UsXG4gICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgICAgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHQsXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OiB7XG4gICAgICBsZXQgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCxcbiAgICAgICAgICAgICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICtcbiAgICAgICAgICAgICAgJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgbGV0IHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgbmV3VGV4dCxcbiAgICAgICAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OiB7XG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZC4gUmUtcmVuZGVyIHdpdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5leHREaWRUaW1lb3V0ID0gbmV4dFN0YXRlICE9PSBudWxsO1xuICAgICAgY29uc3QgcHJldkRpZFRpbWVvdXQgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIW5leHREaWRUaW1lb3V0ICYmIHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgIC8vIFdlIGp1c3Qgc3dpdGNoZWQgZnJvbSB0aGUgZmFsbGJhY2sgdG8gdGhlIG5vcm1hbCBjaGlsZHJlbi4gRGVsZXRlXG4gICAgICAgIC8vIHRoZSBmYWxsYmFjay5cbiAgICAgICAgLy8gVE9ETzogV291bGQgaXQgYmUgYmV0dGVyIHRvIHN0b3JlIHRoZSBmYWxsYmFjayBmcmFnbWVudCBvblxuICAgICAgICAvLyB0aGUgc3RhdGVOb2RlIGR1cmluZyB0aGUgYmVnaW4gcGhhc2U/XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGYWxsYmFja0NoaWxkOiBGaWJlciB8IG51bGwgPSAoY3VycmVudC5jaGlsZDogYW55KS5zaWJsaW5nO1xuICAgICAgICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBEZWxldGlvbnMgZ28gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3RcbiAgICAgICAgICBjb25zdCBmaXJzdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIGlmIChmaXJzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBjdXJyZW50RmFsbGJhY2tDaGlsZDtcbiAgICAgICAgICAgIGN1cnJlbnRGYWxsYmFja0NoaWxkLm5leHRFZmZlY3QgPSBmaXJzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gY3VycmVudEZhbGxiYWNrQ2hpbGQ7XG4gICAgICAgICAgICBjdXJyZW50RmFsbGJhY2tDaGlsZC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudEZhbGxiYWNrQ2hpbGQuZWZmZWN0VGFnID0gRGVsZXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHREaWRUaW1lb3V0IHx8IHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgIC8vIElmIHRoZSBjaGlsZHJlbiBhcmUgaGlkZGVuLCBvciBpZiB0aGV5IHdlcmUgcHJldmlvdXMgaGlkZGVuLCBzY2hlZHVsZVxuICAgICAgICAvLyBhbiBlZmZlY3QgdG8gdG9nZ2xlIHRoZWlyIHZpc2liaWxpdHkuIFRoaXMgaXMgYWxzbyB1c2VkIHRvIGF0dGFjaCBhXG4gICAgICAgIC8vIHJldHJ5IGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIE1vZGU6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiB7XG4gICAgICAvLyBTYW1lIGFzIGNsYXNzIGNvbXBvbmVudCBjYXNlLiBJIHB1dCBpdCBkb3duIGhlcmUgc28gdGhhdCB0aGUgdGFncyBhcmVcbiAgICAgIC8vIHNlcXVlbnRpYWwgdG8gZW5zdXJlIHRoaXMgc3dpdGNoIGlzIGNvbXBpbGVkIHRvIGEganVtcCB0YWJsZS5cbiAgICAgIGNvbnN0IENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAoaXNMZWdhY3lDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICBwb3BMZWdhY3lDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDoge1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBsZXQgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgd2FzSHlkcmF0ZWQsXG4gICAgICAgICAgICAnQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiAnICtcbiAgICAgICAgICAgICAgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGRpZCBub3Qgc3VzcGVuZCBzbyBpdCdzIG5vdyBoeWRyYXRlZC5cbiAgICAgICAgICAvLyBUbyBoYW5kbGUgYW55IGZ1dHVyZSBzdXNwZW5zZSBjYXNlcywgd2UncmUgZ29pbmcgdG8gbm93IHVwZ3JhZGUgaXRcbiAgICAgICAgICAvLyB0byBhIFN1c3BlbnNlIGNvbXBvbmVudC4gV2UgZGV0YWNoIGl0IGZyb20gdGhlIGV4aXN0aW5nIGN1cnJlbnQgZmliZXIuXG4gICAgICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gU3VzcGVuc2VDb21wb25lbnQ7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gJyArXG4gICAgICAgICAgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQge2NvbXBsZXRlV29ya307XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyQ29tcGxldGVXb3JrLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAnLi9SZWFjdEZpYmVyJztcbmltcG9ydCB0eXBlIHtGaWJlclJvb3R9IGZyb20gJy4vUmVhY3RGaWJlclJvb3QnO1xuaW1wb3J0IHR5cGUge0V4cGlyYXRpb25UaW1lfSBmcm9tICcuL1JlYWN0RmliZXJFeHBpcmF0aW9uVGltZSc7XG5pbXBvcnQgdHlwZSB7Q2FwdHVyZWRWYWx1ZX0gZnJvbSAnLi9SZWFjdENhcHR1cmVkVmFsdWUnO1xuaW1wb3J0IHR5cGUge1VwZGF0ZX0gZnJvbSAnLi9SZWFjdFVwZGF0ZVF1ZXVlJztcbmltcG9ydCB0eXBlIHtUaGVuYWJsZX0gZnJvbSAnLi9SZWFjdEZpYmVyU2NoZWR1bGVyJztcbmltcG9ydCB0eXBlIHtTdXNwZW5zZVN0YXRlfSBmcm9tICcuL1JlYWN0RmliZXJTdXNwZW5zZUNvbXBvbmVudCc7XG5cbmltcG9ydCB7dW5zdGFibGVfd3JhcCBhcyBTY2hlZHVsZV90cmFjaW5nX3dyYXB9IGZyb20gJ3NjaGVkdWxlci90cmFjaW5nJztcbmltcG9ydCBnZXRDb21wb25lbnROYW1lIGZyb20gJ3NoYXJlZC9nZXRDb21wb25lbnROYW1lJztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcbmltcG9ydCB7XG4gIENsYXNzQ29tcG9uZW50LFxuICBIb3N0Um9vdCxcbiAgSG9zdENvbXBvbmVudCxcbiAgSG9zdFBvcnRhbCxcbiAgQ29udGV4dFByb3ZpZGVyLFxuICBTdXNwZW5zZUNvbXBvbmVudCxcbiAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50LFxuICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFdvcmtUYWdzJztcbmltcG9ydCB7XG4gIERpZENhcHR1cmUsXG4gIEluY29tcGxldGUsXG4gIE5vRWZmZWN0LFxuICBTaG91bGRDYXB0dXJlLFxuICBMaWZlY3ljbGVFZmZlY3RNYXNrLFxufSBmcm9tICdzaGFyZWQvUmVhY3RTaWRlRWZmZWN0VGFncyc7XG5pbXBvcnQge1xuICBlbmFibGVTY2hlZHVsZXJUcmFjaW5nLFxuICBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyLFxufSBmcm9tICdzaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MnO1xuaW1wb3J0IHtDb25jdXJyZW50TW9kZX0gZnJvbSAnLi9SZWFjdFR5cGVPZk1vZGUnO1xuaW1wb3J0IHtzaG91bGRDYXB0dXJlU3VzcGVuc2V9IGZyb20gJy4vUmVhY3RGaWJlclN1c3BlbnNlQ29tcG9uZW50JztcblxuaW1wb3J0IHtjcmVhdGVDYXB0dXJlZFZhbHVlfSBmcm9tICcuL1JlYWN0Q2FwdHVyZWRWYWx1ZSc7XG5pbXBvcnQge1xuICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUsXG4gIGNyZWF0ZVVwZGF0ZSxcbiAgQ2FwdHVyZVVwZGF0ZSxcbiAgRm9yY2VVcGRhdGUsXG4gIGVucXVldWVVcGRhdGUsXG59IGZyb20gJy4vUmVhY3RVcGRhdGVRdWV1ZSc7XG5pbXBvcnQge2xvZ0Vycm9yfSBmcm9tICcuL1JlYWN0RmliZXJDb21taXRXb3JrJztcbmltcG9ydCB7Z2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kfSBmcm9tICcuL1JlYWN0Q3VycmVudEZpYmVyJztcbmltcG9ydCB7cG9wSG9zdENvbnRhaW5lciwgcG9wSG9zdENvbnRleHR9IGZyb20gJy4vUmVhY3RGaWJlckhvc3RDb250ZXh0JztcbmltcG9ydCB7XG4gIGlzQ29udGV4dFByb3ZpZGVyIGFzIGlzTGVnYWN5Q29udGV4dFByb3ZpZGVyLFxuICBwb3BDb250ZXh0IGFzIHBvcExlZ2FjeUNvbnRleHQsXG4gIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCBhcyBwb3BUb3BMZXZlbExlZ2FjeUNvbnRleHRPYmplY3QsXG59IGZyb20gJy4vUmVhY3RGaWJlckNvbnRleHQnO1xuaW1wb3J0IHtwb3BQcm92aWRlcn0gZnJvbSAnLi9SZWFjdEZpYmVyTmV3Q29udGV4dCc7XG5pbXBvcnQge1xuICByZW5kZXJEaWRTdXNwZW5kLFxuICByZW5kZXJEaWRFcnJvcixcbiAgb25VbmNhdWdodEVycm9yLFxuICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkLFxuICBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5LFxuICBwaW5nU3VzcGVuZGVkUm9vdCxcbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5LFxufSBmcm9tICcuL1JlYWN0RmliZXJTY2hlZHVsZXInO1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3NoYXJlZC9pbnZhcmlhbnQnO1xuaW1wb3J0IG1heFNpZ25lZDMxQml0SW50IGZyb20gJy4vbWF4U2lnbmVkMzFCaXRJbnQnO1xuaW1wb3J0IHtcbiAgU3luYyxcbiAgZXhwaXJhdGlvblRpbWVUb01zLFxuICBMT1dfUFJJT1JJVFlfRVhQSVJBVElPTixcbn0gZnJvbSAnLi9SZWFjdEZpYmVyRXhwaXJhdGlvblRpbWUnO1xuaW1wb3J0IHtmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWx9IGZyb20gJy4vUmVhY3RGaWJlclBlbmRpbmdQcmlvcml0eSc7XG5cbmNvbnN0IFBvc3NpYmx5V2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nID8gV2Vha1NldCA6IFNldDtcbmNvbnN0IFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICBmaWJlcjogRmliZXIsXG4gIGVycm9ySW5mbzogQ2FwdHVyZWRWYWx1ZTxtaXhlZD4sXG4gIGV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbik6IFVwZGF0ZTxtaXhlZD4ge1xuICBjb25zdCB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge2VsZW1lbnQ6IG51bGx9O1xuICBjb25zdCBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgdXBkYXRlLmNhbGxiYWNrID0gKCkgPT4ge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoXG4gIGZpYmVyOiBGaWJlcixcbiAgZXJyb3JJbmZvOiBDYXB0dXJlZFZhbHVlPG1peGVkPixcbiAgZXhwaXJhdGlvblRpbWU6IEV4cGlyYXRpb25UaW1lLFxuKTogVXBkYXRlPG1peGVkPiB7XG4gIGNvbnN0IHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICBjb25zdCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpO1xuICAgIH07XG4gIH1cblxuICBjb25zdCBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgY29uc3Qgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICBsb2dFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIHtcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJyxcbiAgICAgIH0pO1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbiAgICAgICAgICAvLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cbiAgICAgICAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgaXMgc2NoZWR1bGVkIHRoZW4gdGhlIGJvdW5kYXJ5IHdpbGwgc3dhbGxvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgICAgIGZpYmVyLmV4cGlyYXRpb25UaW1lID09PSBTeW5jLFxuICAgICAgICAgICAgJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgK1xuICAgICAgICAgICAgICAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJyxcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihcbiAgcm9vdDogRmliZXJSb290LFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4gIHRoZW5hYmxlOiBUaGVuYWJsZSxcbikge1xuICAvLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZSB0byBcInBpbmdcIiB0aGUgcm9vdCBhbmQgcmV0cnkuIEJ1dFxuICAvLyBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGZvciB0aGUgY3VycmVudCByZW5kZXIgZXhwaXJhdGlvblxuICAvLyB0aW1lICh3aGljaCBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICBsZXQgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIGxldCB0aHJlYWRJRHM7XG4gIGlmIChwaW5nQ2FjaGUgPT09IG51bGwpIHtcbiAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh0aGVuYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHRoZW5hYmxlKTtcbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQodGhlbmFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG4gIGlmICghdGhyZWFkSURzLmhhcyhyZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSB0aHJlYWQgSUQgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuICAgIHRocmVhZElEcy5hZGQocmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGxldCBwaW5nID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChcbiAgICAgIG51bGwsXG4gICAgICByb290LFxuICAgICAgdGhlbmFibGUsXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICApO1xuICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgICBwaW5nID0gU2NoZWR1bGVfdHJhY2luZ193cmFwKHBpbmcpO1xuICAgIH1cbiAgICB0aGVuYWJsZS50aGVuKHBpbmcsIHBpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKFxuICByb290OiBGaWJlclJvb3QsXG4gIHJldHVybkZpYmVyOiBGaWJlcixcbiAgc291cmNlRmliZXI6IEZpYmVyLFxuICB2YWx1ZTogbWl4ZWQsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lOiBFeHBpcmF0aW9uVGltZSxcbikge1xuICAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuXG4gIHNvdXJjZUZpYmVyLmVmZmVjdFRhZyB8PSBJbmNvbXBsZXRlO1xuICAvLyBJdHMgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICBzb3VyY2VGaWJlci5maXJzdEVmZmVjdCA9IHNvdXJjZUZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIGlmIChcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgY29uc3QgdGhlbmFibGU6IFRoZW5hYmxlID0gKHZhbHVlOiBhbnkpO1xuXG4gICAgLy8gRmluZCB0aGUgZWFybGllc3QgdGltZW91dCB0aHJlc2hvbGQgb2YgYWxsIHRoZSBwbGFjZWhvbGRlcnMgaW4gdGhlXG4gICAgLy8gYW5jZXN0b3IgcGF0aC4gV2UgY291bGQgYXZvaWQgdGhpcyB0cmF2ZXJzYWwgYnkgc3RvcmluZyB0aGUgdGhyZXNob2xkcyBvblxuICAgIC8vIHRoZSBzdGFjaywgYnV0IHdlIGNob29zZSBub3QgdG8gYmVjYXVzZSB3ZSBvbmx5IGhpdCB0aGlzIHBhdGggaWYgd2UncmVcbiAgICAvLyBJTy1ib3VuZCAoaS5lLiBpZiBzb21ldGhpbmcgc3VzcGVuZHMpLiBXaGVyZWFzIHRoZSBzdGFjayBpcyB1c2VkIGV2ZW4gaW5cbiAgICAvLyB0aGUgbm9uLUlPLSBib3VuZCBjYXNlLlxuICAgIGxldCB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgIGxldCBlYXJsaWVzdFRpbWVvdXRNcyA9IC0xO1xuICAgIGxldCBzdGFydFRpbWVNcyA9IC0xO1xuICAgIGRvIHtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlOiBTdXNwZW5zZVN0YXRlIHwgbnVsbCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoY3VycmVudFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZWFjaGVkIGEgYm91bmRhcnkgdGhhdCBhbHJlYWR5IHRpbWVkIG91dC4gRG8gbm90IHNlYXJjaFxuICAgICAgICAgICAgLy8gYW55IGZ1cnRoZXIuXG4gICAgICAgICAgICBjb25zdCB0aW1lZE91dEF0ID0gY3VycmVudFN0YXRlLnRpbWVkT3V0QXQ7XG4gICAgICAgICAgICBzdGFydFRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9Ncyh0aW1lZE91dEF0KTtcbiAgICAgICAgICAgIC8vIERvIG5vdCBzZWFyY2ggYW55IGZ1cnRoZXIuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVvdXRQcm9wTXMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMubWF4RHVyYXRpb247XG4gICAgICAgIGlmICh0eXBlb2YgdGltZW91dFByb3BNcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpZiAodGltZW91dFByb3BNcyA8PSAwKSB7XG4gICAgICAgICAgICBlYXJsaWVzdFRpbWVvdXRNcyA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGVhcmxpZXN0VGltZW91dE1zID09PSAtMSB8fFxuICAgICAgICAgICAgdGltZW91dFByb3BNcyA8IGVhcmxpZXN0VGltZW91dE1zXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBlYXJsaWVzdFRpbWVvdXRNcyA9IHRpbWVvdXRQcm9wTXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCB3ZSBkb24ndCBoYXZlIHRvIGRvIGFueXRoaW5nIGJlY2F1c2VcbiAgICAgIC8vIGlmIHNvbWV0aGluZyBzdXNwZW5kcyBpbnNpZGUgaXQsIHdlIHdpbGwgc2ltcGx5IGxlYXZlIHRoYXQgYXMgZGVoeWRyYXRlZC4gSXRcbiAgICAgIC8vIHdpbGwgbmV2ZXIgdGltZW91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcblxuICAgIC8vIFNjaGVkdWxlIHRoZSBuZWFyZXN0IFN1c3BlbnNlIHRvIHJlLXJlbmRlciB0aGUgdGltZWQgb3V0IHZpZXcuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICBkbyB7XG4gICAgICBpZiAoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiZcbiAgICAgICAgc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKHdvcmtJblByb2dyZXNzKVxuICAgICAgKSB7XG4gICAgICAgIC8vIEZvdW5kIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LlxuXG4gICAgICAgIC8vIFN0YXNoIHRoZSBwcm9taXNlIG9uIHRoZSBib3VuZGFyeSBmaWJlci4gSWYgdGhlIGJvdW5kYXJ5IHRpbWVzIG91dCwgd2UnbGxcbiAgICAgICAgLy8gYXR0YWNoIGFub3RoZXIgbGlzdGVuZXIgdG8gZmxpcCB0aGUgYm91bmRhcnkgYmFjayB0byBpdHMgbm9ybWFsIHN0YXRlLlxuICAgICAgICBjb25zdCB0aGVuYWJsZXM6IFNldDxUaGVuYWJsZT4gPSAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU6IGFueSk7XG4gICAgICAgIGlmICh0aGVuYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVRdWV1ZSA9IChuZXcgU2V0KCk6IGFueSk7XG4gICAgICAgICAgdXBkYXRlUXVldWUuYWRkKHRoZW5hYmxlKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoZW5hYmxlcy5hZGQodGhlbmFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IGlzIG91dHNpZGUgb2YgY29uY3VycmVudCBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gc3VzcGVuZCB0aGUgY29tbWl0LiBQcmV0ZW5kIGFzIGlmIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHJlbmRlcmVkXG4gICAgICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBJbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSdsbCBzY2hlZHVsZSBhXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgc3luY2hyb25vdXMgdXBkYXRlIHRvIHJlLXJlbmRlciB0aGUgU3VzcGVuc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IEl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgdGhlIGNvbXBvbmVudCB0aGF0IHN1c3BlbmRlZCB3YXNcbiAgICAgICAgLy8gaW5zaWRlIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIElmIHRoZSBTdXNwZW5zZSBpcyBvdXRzaWRlIG9mIGl0LCB3ZVxuICAgICAgICAvLyBzaG91bGQgKm5vdCogc3VzcGVuZCB0aGUgY29tbWl0LlxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IERpZENhcHR1cmU7XG5cbiAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBjb21taXQgdGhpcyBmaWJlciBldmVuIHRob3VnaCBpdCBkaWRuJ3QgY29tcGxldGUuXG4gICAgICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG4gICAgICAgICAgc291cmNlRmliZXIuZWZmZWN0VGFnICY9IH4oTGlmZWN5Y2xlRWZmZWN0TWFzayB8IEluY29tcGxldGUpO1xuXG4gICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U291cmNlRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbiAgICAgICAgICAgICAgLy8gY29tcGxldGVkIGNsYXNzIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIHdlIHNob3VsZCBub3QgY2FsbFxuICAgICAgICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBpdCBpcyBkZWxldGVkLlxuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXaGVuIHdlIHRyeSByZW5kZXJpbmcgYWdhaW4sIHdlIHNob3VsZCBub3QgcmV1c2UgdGhlIGN1cnJlbnQgZmliZXIsXG4gICAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGR0ZSB0b1xuICAgICAgICAgICAgICAvLyBwcmV2ZW50IGEgYmFpbCBvdXQuXG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShTeW5jKTtcbiAgICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgICAgICBlbnF1ZXVlVXBkYXRlKHNvdXJjZUZpYmVyLCB1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgICAgICAvLyBpbmRpY2F0ZSB0aGF0IGl0IHN0aWxsIGhhcyBwZW5kaW5nIHdvcmsuXG4gICAgICAgICAgc291cmNlRmliZXIuZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuXG4gICAgICAgICAgLy8gRXhpdCB3aXRob3V0IHN1c3BlbmRpbmcuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4gICAgICAgIC8vIHdpdGggdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lLCB0aGVuYWJsZSk7XG5cbiAgICAgICAgbGV0IGFic29sdXRlVGltZW91dE1zO1xuICAgICAgICBpZiAoZWFybGllc3RUaW1lb3V0TXMgPT09IC0xKSB7XG4gICAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgdGhyZXNob2xkIGlzIGdpdmVuLCBkZWZhdWx0IHRvIGFuIGFyYml0cmFyaWx5IGxhcmdlXG4gICAgICAgICAgLy8gdmFsdWUuIFRoZSBhY3R1YWwgc2l6ZSBkb2Vzbid0IG1hdHRlciBiZWNhdXNlIHRoZSB0aHJlc2hvbGQgZm9yIHRoZVxuICAgICAgICAgIC8vIHdob2xlIHRyZWUgd2lsbCBiZSBjbGFtcGVkIHRvIHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgICAgYWJzb2x1dGVUaW1lb3V0TXMgPSBtYXhTaWduZWQzMUJpdEludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lTXMgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHN1c3BlbmQgaGFwcGVuZWQgb3V0c2lkZSBvZiBhbnkgYWxyZWFkeSB0aW1lZC1vdXRcbiAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVycy4gV2UgZG9uJ3Qga25vdyBleGFjdGx5IHdoZW4gdGhlIHVwZGF0ZSB3YXNcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlZCwgYnV0IHdlIGNhbiBpbmZlciBhbiBhcHByb3hpbWF0ZSBzdGFydCB0aW1lIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBleHBpcmF0aW9uIHRpbWUuIEZpcnN0LCBmaW5kIHRoZSBlYXJsaWVzdCB1bmNvbW1pdHRlZCBleHBpcmF0aW9uXG4gICAgICAgICAgICAvLyB0aW1lIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgd29yayB0aGF0IGlzIHN1c3BlbmRlZC4gVGhlbiBzdWJ0cmFjdFxuICAgICAgICAgICAgLy8gdGhlIG9mZnNldCB1c2VkIHRvIGNvbXB1dGUgYW4gYXN5bmMgdXBkYXRlJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhdXNlIGhpZ2ggcHJpb3JpdHkgKGludGVyYWN0aXZlKSB3b3JrIHRvIGV4cGlyZVxuICAgICAgICAgICAgLy8gZWFybGllciB0aGFuIG5lY2Vzc2FyeSwgYnV0IHdlIGNhbiBhY2NvdW50IGZvciB0aGlzIGJ5IGFkanVzdGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBKdXN0IE5vdGljZWFibGUgRGlmZmVyZW5jZS5cbiAgICAgICAgICAgIGNvbnN0IGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwoXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhcbiAgICAgICAgICAgICAgZWFybGllc3RFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdGFydFRpbWVNcyA9IGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyAtIExPV19QUklPUklUWV9FWFBJUkFUSU9OO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhYnNvbHV0ZVRpbWVvdXRNcyA9IHN0YXJ0VGltZU1zICsgZWFybGllc3RUaW1lb3V0TXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXJrIHRoZSBlYXJsaWVzdCB0aW1lb3V0IGluIHRoZSBzdXNwZW5kZWQgZmliZXIncyBhbmNlc3RvciBwYXRoLlxuICAgICAgICAvLyBBZnRlciBjb21wbGV0aW5nIHRoZSByb290LCB3ZSdsbCB0YWtlIHRoZSBsYXJnZXN0IG9mIGFsbCB0aGVcbiAgICAgICAgLy8gc3VzcGVuZGVkIGZpYmVyJ3MgdGltZW91dHMgYW5kIHVzZSBpdCB0byBjb21wdXRlIGEgdGltZW91dCBmb3IgdGhlXG4gICAgICAgIC8vIHdob2xlIHRyZWUuXG4gICAgICAgIHJlbmRlckRpZFN1c3BlbmQocm9vdCwgYWJzb2x1dGVUaW1lb3V0TXMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlciAmJlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPT09IERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudFxuICAgICAgKSB7XG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCByZW5kZXJFeHBpcmF0aW9uVGltZSwgdGhlbmFibGUpO1xuXG4gICAgICAgIC8vIFNpbmNlIHdlIGFscmVhZHkgaGF2ZSBhIGN1cnJlbnQgZmliZXIsIHdlIGNhbiBlYWdlcmx5IGFkZCBhIHJldHJ5IGxpc3RlbmVyLlxuICAgICAgICBsZXQgcmV0cnlDYWNoZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGlmIChyZXRyeUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgJ0EgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBtdXN0IGNvbW1pdCBiZWZvcmUgdHJ5aW5nIHRvIHJlbmRlci4gJyArXG4gICAgICAgICAgICAgICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUgPSByZXRyeUNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIGJvdW5kYXJ5IGZpYmVyIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh0aGVuYWJsZSkpIHtcbiAgICAgICAgICByZXRyeUNhY2hlLmFkZCh0aGVuYWJsZSk7XG4gICAgICAgICAgbGV0IHJldHJ5ID0gcmV0cnlUaW1lZE91dEJvdW5kYXJ5LmJpbmQoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB0aGVuYWJsZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgICAgICAgICByZXRyeSA9IFNjaGVkdWxlX3RyYWNpbmdfd3JhcChyZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoZW5hYmxlLnRoZW4ocmV0cnksIHJldHJ5KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGR1cmluZyB0aGlzIHJlbmRlci4gQ29udGludWUgdG8gdGhlIG5leHRcbiAgICAgIC8vIGJvdW5kYXJ5LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgfSB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICAgIC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gRmFsbHRocm91Z2ggdG8gZXJyb3IgbW9kZS5cbiAgICAvLyBUT0RPOiBVc2UgaW52YXJpYW50IHNvIHRoZSBtZXNzYWdlIGlzIHN0cmlwcGVkIGluIHByb2Q/XG4gICAgdmFsdWUgPSBuZXcgRXJyb3IoXG4gICAgICAoZ2V0Q29tcG9uZW50TmFtZShzb3VyY2VGaWJlci50eXBlKSB8fCAnQSBSZWFjdCBjb21wb25lbnQnKSArXG4gICAgICAgICcgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuJyArXG4gICAgICAgICdcXG4nICtcbiAgICAgICAgJ0FkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gJyArXG4gICAgICAgICdwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS4nICtcbiAgICAgICAgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZUZpYmVyKSxcbiAgICApO1xuICB9XG5cbiAgLy8gV2UgZGlkbid0IGZpbmQgYSBib3VuZGFyeSB0aGF0IGNvdWxkIGhhbmRsZSB0aGlzIHR5cGUgb2YgZXhjZXB0aW9uLiBTdGFydFxuICAvLyBvdmVyIGFuZCB0cmF2ZXJzZSBwYXJlbnQgcGF0aCBhZ2FpbiwgdGhpcyB0aW1lIHRyZWF0aW5nIHRoZSBleGNlcHRpb25cbiAgLy8gYXMgYW4gZXJyb3IuXG4gIHJlbmRlckRpZEVycm9yKCk7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICBsZXQgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgZG8ge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICAgIGNvbnN0IGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgKTtcbiAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgY29uc3QgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCAmJlxuICAgICAgICAgICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIChpbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcbiAgICAgICAgICBjb25zdCB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxuZnVuY3Rpb24gdW53aW5kV29yayhcbiAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZTogRXhwaXJhdGlvblRpbWUsXG4pIHtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OiB7XG4gICAgICBjb25zdCBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKGlzTGVnYWN5Q29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgcG9wTGVnYWN5Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICBpZiAoZWZmZWN0VGFnICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSAoZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUpIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNvbnN0IGVmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgKGVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCxcbiAgICAgICAgJ1RoZSByb290IGZhaWxlZCB0byB1bm1vdW50IGFmdGVyIGFuIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiAnICtcbiAgICAgICAgICAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gKGVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlKSB8IERpZENhcHR1cmU7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OiB7XG4gICAgICBjb25zdCBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICBpZiAoZWZmZWN0VGFnICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSAoZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUpIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgLy8gQ2FwdHVyZWQgYSBzdXNwZW5zZSBlZmZlY3QuIFJlLXJlbmRlciB0aGUgYm91bmRhcnkuXG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDoge1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgY29uc3QgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoZWZmZWN0VGFnICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IChlZmZlY3RUYWcgJiB+U2hvdWxkQ2FwdHVyZSkgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yazogRmliZXIpIHtcbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDoge1xuICAgICAgY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSBpbnRlcnJ1cHRlZFdvcmsudHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvcExlZ2FjeUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBwb3BUb3BMZXZlbExlZ2FjeUNvbnRleHRPYmplY3QoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIHRocm93RXhjZXB0aW9uLFxuICB1bndpbmRXb3JrLFxuICB1bndpbmRJbnRlcnJ1cHRlZFdvcmssXG4gIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSxcbiAgY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyVW53aW5kV29yay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJy4vUmVhY3RGaWJlcic7XG5pbXBvcnQgdHlwZSB7RXhwaXJhdGlvblRpbWV9IGZyb20gJy4vUmVhY3RGaWJlckV4cGlyYXRpb25UaW1lJztcblxuZXhwb3J0IHR5cGUgU3VzcGVuc2VTdGF0ZSA9IHt8XG4gIHRpbWVkT3V0QXQ6IEV4cGlyYXRpb25UaW1lLFxufH07XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uod29ya0luUHJvZ3Jlc3M6IEZpYmVyKTogYm9vbGVhbiB7XG4gIC8vIEluIG9yZGVyIHRvIGNhcHR1cmUsIHRoZSBTdXNwZW5zZSBjb21wb25lbnQgbXVzdCBoYXZlIGEgZmFsbGJhY2sgcHJvcC5cbiAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMuZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJZiBpdCB3YXMgdGhlIHByaW1hcnkgY2hpbGRyZW4gdGhhdCBqdXN0IHN1c3BlbmRlZCwgY2FwdHVyZSBhbmQgcmVuZGVyIHRoZVxuICAvLyBmYWxsYmFjay4gT3RoZXJ3aXNlLCBkb24ndCBjYXB0dXJlIGFuZCBidWJibGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gIGNvbnN0IG5leHRTdGF0ZTogU3VzcGVuc2VTdGF0ZSB8IG51bGwgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gbmV4dFN0YXRlID09PSBudWxsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlclN1c3BlbnNlQ29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtDYXB0dXJlZEVycm9yfSBmcm9tICcuL1JlYWN0Q2FwdHVyZWRWYWx1ZSc7XG5cbmltcG9ydCB7c2hvd0Vycm9yRGlhbG9nfSBmcm9tICcuL1JlYWN0RmliZXJFcnJvckRpYWxvZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3I6IENhcHR1cmVkRXJyb3IpOiB2b2lkIHtcbiAgY29uc3QgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXJyb3IgPSAoY2FwdHVyZWRFcnJvci5lcnJvcjogYW55KTtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21wb25lbnROYW1lLFxuICAgICAgY29tcG9uZW50U3RhY2ssXG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgIGVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgIHdpbGxSZXRyeSxcbiAgICB9ID0gY2FwdHVyZWRFcnJvcjtcblxuICAgIC8vIEJyb3dzZXJzIHN1cHBvcnQgc2lsZW5jaW5nIHVuY2F1Z2h0IGVycm9ycyBieSBjYWxsaW5nXG4gICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGluIHdpbmRvdyBgZXJyb3JgIGhhbmRsZXIuXG4gICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG4gICAgaWYgKGVycm9yICE9IG51bGwgJiYgZXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiB3aWxsUmV0cnkpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIGlzIHJlY292ZXJhYmxlIGFuZCB3YXMgc2lsZW5jZWQuXG4gICAgICAgIC8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgICAvLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbiAgICAgIC8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG4gICAgICAvLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZVxuICAgICAgPyBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JHtjb21wb25lbnROYW1lfT4gY29tcG9uZW50OmBcbiAgICAgIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG5cbiAgICBsZXQgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7XG4gICAgLy8gZXJyb3JCb3VuZGFyeUZvdW5kIGNoZWNrIGlzIHN1ZmZpY2llbnQ7IGVycm9yQm91bmRhcnlOYW1lIGNoZWNrIGlzIHRvIHNhdGlzZnkgRmxvdy5cbiAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICBpZiAod2lsbFJldHJ5KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID1cbiAgICAgICAgICBgUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggYCArXG4gICAgICAgICAgYHVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsICR7ZXJyb3JCb3VuZGFyeU5hbWV9LmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9XG4gICAgICAgICAgYFRoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAke2Vycm9yQm91bmRhcnlOYW1lfS5cXG5gICtcbiAgICAgICAgICBgUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS5gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9XG4gICAgICAgICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICtcbiAgICAgICAgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRNZXNzYWdlID1cbiAgICAgIGAke2NvbXBvbmVudE5hbWVNZXNzYWdlfSR7Y29tcG9uZW50U3RhY2t9XFxuXFxuYCArXG4gICAgICBgJHtlcnJvckJvdW5kYXJ5TWVzc2FnZX1gO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHdlIHByaW50IHRoZSBlcnJvciBkaXJlY3RseS5cbiAgICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgbWVzc2FnZSwgdGhlIEpTIHN0YWNrLCBhbmQgYW55dGhpbmcgdGhlIGJyb3dzZXIgd2FudHMgdG8gc2hvdy5cbiAgICAvLyBXZSBwYXNzIHRoZSBlcnJvciBvYmplY3QgaW5zdGVhZCBvZiBjdXN0b20gbWVzc2FnZSBzbyB0aGF0IHRoZSBicm93c2VyIGRpc3BsYXlzIHRoZSBlcnJvciBuYXRpdmVseS5cbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckVycm9yTG9nZ2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtDYXB0dXJlZEVycm9yfSBmcm9tICcuL1JlYWN0Q2FwdHVyZWRWYWx1ZSc7XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZXhwb3J0IGZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhjYXB0dXJlZEVycm9yOiBDYXB0dXJlZEVycm9yKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckVycm9yRGlhbG9nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7UkVBQ1RfUE9SVEFMX1RZUEV9IGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuXG5pbXBvcnQgdHlwZSB7UmVhY3ROb2RlTGlzdCwgUmVhY3RQb3J0YWx9IGZyb20gJ3NoYXJlZC9SZWFjdFR5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZUxpc3QsXG4gIGNvbnRhaW5lckluZm86IGFueSxcbiAgLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbiAgaW1wbGVtZW50YXRpb246IGFueSxcbiAga2V5OiA/c3RyaW5nID0gbnVsbCxcbik6IFJlYWN0UG9ydGFsIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbixcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3NoYXJlZC9SZWFjdFBvcnRhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG5pbXBvcnQge2dldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEN1cnJlbnRGaWJlcic7XG5pbXBvcnQge3JlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzfSBmcm9tICdldmVudHMvRXZlbnRQbHVnaW5SZWdpc3RyeSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5pbXBvcnQge2NhblVzZURPTX0gZnJvbSAnc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50JztcbmltcG9ydCB3YXJuaW5nV2l0aG91dFN0YWNrIGZyb20gJ3NoYXJlZC93YXJuaW5nV2l0aG91dFN0YWNrJztcblxuaW1wb3J0IHtcbiAgZ2V0VmFsdWVGb3JBdHRyaWJ1dGUsXG4gIGdldFZhbHVlRm9yUHJvcGVydHksXG4gIHNldFZhbHVlRm9yUHJvcGVydHksXG59IGZyb20gJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJztcbmltcG9ydCB7XG4gIGluaXRXcmFwcGVyU3RhdGUgYXMgUmVhY3RET01JbnB1dEluaXRXcmFwcGVyU3RhdGUsXG4gIGdldEhvc3RQcm9wcyBhcyBSZWFjdERPTUlucHV0R2V0SG9zdFByb3BzLFxuICBwb3N0TW91bnRXcmFwcGVyIGFzIFJlYWN0RE9NSW5wdXRQb3N0TW91bnRXcmFwcGVyLFxuICB1cGRhdGVDaGVja2VkIGFzIFJlYWN0RE9NSW5wdXRVcGRhdGVDaGVja2VkLFxuICB1cGRhdGVXcmFwcGVyIGFzIFJlYWN0RE9NSW5wdXRVcGRhdGVXcmFwcGVyLFxuICByZXN0b3JlQ29udHJvbGxlZFN0YXRlIGFzIFJlYWN0RE9NSW5wdXRSZXN0b3JlQ29udHJvbGxlZFN0YXRlLFxufSBmcm9tICcuL1JlYWN0RE9NSW5wdXQnO1xuaW1wb3J0IHtcbiAgZ2V0SG9zdFByb3BzIGFzIFJlYWN0RE9NT3B0aW9uR2V0SG9zdFByb3BzLFxuICBwb3N0TW91bnRXcmFwcGVyIGFzIFJlYWN0RE9NT3B0aW9uUG9zdE1vdW50V3JhcHBlcixcbiAgdmFsaWRhdGVQcm9wcyBhcyBSZWFjdERPTU9wdGlvblZhbGlkYXRlUHJvcHMsXG59IGZyb20gJy4vUmVhY3RET01PcHRpb24nO1xuaW1wb3J0IHtcbiAgaW5pdFdyYXBwZXJTdGF0ZSBhcyBSZWFjdERPTVNlbGVjdEluaXRXcmFwcGVyU3RhdGUsXG4gIGdldEhvc3RQcm9wcyBhcyBSZWFjdERPTVNlbGVjdEdldEhvc3RQcm9wcyxcbiAgcG9zdE1vdW50V3JhcHBlciBhcyBSZWFjdERPTVNlbGVjdFBvc3RNb3VudFdyYXBwZXIsXG4gIHJlc3RvcmVDb250cm9sbGVkU3RhdGUgYXMgUmVhY3RET01TZWxlY3RSZXN0b3JlQ29udHJvbGxlZFN0YXRlLFxuICBwb3N0VXBkYXRlV3JhcHBlciBhcyBSZWFjdERPTVNlbGVjdFBvc3RVcGRhdGVXcmFwcGVyLFxufSBmcm9tICcuL1JlYWN0RE9NU2VsZWN0JztcbmltcG9ydCB7XG4gIGluaXRXcmFwcGVyU3RhdGUgYXMgUmVhY3RET01UZXh0YXJlYUluaXRXcmFwcGVyU3RhdGUsXG4gIGdldEhvc3RQcm9wcyBhcyBSZWFjdERPTVRleHRhcmVhR2V0SG9zdFByb3BzLFxuICBwb3N0TW91bnRXcmFwcGVyIGFzIFJlYWN0RE9NVGV4dGFyZWFQb3N0TW91bnRXcmFwcGVyLFxuICB1cGRhdGVXcmFwcGVyIGFzIFJlYWN0RE9NVGV4dGFyZWFVcGRhdGVXcmFwcGVyLFxuICByZXN0b3JlQ29udHJvbGxlZFN0YXRlIGFzIFJlYWN0RE9NVGV4dGFyZWFSZXN0b3JlQ29udHJvbGxlZFN0YXRlLFxufSBmcm9tICcuL1JlYWN0RE9NVGV4dGFyZWEnO1xuaW1wb3J0IHt0cmFja30gZnJvbSAnLi9pbnB1dFZhbHVlVHJhY2tpbmcnO1xuaW1wb3J0IHNldElubmVySFRNTCBmcm9tICcuL3NldElubmVySFRNTCc7XG5pbXBvcnQgc2V0VGV4dENvbnRlbnQgZnJvbSAnLi9zZXRUZXh0Q29udGVudCc7XG5pbXBvcnQge1xuICBUT1BfRVJST1IsXG4gIFRPUF9JTlZBTElELFxuICBUT1BfTE9BRCxcbiAgVE9QX1JFU0VULFxuICBUT1BfU1VCTUlULFxuICBUT1BfVE9HR0xFLFxufSBmcm9tICcuLi9ldmVudHMvRE9NVG9wTGV2ZWxFdmVudFR5cGVzJztcbmltcG9ydCB7bGlzdGVuVG8sIHRyYXBCdWJibGVkRXZlbnR9IGZyb20gJy4uL2V2ZW50cy9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInO1xuaW1wb3J0IHttZWRpYUV2ZW50VHlwZXN9IGZyb20gJy4uL2V2ZW50cy9ET01Ub3BMZXZlbEV2ZW50VHlwZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzLFxuICBzZXRWYWx1ZUZvclN0eWxlcyxcbiAgdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2LFxufSBmcm9tICcuLi9zaGFyZWQvQ1NTUHJvcGVydHlPcGVyYXRpb25zJztcbmltcG9ydCB7TmFtZXNwYWNlcywgZ2V0SW50cmluc2ljTmFtZXNwYWNlfSBmcm9tICcuLi9zaGFyZWQvRE9NTmFtZXNwYWNlcyc7XG5pbXBvcnQge1xuICBnZXRQcm9wZXJ0eUluZm8sXG4gIHNob3VsZElnbm9yZUF0dHJpYnV0ZSxcbiAgc2hvdWxkUmVtb3ZlQXR0cmlidXRlLFxufSBmcm9tICcuLi9zaGFyZWQvRE9NUHJvcGVydHknO1xuaW1wb3J0IGFzc2VydFZhbGlkUHJvcHMgZnJvbSAnLi4vc2hhcmVkL2Fzc2VydFZhbGlkUHJvcHMnO1xuaW1wb3J0IHtET0NVTUVOVF9OT0RFLCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFfSBmcm9tICcuLi9zaGFyZWQvSFRNTE5vZGVUeXBlJztcbmltcG9ydCBpc0N1c3RvbUNvbXBvbmVudCBmcm9tICcuLi9zaGFyZWQvaXNDdXN0b21Db21wb25lbnQnO1xuaW1wb3J0IHBvc3NpYmxlU3RhbmRhcmROYW1lcyBmcm9tICcuLi9zaGFyZWQvcG9zc2libGVTdGFuZGFyZE5hbWVzJztcbmltcG9ydCB7dmFsaWRhdGVQcm9wZXJ0aWVzIGFzIHZhbGlkYXRlQVJJQVByb3BlcnRpZXN9IGZyb20gJy4uL3NoYXJlZC9SZWFjdERPTUludmFsaWRBUklBSG9vayc7XG5pbXBvcnQge3ZhbGlkYXRlUHJvcGVydGllcyBhcyB2YWxpZGF0ZUlucHV0UHJvcGVydGllc30gZnJvbSAnLi4vc2hhcmVkL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayc7XG5pbXBvcnQge3ZhbGlkYXRlUHJvcGVydGllcyBhcyB2YWxpZGF0ZVVua25vd25Qcm9wZXJ0aWVzfSBmcm9tICcuLi9zaGFyZWQvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJztcblxubGV0IGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG5sZXQgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbmNvbnN0IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MID0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJztcbmNvbnN0IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xuY29uc3QgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbmNvbnN0IEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xuY29uc3QgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xuY29uc3QgU1RZTEUgPSAnc3R5bGUnO1xuY29uc3QgSFRNTCA9ICdfX2h0bWwnO1xuXG5jb25zdCB7aHRtbDogSFRNTF9OQU1FU1BBQ0V9ID0gTmFtZXNwYWNlcztcblxubGV0IHdhcm5lZFVua25vd25UYWdzO1xubGV0IHN1cHByZXNzSHlkcmF0aW9uV2FybmluZztcblxubGV0IHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQ7XG5sZXQgd2FybkZvclRleHREaWZmZXJlbmNlO1xubGV0IHdhcm5Gb3JQcm9wRGlmZmVyZW5jZTtcbmxldCB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzO1xubGV0IHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcjtcbmxldCBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nO1xuXG5sZXQgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlO1xubGV0IG5vcm1hbGl6ZUhUTUw7XG5cbmlmIChfX0RFVl9fKSB7XG4gIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZSxcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWUsXG4gICAgLy8gRWxlY3Ryb24gc2hpcHMgYSBjdXN0b20gPHdlYnZpZXc+IHRhZyB0byBkaXNwbGF5IGV4dGVybmFsIHdlYiBjb250ZW50IGluXG4gICAgLy8gYW4gaXNvbGF0ZWQgZnJhbWUgYW5kIHByb2Nlc3MuXG4gICAgLy8gVGhpcyB0YWcgaXMgbm90IHByZXNlbnQgaW4gbm9uIEVsZWN0cm9uIGVudmlyb25tZW50cyBzdWNoIGFzIEpTRG9tIHdoaWNoXG4gICAgLy8gaXMgb2Z0ZW4gdXNlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAvLyBAc2VlIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvd2Vidmlldy10YWdcbiAgICB3ZWJ2aWV3OiB0cnVlLFxuICB9O1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbih0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlQVJJQVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCAvKiBjYW5Vc2VFdmVudFN5c3RlbSAqLyB0cnVlKTtcbiAgfTtcblxuICAvLyBJRSAxMSBwYXJzZXMgJiBub3JtYWxpemVzIHRoZSBzdHlsZSBhdHRyaWJ1dGUgYXMgb3Bwb3NlZCB0byBvdGhlclxuICAvLyBicm93c2Vycy4gSXQgYWRkcyBzcGFjZXMgYW5kIHNvcnRzIHRoZSBwcm9wZXJ0aWVzIGluIHNvbWVcbiAgLy8gbm9uLWFscGhhYmV0aWNhbCBvcmRlci4gSGFuZGxpbmcgdGhhdCB3b3VsZCByZXF1aXJlIHNvcnRpbmcgQ1NTXG4gIC8vIHByb3BlcnRpZXMgaW4gdGhlIGNsaWVudCAmIHNlcnZlciB2ZXJzaW9ucyBvciBhcHBseWluZ1xuICAvLyBgZXhwZWN0ZWRTdHlsZWAgdG8gYSB0ZW1wb3JhcnkgRE9NIG5vZGUgdG8gcmVhZCBpdHMgYHN0eWxlYCBhdHRyaWJ1dGVcbiAgLy8gbm9ybWFsaXplZC4gU2luY2UgaXQgb25seSBhZmZlY3RzIElFLCB3ZSdyZSBza2lwcGluZyBzdHlsZSB3YXJuaW5nc1xuICAvLyBpbiB0aGF0IGJyb3dzZXIgY29tcGxldGVseSBpbiBmYXZvciBvZiBkb2luZyBhbGwgdGhhdCB3b3JrLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTgwN1xuICBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nID0gY2FuVXNlRE9NICYmICFkb2N1bWVudC5kb2N1bWVudE1vZGU7XG5cbiAgLy8gSFRNTCBwYXJzaW5nIG5vcm1hbGl6ZXMgQ1IgYW5kIENSTEYgdG8gTEYuXG4gIC8vIEl0IGFsc28gY2FuIHR1cm4gXFx1MDAwMCBpbnRvIFxcdUZGRkQgaW5zaWRlIGF0dHJpYnV0ZXMuXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuICAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2gsIGl0IG1pZ2h0IGJlIGNhdXNlZCBieSB0aGF0LlxuICAvLyBXZSB3aWxsIHN0aWxsIHBhdGNoIHVwIGluIHRoaXMgY2FzZSBidXQgbm90IGZpcmUgdGhlIHdhcm5pbmcuXG4gIGNvbnN0IE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIGNvbnN0IE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbihtYXJrdXA6IG1peGVkKTogc3RyaW5nIHtcbiAgICBjb25zdCBtYXJrdXBTdHJpbmcgPVxuICAgICAgdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIChtYXJrdXA6IGFueSk7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZ1xuICAgICAgLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJylcbiAgICAgIC5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uKFxuICAgIHNlcnZlclRleHQ6IHN0cmluZyxcbiAgICBjbGllbnRUZXh0OiBzdHJpbmcgfCBudW1iZXIsXG4gICkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgICBjb25zdCBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJyxcbiAgICAgIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LFxuICAgICAgbm9ybWFsaXplZENsaWVudFRleHQsXG4gICAgKTtcbiAgfTtcblxuICB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbihcbiAgICBwcm9wTmFtZTogc3RyaW5nLFxuICAgIHNlcnZlclZhbHVlOiBtaXhlZCxcbiAgICBjbGllbnRWYWx1ZTogbWl4ZWQsXG4gICkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoXG4gICAgICBjbGllbnRWYWx1ZSxcbiAgICApO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShcbiAgICAgIHNlcnZlclZhbHVlLFxuICAgICk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsXG4gICAgICBwcm9wTmFtZSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksXG4gICAgICBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpLFxuICAgICk7XG4gIH07XG5cbiAgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWVzOiBTZXQ8c3RyaW5nPikge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayhmYWxzZSwgJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgK1xuICAgICAgICAgICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArXG4gICAgICAgICAgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsXG4gICAgICAgIHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICAgIHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICAgIHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJyxcbiAgICAgICAgcmVnaXN0cmF0aW9uTmFtZSxcbiAgICAgICAgdHlwZW9mIGxpc3RlbmVyLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIG5vcm1hbGl6ZUhUTUwgPSBmdW5jdGlvbihwYXJlbnQ6IEVsZW1lbnQsIGh0bWw6IHN0cmluZykge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgY29uc3QgdGVzdEVsZW1lbnQgPVxuICAgICAgcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0VcbiAgICAgICAgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKVxuICAgICAgICA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgIChwYXJlbnQubmFtZXNwYWNlVVJJOiBhbnkpLFxuICAgICAgICAgICAgcGFyZW50LnRhZ05hbWUsXG4gICAgICAgICAgKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIGNvbnN0IGlzRG9jdW1lbnRPckZyYWdtZW50ID1cbiAgICByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fFxuICAgIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICBjb25zdCBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudFxuICAgID8gcm9vdENvbnRhaW5lckVsZW1lbnRcbiAgICA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihcbiAgcm9vdENvbnRhaW5lckVsZW1lbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCxcbik6IERvY3VtZW50IHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFXG4gICAgPyAocm9vdENvbnRhaW5lckVsZW1lbnQ6IGFueSlcbiAgICA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZTogSFRNTEVsZW1lbnQpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKFxuICB0YWc6IHN0cmluZyxcbiAgZG9tRWxlbWVudDogRWxlbWVudCxcbiAgcm9vdENvbnRhaW5lckVsZW1lbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCxcbiAgbmV4dFByb3BzOiBPYmplY3QsXG4gIGlzQ3VzdG9tQ29tcG9uZW50VGFnOiBib29sZWFuLFxuKTogdm9pZCB7XG4gIGZvciAoY29uc3QgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBjb25zdCBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICBjb25zdCBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHxcbiAgICAgIHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXG4gICAgKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIFdlIHBvbHlmaWxsIGl0IHNlcGFyYXRlbHkgb24gdGhlIGNsaWVudCBkdXJpbmcgY29tbWl0LlxuICAgICAgLy8gV2UgY291bGQgaGF2ZSBleGNsdWRlZCBpdCBpbiB0aGUgcHJvcGVydHkgbGlzdCBpbnN0ZWFkIG9mXG4gICAgICAvLyBhZGRpbmcgYSBzcGVjaWFsIGNhc2UgaGVyZSwgYnV0IHRoZW4gaXQgd291bGRuJ3QgYmUgZW1pdHRlZFxuICAgICAgLy8gb24gc2VydmVyIHJlbmRlcmluZyAoYnV0IHdlICpkbyogd2FudCB0byBlbWl0IGl0IGluIFNTUikuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKF9fREVWX18gJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoXG4gIGRvbUVsZW1lbnQ6IEVsZW1lbnQsXG4gIHVwZGF0ZVBheWxvYWQ6IEFycmF5PGFueT4sXG4gIHdhc0N1c3RvbUNvbXBvbmVudFRhZzogYm9vbGVhbixcbiAgaXNDdXN0b21Db21wb25lbnRUYWc6IGJvb2xlYW4sXG4pOiB2b2lkIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICBjb25zdCBwcm9wVmFsdWUgPSB1cGRhdGVQYXlsb2FkW2kgKyAxXTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoXG4gIHR5cGU6IHN0cmluZyxcbiAgcHJvcHM6IE9iamVjdCxcbiAgcm9vdENvbnRhaW5lckVsZW1lbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCxcbiAgcGFyZW50TmFtZXNwYWNlOiBzdHJpbmcsXG4pOiBFbGVtZW50IHtcbiAgbGV0IGlzQ3VzdG9tQ29tcG9uZW50VGFnO1xuXG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuICBjb25zdCBvd25lckRvY3VtZW50OiBEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihcbiAgICByb290Q29udGFpbmVyRWxlbWVudCxcbiAgKTtcbiAgbGV0IGRvbUVsZW1lbnQ6IEVsZW1lbnQ7XG4gIGxldCBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgbmFtZXNwYWNlVVJJID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpO1xuICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgd2FybmluZyhcbiAgICAgICAgaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAnPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgK1xuICAgICAgICAgICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLFxuICAgICAgICB0eXBlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICBjb25zdCBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9ICc8c2NyaXB0PjwnICsgJy9zY3JpcHQ+JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIHlpZWxkIGEgc2NyaXB0IGVsZW1lbnQuXG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gKChkaXYuZmlyc3RDaGlsZDogYW55KTogSFRNTFNjcmlwdEVsZW1lbnQpO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7aXM6IHByb3BzLmlzfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgIC8vIE5vcm1hbGx5IGF0dHJpYnV0ZXMgYXJlIGFzc2lnbmVkIGluIGBzZXRJbml0aWFsRE9NUHJvcGVydGllc2AsIGhvd2V2ZXIgdGhlIGBtdWx0aXBsZWBcbiAgICAgIC8vIGF0dHJpYnV0ZSBvbiBgc2VsZWN0YHMgbmVlZHMgdG8gYmUgYWRkZWQgYmVmb3JlIGBvcHRpb25gcyBhcmUgaW5zZXJ0ZWQuIFRoaXMgcHJldmVudHNcbiAgICAgIC8vIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbiAgICAgIC8vIGBzZWxlY3RgIGVsZW1lbnRzIGF1dG9tYXRpY2FsbHkgcGljayB0aGUgZmlyc3QgaXRlbS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9ICgoZG9tRWxlbWVudDogYW55KTogSFRNTFNlbGVjdEVsZW1lbnQpO1xuICAgICAgICBub2RlLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICBpZiAoX19ERVZfXykge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09XG4gICAgICAgICAgJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiZcbiAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSlcbiAgICAgICkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnICtcbiAgICAgICAgICAgICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgK1xuICAgICAgICAgICAgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUoXG4gIHRleHQ6IHN0cmluZyxcbiAgcm9vdENvbnRhaW5lckVsZW1lbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCxcbik6IFRleHQge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZShcbiAgICB0ZXh0LFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoXG4gIGRvbUVsZW1lbnQ6IEVsZW1lbnQsXG4gIHRhZzogc3RyaW5nLFxuICByYXdQcm9wczogT2JqZWN0LFxuICByb290Q29udGFpbmVyRWxlbWVudDogRWxlbWVudCB8IERvY3VtZW50LFxuKTogdm9pZCB7XG4gIGNvbnN0IGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICBpZiAoXG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyAmJlxuICAgICAgIWRpZFdhcm5TaGFkeURPTSAmJlxuICAgICAgKGRvbUVsZW1lbnQ6IGFueSkuc2hhZHlSb290XG4gICAgKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJyVzIGlzIHVzaW5nIHNoYWR5IERPTS4gVXNpbmcgc2hhZHkgRE9NIHdpdGggUmVhY3QgY2FuICcgK1xuICAgICAgICAgICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsXG4gICAgICAgIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JyxcbiAgICAgICk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIGxldCBwcm9wczogT2JqZWN0O1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfTE9BRCwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9SRVNFVCwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9TVUJNSVQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfVE9HR0xFLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBSZWFjdERPTUlucHV0SW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXRHZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIFJlYWN0RE9NT3B0aW9uVmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IFJlYWN0RE9NT3B0aW9uR2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBSZWFjdERPTVNlbGVjdEluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdEdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBSZWFjdERPTVRleHRhcmVhSW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWFHZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpO1xuXG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKFxuICAgIHRhZyxcbiAgICBkb21FbGVtZW50LFxuICAgIHJvb3RDb250YWluZXJFbGVtZW50LFxuICAgIHByb3BzLFxuICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnLFxuICApO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKChkb21FbGVtZW50OiBhbnkpKTtcbiAgICAgIFJlYWN0RE9NSW5wdXRQb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soKGRvbUVsZW1lbnQ6IGFueSkpO1xuICAgICAgUmVhY3RET01UZXh0YXJlYVBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIFJlYWN0RE9NT3B0aW9uUG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgUmVhY3RET01TZWxlY3RQb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoKChkb21FbGVtZW50OiBhbnkpOiBIVE1MRWxlbWVudCkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKFxuICBkb21FbGVtZW50OiBFbGVtZW50LFxuICB0YWc6IHN0cmluZyxcbiAgbGFzdFJhd1Byb3BzOiBPYmplY3QsXG4gIG5leHRSYXdQcm9wczogT2JqZWN0LFxuICByb290Q29udGFpbmVyRWxlbWVudDogRWxlbWVudCB8IERvY3VtZW50LFxuKTogbnVsbCB8IEFycmF5PG1peGVkPiB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICBsZXQgdXBkYXRlUGF5bG9hZDogbnVsbCB8IEFycmF5PGFueT4gPSBudWxsO1xuXG4gIGxldCBsYXN0UHJvcHM6IE9iamVjdDtcbiAgbGV0IG5leHRQcm9wczogT2JqZWN0O1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NSW5wdXRHZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXRHZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbkdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb25HZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdEdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3RHZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWFHZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWFHZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudCgoKGRvbUVsZW1lbnQ6IGFueSk6IEhUTUxFbGVtZW50KSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMpO1xuXG4gIGxldCBwcm9wS2V5O1xuICBsZXQgc3R5bGVOYW1lO1xuICBsZXQgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChcbiAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fFxuICAgICAgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fFxuICAgICAgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGxcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIGNvbnN0IGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHxcbiAgICAgIHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXG4gICAgKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBjb25zdCBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBjb25zdCBsYXN0UHJvcCA9IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgIGlmIChcbiAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHxcbiAgICAgIG5leHRQcm9wID09PSBsYXN0UHJvcCB8fFxuICAgICAgKG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbClcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIGNvbnN0IG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGFzdFByb3AgIT09IG5leHRQcm9wICYmXG4gICAgICAgICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpXG4gICAgICApIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHxcbiAgICAgIHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXG4gICAgKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgLy8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG4gICAgICAgIGlmIChfX0RFVl9fICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkICYmIGxhc3RQcm9wICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBwcm9wcyBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgd2hpdGVsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB2YWxpZGF0ZVNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uSW5EZXYoc3R5bGVVcGRhdGVzLCBuZXh0UHJvcHNbU1RZTEVdKTtcbiAgICB9XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKFxuICBkb21FbGVtZW50OiBFbGVtZW50LFxuICB1cGRhdGVQYXlsb2FkOiBBcnJheTxhbnk+LFxuICB0YWc6IHN0cmluZyxcbiAgbGFzdFJhd1Byb3BzOiBPYmplY3QsXG4gIG5leHRSYXdQcm9wczogT2JqZWN0LFxuKTogdm9pZCB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAoXG4gICAgdGFnID09PSAnaW5wdXQnICYmXG4gICAgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiZcbiAgICBuZXh0UmF3UHJvcHMubmFtZSAhPSBudWxsXG4gICkge1xuICAgIFJlYWN0RE9NSW5wdXRVcGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICBjb25zdCB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIGNvbnN0IGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICAvLyBBcHBseSB0aGUgZGlmZi5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhcbiAgICBkb21FbGVtZW50LFxuICAgIHVwZGF0ZVBheWxvYWQsXG4gICAgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLFxuICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnLFxuICApO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICBSZWFjdERPTUlucHV0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgUmVhY3RET01UZXh0YXJlYVVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBSZWFjdERPTVNlbGVjdFBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgbG93ZXJDYXNlZE5hbWUgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKFxuICBkb21FbGVtZW50OiBFbGVtZW50LFxuICB0YWc6IHN0cmluZyxcbiAgcmF3UHJvcHM6IE9iamVjdCxcbiAgcGFyZW50TmFtZXNwYWNlOiBzdHJpbmcsXG4gIHJvb3RDb250YWluZXJFbGVtZW50OiBFbGVtZW50IHwgRG9jdW1lbnQsXG4pOiBudWxsIHwgQXJyYXk8bWl4ZWQ+IHtcbiAgbGV0IGlzQ3VzdG9tQ29tcG9uZW50VGFnO1xuICBsZXQgZXh0cmFBdHRyaWJ1dGVOYW1lczogU2V0PHN0cmluZz47XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gPT09IHRydWU7XG4gICAgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmXG4gICAgICAhZGlkV2FyblNoYWR5RE9NICYmXG4gICAgICAoZG9tRWxlbWVudDogYW55KS5zaGFkeVJvb3RcbiAgICApIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArXG4gICAgICAgICAgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJyxcbiAgICAgICAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLFxuICAgICAgKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9MT0FELCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9FUlJPUiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9SRVNFVCwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9TVUJNSVQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9UT0dHTEUsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgUmVhY3RET01JbnB1dEluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIFJlYWN0RE9NT3B0aW9uVmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgUmVhY3RET01TZWxlY3RJbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIFJlYWN0RE9NVGV4dGFyZWFJbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzKTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIGV4dHJhQXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVzW2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkXG4gICAgICAgIGNhc2UgJ2RhdGEtcmVhY3Ryb290JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAoY29uc3QgcHJvcEtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKF9fREVWX18gJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAoX19ERVZfXyAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChfX0RFVl9fICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBfX0RFVl9fICYmXG4gICAgICAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgICAgdHlwZW9mIGlzQ3VzdG9tQ29tcG9uZW50VGFnID09PSAnYm9vbGVhbidcbiAgICApIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICBsZXQgc2VydmVyVmFsdWU7XG4gICAgICBjb25zdCBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSk7XG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcuIFdlJ3JlIGlnbm9yaW5nIGFsbCB0aGVzZSB3YXJuaW5ncy5cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fFxuICAgICAgICBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyB8fFxuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHxcbiAgICAgICAgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8XG4gICAgICAgIHByb3BLZXkgPT09ICdzZWxlY3RlZCdcbiAgICAgICkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgY29uc3QgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBleHBlY3RlZEhUTUwgPSBub3JtYWxpemVIVE1MKFxuICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgbmV4dEh0bWwgIT0gbnVsbCA/IG5leHRIdG1sIDogJycsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuXG4gICAgICAgIGlmIChjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRTdHlsZSAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAhc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmXG4gICAgICAgICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUoXG4gICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICBuZXh0UHJvcCxcbiAgICAgICAgICBwcm9wZXJ0eUluZm8sXG4gICAgICAgICAgaXNDdXN0b21Db21wb25lbnRUYWcsXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBsZXQgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShcbiAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgbmV4dFByb3AsXG4gICAgICAgICAgICBwcm9wZXJ0eUluZm8sXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYXJkTmFtZSA9IGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO1xuICAgICAgICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbnVsbCAmJiBzdGFuZGFyZE5hbWUgIT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4gICAgICAgICAgICAgIC8vIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgZnJvbSBIVE1MLCBidXQgd2lsbCBwcm9kdWNlIGEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSdsbCBza2lwIHRoZSBtaXNsZWFkaW5nIGV4dHJhIG1pc21hdGNoIHdhcm5pbmcgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHN0YW5kYXJkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlICYmICFpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soKGRvbUVsZW1lbnQ6IGFueSkpO1xuICAgICAgUmVhY3RET01JbnB1dFBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKChkb21FbGVtZW50OiBhbnkpKTtcbiAgICAgIFJlYWN0RE9NVGV4dGFyZWFQb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIC8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuICAgICAgLy8gcG9zdCBtb3VudCB0byBmb3JjZSBpdCB0byBkaXZlcmdlIGZyb20gYXR0cmlidXRlcy4gSG93ZXZlciwgZm9yXG4gICAgICAvLyBvcHRpb24gYW5kIHNlbGVjdCB3ZSBkb24ndCBxdWl0ZSBkbyB0aGUgc2FtZSB0aGluZyBhbmQgc2VsZWN0XG4gICAgICAvLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbm90IGRvaW5nIHRoaXMgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYS5cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoKChkb21FbGVtZW50OiBhbnkpOiBIVE1MRWxlbWVudCkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQodGV4dE5vZGU6IFRleHQsIHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQodGV4dE5vZGU6IFRleHQsIHRleHQ6IHN0cmluZykge1xuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIHRleHQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KFxuICBwYXJlbnROb2RlOiBFbGVtZW50IHwgRG9jdW1lbnQsXG4gIGNoaWxkOiBFbGVtZW50LFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICAnRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLFxuICAgICAgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KFxuICBwYXJlbnROb2RlOiBFbGVtZW50IHwgRG9jdW1lbnQsXG4gIGNoaWxkOiBUZXh0LFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICAnRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsXG4gICAgICBjaGlsZC5ub2RlVmFsdWUsXG4gICAgICBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KFxuICBwYXJlbnROb2RlOiBFbGVtZW50IHwgRG9jdW1lbnQsXG4gIHRhZzogc3RyaW5nLFxuICBwcm9wczogT2JqZWN0LFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrKFxuICAgICAgZmFsc2UsXG4gICAgICAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLFxuICAgICAgdGFnLFxuICAgICAgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChcbiAgcGFyZW50Tm9kZTogRWxlbWVudCB8IERvY3VtZW50LFxuICB0ZXh0OiBzdHJpbmcsXG4pIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgIC8vIFdlIGV4cGVjdCB0byBpbnNlcnQgZW1wdHkgdGV4dCBub2RlcyBzaW5jZSB0aGV5J3JlIG5vdCByZXByZXNlbnRlZCBpblxuICAgICAgLy8gdGhlIEhUTUwuXG4gICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgaWYgd2UgY2FuIGp1c3QgYXZvaWQgaW5zZXJ0aW5nIGVtcHR5XG4gICAgICAvLyB0ZXh0IG5vZGVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICBmYWxzZSxcbiAgICAgICdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgdGV4dCBub2RlIGZvciBcIiVzXCIgaW4gPCVzPi4nLFxuICAgICAgdGV4dCxcbiAgICAgIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKFxuICBkb21FbGVtZW50OiBFbGVtZW50LFxuICB0YWc6IHN0cmluZyxcbiAgcHJvcHM6IE9iamVjdCxcbik6IHZvaWQge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIFJlYWN0RE9NSW5wdXRSZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBSZWFjdERPTVRleHRhcmVhUmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIFJlYWN0RE9NU2VsZWN0UmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NQ29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5pbXBvcnQge2dldFRvU3RyaW5nVmFsdWUsIHRvU3RyaW5nfSBmcm9tICcuL1RvU3RyaW5nVmFsdWUnO1xuXG5sZXQgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcbmxldCBkaWRXYXJuSW52YWxpZENoaWxkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICBsZXQgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4uIFdlJ2xsIHdhcm4gaWYgdGhleSBhcmUgaW52YWxpZFxuICAvLyBkdXJpbmcgdmFsaWRhdGVQcm9wcygpIHdoaWNoIHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHRocm93IG9uIG5vbi1lbGVtZW50IG9iamVjdHMuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdHJpbmdpZmllZCAod2hpY2ggaXMgbm9ybWFsbHkgaXJyZWxldmFudFxuICAvLyBidXQgbWF0dGVycyBmb3IgPGZidD4pLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgLy8gTm90ZTogd2UgZG9uJ3Qgd2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gSW5zdGVhZCwgdGhpcyBpcyBkb25lIHNlcGFyYXRlbHkgYmVsb3cgc28gdGhhdFxuICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIHRoZSBoeWRyYXRpb24gY29kZXBhdGggdG9vLlxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBjb2RlcGF0aCBhYm92ZSwgYnV0IHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gICAgLy8gV2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUgc28gdGhhdCBjbGllbnQgYW5kIGh5ZHJhdGlvbiBhcmUgY29uc2lzdGVudC5cbiAgICAvLyBUT0RPOiB0aGlzIHNlZW1zIGxpa2UgaXQgY291bGQgY2F1c2UgYSBERVYtb25seSB0aHJvdyBmb3IgaHlkcmF0aW9uXG4gICAgLy8gaWYgY2hpbGRyZW4gY29udGFpbnMgYSBub24tZWxlbWVudCBvYmplY3QuIFdlIHNob3VsZCB0cnkgdG8gYXZvaWQgdGhhdC5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnb2JqZWN0JyAmJiBwcm9wcy5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRDaGlsZCkge1xuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmIChwcm9wcy5zZWxlY3RlZCAhPSBudWxsICYmICFkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbikge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICtcbiAgICAgICAgICAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicsXG4gICAgICApO1xuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvc3RQcm9wcyhlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIGNvbnN0IGhvc3RQcm9wcyA9IHtjaGlsZHJlbjogdW5kZWZpbmVkLCAuLi5wcm9wc307XG4gIGNvbnN0IGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9SZWFjdERPTU9wdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG5pbXBvcnQge2dldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEN1cnJlbnRGaWJlcic7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbmltcG9ydCBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyBmcm9tICcuLi9zaGFyZWQvUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMnO1xuaW1wb3J0IHtnZXRUb1N0cmluZ1ZhbHVlLCB0b1N0cmluZ30gZnJvbSAnLi9Ub1N0cmluZ1ZhbHVlJztcblxubGV0IGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZTtcblxuaWYgKF9fREVWX18pIHtcbiAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG59XG5cbnR5cGUgU2VsZWN0V2l0aFdyYXBwZXJTdGF0ZSA9IEhUTUxTZWxlY3RFbGVtZW50ICYge1xuICBfd3JhcHBlclN0YXRlOiB7XG4gICAgd2FzTXVsdGlwbGU6IGJvb2xlYW4sXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGNvbnN0IG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG4gIGlmIChvd25lck5hbWUpIHtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmNvbnN0IHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpIHtcbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArXG4gICAgICAgICAgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsXG4gICAgICAgIHByb3BOYW1lLFxuICAgICAgICBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArXG4gICAgICAgICAgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLFxuICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCksXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKFxuICBub2RlOiBIVE1MU2VsZWN0RWxlbWVudCxcbiAgbXVsdGlwbGU6IGJvb2xlYW4sXG4gIHByb3BWYWx1ZTogYW55LFxuICBzZXREZWZhdWx0U2VsZWN0ZWQ6IGJvb2xlYW4sXG4pIHtcbiAgdHlwZSBJbmRleGFibGVIVE1MT3B0aW9uc0NvbGxlY3Rpb24gPSBIVE1MT3B0aW9uc0NvbGxlY3Rpb24gJiB7XG4gICAgW2tleTogbnVtYmVyXTogSFRNTE9wdGlvbkVsZW1lbnQsXG4gIH07XG4gIGNvbnN0IG9wdGlvbnM6IEluZGV4YWJsZUhUTUxPcHRpb25zQ29sbGVjdGlvbiA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSAocHJvcFZhbHVlOiBBcnJheTxzdHJpbmc+KTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkICYmIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUoKHByb3BWYWx1ZTogYW55KSkpO1xuICAgIGxldCBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tpXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQ6IEVsZW1lbnQsIHByb3BzOiBPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQ6IEVsZW1lbnQsIHByb3BzOiBPYmplY3QpIHtcbiAgY29uc3Qgbm9kZSA9ICgoZWxlbWVudDogYW55KTogU2VsZWN0V2l0aFdyYXBwZXJTdGF0ZSk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlLFxuICB9O1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKFxuICAgICAgcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWVcbiAgICApIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgK1xuICAgICAgICAgICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICtcbiAgICAgICAgICAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgK1xuICAgICAgICAgICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgK1xuICAgICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsXG4gICAgICApO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudDogRWxlbWVudCwgcHJvcHM6IE9iamVjdCkge1xuICBjb25zdCBub2RlID0gKChlbGVtZW50OiBhbnkpOiBTZWxlY3RXaXRoV3JhcHBlclN0YXRlKTtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIGNvbnN0IHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIGNvbnN0IG5vZGUgPSAoKGVsZW1lbnQ6IGFueSk6IFNlbGVjdFdpdGhXcmFwcGVyU3RhdGUpO1xuICBjb25zdCB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICBjb25zdCB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gISFwcm9wcy5tdWx0aXBsZSkge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZWxlbWVudDogRWxlbWVudCwgcHJvcHM6IE9iamVjdCkge1xuICBjb25zdCBub2RlID0gKChlbGVtZW50OiBhbnkpOiBTZWxlY3RXaXRoV3JhcHBlclN0YXRlKTtcbiAgY29uc3QgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9jbGllbnQvUmVhY3RET01TZWxlY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3NoYXJlZC93YXJuaW5nJztcblxuaW1wb3J0IFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzIGZyb20gJy4uL3NoYXJlZC9SZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyc7XG5pbXBvcnQge2dldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEN1cnJlbnRGaWJlcic7XG5pbXBvcnQge2dldFRvU3RyaW5nVmFsdWUsIHRvU3RyaW5nfSBmcm9tICcuL1RvU3RyaW5nVmFsdWUnO1xuaW1wb3J0IHR5cGUge1RvU3RyaW5nVmFsdWV9IGZyb20gJy4vVG9TdHJpbmdWYWx1ZSc7XG5cbmxldCBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG50eXBlIFRleHRBcmVhV2l0aFdyYXBwZXJTdGF0ZSA9IEhUTUxUZXh0QXJlYUVsZW1lbnQgJiB7XG4gIF93cmFwcGVyU3RhdGU6IHtcbiAgICBpbml0aWFsVmFsdWU6IFRvU3RyaW5nVmFsdWUsXG4gIH0sXG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQ6IEVsZW1lbnQsIHByb3BzOiBPYmplY3QpIHtcbiAgY29uc3Qgbm9kZSA9ICgoZWxlbWVudDogYW55KTogVGV4dEFyZWFXaXRoV3JhcHBlclN0YXRlKTtcbiAgaW52YXJpYW50KFxuICAgIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwsXG4gICAgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicsXG4gICk7XG5cbiAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG4gIGNvbnN0IGhvc3RQcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoaWxkcmVuOiB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSxcbiAgfTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIGNvbnN0IG5vZGUgPSAoKGVsZW1lbnQ6IGFueSk6IFRleHRBcmVhV2l0aFdyYXBwZXJTdGF0ZSk7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMpO1xuICAgIGlmIChcbiAgICAgIHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhZGlkV2FyblZhbERlZmF1bHRWYWxcbiAgICApIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXMgY29udGFpbnMgYSB0ZXh0YXJlYSB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArXG4gICAgICAgICAgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgK1xuICAgICAgICAgICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICtcbiAgICAgICAgICAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArXG4gICAgICAgICAgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgK1xuICAgICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsXG4gICAgICAgIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JyxcbiAgICAgICk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgbGV0IGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIGxldCBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICtcbiAgICAgICAgICAgICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9PSBudWxsLFxuICAgICAgICAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicsXG4gICAgICApO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPD0gMSxcbiAgICAgICAgICAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicsXG4gICAgICAgICk7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKGluaXRpYWxWYWx1ZSksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQ6IEVsZW1lbnQsIHByb3BzOiBPYmplY3QpIHtcbiAgY29uc3Qgbm9kZSA9ICgoZWxlbWVudDogYW55KTogVGV4dEFyZWFXaXRoV3JhcHBlclN0YXRlKTtcbiAgY29uc3QgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCAmJiBub2RlLmRlZmF1bHRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcoZGVmYXVsdFZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50OiBFbGVtZW50LCBwcm9wczogT2JqZWN0KSB7XG4gIGNvbnN0IG5vZGUgPSAoKGVsZW1lbnQ6IGFueSk6IFRleHRBcmVhV2l0aFdyYXBwZXJTdGF0ZSk7XG4gIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQ6IEVsZW1lbnQsIHByb3BzOiBPYmplY3QpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9SZWFjdERPTVRleHRhcmVhLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7TmFtZXNwYWNlc30gZnJvbSAnLi4vc2hhcmVkL0RPTU5hbWVzcGFjZXMnO1xuaW1wb3J0IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gZnJvbSAnLi4vc2hhcmVkL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nO1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG5sZXQgcmV1c2FibGVTVkdDb250YWluZXI7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oXG4gIG5vZGU6IEVsZW1lbnQsXG4gIGh0bWw6IHN0cmluZyxcbik6IHZvaWQge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcblxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9XG4gICAgICByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIGNvbnN0IHN2Z05vZGUgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRJbm5lckhUTUw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9zZXRJbm5lckhUTUwuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xuY29uc3QgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtURVhUX05PREV9IGZyb20gJy4uL3NoYXJlZC9IVE1MTm9kZVR5cGUnO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLiBGb3IgdGV4dCB1cGRhdGVzLCBpdCdzIGZhc3RlclxuICogdG8gc2V0IHRoZSBgbm9kZVZhbHVlYCBvZiB0aGUgVGV4dCBub2RlIGRpcmVjdGx5IGluc3RlYWQgb2YgdXNpbmdcbiAqIGAudGV4dENvbnRlbnRgIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBleGlzdGluZyBub2RlIGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbihub2RlOiBFbGVtZW50LCB0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKHRleHQpIHtcbiAgICBsZXQgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChcbiAgICAgIGZpcnN0Q2hpbGQgJiZcbiAgICAgIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmXG4gICAgICBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREVcbiAgICApIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZXRUZXh0Q29udGVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L3NldFRleHRDb250ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge3Nob3J0aGFuZFRvTG9uZ2hhbmR9IGZyb20gJy4vQ1NTU2hvcnRoYW5kUHJvcGVydHknO1xuXG5pbXBvcnQgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSBmcm9tICcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnO1xuaW1wb3J0IGh5cGhlbmF0ZVN0eWxlTmFtZSBmcm9tICcuL2h5cGhlbmF0ZVN0eWxlTmFtZSc7XG5pbXBvcnQgd2FyblZhbGlkU3R5bGUgZnJvbSAnLi93YXJuVmFsaWRTdHlsZSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbmltcG9ydCB7d2FybkFib3V0U2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb259IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWQgPSAnJztcbiAgICBsZXQgZGVsaW1pdGVyID0gJyc7XG4gICAgZm9yIChjb25zdCBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShcbiAgICAgICAgICBzdHlsZU5hbWUsXG4gICAgICAgICAgc3R5bGVWYWx1ZSxcbiAgICAgICAgICBpc0N1c3RvbVByb3BlcnR5LFxuICAgICAgICApO1xuXG4gICAgICAgIGRlbGltaXRlciA9ICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIGNvbnN0IHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yIChsZXQgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoXG4gICAgICBzdHlsZU5hbWUsXG4gICAgICBzdHlsZXNbc3R5bGVOYW1lXSxcbiAgICAgIGlzQ3VzdG9tUHJvcGVydHksXG4gICAgKTtcbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsdWVFbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG59XG5cbi8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZXMpIHtcbiAgY29uc3QgZXhwYW5kZWQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgbG9uZ2hhbmRzID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXldIHx8IFtrZXldO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9uZ2hhbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHBhbmRlZFtsb25naGFuZHNbaV1dID0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwYW5kZWQ7XG59XG5cbi8qKlxuICogV2hlbiBtaXhpbmcgc2hvcnRoYW5kIGFuZCBsb25naGFuZCBwcm9wZXJ0eSBuYW1lcywgd2Ugd2FybiBkdXJpbmcgdXBkYXRlcyBpZlxuICogd2UgZXhwZWN0IGFuIGluY29ycmVjdCByZXN1bHQgdG8gb2NjdXIuIEluIHBhcnRpY3VsYXIsIHdlIHdhcm4gZm9yOlxuICpcbiAqIFVwZGF0aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIG92ZXJ3cml0dGVuKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnYmF6JywgZm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJ2JheidcbiAqIFJlbW92aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIGxvc3QgdG9vKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnJ1xuICogUmVtb3ZpbmcgYSBsb25naGFuZCBwcm9wZXJ0eSAoc2hvdWxkIHJldmVydCB0byBzaG9ydGhhbmQ7IGRvZXNuJ3QpOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdmb28nfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250VmFyaWFudCA9ICcnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uSW5EZXYoXG4gIHN0eWxlVXBkYXRlcyxcbiAgbmV4dFN0eWxlcyxcbikge1xuICBpZiAoIXdhcm5BYm91dFNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFuZXh0U3R5bGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwYW5kZWRVcGRhdGVzID0gZXhwYW5kU2hvcnRoYW5kTWFwKHN0eWxlVXBkYXRlcyk7XG4gIGNvbnN0IGV4cGFuZGVkU3R5bGVzID0gZXhwYW5kU2hvcnRoYW5kTWFwKG5leHRTdHlsZXMpO1xuICBjb25zdCB3YXJuZWRBYm91dCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBleHBhbmRlZFVwZGF0ZXMpIHtcbiAgICBjb25zdCBvcmlnaW5hbEtleSA9IGV4cGFuZGVkVXBkYXRlc1trZXldO1xuICAgIGNvbnN0IGNvcnJlY3RPcmlnaW5hbEtleSA9IGV4cGFuZGVkU3R5bGVzW2tleV07XG4gICAgaWYgKGNvcnJlY3RPcmlnaW5hbEtleSAmJiBvcmlnaW5hbEtleSAhPT0gY29ycmVjdE9yaWdpbmFsS2V5KSB7XG4gICAgICBjb25zdCB3YXJuaW5nS2V5ID0gb3JpZ2luYWxLZXkgKyAnLCcgKyBjb3JyZWN0T3JpZ2luYWxLZXk7XG4gICAgICBpZiAod2FybmVkQWJvdXRbd2FybmluZ0tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3YXJuZWRBYm91dFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJyVzIGEgc3R5bGUgcHJvcGVydHkgZHVyaW5nIHJlcmVuZGVyICglcykgd2hlbiBhICcgK1xuICAgICAgICAgICdjb25mbGljdGluZyBwcm9wZXJ0eSBpcyBzZXQgKCVzKSBjYW4gbGVhZCB0byBzdHlsaW5nIGJ1Z3MuIFRvICcgK1xuICAgICAgICAgIFwiYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIFwiICtcbiAgICAgICAgICAnZm9yIHRoZSBzYW1lIHZhbHVlOyBpbnN0ZWFkLCByZXBsYWNlIHRoZSBzaG9ydGhhbmQgd2l0aCAnICtcbiAgICAgICAgICAnc2VwYXJhdGUgdmFsdWVzLicsXG4gICAgICAgIGlzVmFsdWVFbXB0eShzdHlsZVVwZGF0ZXNbb3JpZ2luYWxLZXldKSA/ICdSZW1vdmluZycgOiAnVXBkYXRpbmcnLFxuICAgICAgICBvcmlnaW5hbEtleSxcbiAgICAgICAgY29ycmVjdE9yaWdpbmFsS2V5LFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG5leHBvcnQgY29uc3Qgc2hvcnRoYW5kVG9Mb25naGFuZCA9IHtcbiAgYW5pbWF0aW9uOiBbXG4gICAgJ2FuaW1hdGlvbkRlbGF5JyxcbiAgICAnYW5pbWF0aW9uRGlyZWN0aW9uJyxcbiAgICAnYW5pbWF0aW9uRHVyYXRpb24nLFxuICAgICdhbmltYXRpb25GaWxsTW9kZScsXG4gICAgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JyxcbiAgICAnYW5pbWF0aW9uTmFtZScsXG4gICAgJ2FuaW1hdGlvblBsYXlTdGF0ZScsXG4gICAgJ2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uJyxcbiAgXSxcbiAgYmFja2dyb3VuZDogW1xuICAgICdiYWNrZ3JvdW5kQXR0YWNobWVudCcsXG4gICAgJ2JhY2tncm91bmRDbGlwJyxcbiAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAnYmFja2dyb3VuZEltYWdlJyxcbiAgICAnYmFja2dyb3VuZE9yaWdpbicsXG4gICAgJ2JhY2tncm91bmRQb3NpdGlvblgnLFxuICAgICdiYWNrZ3JvdW5kUG9zaXRpb25ZJyxcbiAgICAnYmFja2dyb3VuZFJlcGVhdCcsXG4gICAgJ2JhY2tncm91bmRTaXplJyxcbiAgXSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiBbJ2JhY2tncm91bmRQb3NpdGlvblgnLCAnYmFja2dyb3VuZFBvc2l0aW9uWSddLFxuICBib3JkZXI6IFtcbiAgICAnYm9yZGVyQm90dG9tQ29sb3InLFxuICAgICdib3JkZXJCb3R0b21TdHlsZScsXG4gICAgJ2JvcmRlckJvdHRvbVdpZHRoJyxcbiAgICAnYm9yZGVySW1hZ2VPdXRzZXQnLFxuICAgICdib3JkZXJJbWFnZVJlcGVhdCcsXG4gICAgJ2JvcmRlckltYWdlU2xpY2UnLFxuICAgICdib3JkZXJJbWFnZVNvdXJjZScsXG4gICAgJ2JvcmRlckltYWdlV2lkdGgnLFxuICAgICdib3JkZXJMZWZ0Q29sb3InLFxuICAgICdib3JkZXJMZWZ0U3R5bGUnLFxuICAgICdib3JkZXJMZWZ0V2lkdGgnLFxuICAgICdib3JkZXJSaWdodENvbG9yJyxcbiAgICAnYm9yZGVyUmlnaHRTdHlsZScsXG4gICAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAgICdib3JkZXJUb3BDb2xvcicsXG4gICAgJ2JvcmRlclRvcFN0eWxlJyxcbiAgICAnYm9yZGVyVG9wV2lkdGgnLFxuICBdLFxuICBib3JkZXJCbG9ja0VuZDogW1xuICAgICdib3JkZXJCbG9ja0VuZENvbG9yJyxcbiAgICAnYm9yZGVyQmxvY2tFbmRTdHlsZScsXG4gICAgJ2JvcmRlckJsb2NrRW5kV2lkdGgnLFxuICBdLFxuICBib3JkZXJCbG9ja1N0YXJ0OiBbXG4gICAgJ2JvcmRlckJsb2NrU3RhcnRDb2xvcicsXG4gICAgJ2JvcmRlckJsb2NrU3RhcnRTdHlsZScsXG4gICAgJ2JvcmRlckJsb2NrU3RhcnRXaWR0aCcsXG4gIF0sXG4gIGJvcmRlckJvdHRvbTogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCddLFxuICBib3JkZXJDb2xvcjogW1xuICAgICdib3JkZXJCb3R0b21Db2xvcicsXG4gICAgJ2JvcmRlckxlZnRDb2xvcicsXG4gICAgJ2JvcmRlclJpZ2h0Q29sb3InLFxuICAgICdib3JkZXJUb3BDb2xvcicsXG4gIF0sXG4gIGJvcmRlckltYWdlOiBbXG4gICAgJ2JvcmRlckltYWdlT3V0c2V0JyxcbiAgICAnYm9yZGVySW1hZ2VSZXBlYXQnLFxuICAgICdib3JkZXJJbWFnZVNsaWNlJyxcbiAgICAnYm9yZGVySW1hZ2VTb3VyY2UnLFxuICAgICdib3JkZXJJbWFnZVdpZHRoJyxcbiAgXSxcbiAgYm9yZGVySW5saW5lRW5kOiBbXG4gICAgJ2JvcmRlcklubGluZUVuZENvbG9yJyxcbiAgICAnYm9yZGVySW5saW5lRW5kU3R5bGUnLFxuICAgICdib3JkZXJJbmxpbmVFbmRXaWR0aCcsXG4gIF0sXG4gIGJvcmRlcklubGluZVN0YXJ0OiBbXG4gICAgJ2JvcmRlcklubGluZVN0YXJ0Q29sb3InLFxuICAgICdib3JkZXJJbmxpbmVTdGFydFN0eWxlJyxcbiAgICAnYm9yZGVySW5saW5lU3RhcnRXaWR0aCcsXG4gIF0sXG4gIGJvcmRlckxlZnQ6IFsnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnXSxcbiAgYm9yZGVyUmFkaXVzOiBbXG4gICAgJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLFxuICAgICdib3JkZXJCb3R0b21SaWdodFJhZGl1cycsXG4gICAgJ2JvcmRlclRvcExlZnRSYWRpdXMnLFxuICAgICdib3JkZXJUb3BSaWdodFJhZGl1cycsXG4gIF0sXG4gIGJvcmRlclJpZ2h0OiBbJ2JvcmRlclJpZ2h0Q29sb3InLCAnYm9yZGVyUmlnaHRTdHlsZScsICdib3JkZXJSaWdodFdpZHRoJ10sXG4gIGJvcmRlclN0eWxlOiBbXG4gICAgJ2JvcmRlckJvdHRvbVN0eWxlJyxcbiAgICAnYm9yZGVyTGVmdFN0eWxlJyxcbiAgICAnYm9yZGVyUmlnaHRTdHlsZScsXG4gICAgJ2JvcmRlclRvcFN0eWxlJyxcbiAgXSxcbiAgYm9yZGVyVG9wOiBbJ2JvcmRlclRvcENvbG9yJywgJ2JvcmRlclRvcFN0eWxlJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGJvcmRlcldpZHRoOiBbXG4gICAgJ2JvcmRlckJvdHRvbVdpZHRoJyxcbiAgICAnYm9yZGVyTGVmdFdpZHRoJyxcbiAgICAnYm9yZGVyUmlnaHRXaWR0aCcsXG4gICAgJ2JvcmRlclRvcFdpZHRoJyxcbiAgXSxcbiAgY29sdW1uUnVsZTogWydjb2x1bW5SdWxlQ29sb3InLCAnY29sdW1uUnVsZVN0eWxlJywgJ2NvbHVtblJ1bGVXaWR0aCddLFxuICBjb2x1bW5zOiBbJ2NvbHVtbkNvdW50JywgJ2NvbHVtbldpZHRoJ10sXG4gIGZsZXg6IFsnZmxleEJhc2lzJywgJ2ZsZXhHcm93JywgJ2ZsZXhTaHJpbmsnXSxcbiAgZmxleEZsb3c6IFsnZmxleERpcmVjdGlvbicsICdmbGV4V3JhcCddLFxuICBmb250OiBbXG4gICAgJ2ZvbnRGYW1pbHknLFxuICAgICdmb250RmVhdHVyZVNldHRpbmdzJyxcbiAgICAnZm9udEtlcm5pbmcnLFxuICAgICdmb250TGFuZ3VhZ2VPdmVycmlkZScsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAnZm9udFNpemVBZGp1c3QnLFxuICAgICdmb250U3RyZXRjaCcsXG4gICAgJ2ZvbnRTdHlsZScsXG4gICAgJ2ZvbnRWYXJpYW50JyxcbiAgICAnZm9udFZhcmlhbnRBbHRlcm5hdGVzJyxcbiAgICAnZm9udFZhcmlhbnRDYXBzJyxcbiAgICAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLFxuICAgICdmb250VmFyaWFudExpZ2F0dXJlcycsXG4gICAgJ2ZvbnRWYXJpYW50TnVtZXJpYycsXG4gICAgJ2ZvbnRWYXJpYW50UG9zaXRpb24nLFxuICAgICdmb250V2VpZ2h0JyxcbiAgICAnbGluZUhlaWdodCcsXG4gIF0sXG4gIGZvbnRWYXJpYW50OiBbXG4gICAgJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsXG4gICAgJ2ZvbnRWYXJpYW50Q2FwcycsXG4gICAgJ2ZvbnRWYXJpYW50RWFzdEFzaWFuJyxcbiAgICAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLFxuICAgICdmb250VmFyaWFudE51bWVyaWMnLFxuICAgICdmb250VmFyaWFudFBvc2l0aW9uJyxcbiAgXSxcbiAgZ2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZDogW1xuICAgICdncmlkQXV0b0NvbHVtbnMnLFxuICAgICdncmlkQXV0b0Zsb3cnLFxuICAgICdncmlkQXV0b1Jvd3MnLFxuICAgICdncmlkVGVtcGxhdGVBcmVhcycsXG4gICAgJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLFxuICAgICdncmlkVGVtcGxhdGVSb3dzJyxcbiAgXSxcbiAgZ3JpZEFyZWE6IFsnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3RhcnQnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3RhcnQnXSxcbiAgZ3JpZENvbHVtbjogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCddLFxuICBncmlkQ29sdW1uR2FwOiBbJ2NvbHVtbkdhcCddLFxuICBncmlkR2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZFJvdzogWydncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkUm93R2FwOiBbJ3Jvd0dhcCddLFxuICBncmlkVGVtcGxhdGU6IFtcbiAgICAnZ3JpZFRlbXBsYXRlQXJlYXMnLFxuICAgICdncmlkVGVtcGxhdGVDb2x1bW5zJyxcbiAgICAnZ3JpZFRlbXBsYXRlUm93cycsXG4gIF0sXG4gIGxpc3RTdHlsZTogWydsaXN0U3R5bGVJbWFnZScsICdsaXN0U3R5bGVQb3NpdGlvbicsICdsaXN0U3R5bGVUeXBlJ10sXG4gIG1hcmdpbjogWydtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Ub3AnXSxcbiAgbWFya2VyOiBbJ21hcmtlckVuZCcsICdtYXJrZXJNaWQnLCAnbWFya2VyU3RhcnQnXSxcbiAgbWFzazogW1xuICAgICdtYXNrQ2xpcCcsXG4gICAgJ21hc2tDb21wb3NpdGUnLFxuICAgICdtYXNrSW1hZ2UnLFxuICAgICdtYXNrTW9kZScsXG4gICAgJ21hc2tPcmlnaW4nLFxuICAgICdtYXNrUG9zaXRpb25YJyxcbiAgICAnbWFza1Bvc2l0aW9uWScsXG4gICAgJ21hc2tSZXBlYXQnLFxuICAgICdtYXNrU2l6ZScsXG4gIF0sXG4gIG1hc2tQb3NpdGlvbjogWydtYXNrUG9zaXRpb25YJywgJ21hc2tQb3NpdGlvblknXSxcbiAgb3V0bGluZTogWydvdXRsaW5lQ29sb3InLCAnb3V0bGluZVN0eWxlJywgJ291dGxpbmVXaWR0aCddLFxuICBvdmVyZmxvdzogWydvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ10sXG4gIHBhZGRpbmc6IFsncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ1RvcCddLFxuICBwbGFjZUNvbnRlbnQ6IFsnYWxpZ25Db250ZW50JywgJ2p1c3RpZnlDb250ZW50J10sXG4gIHBsYWNlSXRlbXM6IFsnYWxpZ25JdGVtcycsICdqdXN0aWZ5SXRlbXMnXSxcbiAgcGxhY2VTZWxmOiBbJ2FsaWduU2VsZicsICdqdXN0aWZ5U2VsZiddLFxuICB0ZXh0RGVjb3JhdGlvbjogW1xuICAgICd0ZXh0RGVjb3JhdGlvbkNvbG9yJyxcbiAgICAndGV4dERlY29yYXRpb25MaW5lJyxcbiAgICAndGV4dERlY29yYXRpb25TdHlsZScsXG4gIF0sXG4gIHRleHRFbXBoYXNpczogWyd0ZXh0RW1waGFzaXNDb2xvcicsICd0ZXh0RW1waGFzaXNTdHlsZSddLFxuICB0cmFuc2l0aW9uOiBbXG4gICAgJ3RyYW5zaXRpb25EZWxheScsXG4gICAgJ3RyYW5zaXRpb25EdXJhdGlvbicsXG4gICAgJ3RyYW5zaXRpb25Qcm9wZXJ0eScsXG4gICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbicsXG4gIF0sXG4gIHdvcmRXcmFwOiBbJ292ZXJmbG93V3JhcCddLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0NTU1Nob3J0aGFuZFByb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge2lzVW5pdGxlc3NOdW1iZXJ9IGZyb20gJy4vQ1NTUHJvcGVydHknO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgY29uc3QgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChcbiAgICAhaXNDdXN0b21Qcm9wZXJ0eSAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSAhPT0gMCAmJlxuICAgICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKVxuICApIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWUsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG5jb25zdCBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvQ1NTUHJvcGVydHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuY29uc3QgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5jb25zdCBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5hbWVcbiAgICAucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJylcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnc2hhcmVkL3dhcm5pbmcnO1xuXG5sZXQgd2FyblZhbGlkU3R5bGUgPSAoKSA9PiB7fTtcblxuaWYgKF9fREVWX18pIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICBjb25zdCBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIGNvbnN0IG1zUGF0dGVybiA9IC9eLW1zLS87XG4gIGNvbnN0IGh5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICBjb25zdCBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICBjb25zdCB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIGNvbnN0IHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIGxldCB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICBsZXQgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIGNvbnN0IGNhbWVsaXplID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLFxuICAgICAgbmFtZSxcbiAgICAgIC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAgICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSksXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLFxuICAgICAgbmFtZSxcbiAgICAgIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuICAgICk7XG4gIH07XG5cbiAgY29uc3Qgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICtcbiAgICAgICAgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpLFxuICAgICk7XG4gIH07XG5cbiAgY29uc3Qgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJyxcbiAgICAgIG5hbWUsXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsXG4gICAgICBuYW1lLFxuICAgICk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdhcm5WYWxpZFN0eWxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvd2FyblZhbGlkU3R5bGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnc2hhcmVkL2ludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG4vLyBUT0RPOiBXZSBjYW4gcmVtb3ZlIHRoaXMgaWYgd2UgYWRkIGludmFyaWFudFdpdGhTdGFjaygpXG4vLyBvciBhZGQgc3RhY2sgYnkgZGVmYXVsdCB0byBpbnZhcmlhbnRzIHdoZXJlIHBvc3NpYmxlLlxuaW1wb3J0IFJlYWN0U2hhcmVkSW50ZXJuYWxzIGZyb20gJ3NoYXJlZC9SZWFjdFNoYXJlZEludGVybmFscyc7XG5cbmltcG9ydCB2b2lkRWxlbWVudFRhZ3MgZnJvbSAnLi92b2lkRWxlbWVudFRhZ3MnO1xuXG5jb25zdCBIVE1MID0gJ19faHRtbCc7XG5cbmxldCBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gbnVsbDtcbmlmIChfX0RFVl9fKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZzogc3RyaW5nLCBwcm9wczogP09iamVjdCkge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGludmFyaWFudChcbiAgICAgIHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCxcbiAgICAgICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yICcgK1xuICAgICAgICAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLFxuICAgICAgdGFnLFxuICAgICAgX19ERVZfXyA/IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpIDogJycsXG4gICAgKTtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHByb3BzLmNoaWxkcmVuID09IG51bGwsXG4gICAgICAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyxcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCxcbiAgICAgICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICtcbiAgICAgICAgJ1BsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCAnICtcbiAgICAgICAgJ2ZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgKTtcbiAgfVxuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5pbmcoXG4gICAgICBwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHxcbiAgICAgICAgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fFxuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLFxuICAgICAgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArXG4gICAgICAgICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICtcbiAgICAgICAgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICtcbiAgICAgICAgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nLFxuICAgICk7XG4gIH1cbiAgaW52YXJpYW50KFxuICAgIHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JyxcbiAgICAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCAnICtcbiAgICAgIFwibm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIFwiICtcbiAgICAgICd1c2luZyBKU1guJXMnLFxuICAgIF9fREVWX18gPyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSA6ICcnLFxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NlcnRWYWxpZFByb3BzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvYXNzZXJ0VmFsaWRQcm9wcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IG9taXR0ZWRDbG9zZVRhZ3MgZnJvbSAnLi9vbWl0dGVkQ2xvc2VUYWdzJztcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG5jb25zdCB2b2lkRWxlbWVudFRhZ3MgPSB7XG4gIG1lbnVpdGVtOiB0cnVlLFxuICAuLi5vbWl0dGVkQ2xvc2VUYWdzLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdm9pZEVsZW1lbnRUYWdzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvdm9pZEVsZW1lbnRUYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG5jb25zdCBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSxcbiAgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9taXR0ZWRDbG9zZVRhZ3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9vbWl0dGVkQ2xvc2VUYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbmltcG9ydCB7QVRUUklCVVRFX05BTUVfQ0hBUn0gZnJvbSAnLi9ET01Qcm9wZXJ0eSc7XG5pbXBvcnQgaXNDdXN0b21Db21wb25lbnQgZnJvbSAnLi9pc0N1c3RvbUNvbXBvbmVudCc7XG5pbXBvcnQgdmFsaWRBcmlhUHJvcGVydGllcyBmcm9tICcuL3ZhbGlkQXJpYVByb3BlcnRpZXMnO1xuXG5jb25zdCB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5jb25zdCByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuY29uc3QgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgIGNvbnN0IGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjb3JyZWN0TmFtZSA9IHZhbGlkQXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpXG4gICAgICA/IGFyaWFOYW1lXG4gICAgICA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJyxcbiAgICAgICAgbmFtZSxcbiAgICAgICk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLFxuICAgICAgICBuYW1lLFxuICAgICAgICBjb3JyZWN0TmFtZSxcbiAgICAgICk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgY29uc3QgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgc3RhbmRhcmROYW1lID0gdmFsaWRBcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSlcbiAgICAgID8gbG93ZXJDYXNlZE5hbWVcbiAgICAgIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhbmRhcmROYW1lLFxuICAgICAgKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIGNvbnN0IGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHNcbiAgICAubWFwKHByb3AgPT4gJ2AnICsgcHJvcCArICdgJylcbiAgICAuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArXG4gICAgICAgICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AnLFxuICAgICAgdW5rbm93blByb3BTdHJpbmcsXG4gICAgICB0eXBlLFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICtcbiAgICAgICAgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCcsXG4gICAgICB1bmtub3duUHJvcFN0cmluZyxcbiAgICAgIHR5cGUsXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvUmVhY3RET01JbnZhbGlkQVJJQUhvb2suanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXJpYVByb3BlcnRpZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC92YWxpZEFyaWFQcm9wZXJ0aWVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICdzaGFyZWQvd2FybmluZyc7XG5cbmxldCBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArXG4gICAgICAgICAgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgK1xuICAgICAgICAgICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLFxuICAgICAgICB0eXBlLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgK1xuICAgICAgICAgICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICtcbiAgICAgICAgICAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsXG4gICAgICAgIHR5cGUsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQge1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyxcbn0gZnJvbSAnZXZlbnRzL0V2ZW50UGx1Z2luUmVnaXN0cnknO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnc2hhcmVkL3dhcm5pbmcnO1xuXG5pbXBvcnQge1xuICBBVFRSSUJVVEVfTkFNRV9DSEFSLFxuICBCT09MRUFOLFxuICBSRVNFUlZFRCxcbiAgc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcsXG4gIGdldFByb3BlcnR5SW5mbyxcbn0gZnJvbSAnLi9ET01Qcm9wZXJ0eSc7XG5pbXBvcnQgaXNDdXN0b21Db21wb25lbnQgZnJvbSAnLi9pc0N1c3RvbUNvbXBvbmVudCc7XG5pbXBvcnQgcG9zc2libGVTdGFuZGFyZE5hbWVzIGZyb20gJy4vcG9zc2libGVTdGFuZGFyZE5hbWVzJztcblxubGV0IHZhbGlkYXRlUHJvcGVydHkgPSAoKSA9PiB7fTtcblxuaWYgKF9fREVWX18pIHtcbiAgY29uc3Qgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuICBjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGNvbnN0IEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIGNvbnN0IElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICBjb25zdCByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICBjb25zdCByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbih0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgK1xuICAgICAgICAgICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgK1xuICAgICAgICAgICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyxcbiAgICAgICk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgIGxvd2VyQ2FzZWROYW1lLFxuICAgICAgKVxuICAgICAgICA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICByZWdpc3RyYXRpb25OYW1lLFxuICAgICAgICApO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICApO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgK1xuICAgICAgICAgICAgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgK1xuICAgICAgICAgICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nLFxuICAgICAgKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgK1xuICAgICAgICAgICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyxcbiAgICAgICk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmXG4gICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgK1xuICAgICAgICAgICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJyxcbiAgICAgICAgdHlwZW9mIHZhbHVlLFxuICAgICAgKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgK1xuICAgICAgICAgICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJyxcbiAgICAgICAgbmFtZSxcbiAgICAgICk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgICBjb25zdCBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcblxuICAgIC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIGNvbnN0IHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzdGFuZGFyZE5hbWUsXG4gICAgICAgICk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgK1xuICAgICAgICAgICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArXG4gICAgICAgICAgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArXG4gICAgICAgICAgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArXG4gICAgICAgICAgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGxvd2VyQ2FzZWROYW1lLFxuICAgICAgKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiZcbiAgICAgIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKVxuICAgICkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArXG4gICAgICAgICAgICAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICtcbiAgICAgICAgICAgICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgK1xuICAgICAgICAgICAgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArXG4gICAgICAgICAgICAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICtcbiAgICAgICAgICAgICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArXG4gICAgICAgICAgICAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJyxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuICAgIGlmIChcbiAgICAgICh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJlxuICAgICAgcHJvcGVydHlJbmZvICE9PSBudWxsICYmXG4gICAgICBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTlxuICAgICkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICtcbiAgICAgICAgICAnJXMgJyArXG4gICAgICAgICAgJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgICAgID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLidcbiAgICAgICAgICA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmNvbnN0IHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBjb25zdCB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGNhblVzZUV2ZW50U3lzdGVtKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHNcbiAgICAubWFwKHByb3AgPT4gJ2AnICsgcHJvcCArICdgJylcbiAgICAuam9pbignLCAnKTtcbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICtcbiAgICAgICAgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArXG4gICAgICAgICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJyxcbiAgICAgIHVua25vd25Qcm9wU3RyaW5nLFxuICAgICAgdHlwZSxcbiAgICApO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgK1xuICAgICAgICAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgK1xuICAgICAgICAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvcicsXG4gICAgICB1bmtub3duUHJvcFN0cmluZyxcbiAgICAgIHR5cGUsXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgKiBmcm9tICdyZWFjdC1kb20vc3JjL2NsaWVudC9SZWFjdERPTUhvc3RDb25maWcnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvZm9ya3MvUmVhY3RGaWJlckhvc3RDb25maWcuZG9tLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7cHJlY2FjaGVGaWJlck5vZGUsIHVwZGF0ZUZpYmVyUHJvcHN9IGZyb20gJy4vUmVhY3RET01Db21wb25lbnRUcmVlJztcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZVRleHROb2RlLFxuICBzZXRJbml0aWFsUHJvcGVydGllcyxcbiAgZGlmZlByb3BlcnRpZXMsXG4gIHVwZGF0ZVByb3BlcnRpZXMsXG4gIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMsXG4gIGRpZmZIeWRyYXRlZFRleHQsXG4gIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50LFxuICB3YXJuRm9yVW5tYXRjaGVkVGV4dCxcbiAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCxcbiAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCxcbiAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50LFxuICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQsXG59IGZyb20gJy4vUmVhY3RET01Db21wb25lbnQnO1xuaW1wb3J0IHtnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiwgcmVzdG9yZVNlbGVjdGlvbn0gZnJvbSAnLi9SZWFjdElucHV0U2VsZWN0aW9uJztcbmltcG9ydCBzZXRUZXh0Q29udGVudCBmcm9tICcuL3NldFRleHRDb250ZW50JztcbmltcG9ydCB7dmFsaWRhdGVET01OZXN0aW5nLCB1cGRhdGVkQW5jZXN0b3JJbmZvfSBmcm9tICcuL3ZhbGlkYXRlRE9NTmVzdGluZyc7XG5pbXBvcnQge1xuICBpc0VuYWJsZWQgYXMgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVySXNFbmFibGVkLFxuICBzZXRFbmFibGVkIGFzIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlclNldEVuYWJsZWQsXG59IGZyb20gJy4uL2V2ZW50cy9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInO1xuaW1wb3J0IHtnZXRDaGlsZE5hbWVzcGFjZX0gZnJvbSAnLi4vc2hhcmVkL0RPTU5hbWVzcGFjZXMnO1xuaW1wb3J0IHtcbiAgRUxFTUVOVF9OT0RFLFxuICBURVhUX05PREUsXG4gIENPTU1FTlRfTk9ERSxcbiAgRE9DVU1FTlRfTk9ERSxcbiAgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSxcbn0gZnJvbSAnLi4vc2hhcmVkL0hUTUxOb2RlVHlwZSc7XG5pbXBvcnQgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSBmcm9tICcuLi9zaGFyZWQvZGFuZ2Vyb3VzU3R5bGVWYWx1ZSc7XG5cbmltcG9ydCB0eXBlIHtET01Db250YWluZXJ9IGZyb20gJy4vUmVhY3RET00nO1xuXG5leHBvcnQgdHlwZSBUeXBlID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgUHJvcHMgPSB7XG4gIGF1dG9Gb2N1cz86IGJvb2xlYW4sXG4gIGNoaWxkcmVuPzogbWl4ZWQsXG4gIGhpZGRlbj86IGJvb2xlYW4sXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZz86IGJvb2xlYW4sXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPzogbWl4ZWQsXG4gIHN0eWxlPzoge1xuICAgIGRpc3BsYXk/OiBzdHJpbmcsXG4gIH0sXG59O1xuZXhwb3J0IHR5cGUgQ29udGFpbmVyID0gRWxlbWVudCB8IERvY3VtZW50O1xuZXhwb3J0IHR5cGUgSW5zdGFuY2UgPSBFbGVtZW50O1xuZXhwb3J0IHR5cGUgVGV4dEluc3RhbmNlID0gVGV4dDtcbmV4cG9ydCB0eXBlIFN1c3BlbnNlSW5zdGFuY2UgPSBDb21tZW50O1xuZXhwb3J0IHR5cGUgSHlkcmF0YWJsZUluc3RhbmNlID0gSW5zdGFuY2UgfCBUZXh0SW5zdGFuY2UgfCBTdXNwZW5zZUluc3RhbmNlO1xuZXhwb3J0IHR5cGUgUHVibGljSW5zdGFuY2UgPSBFbGVtZW50IHwgVGV4dDtcbnR5cGUgSG9zdENvbnRleHREZXYgPSB7XG4gIG5hbWVzcGFjZTogc3RyaW5nLFxuICBhbmNlc3RvckluZm86IG1peGVkLFxufTtcbnR5cGUgSG9zdENvbnRleHRQcm9kID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgSG9zdENvbnRleHQgPSBIb3N0Q29udGV4dERldiB8IEhvc3RDb250ZXh0UHJvZDtcbmV4cG9ydCB0eXBlIFVwZGF0ZVBheWxvYWQgPSBBcnJheTxtaXhlZD47XG5leHBvcnQgdHlwZSBDaGlsZFNldCA9IHZvaWQ7IC8vIFVudXNlZFxuZXhwb3J0IHR5cGUgVGltZW91dEhhbmRsZSA9IFRpbWVvdXRJRDtcbmV4cG9ydCB0eXBlIE5vVGltZW91dCA9IC0xO1xuXG5pbXBvcnQge1xuICB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIGFzIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxcbiAgdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgYXMgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayxcbn0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7ZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcn0gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcbmV4cG9ydCB7XG4gIHVuc3RhYmxlX25vdyBhcyBub3csXG4gIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgYXMgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICB1bnN0YWJsZV9zaG91bGRZaWVsZCBhcyBzaG91bGRZaWVsZCxcbiAgdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgYXMgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayxcbn0gZnJvbSAnc2NoZWR1bGVyJztcblxubGV0IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HO1xuaWYgKF9fREVWX18pIHtcbiAgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbn1cblxuY29uc3QgU1VTUEVOU0VfU1RBUlRfREFUQSA9ICckJztcbmNvbnN0IFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcblxuY29uc3QgU1RZTEUgPSAnc3R5bGUnO1xuXG5sZXQgZXZlbnRzRW5hYmxlZDogP2Jvb2xlYW4gPSBudWxsO1xubGV0IHNlbGVjdGlvbkluZm9ybWF0aW9uOiA/bWl4ZWQgPSBudWxsO1xuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGU6IHN0cmluZywgcHJvcHM6IFByb3BzKTogYm9vbGVhbiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0ICogZnJvbSAnc2hhcmVkL0hvc3RDb25maWdXaXRoTm9QZXJzaXN0ZW5jZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRleHQoXG4gIHJvb3RDb250YWluZXJJbnN0YW5jZTogQ29udGFpbmVyLFxuKTogSG9zdENvbnRleHQge1xuICBsZXQgdHlwZTtcbiAgbGV0IG5hbWVzcGFjZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSByb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7XG4gIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOiB7XG4gICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgbGV0IHJvb3QgPSAocm9vdENvbnRhaW5lckluc3RhbmNlOiBhbnkpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBjb250YWluZXI6IGFueSA9XG4gICAgICAgIG5vZGVUeXBlID09PSBDT01NRU5UX05PREVcbiAgICAgICAgICA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlXG4gICAgICAgICAgOiByb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICBjb25zdCBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnKTtcbiAgICByZXR1cm4ge25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvfTtcbiAgfVxuICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hpbGRIb3N0Q29udGV4dChcbiAgcGFyZW50SG9zdENvbnRleHQ6IEhvc3RDb250ZXh0LFxuICB0eXBlOiBzdHJpbmcsXG4gIHJvb3RDb250YWluZXJJbnN0YW5jZTogQ29udGFpbmVyLFxuKTogSG9zdENvbnRleHQge1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnN0IHBhcmVudEhvc3RDb250ZXh0RGV2ID0gKChwYXJlbnRIb3N0Q29udGV4dDogYW55KTogSG9zdENvbnRleHREZXYpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgY29uc3QgYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhcbiAgICAgIHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyxcbiAgICAgIHR5cGUsXG4gICAgKTtcbiAgICByZXR1cm4ge25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvfTtcbiAgfVxuICBjb25zdCBwYXJlbnROYW1lc3BhY2UgPSAoKHBhcmVudEhvc3RDb250ZXh0OiBhbnkpOiBIb3N0Q29udGV4dFByb2QpO1xuICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlOiBJbnN0YW5jZSk6ICoge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm86IENvbnRhaW5lcik6IHZvaWQge1xuICBldmVudHNFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVySXNFbmFibGVkKCk7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyU2V0RW5hYmxlZChmYWxzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEFmdGVyQ29tbWl0KGNvbnRhaW5lckluZm86IENvbnRhaW5lcik6IHZvaWQge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJTZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICBldmVudHNFbmFibGVkID0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKFxuICB0eXBlOiBzdHJpbmcsXG4gIHByb3BzOiBQcm9wcyxcbiAgcm9vdENvbnRhaW5lckluc3RhbmNlOiBDb250YWluZXIsXG4gIGhvc3RDb250ZXh0OiBIb3N0Q29udGV4dCxcbiAgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZTogT2JqZWN0LFxuKTogSW5zdGFuY2Uge1xuICBsZXQgcGFyZW50TmFtZXNwYWNlOiBzdHJpbmc7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICBjb25zdCBob3N0Q29udGV4dERldiA9ICgoaG9zdENvbnRleHQ6IGFueSk6IEhvc3RDb250ZXh0RGV2KTtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInXG4gICAgKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgY29uc3Qgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhcbiAgICAgICAgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLFxuICAgICAgICB0eXBlLFxuICAgICAgKTtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROYW1lc3BhY2UgPSAoKGhvc3RDb250ZXh0OiBhbnkpOiBIb3N0Q29udGV4dFByb2QpO1xuICB9XG4gIGNvbnN0IGRvbUVsZW1lbnQ6IEluc3RhbmNlID0gY3JlYXRlRWxlbWVudChcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICBwYXJlbnROYW1lc3BhY2UsXG4gICk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRJbml0aWFsQ2hpbGQoXG4gIHBhcmVudEluc3RhbmNlOiBJbnN0YW5jZSxcbiAgY2hpbGQ6IEluc3RhbmNlIHwgVGV4dEluc3RhbmNlLFxuKTogdm9pZCB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKFxuICBkb21FbGVtZW50OiBJbnN0YW5jZSxcbiAgdHlwZTogc3RyaW5nLFxuICBwcm9wczogUHJvcHMsXG4gIHJvb3RDb250YWluZXJJbnN0YW5jZTogQ29udGFpbmVyLFxuICBob3N0Q29udGV4dDogSG9zdENvbnRleHQsXG4pOiBib29sZWFuIHtcbiAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVVcGRhdGUoXG4gIGRvbUVsZW1lbnQ6IEluc3RhbmNlLFxuICB0eXBlOiBzdHJpbmcsXG4gIG9sZFByb3BzOiBQcm9wcyxcbiAgbmV3UHJvcHM6IFByb3BzLFxuICByb290Q29udGFpbmVySW5zdGFuY2U6IENvbnRhaW5lcixcbiAgaG9zdENvbnRleHQ6IEhvc3RDb250ZXh0LFxuKTogbnVsbCB8IEFycmF5PG1peGVkPiB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgaG9zdENvbnRleHREZXYgPSAoKGhvc3RDb250ZXh0OiBhbnkpOiBIb3N0Q29udGV4dERldik7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiZcbiAgICAgICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpXG4gICAgKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgY29uc3Qgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhcbiAgICAgICAgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLFxuICAgICAgICB0eXBlLFxuICAgICAgKTtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmUHJvcGVydGllcyhcbiAgICBkb21FbGVtZW50LFxuICAgIHR5cGUsXG4gICAgb2xkUHJvcHMsXG4gICAgbmV3UHJvcHMsXG4gICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZTogc3RyaW5nLCBwcm9wczogUHJvcHMpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlID09PSAndGV4dGFyZWEnIHx8XG4gICAgdHlwZSA9PT0gJ29wdGlvbicgfHxcbiAgICB0eXBlID09PSAnbm9zY3JpcHQnIHx8XG4gICAgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHxcbiAgICAodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJlxuICAgICAgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09IG51bGwgJiZcbiAgICAgIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlOiBzdHJpbmcsIHByb3BzOiBQcm9wcyk6IGJvb2xlYW4ge1xuICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gIHRleHQ6IHN0cmluZyxcbiAgcm9vdENvbnRhaW5lckluc3RhbmNlOiBDb250YWluZXIsXG4gIGhvc3RDb250ZXh0OiBIb3N0Q29udGV4dCxcbiAgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZTogT2JqZWN0LFxuKTogVGV4dEluc3RhbmNlIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBob3N0Q29udGV4dERldiA9ICgoaG9zdENvbnRleHQ6IGFueSk6IEhvc3RDb250ZXh0RGV2KTtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgfVxuICBjb25zdCB0ZXh0Tm9kZTogVGV4dEluc3RhbmNlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICByZXR1cm4gdGV4dE5vZGU7XG59XG5cbmV4cG9ydCBjb25zdCBpc1ByaW1hcnlSZW5kZXJlciA9IHRydWU7XG4vLyBUaGlzIGluaXRpYWxpemF0aW9uIGNvZGUgbWF5IHJ1biBldmVuIG9uIHNlcnZlciBlbnZpcm9ubWVudHNcbi8vIGlmIGEgY29tcG9uZW50IGp1c3QgaW1wb3J0cyBSZWFjdERPTSAoZS5nLiBmb3IgZmluZERPTU5vZGUpLlxuLy8gU29tZSBlbnZpcm9ubWVudHMgbWlnaHQgbm90IGhhdmUgc2V0VGltZW91dCBvciBjbGVhclRpbWVvdXQuXG5leHBvcnQgY29uc3Qgc2NoZWR1bGVUaW1lb3V0ID1cbiAgdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogKHVuZGVmaW5lZDogYW55KTtcbmV4cG9ydCBjb25zdCBjYW5jZWxUaW1lb3V0ID1cbiAgdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6ICh1bmRlZmluZWQ6IGFueSk7XG5leHBvcnQgY29uc3Qgbm9UaW1lb3V0ID0gLTE7XG5leHBvcnQgY29uc3Qgc2NoZWR1bGVQYXNzaXZlRWZmZWN0cyA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjaztcbmV4cG9ydCBjb25zdCBjYW5jZWxQYXNzaXZlRWZmZWN0cyA9IGNhbmNlbERlZmVycmVkQ2FsbGJhY2s7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBNdXRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNNdXRhdGlvbiA9IHRydWU7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRNb3VudChcbiAgZG9tRWxlbWVudDogSW5zdGFuY2UsXG4gIHR5cGU6IHN0cmluZyxcbiAgbmV3UHJvcHM6IFByb3BzLFxuICBpbnRlcm5hbEluc3RhbmNlSGFuZGxlOiBPYmplY3QsXG4pOiB2b2lkIHtcbiAgLy8gRGVzcGl0ZSB0aGUgbmFtaW5nIHRoYXQgbWlnaHQgaW1wbHkgb3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBvbmx5XG4gIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAvLyBUaGlzIGhhcHBlbnMgaWYgYGZpbmFsaXplSW5pdGlhbENoaWxkcmVuYCByZXR1cm5zIGB0cnVlYCAod2hpY2ggaXRcbiAgLy8gZG9lcyB0byBpbXBsZW1lbnQgdGhlIGBhdXRvRm9jdXNgIGF0dHJpYnV0ZSBvbiB0aGUgY2xpZW50KS4gQnV0XG4gIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgLy8gdXAgdGV4dCBjb250ZW50IGR1cmluZyBoeWRyYXRpb24gbWlzbWF0Y2gpLiBTbyB3ZSdsbCBjaGVjayB0aGlzIGFnYWluLlxuICBpZiAoc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBuZXdQcm9wcykpIHtcbiAgICAoKGRvbUVsZW1lbnQ6IGFueSk6XG4gICAgICB8IEhUTUxCdXR0b25FbGVtZW50XG4gICAgICB8IEhUTUxJbnB1dEVsZW1lbnRcbiAgICAgIHwgSFRNTFNlbGVjdEVsZW1lbnRcbiAgICAgIHwgSFRNTFRleHRBcmVhRWxlbWVudCkuZm9jdXMoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0VXBkYXRlKFxuICBkb21FbGVtZW50OiBJbnN0YW5jZSxcbiAgdXBkYXRlUGF5bG9hZDogQXJyYXk8bWl4ZWQ+LFxuICB0eXBlOiBzdHJpbmcsXG4gIG9sZFByb3BzOiBQcm9wcyxcbiAgbmV3UHJvcHM6IFByb3BzLFxuICBpbnRlcm5hbEluc3RhbmNlSGFuZGxlOiBPYmplY3QsXG4pOiB2b2lkIHtcbiAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRUZXh0Q29udGVudChkb21FbGVtZW50OiBJbnN0YW5jZSk6IHZvaWQge1xuICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCAnJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKFxuICB0ZXh0SW5zdGFuY2U6IFRleHRJbnN0YW5jZSxcbiAgb2xkVGV4dDogc3RyaW5nLFxuICBuZXdUZXh0OiBzdHJpbmcsXG4pOiB2b2lkIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChcbiAgcGFyZW50SW5zdGFuY2U6IEluc3RhbmNlLFxuICBjaGlsZDogSW5zdGFuY2UgfCBUZXh0SW5zdGFuY2UsXG4pOiB2b2lkIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihcbiAgY29udGFpbmVyOiBET01Db250YWluZXIsXG4gIGNoaWxkOiBJbnN0YW5jZSB8IFRleHRJbnN0YW5jZSxcbik6IHZvaWQge1xuICBsZXQgcGFyZW50Tm9kZTtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgcGFyZW50Tm9kZSA9IChjb250YWluZXIucGFyZW50Tm9kZTogYW55KTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyO1xuICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG4gIC8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuICAvLyBJZiBzb21ldGhpbmcgaW5zaWRlIGEgcG9ydGFsIGlzIGNsaWNrZWQsIHRoYXQgY2xpY2sgc2hvdWxkIGJ1YmJsZVxuICAvLyB0aHJvdWdoIHRoZSBSZWFjdCB0cmVlLiBIb3dldmVyLCBvbiBNb2JpbGUgU2FmYXJpIHRoZSBjbGljayB3b3VsZFxuICAvLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4gIC8vIGV2ZW50IGV4aXN0cy4gU28gd2Ugd291bGRuJ3Qgc2VlIGl0IGFuZCBkaXNwYXRjaCBpdC5cbiAgLy8gVGhpcyBpcyB3aHkgd2UgZW5zdXJlIHRoYXQgbm9uIFJlYWN0IHJvb3QgY29udGFpbmVycyBoYXZlIGlubGluZSBvbmNsaWNrXG4gIC8vIGRlZmluZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE5MThcbiAgY29uc3QgcmVhY3RSb290Q29udGFpbmVyID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmIChcbiAgICAocmVhY3RSb290Q29udGFpbmVyID09PSBudWxsIHx8IHJlYWN0Um9vdENvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSAmJlxuICAgIHBhcmVudE5vZGUub25jbGljayA9PT0gbnVsbFxuICApIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KCgocGFyZW50Tm9kZTogYW55KTogSFRNTEVsZW1lbnQpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKFxuICBwYXJlbnRJbnN0YW5jZTogSW5zdGFuY2UsXG4gIGNoaWxkOiBJbnN0YW5jZSB8IFRleHRJbnN0YW5jZSxcbiAgYmVmb3JlQ2hpbGQ6IEluc3RhbmNlIHwgVGV4dEluc3RhbmNlIHwgU3VzcGVuc2VJbnN0YW5jZSxcbik6IHZvaWQge1xuICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKFxuICBjb250YWluZXI6IENvbnRhaW5lcixcbiAgY2hpbGQ6IEluc3RhbmNlIHwgVGV4dEluc3RhbmNlLFxuICBiZWZvcmVDaGlsZDogSW5zdGFuY2UgfCBUZXh0SW5zdGFuY2UgfCBTdXNwZW5zZUluc3RhbmNlLFxuKTogdm9pZCB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIChjb250YWluZXIucGFyZW50Tm9kZTogYW55KS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKFxuICBwYXJlbnRJbnN0YW5jZTogSW5zdGFuY2UsXG4gIGNoaWxkOiBJbnN0YW5jZSB8IFRleHRJbnN0YW5jZSB8IFN1c3BlbnNlSW5zdGFuY2UsXG4pOiB2b2lkIHtcbiAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKFxuICBjb250YWluZXI6IENvbnRhaW5lcixcbiAgY2hpbGQ6IEluc3RhbmNlIHwgVGV4dEluc3RhbmNlIHwgU3VzcGVuc2VJbnN0YW5jZSxcbik6IHZvaWQge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAoY29udGFpbmVyLnBhcmVudE5vZGU6IGFueSkucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShcbiAgcGFyZW50SW5zdGFuY2U6IEluc3RhbmNlLFxuICBzdXNwZW5zZUluc3RhbmNlOiBTdXNwZW5zZUluc3RhbmNlLFxuKTogdm9pZCB7XG4gIGxldCBub2RlID0gc3VzcGVuc2VJbnN0YW5jZTtcbiAgLy8gRGVsZXRlIGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbiAgLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG4gIGxldCBkZXB0aCA9IDA7XG4gIGRvIHtcbiAgICBsZXQgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIGlmIChuZXh0Tm9kZSAmJiBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICBsZXQgZGF0YSA9ICgobmV4dE5vZGU6IGFueSkuZGF0YTogc3RyaW5nKTtcbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChuZXh0Tm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlID0gbmV4dE5vZGU7XG4gIH0gd2hpbGUgKG5vZGUpO1xuICAvLyBUT0RPOiBXYXJuLCB3ZSBkaWRuJ3QgZmluZCB0aGUgZW5kIGNvbW1lbnQgYm91bmRhcnkuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKFxuICBjb250YWluZXI6IENvbnRhaW5lcixcbiAgc3VzcGVuc2VJbnN0YW5jZTogU3VzcGVuc2VJbnN0YW5jZSxcbik6IHZvaWQge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkoKGNvbnRhaW5lci5wYXJlbnROb2RlOiBhbnkpLCBzdXNwZW5zZUluc3RhbmNlKTtcbiAgfSBlbHNlIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeSgoY29udGFpbmVyOiBhbnkpLCBzdXNwZW5zZUluc3RhbmNlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEb2N1bWVudCBub2RlcyBzaG91bGQgbmV2ZXIgY29udGFpbiBzdXNwZW5zZSBib3VuZGFyaWVzLlxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2U6IEluc3RhbmNlKTogdm9pZCB7XG4gIC8vIFRPRE86IERvZXMgdGhpcyB3b3JrIGZvciBhbGwgZWxlbWVudCB0eXBlcz8gV2hhdCBhYm91dCBNYXRoTUw/IFNob3VsZCB3ZVxuICAvLyBwYXNzIGhvc3QgY29udGV4dCB0byB0aGlzIG1ldGhvZD9cbiAgaW5zdGFuY2UgPSAoKGluc3RhbmNlOiBhbnkpOiBIVE1MRWxlbWVudCk7XG4gIGluc3RhbmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZTogVGV4dEluc3RhbmNlKTogdm9pZCB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlOiBJbnN0YW5jZSwgcHJvcHM6IFByb3BzKTogdm9pZCB7XG4gIGluc3RhbmNlID0gKChpbnN0YW5jZTogYW55KTogSFRNTEVsZW1lbnQpO1xuICBjb25zdCBzdHlsZVByb3AgPSBwcm9wc1tTVFlMRV07XG4gIGNvbnN0IGRpc3BsYXkgPVxuICAgIHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgc3R5bGVQcm9wICE9PSBudWxsICYmXG4gICAgc3R5bGVQcm9wLmhhc093blByb3BlcnR5KCdkaXNwbGF5JylcbiAgICAgID8gc3R5bGVQcm9wLmRpc3BsYXlcbiAgICAgIDogbnVsbDtcbiAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZShcbiAgdGV4dEluc3RhbmNlOiBUZXh0SW5zdGFuY2UsXG4gIHRleHQ6IHN0cmluZyxcbik6IHZvaWQge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gdGV4dDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIEh5ZHJhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNIeWRyYXRpb24gPSB0cnVlO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKFxuICBpbnN0YW5jZTogSHlkcmF0YWJsZUluc3RhbmNlLFxuICB0eXBlOiBzdHJpbmcsXG4gIHByb3BzOiBQcm9wcyxcbik6IG51bGwgfCBJbnN0YW5jZSB7XG4gIGlmIChcbiAgICBpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8XG4gICAgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICByZXR1cm4gKChpbnN0YW5jZTogYW55KTogSW5zdGFuY2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShcbiAgaW5zdGFuY2U6IEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgdGV4dDogc3RyaW5nLFxuKTogbnVsbCB8IFRleHRJbnN0YW5jZSB7XG4gIGlmICh0ZXh0ID09PSAnJyB8fCBpbnN0YW5jZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gIHJldHVybiAoKGluc3RhbmNlOiBhbnkpOiBUZXh0SW5zdGFuY2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UoXG4gIGluc3RhbmNlOiBIeWRyYXRhYmxlSW5zdGFuY2UsXG4pOiBudWxsIHwgU3VzcGVuc2VJbnN0YW5jZSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSBzdXNwZW5zZSBub2RlLlxuICByZXR1cm4gKChpbnN0YW5jZTogYW55KTogU3VzcGVuc2VJbnN0YW5jZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoXG4gIGluc3RhbmNlOiBIeWRyYXRhYmxlSW5zdGFuY2UsXG4pOiBudWxsIHwgSHlkcmF0YWJsZUluc3RhbmNlIHtcbiAgbGV0IG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgd2hpbGUgKFxuICAgIG5vZGUgJiZcbiAgICBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiZcbiAgICBub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUgJiZcbiAgICAoIWVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgfHxcbiAgICAgIG5vZGUubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSB8fFxuICAgICAgKG5vZGU6IGFueSkuZGF0YSAhPT0gU1VTUEVOU0VfU1RBUlRfREFUQSlcbiAgKSB7XG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIChub2RlOiBhbnkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQoXG4gIHBhcmVudEluc3RhbmNlOiBDb250YWluZXIgfCBJbnN0YW5jZSxcbik6IG51bGwgfCBIeWRyYXRhYmxlSW5zdGFuY2Uge1xuICBsZXQgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIHdoaWxlIChcbiAgICBuZXh0ICYmXG4gICAgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmXG4gICAgbmV4dC5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFICYmXG4gICAgKCFlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyIHx8XG4gICAgICBuZXh0Lm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHxcbiAgICAgIChuZXh0OiBhbnkpLmRhdGEgIT09IFNVU1BFTlNFX1NUQVJUX0RBVEEpXG4gICkge1xuICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICB9XG4gIHJldHVybiAobmV4dDogYW55KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGVJbnN0YW5jZShcbiAgaW5zdGFuY2U6IEluc3RhbmNlLFxuICB0eXBlOiBzdHJpbmcsXG4gIHByb3BzOiBQcm9wcyxcbiAgcm9vdENvbnRhaW5lckluc3RhbmNlOiBDb250YWluZXIsXG4gIGhvc3RDb250ZXh0OiBIb3N0Q29udGV4dCxcbiAgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZTogT2JqZWN0LFxuKTogbnVsbCB8IEFycmF5PG1peGVkPiB7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gIC8vIGdldCBhdHRhY2hlZC5cbiAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICBsZXQgcGFyZW50TmFtZXNwYWNlOiBzdHJpbmc7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgaG9zdENvbnRleHREZXYgPSAoKGhvc3RDb250ZXh0OiBhbnkpOiBIb3N0Q29udGV4dERldik7XG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5hbWVzcGFjZSA9ICgoaG9zdENvbnRleHQ6IGFueSk6IEhvc3RDb250ZXh0UHJvZCk7XG4gIH1cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoXG4gICAgaW5zdGFuY2UsXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBwYXJlbnROYW1lc3BhY2UsXG4gICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZVRleHRJbnN0YW5jZShcbiAgdGV4dEluc3RhbmNlOiBUZXh0SW5zdGFuY2UsXG4gIHRleHQ6IHN0cmluZyxcbiAgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZTogT2JqZWN0LFxuKTogYm9vbGVhbiB7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gIHJldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKFxuICBzdXNwZW5zZUluc3RhbmNlOiBTdXNwZW5zZUluc3RhbmNlLFxuKTogbnVsbCB8IEh5ZHJhdGFibGVJbnN0YW5jZSB7XG4gIGxldCBub2RlID0gc3VzcGVuc2VJbnN0YW5jZS5uZXh0U2libGluZztcbiAgLy8gU2tpcCBwYXN0IGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbiAgLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG4gIGxldCBkZXB0aCA9IDA7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgbGV0IGRhdGEgPSAoKG5vZGU6IGFueSkuZGF0YTogc3RyaW5nKTtcbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKChub2RlOiBhbnkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH1cbiAgLy8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UoXG4gIHBhcmVudENvbnRhaW5lcjogQ29udGFpbmVyLFxuICB0ZXh0SW5zdGFuY2U6IFRleHRJbnN0YW5jZSxcbiAgdGV4dDogc3RyaW5nLFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShcbiAgcGFyZW50VHlwZTogc3RyaW5nLFxuICBwYXJlbnRQcm9wczogUHJvcHMsXG4gIHBhcmVudEluc3RhbmNlOiBJbnN0YW5jZSxcbiAgdGV4dEluc3RhbmNlOiBUZXh0SW5zdGFuY2UsXG4gIHRleHQ6IHN0cmluZyxcbikge1xuICBpZiAoX19ERVZfXyAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UoXG4gIHBhcmVudENvbnRhaW5lcjogQ29udGFpbmVyLFxuICBpbnN0YW5jZTogSHlkcmF0YWJsZUluc3RhbmNlLFxuKSB7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCAoaW5zdGFuY2U6IGFueSkpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgLy8gVE9ETzogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlU3VzcGVuc2VCb3VuZGFyeVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgKGluc3RhbmNlOiBhbnkpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShcbiAgcGFyZW50VHlwZTogc3RyaW5nLFxuICBwYXJlbnRQcm9wczogUHJvcHMsXG4gIHBhcmVudEluc3RhbmNlOiBJbnN0YW5jZSxcbiAgaW5zdGFuY2U6IEh5ZHJhdGFibGVJbnN0YW5jZSxcbikge1xuICBpZiAoX19ERVZfXyAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgKGluc3RhbmNlOiBhbnkpKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIC8vIFRPRE86IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVN1c3BlbnNlQm91bmRhcnlcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgKGluc3RhbmNlOiBhbnkpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UoXG4gIHBhcmVudENvbnRhaW5lcjogQ29udGFpbmVyLFxuICB0eXBlOiBzdHJpbmcsXG4gIHByb3BzOiBQcm9wcyxcbikge1xuICBpZiAoX19ERVZfXykge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UoXG4gIHBhcmVudENvbnRhaW5lcjogQ29udGFpbmVyLFxuICB0ZXh0OiBzdHJpbmcsXG4pIHtcbiAgaWYgKF9fREVWX18pIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJTdXNwZW5zZUluc3RhbmNlKFxuICBwYXJlbnRDb250YWluZXI6IENvbnRhaW5lcixcbikge1xuICBpZiAoX19ERVZfXykge1xuICAgIC8vIFRPRE86IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkU3Vwc2Vuc2UocGFyZW50Q29udGFpbmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShcbiAgcGFyZW50VHlwZTogc3RyaW5nLFxuICBwYXJlbnRQcm9wczogUHJvcHMsXG4gIHBhcmVudEluc3RhbmNlOiBJbnN0YW5jZSxcbiAgdHlwZTogc3RyaW5nLFxuICBwcm9wczogUHJvcHMsXG4pIHtcbiAgaWYgKF9fREVWX18gJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKFxuICBwYXJlbnRUeXBlOiBzdHJpbmcsXG4gIHBhcmVudFByb3BzOiBQcm9wcyxcbiAgcGFyZW50SW5zdGFuY2U6IEluc3RhbmNlLFxuICB0ZXh0OiBzdHJpbmcsXG4pIHtcbiAgaWYgKF9fREVWX18gJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKFxuICBwYXJlbnRUeXBlOiBzdHJpbmcsXG4gIHBhcmVudFByb3BzOiBQcm9wcyxcbiAgcGFyZW50SW5zdGFuY2U6IEluc3RhbmNlLFxuKSB7XG4gIGlmIChfX0RFVl9fICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIC8vIFRPRE86IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkU3VzcGVuc2UocGFyZW50SW5zdGFuY2UpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL2NsaWVudC9SZWFjdERPTUhvc3RDb25maWcuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdzaGFyZWQvaW52YXJpYW50JztcblxuLy8gUmVuZGVyZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBwZXJzaXN0ZW5jZVxuLy8gY2FuIHJlLWV4cG9ydCBldmVyeXRoaW5nIGZyb20gdGhpcyBtb2R1bGUuXG5cbmZ1bmN0aW9uIHNoaW0oLi4uYXJnczogYW55KSB7XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICAnVGhlIGN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBwZXJzaXN0ZW5jZS4gJyArXG4gICAgICAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiAnICtcbiAgICAgICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICApO1xufVxuXG4vLyBQZXJzaXN0ZW5jZSAod2hlbiB1bnN1cHBvcnRlZClcbmV4cG9ydCBjb25zdCBzdXBwb3J0c1BlcnNpc3RlbmNlID0gZmFsc2U7XG5leHBvcnQgY29uc3QgY2xvbmVJbnN0YW5jZSA9IHNoaW07XG5leHBvcnQgY29uc3QgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBzaGltO1xuZXhwb3J0IGNvbnN0IGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHNoaW07XG5leHBvcnQgY29uc3QgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHNoaW07XG5leHBvcnQgY29uc3QgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gc2hpbTtcbmV4cG9ydCBjb25zdCBjbG9uZUhpZGRlbkluc3RhbmNlID0gc2hpbTtcbmV4cG9ydCBjb25zdCBjbG9uZVVuaGlkZGVuSW5zdGFuY2UgPSBzaGltO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUhpZGRlblRleHRJbnN0YW5jZSA9IHNoaW07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9zaGFyZWQvSG9zdENvbmZpZ1dpdGhOb1BlcnNpc3RlbmNlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgd2FybmluZ1dpdGhvdXRTdGFjayBmcm9tICdzaGFyZWQvd2FybmluZ1dpdGhvdXRTdGFjayc7XG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG5pbXBvcnQge2dldEN1cnJlbnRGaWJlclN0YWNrSW5EZXZ9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0Q3VycmVudEZpYmVyJztcblxubGV0IHZhbGlkYXRlRE9NTmVzdGluZyA9ICgpID0+IHt9O1xubGV0IHVwZGF0ZWRBbmNlc3RvckluZm8gPSAoKSA9PiB7fTtcblxuaWYgKF9fREVWX18pIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIGNvbnN0IHNwZWNpYWxUYWdzID0gW1xuICAgICdhZGRyZXNzJyxcbiAgICAnYXBwbGV0JyxcbiAgICAnYXJlYScsXG4gICAgJ2FydGljbGUnLFxuICAgICdhc2lkZScsXG4gICAgJ2Jhc2UnLFxuICAgICdiYXNlZm9udCcsXG4gICAgJ2Jnc291bmQnLFxuICAgICdibG9ja3F1b3RlJyxcbiAgICAnYm9keScsXG4gICAgJ2JyJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnY2FwdGlvbicsXG4gICAgJ2NlbnRlcicsXG4gICAgJ2NvbCcsXG4gICAgJ2NvbGdyb3VwJyxcbiAgICAnZGQnLFxuICAgICdkZXRhaWxzJyxcbiAgICAnZGlyJyxcbiAgICAnZGl2JyxcbiAgICAnZGwnLFxuICAgICdkdCcsXG4gICAgJ2VtYmVkJyxcbiAgICAnZmllbGRzZXQnLFxuICAgICdmaWdjYXB0aW9uJyxcbiAgICAnZmlndXJlJyxcbiAgICAnZm9vdGVyJyxcbiAgICAnZm9ybScsXG4gICAgJ2ZyYW1lJyxcbiAgICAnZnJhbWVzZXQnLFxuICAgICdoMScsXG4gICAgJ2gyJyxcbiAgICAnaDMnLFxuICAgICdoNCcsXG4gICAgJ2g1JyxcbiAgICAnaDYnLFxuICAgICdoZWFkJyxcbiAgICAnaGVhZGVyJyxcbiAgICAnaGdyb3VwJyxcbiAgICAnaHInLFxuICAgICdodG1sJyxcbiAgICAnaWZyYW1lJyxcbiAgICAnaW1nJyxcbiAgICAnaW5wdXQnLFxuICAgICdpc2luZGV4JyxcbiAgICAnbGknLFxuICAgICdsaW5rJyxcbiAgICAnbGlzdGluZycsXG4gICAgJ21haW4nLFxuICAgICdtYXJxdWVlJyxcbiAgICAnbWVudScsXG4gICAgJ21lbnVpdGVtJyxcbiAgICAnbWV0YScsXG4gICAgJ25hdicsXG4gICAgJ25vZW1iZWQnLFxuICAgICdub2ZyYW1lcycsXG4gICAgJ25vc2NyaXB0JyxcbiAgICAnb2JqZWN0JyxcbiAgICAnb2wnLFxuICAgICdwJyxcbiAgICAncGFyYW0nLFxuICAgICdwbGFpbnRleHQnLFxuICAgICdwcmUnLFxuICAgICdzY3JpcHQnLFxuICAgICdzZWN0aW9uJyxcbiAgICAnc2VsZWN0JyxcbiAgICAnc291cmNlJyxcbiAgICAnc3R5bGUnLFxuICAgICdzdW1tYXJ5JyxcbiAgICAndGFibGUnLFxuICAgICd0Ym9keScsXG4gICAgJ3RkJyxcbiAgICAndGVtcGxhdGUnLFxuICAgICd0ZXh0YXJlYScsXG4gICAgJ3Rmb290JyxcbiAgICAndGgnLFxuICAgICd0aGVhZCcsXG4gICAgJ3RpdGxlJyxcbiAgICAndHInLFxuICAgICd0cmFjaycsXG4gICAgJ3VsJyxcbiAgICAnd2JyJyxcbiAgICAneG1wJyxcbiAgXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICBjb25zdCBpblNjb3BlVGFncyA9IFtcbiAgICAnYXBwbGV0JyxcbiAgICAnY2FwdGlvbicsXG4gICAgJ2h0bWwnLFxuICAgICd0YWJsZScsXG4gICAgJ3RkJyxcbiAgICAndGgnLFxuICAgICdtYXJxdWVlJyxcbiAgICAnb2JqZWN0JyxcbiAgICAndGVtcGxhdGUnLFxuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAgIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAgIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgICAnZm9yZWlnbk9iamVjdCcsXG4gICAgJ2Rlc2MnLFxuICAgICd0aXRsZScsXG4gIF07XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIGNvbnN0IGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIGNvbnN0IGltcGxpZWRFbmRUYWdzID0gW1xuICAgICdkZCcsXG4gICAgJ2R0JyxcbiAgICAnbGknLFxuICAgICdvcHRpb24nLFxuICAgICdvcHRncm91cCcsXG4gICAgJ3AnLFxuICAgICdycCcsXG4gICAgJ3J0JyxcbiAgXTtcblxuICBjb25zdCBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgfTtcblxuICB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24ob2xkSW5mbywgdGFnKSB7XG4gICAgbGV0IGFuY2VzdG9ySW5mbyA9IHsuLi4ob2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyl9O1xuICAgIGxldCBpbmZvID0ge3RhZ307XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoXG4gICAgICBzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmXG4gICAgICB0YWcgIT09ICdhZGRyZXNzJyAmJlxuICAgICAgdGFnICE9PSAnZGl2JyAmJlxuICAgICAgdGFnICE9PSAncCdcbiAgICApIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICBjb25zdCBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRhZyA9PT0gJ3RoJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3RkJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3NjcmlwdCcgfHxcbiAgICAgICAgICB0YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgICAgKTtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGFnID09PSAndHInIHx8XG4gICAgICAgICAgdGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgdGFnID09PSAnc2NyaXB0JyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgICApO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0YWcgPT09ICdjYXB0aW9uJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ2NvbGdyb3VwJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3Rib2R5JyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3Rmb290JyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3RoZWFkJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3NjcmlwdCcgfHxcbiAgICAgICAgICB0YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgICAgKTtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRhZyA9PT0gJ2Jhc2UnIHx8XG4gICAgICAgICAgdGFnID09PSAnYmFzZWZvbnQnIHx8XG4gICAgICAgICAgdGFnID09PSAnYmdzb3VuZCcgfHxcbiAgICAgICAgICB0YWcgPT09ICdsaW5rJyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ21ldGEnIHx8XG4gICAgICAgICAgdGFnID09PSAndGl0bGUnIHx8XG4gICAgICAgICAgdGFnID09PSAnbm9zY3JpcHQnIHx8XG4gICAgICAgICAgdGFnID09PSAnbm9mcmFtZXMnIHx8XG4gICAgICAgICAgdGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgdGFnID09PSAnc2NyaXB0JyB8fFxuICAgICAgICAgIHRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgICApO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHBhcmVudFRhZyAhPT0gJ2gxJyAmJlxuICAgICAgICAgIHBhcmVudFRhZyAhPT0gJ2gyJyAmJlxuICAgICAgICAgIHBhcmVudFRhZyAhPT0gJ2gzJyAmJlxuICAgICAgICAgIHBhcmVudFRhZyAhPT0gJ2g0JyAmJlxuICAgICAgICAgIHBhcmVudFRhZyAhPT0gJ2g1JyAmJlxuICAgICAgICAgIHBhcmVudFRhZyAhPT0gJ2g2J1xuICAgICAgICApO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgY29uc3QgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGNvbnN0IGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbihjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgY29uc3QgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIGNvbnN0IHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGNoaWxkVGFnID09IG51bGwsXG4gICAgICAgICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnLFxuICAgICAgKTtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZylcbiAgICAgID8gbnVsbFxuICAgICAgOiBwYXJlbnRJbmZvO1xuICAgIGNvbnN0IGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnRcbiAgICAgID8gbnVsbFxuICAgICAgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIGNvbnN0IGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIGNvbnN0IGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpO1xuXG4gICAgY29uc3Qgd2FybktleSA9XG4gICAgICAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgYWRkZW5kdW07XG4gICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICBsZXQgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICBsZXQgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9XG4gICAgICAgICAgXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArXG4gICAgICAgICAgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIGxldCBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPVxuICAgICAgICAgICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICtcbiAgICAgICAgICAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2soXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMlcycsXG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lLFxuICAgICAgICBhbmNlc3RvclRhZyxcbiAgICAgICAgd2hpdGVzcGFjZUluZm8sXG4gICAgICAgIGluZm8sXG4gICAgICAgIGFkZGVuZHVtLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayhcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArXG4gICAgICAgICAgJzwlcz4uJXMnLFxuICAgICAgICB0YWdEaXNwbGF5TmFtZSxcbiAgICAgICAgYW5jZXN0b3JUYWcsXG4gICAgICAgIGFkZGVuZHVtLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7dXBkYXRlZEFuY2VzdG9ySW5mbywgdmFsaWRhdGVET01OZXN0aW5nfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L3ZhbGlkYXRlRE9NTmVzdGluZy5qcyJdLCJzb3VyY2VSb290IjoiIn0=